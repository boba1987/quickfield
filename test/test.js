(function(f){typeof define==='function'&&define.amd?define(f):f();}(function(){'use strict';var companyNames = ["Kiehn Inc", "Marks and Sons", "Waelchi Schiller and Denesik", "Olson Zemlak and Maggio", "Jacobs - Von", "Auer Lowe and Gutmann", "Feeney Rempel and Cassin", "Sawayn - Marks", "Johns and Sons", "Rodriguez Champlin and Dare", "Lowe - Ritchie", "Gleichner Goldner and Becker", "Jerde - Osinski", "Baumbach Group", "Schroeder Zulauf and Rempel", "O'Reilly Mills and Denesik", "Kohler - Veum", "O'Hara Inc", "Oberbrunner and Sons", "Emmerich Group", "Murray Zieme and Franecki", "Moen - Luettgen", "Gorczany Harvey and Gulgowski", "Reilly - Ruecker", "McDermott - Hyatt", "Spinka - Marks", "Hayes and Sons", "Kilback Kiehn and Monahan", "Davis and Sons", "Hudson - Yundt", "Goodwin - Zemlak", "Beer Kuhlman and Walker", "Jones Carroll and Anderson", "Rutherford Inc", "Predovic White and Collins", "Sporer Baumbach and Crist", "Grimes and Sons", "Kunde and Sons", "Tillman - Bode", "Cronin - Koepp", "Smitham Zieme and Daniel", "Kunze Welch and Russel", "Johns Labadie and Harber", "Lesch - Waters", "Brakus - Smitham", "Bins and Sons", "Nitzsche Inc", "Wunsch Inc", "Schowalter Franecki and Kuphal", "Reynolds - Swaniawski"];var isEditable = function (element) {
  if (element.ownerDocument.designMode && element.ownerDocument.designMode.toLowerCase() === 'on') {
    return true;
  }

  switch (element.tagName.toLowerCase()) {
    case 'input':
      return isEditableInput(element);
    case 'textarea':
      return true;
  }

  if (isContentEditable(element)) {
    return true;
  }

  return false;
};

function isContentEditable(element) {
  if (element.contentEditable && element.contentEditable.toLowerCase() === 'true') {
    return true;
  }
  if (element.contentEditable && element.contentEditable.toLowerCase() === 'inherit' && element.parentNode) {
    return isContentEditable(element.parentNode);
  }
  return false;
}

function isEditableInput(input) {
  switch (input.type) {
    case 'text':
      return true;
    case 'email':
      return true;
    case 'password':
      return true;
    case 'search':
      return true;
    case 'tel':
      return true;
    case 'url':
      return true;
    default:
      return false;
  }
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var CTRL = 1 << 0;
var META = 1 << 1;
var ALT = 1 << 2;
var SHIFT = 1 << 3;

// Key Events
var KeyEvents = {
  DOWN: 1 << 0,
  PRESS: 1 << 1,
  UP: 1 << 2,
  INPUT: 1 << 3
};
KeyEvents.ALL = KeyEvents.DOWN | KeyEvents.PRESS | KeyEvents.UP | KeyEvents.INPUT;

/**
 * Represents a keystroke, or a single key code with a set of active modifiers.
 *
 * @class Keystroke
 */
var Keystroke =
/**
 * @param {number} modifiers A bitmask formed by CTRL, META, ALT, and SHIFT.
 * @param {number} keyCode
 */
function Keystroke(modifiers, keyCode) {
  classCallCheck(this, Keystroke);

  this.modifiers = modifiers;
  this.ctrlKey = !!(modifiers & CTRL);
  this.metaKey = !!(modifiers & META);
  this.altKey = !!(modifiers & ALT);
  this.shiftKey = !!(modifiers & SHIFT);
  this.keyCode = keyCode;
};

/**
 * Simulates a keyboard with a particular key-to-character and key-to-action
 * mapping. Use `US_ENGLISH` to get a pre-configured keyboard.
 */
Keystroke.CTRL = CTRL;
Keystroke.META = META;
Keystroke.ALT = ALT;
Keystroke.SHIFT = SHIFT;
var Keyboard = function () {
  /**
   * @param {Object.<number, Keystroke>} charCodeKeyCodeMap
   * @param {Object.<string, number>} actionKeyCodeMap
   */
  function Keyboard(charCodeKeyCodeMap, actionKeyCodeMap) {
    classCallCheck(this, Keyboard);

    this._charCodeKeyCodeMap = charCodeKeyCodeMap;
    this._actionKeyCodeMap = actionKeyCodeMap;
  }

  /**
   * Determines the character code generated by pressing the given keystroke.
   *
   * @param {Keystroke} keystroke
   * @return {?number}
   */


  createClass(Keyboard, [{
    key: 'charCodeForKeystroke',
    value: function charCodeForKeystroke(keystroke) {
      var map = this._charCodeKeyCodeMap;
      for (var charCode in map) {
        if (Object.prototype.hasOwnProperty.call(map, charCode)) {
          var keystrokeForCharCode = map[charCode];
          if (keystroke.keyCode === keystrokeForCharCode.keyCode && keystroke.modifiers === keystrokeForCharCode.modifiers) {
            return parseInt(charCode, 10);
          }
        }
      }
      return null;
    }

    /**
     * Creates an event ready for dispatching onto the given target.
     *
     * @param {string} type One of "keydown", "keypress", "keyup", "textInput" or "input".
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @return {Event}
     */

  }, {
    key: 'createEventFromKeystroke',
    value: function createEventFromKeystroke(type, keystroke, target) {
      var document = target.ownerDocument;
      var window = document.defaultView;
      var Event = window.Event;

      var event = void 0;

      try {
        event = new Event(type);
      } catch (e) {
        event = document.createEvent('UIEvents');
      }

      event.initEvent(type, true, true);

      switch (type) {
        case 'textInput':
          event.data = String.fromCharCode(this.charCodeForKeystroke(keystroke));
          break;

        case 'keydown':case 'keypress':case 'keyup':
          event.shiftKey = keystroke.shiftKey;
          event.altKey = keystroke.altKey;
          event.metaKey = keystroke.metaKey;
          event.ctrlKey = keystroke.ctrlKey;
          event.keyCode = type === 'keypress' ? this.charCodeForKeystroke(keystroke) : keystroke.keyCode;
          event.charCode = type === 'keypress' ? event.keyCode : 0;
          event.which = event.keyCode;
          break;
      }

      return event;
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * action was undertaken by a human.
     *
     * @param {string} action e.g. "alt+shift+left" or "backspace"
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForAction',
    value: function dispatchEventsForAction(action, target) {
      var keystroke = this.keystrokeForAction(action);
      this.dispatchEventsForKeystroke(keystroke, target);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * input had been typed by a human.
     *
     * @param {string} input
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForInput',
    value: function dispatchEventsForInput(input, target) {
      var currentModifierState = 0;
      for (var i = 0, length = input.length; i < length; i++) {
        var keystroke = this.keystrokeForCharCode(input.charCodeAt(i));
        this.dispatchModifierStateTransition(target, currentModifierState, keystroke.modifiers);
        this.dispatchEventsForKeystroke(keystroke, target, false);
        currentModifierState = keystroke.modifiers;
      }
      this.dispatchModifierStateTransition(target, currentModifierState, 0);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * keystroke was performed by a human. When simulating, for example, typing
     * the letter "A" (assuming a U.S. English keyboard) then the sequence will
     * look like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0      shiftKey=true
     *   keydown   keyCode=65 (A)     charCode=0      shiftKey=true
     *   keypress  keyCode=65 (A)     charCode=65 (A) shiftKey=true
     *   textInput data=A
     *   input
     *   keyup     keyCode=65 (A)     charCode=0      shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0      shiftKey=false
     *
     * If the keystroke would not cause a character to be input, such as when
     * pressing alt+shift+left, the sequence looks like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=true
     *   keydown   keyCode=18 (ALT)   charCode=0 altKey=true  shiftKey=true
     *   keydown   keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=18 (ALT)   charCode=0 altKey=false shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=false
     *
     * To disable handling of modifier keys, call with `transitionModifers` set
     * to false. Doing so will omit the keydown and keyup events associated with
     * shift, ctrl, alt, and meta keys surrounding the actual keystroke.
     *
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @param {boolean=} transitionModifiers
     * @param {number} events
     */

  }, {
    key: 'dispatchEventsForKeystroke',
    value: function dispatchEventsForKeystroke(keystroke, target) {
      var transitionModifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, 0, keystroke.modifiers, events);
      }

      var keydownEvent = void 0;
      if (events & KeyEvents.DOWN) {
        keydownEvent = this.createEventFromKeystroke('keydown', keystroke, target);
      }

      if (keydownEvent && target.dispatchEvent(keydownEvent) && this.targetCanReceiveTextInput(target)) {
        var keypressEvent = void 0;
        if (events & KeyEvents.PRESS) {
          keypressEvent = this.createEventFromKeystroke('keypress', keystroke, target);
        }
        if (keypressEvent && keypressEvent.charCode && target.dispatchEvent(keypressEvent)) {
          if (events & KeyEvents.INPUT) {
            var textinputEvent = this.createEventFromKeystroke('textInput', keystroke, target);
            target.dispatchEvent(textinputEvent);

            var inputEvent = this.createEventFromKeystroke('input', keystroke, target);
            target.dispatchEvent(inputEvent);
          }
        }
      }

      if (events & KeyEvents.UP) {
        var keyupEvent = this.createEventFromKeystroke('keyup', keystroke, target);
        target.dispatchEvent(keyupEvent);
      }

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, keystroke.modifiers, 0);
      }
    }

    /**
     * Transitions from one modifier state to another by dispatching key events.
     *
     * @param {EventTarget} target
     * @param {number} fromModifierState
     * @param {number} toModifierState
     * @param {number} events
     * @private
     */

  }, {
    key: 'dispatchModifierStateTransition',
    value: function dispatchModifierStateTransition(target, fromModifierState, toModifierState) {
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      var currentModifierState = fromModifierState;
      var didHaveMeta = (fromModifierState & META) === META;
      var willHaveMeta = (toModifierState & META) === META;
      var didHaveCtrl = (fromModifierState & CTRL) === CTRL;
      var willHaveCtrl = (toModifierState & CTRL) === CTRL;
      var didHaveShift = (fromModifierState & SHIFT) === SHIFT;
      var willHaveShift = (toModifierState & SHIFT) === SHIFT;
      var didHaveAlt = (fromModifierState & ALT) === ALT;
      var willHaveAlt = (toModifierState & ALT) === ALT;

      var includeKeyUp = events & KeyEvents.UP;
      var includeKeyDown = events & KeyEvents.DOWN;

      if (includeKeyUp && didHaveMeta === true && willHaveMeta === false) {
        // Release the meta key.
        currentModifierState &= ~META;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyUp && didHaveCtrl === true && willHaveCtrl === false) {
        // Release the ctrl key.
        currentModifierState &= ~CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyUp && didHaveShift === true && willHaveShift === false) {
        // Release the shift key.
        currentModifierState &= ~SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyUp && didHaveAlt === true && willHaveAlt === false) {
        // Release the alt key.
        currentModifierState &= ~ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (includeKeyDown && didHaveMeta === false && willHaveMeta === true) {
        // Press the meta key.
        currentModifierState |= META;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyDown && didHaveCtrl === false && willHaveCtrl === true) {
        // Press the ctrl key.
        currentModifierState |= CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyDown && didHaveShift === false && willHaveShift === true) {
        // Press the shift key.
        currentModifierState |= SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyDown && didHaveAlt === false && willHaveAlt === true) {
        // Press the alt key.
        currentModifierState |= ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (currentModifierState !== toModifierState) {
        throw new Error('internal error, expected modifier state: ' + toModifierState + (', got: ' + currentModifierState));
      }
    }

    /**
     * Returns the keystroke associated with the given action.
     *
     * @param {string} action
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForAction',
    value: function keystrokeForAction(action) {
      var keyCode = null;
      var modifiers = 0;

      var parts = action.split('+');
      var lastPart = parts.pop();

      parts.forEach(function (part) {
        switch (part.toUpperCase()) {
          case 'CTRL':
            modifiers |= CTRL;break;
          case 'META':
            modifiers |= META;break;
          case 'ALT':
            modifiers |= ALT;break;
          case 'SHIFT':
            modifiers |= SHIFT;break;
          default:
            throw new Error('in "' + action + '", invalid modifier: ' + part);
        }
      });

      if (lastPart.toUpperCase() in this._actionKeyCodeMap) {
        keyCode = this._actionKeyCodeMap[lastPart.toUpperCase()];
      } else if (lastPart.length === 1) {
        var lastPartKeystroke = this.keystrokeForCharCode(lastPart.charCodeAt(0));
        modifiers |= lastPartKeystroke.modifiers;
        keyCode = lastPartKeystroke.keyCode;
      } else {
        throw new Error('in "' + action + '", invalid action: ' + lastPart);
      }

      return new Keystroke(modifiers, keyCode);
    }

    /**
     * Gets the keystroke used to generate the given character code.
     *
     * @param {number} charCode
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForCharCode',
    value: function keystrokeForCharCode(charCode) {
      return this._charCodeKeyCodeMap[charCode] || null;
    }

    /**
     * @param {EventTarget} target
     * @private
     */

  }, {
    key: 'targetCanReceiveTextInput',
    value: function targetCanReceiveTextInput(target) {
      if (!target) {
        return false;
      }

      return isEditable(target);
    }
  }]);
  return Keyboard;
}();

var US_ENGLISH_CHARCODE_KEYCODE_MAP = {
  32: new Keystroke(0, 32), // <space>
  33: new Keystroke(SHIFT, 49), // !
  34: new Keystroke(SHIFT, 222), // "
  35: new Keystroke(SHIFT, 51), // #
  36: new Keystroke(SHIFT, 52), // $
  37: new Keystroke(SHIFT, 53), // %
  38: new Keystroke(SHIFT, 55), // &
  39: new Keystroke(0, 222), // '
  40: new Keystroke(SHIFT, 57), // (
  41: new Keystroke(SHIFT, 48), // )
  42: new Keystroke(SHIFT, 56), // *
  43: new Keystroke(SHIFT, 187), // +
  44: new Keystroke(0, 188), // ,
  45: new Keystroke(0, 189), // -
  46: new Keystroke(0, 190), // .
  47: new Keystroke(0, 191), // /
  48: new Keystroke(0, 48), // 0
  49: new Keystroke(0, 49), // 1
  50: new Keystroke(0, 50), // 2
  51: new Keystroke(0, 51), // 3
  52: new Keystroke(0, 52), // 4
  53: new Keystroke(0, 53), // 5
  54: new Keystroke(0, 54), // 6
  55: new Keystroke(0, 55), // 7
  56: new Keystroke(0, 56), // 8
  57: new Keystroke(0, 57), // 9
  58: new Keystroke(SHIFT, 186), // :
  59: new Keystroke(0, 186), // ;
  60: new Keystroke(SHIFT, 188), // <
  61: new Keystroke(0, 187), // =
  62: new Keystroke(SHIFT, 190), // >
  63: new Keystroke(SHIFT, 191), // ?
  64: new Keystroke(SHIFT, 50), // @
  65: new Keystroke(SHIFT, 65), // A
  66: new Keystroke(SHIFT, 66), // B
  67: new Keystroke(SHIFT, 67), // C
  68: new Keystroke(SHIFT, 68), // D
  69: new Keystroke(SHIFT, 69), // E
  70: new Keystroke(SHIFT, 70), // F
  71: new Keystroke(SHIFT, 71), // G
  72: new Keystroke(SHIFT, 72), // H
  73: new Keystroke(SHIFT, 73), // I
  74: new Keystroke(SHIFT, 74), // J
  75: new Keystroke(SHIFT, 75), // K
  76: new Keystroke(SHIFT, 76), // L
  77: new Keystroke(SHIFT, 77), // M
  78: new Keystroke(SHIFT, 78), // N
  79: new Keystroke(SHIFT, 79), // O
  80: new Keystroke(SHIFT, 80), // P
  81: new Keystroke(SHIFT, 81), // Q
  82: new Keystroke(SHIFT, 82), // R
  83: new Keystroke(SHIFT, 83), // S
  84: new Keystroke(SHIFT, 84), // T
  85: new Keystroke(SHIFT, 85), // U
  86: new Keystroke(SHIFT, 86), // V
  87: new Keystroke(SHIFT, 87), // W
  88: new Keystroke(SHIFT, 88), // X
  89: new Keystroke(SHIFT, 89), // Y
  90: new Keystroke(SHIFT, 90), // Z
  91: new Keystroke(0, 219), // [
  92: new Keystroke(0, 220), // \
  93: new Keystroke(0, 221), // ]
  96: new Keystroke(0, 192), // `
  97: new Keystroke(0, 65), // a
  98: new Keystroke(0, 66), // b
  99: new Keystroke(0, 67), // c
  100: new Keystroke(0, 68), // d
  101: new Keystroke(0, 69), // e
  102: new Keystroke(0, 70), // f
  103: new Keystroke(0, 71), // g
  104: new Keystroke(0, 72), // h
  105: new Keystroke(0, 73), // i
  106: new Keystroke(0, 74), // j
  107: new Keystroke(0, 75), // k
  108: new Keystroke(0, 76), // l
  109: new Keystroke(0, 77), // m
  110: new Keystroke(0, 78), // n
  111: new Keystroke(0, 79), // o
  112: new Keystroke(0, 80), // p
  113: new Keystroke(0, 81), // q
  114: new Keystroke(0, 82), // r
  115: new Keystroke(0, 83), // s
  116: new Keystroke(0, 84), // t
  117: new Keystroke(0, 85), // u
  118: new Keystroke(0, 86), // v
  119: new Keystroke(0, 87), // w
  120: new Keystroke(0, 88), // x
  121: new Keystroke(0, 89), // y
  122: new Keystroke(0, 90), // z
  123: new Keystroke(SHIFT, 219), // {
  124: new Keystroke(SHIFT, 220), // |
  125: new Keystroke(SHIFT, 221), // }
  126: new Keystroke(SHIFT, 192) // ~
};

var US_ENGLISH_ACTION_KEYCODE_MAP = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPSLOCK: 20,
  ESCAPE: 27,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  INSERT: 45,
  DELETE: 46,
  META: 91,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123
};

/**
 * Gets a keyboard instance configured as a U.S. English keyboard would be.
 *
 * @return {Keyboard}
 */
Keyboard.US_ENGLISH = new Keyboard(US_ENGLISH_CHARCODE_KEYCODE_MAP, US_ENGLISH_ACTION_KEYCODE_MAP);var keyboard;
keyboard = Keyboard.US_ENGLISH;
function simulateKeys (target, keys, value) {
  if (target.focus) {
    target.focus();
  }

  target.value += value != null ? value || '' : keys;
  return keyboard.dispatchEventsForInput(keys, target);
}var keyboard$1;
keyboard$1 = Keyboard.US_ENGLISH;
function simulateAction (target, keys) {
  return keyboard$1.dispatchEventsForAction(keys, target);
}function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var REGEX_LEN_VAL = /^\d+(?:[a-z]|\%)+$/i;
var REGEX_DIGITS = /\d+$/;
var REGEX_SPACE = /\s/;
var REGEX_KEBAB = /([A-Z])+/g;
var IMPORTANT = 'important';
var POSSIBLE_PREFIXES = ['webkit', 'moz', 'ms', 'o'];
var REQUIRES_UNIT_VALUE = ['background-position-x', 'background-position-y', 'block-size', 'border-width', 'columnRule-width', 'cx', 'cy', 'font-size', 'grid-column-gap', 'grid-row-gap', 'height', 'inline-size', 'line-height', 'minBlock-size', 'min-height', 'min-inline-size', 'min-width', 'max-height', 'max-width', 'outline-offset', 'outline-width', 'perspective', 'shape-margin', 'stroke-dashoffset', 'stroke-width', 'text-indent', 'width', 'word-spacing', 'top', 'bottom', 'left', 'right', 'x', 'y'];
var QUAD_SHORTHANDS = ['margin', 'padding', 'border', 'border-radius'];
var DIRECTIONS = ['top', 'bottom', 'left', 'right'];
QUAD_SHORTHANDS.forEach(function (property) {
  var direction, i, len;
  REQUIRES_UNIT_VALUE.push(property);

  for (i = 0, len = DIRECTIONS.length; i < len; i++) {
    direction = DIRECTIONS[i];
    REQUIRES_UNIT_VALUE.push(property + '-' + direction);
  }
});
var SAMPLE_STYLE, styleConfig;
SAMPLE_STYLE = document.createElement('div').style;

var includes = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var isIterable = function isIterable(target) {
  return target && _typeof(target) === 'object' && typeof target.length === 'number' && !target.nodeType;
};

var toKebabCase = function toKebabCase(string) {
  return string.replace(REGEX_KEBAB, function (e, letter) {
    return "-".concat(letter.toLowerCase());
  });
};

var isPropSupported = function isPropSupported(property) {
  return typeof SAMPLE_STYLE[property] !== 'undefined';
};

var isValueSupported = function isValueSupported(property, value) {
  if (window.CSS && window.CSS.supports) {
    return window.CSS.supports(property, value);
  } else {
    SAMPLE_STYLE[property] = value;
    return SAMPLE_STYLE[property] === '' + value;
  }
};

var getPrefix = function getPrefix(property, skipInitialCheck) {
  var j, len1, prefix;

  if (skipInitialCheck || !isPropSupported(property)) {
    for (j = 0, len1 = POSSIBLE_PREFIXES.length; j < len1; j++) {
      prefix = POSSIBLE_PREFIXES[j];

      if (isPropSupported("-".concat(prefix, "-").concat(property))) {
        /* istanbul ignore next */
        return "-".concat(prefix, "-");
      }
    }
  }

  return '';
};

var normalizeProperty = function normalizeProperty(property) {
  property = toKebabCase(property);

  if (isPropSupported(property)) {
    return property;
  } else {
    return "".concat(getPrefix(property, true)).concat(property);
  }
};

var normalizeValue = function normalizeValue(property, value) {
  if (includes(REQUIRES_UNIT_VALUE, property) && value !== null) {
    value = '' + value;

    if (REGEX_DIGITS.test(value) && !REGEX_LEN_VAL.test(value) && !REGEX_SPACE.test(value)) {
      value += property === 'line-height' ? 'em' : 'px';
    }
  }

  return value;
};

var sort = function sort(array) {
  var great, i, len, less, pivot;

  if (array.length < 2) {
    return array;
  } else {
    pivot = array[0];
    less = [];
    great = [];
    len = array.length;
    i = 0;

    while (++i !== len) {
      if (array[i] <= pivot) {
        less.push(array[i]);
      } else {
        great.push(array[i]);
      }
    }

    return sort(less).concat(pivot, sort(great));
  }
};

var hash = function hash(string) {
  var hsh, i, length;
  hsh = 5381;
  i = -1;
  length = string.length;

  while (++i !== string.length) {
    hsh = (hsh << 5) - hsh + string.charCodeAt(i);
    hsh |= 0;
  }

  return '_' + (hsh < 0 ? hsh * -2 : hsh);
};

var ruleToString = function ruleToString(rule, important) {
  var j, len1, output, prop, property, props, value;
  output = '';
  props = sort(Object.keys(rule));

  for (j = 0, len1 = props.length; j < len1; j++) {
    prop = props[j];

    if (typeof rule[prop] === 'string' || typeof rule[prop] === 'number') {
      property = normalizeProperty(prop);
      value = normalizeValue(property, rule[prop]);

      if (important) {
        value += " !important";
      }

      output += "".concat(property, ":").concat(value, ";");
    }
  }

  return output;
};

var inlineStyleConfig = styleConfig = Object.create(null);

var inlineStyle = function inlineStyle(rule, valueToStore, level) {
  var config, styleEl;

  if (!(config = styleConfig[level])) {
    styleEl = document.createElement('style');
    styleEl.id = "quickcss".concat(level || '');
    document.head.appendChild(styleEl);
    styleConfig[level] = config = {
      el: styleEl,
      content: '',
      cache: Object.create(null)
    };
  }

  if (!config.cache[rule]) {
    config.cache[rule] = valueToStore || true;
    config.el.textContent = config.content += rule;
  }
};

var clearInlineStyle = function clearInlineStyle(level) {
  var config, j, key, keys, len1;

  if (config = styleConfig[level]) {
    if (!config.content) {
      return;
    }

    config.el.textContent = config.content = '';
    keys = Object.keys(config.cache);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];
      config.cache[key] = null;
    }
  }
};

var version = "1.4.3";

var _quickcss;

var index = _quickcss = function quickcss(targetEl, property, value, important) {
  var computedStyle, i, len, subEl, subProperty, subValue;

  switch (false) {
    case !isIterable(targetEl):
      for (i = 0, len = targetEl.length; i < len; i++) {
        subEl = targetEl[i];

        _quickcss(subEl, property, value);
      }

      break;

    case _typeof(property) !== 'object':
      // Passed a style map
      for (subProperty in property) {
        subValue = property[subProperty];

        _quickcss(targetEl, subProperty, subValue);
      }

      break;

    default:
      property = normalizeProperty(property);

      if (typeof value === 'undefined') {
        computedStyle = targetEl._computedStyle || (targetEl._computedStyle = getComputedStyle(targetEl));
        return computedStyle[property];
      } else if (property) {
        targetEl.style.setProperty(property, normalizeValue(property, value), important ? IMPORTANT : void 0);
      }

  }
};

_quickcss.animation = function (name$$1, frames) {
  var frame, generated, prefix, rules;

  if (name$$1 && typeof name$$1 === 'string' && frames && _typeof(frames) === 'object') {
    prefix = getPrefix('animation');
    generated = '';

    for (frame in frames) {
      rules = frames[frame];
      generated += "".concat(frame, " {").concat(ruleToString(rules), "}");
    }

    generated = "@".concat(prefix, "keyframes ").concat(name$$1, " {").concat(generated, "}");
    return inlineStyle(generated, true, 0);
  }
};

_quickcss.register = function (rule, level, important) {
  var className, ref, style;

  if (rule && _typeof(rule) === 'object') {
    level || (level = 0);
    rule = ruleToString(rule, important);

    if (!(className = (ref = inlineStyleConfig[level]) != null ? ref[rule] : void 0)) {
      className = hash(rule);
      style = ".".concat(className, " {").concat(rule, "}");
      inlineStyle(style, className, level);
    }

    return className;
  }
};

_quickcss.clearRegistered = function (level) {
  return clearInlineStyle(level || 0);
};
/* istanbul ignore next */


_quickcss.UNSET = function () {
  switch (false) {
    case !isValueSupported('display', 'unset'):
      return 'unset';

    case !isValueSupported('display', 'initial'):
      return 'initial';

    case !isValueSupported('display', 'inherit'):
      return 'inherit';
  }
}();

_quickcss.supports = isValueSupported;
_quickcss.supportsProperty = isPropSupported;
_quickcss.normalizeProperty = normalizeProperty;
_quickcss.normalizeValue = normalizeValue;
_quickcss.version = version;function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

var _extend, isArray, isObject, _shouldDeepExtend;

isArray = function isArray(target) {
  return Array.isArray(target);
};

isObject = function isObject(target) {
  return target && Object.prototype.toString.call(target) === '[object Object]' || isArray(target);
};

_shouldDeepExtend = function shouldDeepExtend(options, target, parentKey) {
  if (options.deep) {
    if (options.notDeep) {
      return !options.notDeep[target];
    } else {
      return true;
    }
  } else if (options.deepOnly) {
    return options.deepOnly[target] || parentKey && _shouldDeepExtend(options, parentKey);
  }
}; // else false


var extend = _extend = function extend(options, target, sources, parentKey) {
  var i, key, len, source, sourceValue, subTarget, targetValue;

  if (!target || _typeof$1(target) !== 'object' && typeof target !== 'function') {
    target = {};
  }

  for (i = 0, len = sources.length; i < len; i++) {
    source = sources[i];

    if (source != null) {
      for (key in source) {
        sourceValue = source[key];
        targetValue = target[key];

        if (sourceValue === target || sourceValue === void 0 || sourceValue === null && !options.allowNull && !options.nullDeletes || options.keys && !options.keys[key] || options.notKeys && options.notKeys[key] || options.own && !source.hasOwnProperty(key) || options.globalFilter && !options.globalFilter(sourceValue, key, source) || options.filters && options.filters[key] && !options.filters[key](sourceValue, key, source)) {
          continue;
        }

        if (sourceValue === null && options.nullDeletes) {
          delete target[key];
          continue;
        }

        if (options.globalTransform) {
          sourceValue = options.globalTransform(sourceValue, key, source);
        }

        if (options.transforms && options.transforms[key]) {
          sourceValue = options.transforms[key](sourceValue, key, source);
        }

        switch (false) {
          case !(options.concat && isArray(sourceValue) && isArray(targetValue)):
            target[key] = targetValue.concat(sourceValue);
            break;

          case !(_shouldDeepExtend(options, key, parentKey) && isObject(sourceValue)):
            subTarget = isObject(targetValue) ? targetValue : isArray(sourceValue) ? [] : {};
            target[key] = _extend(options, subTarget, [sourceValue], key);
            break;

          default:
            target[key] = sourceValue;
        }
      }
    }
  }

  return target;
};

var version$1 = "1.7.4";
var modifiers, newBuilder, normalizeKeys, primaryBuilder;

normalizeKeys = function normalizeKeys(keys) {
  var i, key, len, output;

  if (keys) {
    output = {};

    if (_typeof$1(keys) !== 'object') {
      output[keys] = true;
    } else {
      if (!Array.isArray(keys)) {
        keys = Object.keys(keys);
      }

      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        output[key] = true;
      }
    }

    return output;
  }
};

newBuilder = function newBuilder(isBase) {
  var _builder;

  _builder = function builder(target) {
    var theTarget;
    var $_len = arguments.length,
        $_i = -1,
        sources = new Array($_len);

    while (++$_i < $_len) sources[$_i] = arguments[$_i];

    if (_builder.options.target) {
      theTarget = _builder.options.target;
    } else {
      theTarget = target;
      sources.shift();
    }

    return extend(_builder.options, theTarget, sources);
  };

  if (isBase) {
    _builder.isBase = true;
  }

  _builder.options = {};
  Object.defineProperties(_builder, modifiers);
  return _builder;
};

modifiers = {
  'deep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.deep = true;
      return _;
    }
  },
  'own': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.own = true;
      return _;
    }
  },
  'allowNull': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.allowNull = true;
      return _;
    }
  },
  'nullDeletes': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.nullDeletes = true;
      return _;
    }
  },
  'concat': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.concat = true;
      return _;
    }
  },
  'clone': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.target = {};
      return _;
    }
  },
  'notDeep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notDeep = normalizeKeys(keys);
        return _;
      };
    }
  },
  'deepOnly': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.deepOnly = normalizeKeys(keys);
        return _;
      };
    }
  },
  'keys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.keys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'notKeys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notKeys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'transform': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (transform) {
        if (typeof transform === 'function') {
          _.options.globalTransform = transform;
        } else if (transform && _typeof$1(transform) === 'object') {
          _.options.transforms = transform;
        }

        return _;
      };
    }
  },
  'filter': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (filter) {
        if (typeof filter === 'function') {
          _.options.globalFilter = filter;
        } else if (filter && _typeof$1(filter) === 'object') {
          _.options.filters = filter;
        }

        return _;
      };
    }
  }
};
primaryBuilder = newBuilder(true);
primaryBuilder.version = version$1;
var primaryBuilder$1 = primaryBuilder;function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$2 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$2(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var defined = function defined(subject) {
  return subject !== void 0;
};

var array = function array(subject) {
  return subject instanceof Array;
};

var object = function object(subject) {
  return _typeof$2(subject) === 'object' && subject; // 2nd check is to test against 'null' values
};

var objectPlain = function objectPlain(subject) {
  return object(subject) && Object.prototype.toString.call(subject) === '[object Object]' && subject.constructor === Object;
};

var string = function string(subject) {
  return typeof subject === 'string';
};

var number = function number(subject) {
  return typeof subject === 'number' && !isNaN(subject);
};

var numberLoose = function numberLoose(subject) {
  return number(subject) || string(subject) && number(Number(subject));
};

var iterable = function iterable(subject) {
  return object(subject) && number(subject.length);
};

var function_ = function function_(subject) {
  return typeof subject === 'function';
};

var natives =
/*#__PURE__*/
Object.freeze({
  defined: defined,
  array: array,
  object: object,
  objectPlain: objectPlain,
  string: string,
  number: number,
  numberLoose: numberLoose,
  iterable: iterable,
  function_: function_
});

var domDoc = function domDoc(subject) {
  return subject && subject.nodeType === 9;
};

var domEl = function domEl(subject) {
  return subject && subject.nodeType === 1;
};

var domText = function domText(subject) {
  return subject && subject.nodeType === 3;
};

var domNode = function domNode(subject) {
  return domEl(subject) || domText(subject);
};

var domTextarea = function domTextarea(subject) {
  return subject && subject.nodeName === 'TEXTAREA';
};

var domInput = function domInput(subject) {
  return subject && subject.nodeName === 'INPUT';
};

var domSelect = function domSelect(subject) {
  return subject && subject.nodeName === 'SELECT';
};

var domField = function domField(subject) {
  return domInput(subject) || domTextarea(subject) || domSelect(subject);
};

var dom =
/*#__PURE__*/
Object.freeze({
  domDoc: domDoc,
  domEl: domEl,
  domText: domText,
  domNode: domNode,
  domTextarea: domTextarea,
  domInput: domInput,
  domSelect: domSelect,
  domField: domField
});
var AVAIL_SETS, Checks;
AVAIL_SETS = {
  natives: natives,
  dom: dom
};

Checks =
/*#__PURE__*/
function () {
  _createClass(Checks, [{
    key: "create",
    value: function create() {
      var args;

      if (arguments.length) {
        args = Array.prototype.slice.call(arguments);
      }

      return new Checks(args);
    }
  }]);

  function Checks(sets) {
    _classCallCheck(this, Checks);

    var i, len, set;

    if (sets == null) {
      sets = ['natives'];
    }

    for (i = 0, len = sets.length; i < len; i++) {
      set = sets[i];

      if (AVAIL_SETS[set]) {
        this.load(AVAIL_SETS[set]);
      }
    }
  }

  _createClass(Checks, [{
    key: "load",
    value: function load(set) {
      var key, value;

      if (AVAIL_SETS.natives.string(set)) {
        set = AVAIL_SETS[set];
      }

      if (!AVAIL_SETS.natives.objectPlain(set)) {
        return;
      }

      for (key in set) {
        value = set[key];

        if (key === 'function_') {
          key = 'function';
        }

        this[key] = value;
      }
    }
  }]);

  return Checks;
}();

var index$1 = Checks.prototype.create();function _typeof$3(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$3 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$3(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var template = ['id', 'name', 'type', 'href', 'selected', 'checked', 'className']; // To copy from DOM Elements

var element = ['id', 'ref', 'type', 'name', 'text', 'style', 'class', 'className', 'url', 'href', 'selected', 'checked', 'props', 'attrs', 'passStateToChildren', 'stateTriggers', 'unpassableStates']; // Used in QuickElement::toJSON
// 'relatedInstance'

var IS;
IS = index$1.create('natives', 'dom');
IS.load({
  quickDomEl: function quickDomEl(subject) {
    return subject && subject.constructor.name === 'QuickElement';
  },
  template: function template(subject) {
    return subject && subject.constructor.name === 'QuickTemplate';
  }
}); // batch: (subject)-> subject and subject.constructor.name is 'QuickBatch'

var IS$1 = IS;

var QuickElement, QuickWindow, _quickdom;

QuickElement = null;
QuickWindow = null;

_quickdom = function quickdom() {
  var arg, args, element, i, j, len, prevCount;
  args = new Array(arguments.length);

  for (i = j = 0, len = arguments.length; j < len; i = ++j) {
    arg = arguments[i];
    args[i] = arg;
  }

  prevCount = QuickElement.count;
  element = _quickdom.create(args);

  if (element && element._postCreation && QuickElement.count !== prevCount) {
    element._postCreation();
  }

  return element;
};

_quickdom.create = function (args) {
  var argsLength, child, children, element, i, j, len, options, type;

  switch (false) {
    case !IS$1.array(args[0]):
      return _quickdom.apply(void 0, _toConsumableArray(args[0]));

    case !IS$1.template(args[0]):
      return args[0].spawn();

    case !IS$1.quickDomEl(args[0]):
      if (args[1]) {
        return args[0].updateOptions(args[1]);
      } else {
        return args[0];
      }

    case !(IS$1.domNode(args[0]) || IS$1.domDoc(args[0])):
      if (args[0]._quickElement) {
        return args[0]._quickElement;
      }

      type = args[0].nodeName.toLowerCase().replace('#', '');
      options = args[1] || {};
      options.existing = args[0];
      return new QuickElement(type, options);

    case args[0] !== window:
      return QuickWindow;

    case !IS$1.string(args[0]):
      type = args[0].toLowerCase();

      if (type === 'text') {
        options = IS$1.object(args[1]) ? args[1] : {
          text: args[1] || ''
        };
      } else {
        options = IS$1.object(args[1]) ? args[1] : {};
      }

      element = new QuickElement(type, options);

      if (args.length > 2) {
        children = new Array(argsLength = args.length);
        i = 1;

        while (++i < argsLength) {
          children[i + 1] = args[i];
        }

        for (j = 0, len = children.length; j < len; j++) {
          child = children[j];

          if (IS$1.string(child)) {
            child = _quickdom.text(child);
          }

          if (IS$1.array(child)) {
            child = _quickdom.apply(void 0, _toConsumableArray(child));
          }

          if (IS$1.quickDomEl(child)) {
            element.append(child);
          }
        }
      }

      return element;

    case !(args[0] && (IS$1.domNode(args[0][0]) || IS$1.domDoc(args[0][0]))):
      return _quickdom(args[0][0]);
  }
};

_quickdom.html = function (innerHTML) {
  var children, container;
  container = document.createElement('div');
  container.innerHTML = innerHTML;
  children = Array.prototype.slice.call(container.childNodes);
  return _quickdom.batch(children);
};

_quickdom.isQuickEl = function (target) {
  return IS$1.quickDomEl(target);
};

_quickdom.isEl = function (target) {
  return IS$1.domEl(target);
};

var init = function init(QuickElement_, QuickWindow_) {
  QuickElement = QuickElement_;
  QuickWindow = QuickWindow_;
  return _quickdom;
};

var includes$1 = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var removeItem = function removeItem(target, item) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    target.splice(itemIndex, 1);
  }

  return target;
};

var normalizeElementArg = function normalizeElementArg(targetEl) {
  switch (false) {
    case !IS$1.string(targetEl):
      return quickdom.text(targetEl);

    case !IS$1.domNode(targetEl):
      return quickdom(targetEl);

    case !IS$1.template(targetEl):
      return targetEl.spawn();

    default:
      return targetEl;
  }
};

var isStateStyle = function isStateStyle(string) {
  return string[0] === '$' || string[0] === '@';
};

var registerStyle = function registerStyle(rule, level, important) {
  var cached, i, len, output, prop, props;
  level || (level = 0);
  cached = styleCache.get(rule, level);

  if (cached) {
    return cached;
  }

  output = {
    className: [index.register(rule, level, important)],
    fns: [],
    rule: rule
  };
  props = Object.keys(rule);

  for (i = 0, len = props.length; i < len; i++) {
    prop = props[i];

    if (typeof rule[prop] === 'function') {
      output.fns.push([prop, rule[prop]]);
    }
  }

  return styleCache.set(rule, output, level);
};

var styleCache = new (
/*#__PURE__*/
function () {
  function _class() {
    _classCallCheck$1(this, _class);

    this.keys = Object.create(null);
    this.values = Object.create(null);
  }

  _createClass$1(_class, [{
    key: "get",
    value: function get(key, level) {
      var index$$1;

      if (this.keys[level]) {
        index$$1 = this.keys[level].indexOf(key);

        if (index$$1 !== -1) {
          return this.values[level][index$$1];
        }
      }
    }
  }, {
    key: "set",
    value: function set(key, value, level) {
      if (!this.keys[level]) {
        this.keys[level] = [];
        this.values[level] = [];
      }

      this.keys[level].push(key);
      this.values[level].push(value);
      return value;
    }
  }]);

  return _class;
}())();
var REGEX_WHITESPACE;
REGEX_WHITESPACE = /\s+/;

var on_ = function on_(eventNames, callback, useCapture, isPrivate) {
  var _this = this;

  var callbackRef, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (IS$1.string(eventNames) && IS$1.function(callback)) {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];

    if (eventNames === 'inserted' && this._inserted) {
      callback.call(this, this._parent);
      return this;
    }

    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var base;

      if (!_this._eventCallbacks[eventName]) {
        _this._eventCallbacks[eventName] = [];

        if (!isPrivate) {
          _this._listenTo(eventName, function (event) {
            return _this._invokeHandlers(eventName, event);
          }, useCapture);
        }
      }

      if (callbackRef) {
        if ((base = _this._eventCallbacks.__refs)[eventName] == null) {
          base[eventName] = {};
        }

        _this._eventCallbacks.__refs[eventName][callbackRef] = callback;
      }

      return _this._eventCallbacks[eventName].push(callback);
    });
  }

  return this;
};

var once = function once(eventNames, callback) {
  var _this2 = this;

  var _onceCallback;

  if (IS$1.string(eventNames) && IS$1.function(callback)) {
    this.on(eventNames, _onceCallback = function onceCallback(event) {
      _this2.off(eventNames, _onceCallback);

      return callback.call(_this2, event);
    });
  }

  return this;
};

var off_ = function off_(eventNames, callback) {
  var _this3 = this;

  var callbackRef, eventName, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (!IS$1.string(eventNames)) {
    for (eventName in this._eventCallbacks) {
      this.off(eventName);
    }
  } else {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];
    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var ref;

      if (_this3._eventCallbacks[eventName]) {
        if (callback == null) {
          callback = (ref = _this3._eventCallbacks.__refs[eventName]) != null ? ref[callbackRef] : void 0;
        }

        if (IS$1.function(callback)) {
          return removeItem(_this3._eventCallbacks[eventName], callback);
        } else if (!callbackRef) {
          return _this3._eventCallbacks[eventName].length = 0;
        }
      }
    });
  }

  return this;
};

var emit = function emit(eventName) {
  var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var data = arguments.length > 3 ? arguments[3] : undefined;
  var event;

  if (eventName && IS$1.string(eventName)) {
    event = document.createEvent('Event');
    event.initEvent(eventName, bubbles, cancelable);

    if (data && _typeof$3(data) === 'object') {
      primaryBuilder$1(event, data);
    }

    this.el.dispatchEvent(event);
  }

  return this;
};

var emitPrivate = function emitPrivate(eventName, arg) {
  var ref;

  if (eventName && IS$1.string(eventName) && ((ref = this._eventCallbacks) != null ? ref[eventName] : void 0)) {
    this._invokeHandlers(eventName, arg);
  }

  return this;
};

var _invokeHandlers = function _invokeHandlers(eventName, arg) {
  var callbacks, cb, i, len;
  callbacks = this._eventCallbacks[eventName].slice();

  for (i = 0, len = callbacks.length; i < len; i++) {
    cb = callbacks[i];
    cb.call(this, arg);
  }
};
/* istanbul ignore next */


var _listenTo = function _listenTo(eventName, callback, useCapture) {
  var eventNameToListenFor, listenMethod;
  listenMethod = this.el.addEventListener ? 'addEventListener' : 'attachEvent';
  eventNameToListenFor = this.el.addEventListener ? eventName : "on".concat(eventName);
  this.el[listenMethod](eventNameToListenFor, callback, useCapture);
  return this;
};

function events(QuickElement) {
  QuickElement.prototype.on = on_;
  QuickElement.prototype.once = once;
  QuickElement.prototype.off = off_;
  QuickElement.prototype.emit = emit;
  QuickElement.prototype.emitPrivate = emitPrivate;
  QuickElement.prototype._invokeHandlers = _invokeHandlers;
  return QuickElement.prototype._listenTo = _listenTo;
}
/**
* Sets/gets the value of a style property. In getter mode the computed property of
* the style will be returned unless the element is not inserted into the DOM. In
* webkit browsers all computed properties of a detached node are always an empty
* string but in gecko they reflect on the actual computed value, hence we need
* to "normalize" this behavior and make sure that even on gecko an empty string
* is returned
* @return {[type]} [description]
*/


var style = function style(property) {
  var _this = this;

  var args, i, key, keys, result, value;

  if (this.type === 'text') {
    return;
  }

  args = arguments;

  if (IS$1.string(property)) {
    value = typeof args[1] === 'function' ? args[1].call(this, this.related) : args[1];

    if (args[1] === null && IS$1.defined(this.currentStateStyle(property)) && !IS$1.function(this.currentStateStyle(property))) {
      value = index.UNSET;
    }

    if (value && typeof value.then === 'function') {
      value.then(function (value) {
        return index(_this.el, property, value, _this.options.forceStyle);
      });
    } else {
      result = index(this.el, property, value, this.options.forceStyle);
    }

    if (args.length === 1) {
      /* istanbul ignore next */
      if (this._inserted) {
        return result;
      } else if (!result) {
        return result;
      } else {
        return '';
      }
    }
  } else if (IS$1.object(property)) {
    keys = Object.keys(property);
    i = -1;

    while (key = keys[++i]) {
      this.style(key, property[key]);
    }
  }

  return this;
};
/**
* Attempts to resolve the value for a given property in the following order if each one isn't a valid value:
* 1. from computed style (for dom-inserted els)
* 2. from DOMElement.style object (for non-inserted els; if options.styleAfterInsert, will only have state styles)
* 3. from provided style options
* (for non-inserted els; checking only $base since state styles will always be applied to the style object even for non-inserted)
 */


var styleSafe = function styleSafe(property, skipComputed) {
  var computed, result, sample;

  if (this.type === 'text') {
    return;
  }

  sample = this.el.style[property];

  if (IS$1.string(sample) || IS$1.number(sample)) {
    computed = skipComputed ? 0 : this.style(property);
    result = computed || this.el.style[property] || this.currentStateStyle(property) || '';

    if (typeof result === 'function') {
      return result.call(this, this.related);
    } else {
      return result;
    }
  }

  return this;
};

var styleParsed = function styleParsed(property, skipComputed) {
  return parseFloat(this.styleSafe(property, skipComputed));
};

var recalcStyle = function recalcStyle(recalcChildren) {
  var child, j, len, ref, targetStyles;
  targetStyles = this._resolveFnStyles(this._getActiveStates(), true);
  this.style(targetStyles);

  if (recalcChildren) {
    ref = this._children;

    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      child.recalcStyle();
    }
  }

  return this;
};

var currentStateStyle = function currentStateStyle(property) {
  var i, state, states;

  if (property) {
    if (this._state.length) {
      states = this._state.slice();

      if (this._stateShared && this._stateShared.length) {
        var _states;

        (_states = states).push.apply(_states, _toConsumableArray(this._stateShared));
      }

      i = states.length;

      while (state = states[--i]) {
        if (this._styles[state] && IS$1.defined(this._styles[state].rule[property])) {
          return this._styles[state].rule[property];
        }
      }
    }

    if (this._styles.base) {
      return this._styles.base.rule[property];
    }
  }
};

var hide = function hide() {
  return this.style('display', 'none');
};

var show = function show(display) {
  var ref;

  if (!display) {
    display = this.currentStateStyle('display');

    if (display === 'none' || !display) {
      display = 'block';
    }
  }

  if (display == null) {
    display = ((ref = this._styles.base) != null ? ref.display : void 0) || 'block';
  }

  return this.style('display', display);
};

var orientationGetter = {
  get: function get() {
    if (this.width > this.height) {
      return 'landscape';
    } else {
      return 'portrait';
    }
  }
};
var aspectRatioGetter = {
  get: function get() {
    return this.width / this.height;
  }
};

function style$1(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'orientation': orientationGetter,
    'aspectRatio': aspectRatioGetter,
    'rect': {
      get: function get() {
        return this.el.getBoundingClientRect();
      }
    },
    'width': {
      get: function get() {
        return parseFloat(this.style('width'));
      },
      set: function set(value) {
        return this.style('width', value);
      }
    },
    'height': {
      get: function get() {
        return parseFloat(this.style('height'));
      },
      set: function set(value) {
        return this.style('height', value);
      }
    }
  });
  QuickElement.prototype.style = style;
  QuickElement.prototype.styleSafe = styleSafe;
  QuickElement.prototype.styleParsed = styleParsed;
  QuickElement.prototype.recalcStyle = recalcStyle;
  QuickElement.prototype.currentStateStyle = currentStateStyle;
  QuickElement.prototype.hide = hide;
  return QuickElement.prototype.show = show;
}

var QuickWindow$1;
var QuickWindow$2 = QuickWindow$1 = {
  type: 'window',
  el: window,
  raw: window,
  _eventCallbacks: {
    __refs: {}
  }
};
QuickWindow$1.on = on_;
QuickWindow$1.off = off_;
QuickWindow$1.emit = emit;
QuickWindow$1.emitPrivate = emitPrivate;
QuickWindow$1._listenTo = _listenTo;
QuickWindow$1._invokeHandlers = _invokeHandlers;
Object.defineProperties(QuickWindow$1, {
  'width': {
    get: function get() {
      return window.innerWidth;
    }
  },
  'height': {
    get: function get() {
      return window.innerHeight;
    }
  },
  'orientation': orientationGetter,
  'aspectRatio': aspectRatioGetter
});
var MediaQuery, RULE_DEILIMITER;
RULE_DEILIMITER = /,\s*/;
var MediaQuery$1 = MediaQuery = new function () {
  var callbacks, testRule;
  callbacks = [];
  window.addEventListener('resize', function () {
    var callback, i, len;

    for (i = 0, len = callbacks.length; i < len; i++) {
      callback = callbacks[i];
      callback();
    }
  });

  this.parseQuery = function (target, queryString) {
    var querySplit, rules, source;
    querySplit = queryString.split('(');
    source = querySplit[0];

    source = function () {
      switch (source) {
        case 'window':
          return QuickWindow$2;

        case 'parent':
          return target.parent;

        case 'self':
          return target;

        default:
          return target.parentMatching(function (parent) {
            return parent.ref === source.slice(1);
          });
      }
    }();

    rules = querySplit[1].slice(0, -1).split(RULE_DEILIMITER).map(function (rule) {
      var getter, key, keyPrefix, max, min, split, value;
      split = rule.split(':');
      value = parseFloat(split[1]);

      if (isNaN(value)) {
        value = split[1];
      }

      key = split[0];
      keyPrefix = key.slice(0, 4);
      max = keyPrefix === 'max-';
      min = !max && keyPrefix === 'min-';

      if (max || min) {
        key = key.slice(4);
      }

      getter = function () {
        switch (key) {
          case 'orientation':
            return function () {
              return source.orientation;
            };

          case 'aspect-ratio':
            return function () {
              return source.aspectRatio;
            };

          case 'width':
          case 'height':
            return function () {
              return source[key];
            };

          default:
            return function () {
              var parsedValue, stringValue;
              stringValue = source.style(key);
              parsedValue = parseFloat(stringValue);

              if (isNaN(parsedValue)) {
                return stringValue;
              } else {
                return parsedValue;
              }
            };
        }
      }();

      return {
        key: key,
        value: value,
        min: min,
        max: max,
        getter: getter
      };
    });
    return {
      source: source,
      rules: rules
    };
  };

  this.register = function (target, queryString) {
    var callback, query;
    query = this.parseQuery(target, queryString);

    if (query.source) {
      callbacks.push(callback = function callback() {
        return testRule(target, query, queryString);
      });
      callback();
    }

    return query;
  };

  testRule = function testRule(target, query, queryString) {
    var currentValue, i, len, passed, ref, rule;
    passed = true;
    ref = query.rules;

    for (i = 0, len = ref.length; i < len; i++) {
      rule = ref[i];
      currentValue = rule.getter();

      passed = function () {
        switch (false) {
          case !rule.min:
            return currentValue >= rule.value;

          case !rule.max:
            return currentValue <= rule.value;

          default:
            return currentValue === rule.value;
        }
      }();

      if (!passed) {
        break;
      }
    }

    return target.state(queryString, passed);
  };

  return this;
}();
var StateChain;

var StateChain$1 = StateChain =
/*#__PURE__*/
function () {
  function StateChain(states) {
    _classCallCheck$1(this, StateChain);

    this.string = states.join('+');
    this.array = states.slice();
    this.length = states.length;
  }

  _createClass$1(StateChain, [{
    key: "includes",
    value: function includes(target) {
      var i, len, ref, state;
      ref = this.array;

      for (i = 0, len = ref.length; i < len; i++) {
        state = ref[i];

        if (state === target) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "without",
    value: function without(target) {
      return this.array.filter(function (state) {
        return state !== target;
      }).join('+');
    }
  }, {
    key: "isApplicable",
    value: function isApplicable(target, otherActive) {
      var active;
      active = this.array.filter(function (state) {
        return state === target || otherActive.indexOf(state) !== -1;
      });
      return active.length === this.array.length;
    }
  }]);

  return StateChain;
}();

var BASE_STATE_TRIGGERS, CACHED_FN_INSERTED;
BASE_STATE_TRIGGERS = {
  'hover': {
    on: 'mouseenter',
    off: 'mouseleave',
    bubbles: true
  },
  'focus': {
    on: 'focus',
    off: 'blur',
    bubbles: true
  }
};

var _normalizeOptions = function _normalizeOptions() {
  var base1, base2, base3, base4, base5;

  if (this.options.relatedInstance) {
    (base1 = this.options).related || (base1.related = this.options.relatedInstance);
    this.options.relatedInstance = null;
  }

  this.related = (base2 = this.options).related != null ? base2.related : base2.related = this;

  if (this.options.class) {
    this.options.className = this.options.class;
  }

  if (this.options.url) {
    this.options.href = this.options.url;
  }

  if ((base3 = this.options).unpassableStates == null) {
    base3.unpassableStates = [];
  }

  if ((base4 = this.options).passStateToChildren == null) {
    base4.passStateToChildren = true;
  }

  if ((base5 = this.options).passDataToChildren == null) {
    base5.passDataToChildren = true;
  }

  this.options.stateTriggers = this.options.stateTriggers ? primaryBuilder$1.clone.deep(BASE_STATE_TRIGGERS, this.options.stateTriggers) : BASE_STATE_TRIGGERS;

  if (this.type === 'text') {
    primaryBuilder$1(this, this._parseTexts(this.options.text, this._texts));
  } else {
    primaryBuilder$1(this, this._parseStyles(this.options.style, this._styles));
  }
};

var _parseStyles = function _parseStyles(styles, store) {
  var _mediaStates, _providedStates, _providedStatesShared, _stateShared, _styles, base, _flattenNestedStates, forceStyle, i, keys, len, specialStates, state, stateStyles, state_, states;

  if (!IS$1.objectPlain(styles)) {
    return;
  }

  keys = Object.keys(styles);
  states = keys.filter(function (key) {
    return isStateStyle(key);
  });
  specialStates = removeItem(states.slice(), '$base');
  _mediaStates = states.filter(function (key) {
    return key[0] === '@';
  }).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.map(function (state) {
    return state.slice(1); // Remove '$' prefix
  });
  _styles = store || {};
  _stateShared = _providedStatesShared = void 0;
  base = !includes$1(states, '$base') ? styles : styles.$base;
  _styles.base = registerStyle(base, 0, forceStyle = this.options.forceStyle);

  if (specialStates.length) {
    _flattenNestedStates = function flattenNestedStates(styleObject, chain, level) {
      var hasNonStateProps, i, len, output, state, stateChain, state_, styleKeys;
      styleKeys = Object.keys(styleObject);
      output = {};
      hasNonStateProps = false;

      for (i = 0, len = styleKeys.length; i < len; i++) {
        state = styleKeys[i];

        if (!isStateStyle(state)) {
          hasNonStateProps = true;
          output[state] = styleObject[state];
        } else {
          chain.push(state_ = state.slice(1));
          stateChain = new StateChain$1(chain);

          if (_stateShared == null) {
            _stateShared = [];
          }

          if (_providedStatesShared == null) {
            _providedStatesShared = [];
          }

          _providedStatesShared.push(stateChain);

          if (state[0] === '@') {
            _mediaStates.push(state_);
          }

          _styles[stateChain.string] = registerStyle(_flattenNestedStates(styleObject[state], chain, level + 1), level + 1, forceStyle);
        }
      }

      if (hasNonStateProps) {
        return output;
      }
    };

    for (i = 0, len = specialStates.length; i < len; i++) {
      state = specialStates[i];
      state_ = state.slice(1);
      stateStyles = _flattenNestedStates(styles[state], [state_], 1);

      if (stateStyles) {
        _styles[state_] = registerStyle(stateStyles, 1);
      }
    }
  }

  return {
    _styles: _styles,
    _mediaStates: _mediaStates,
    _stateShared: _stateShared,
    _providedStates: _providedStates,
    _providedStatesShared: _providedStatesShared
  };
};

var _parseTexts = function _parseTexts(texts, store) {
  var _providedStates, _texts, i, len, state, states;

  if (!IS$1.objectPlain(texts)) {
    return;
  }

  states = Object.keys(texts).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.filter(function (state) {
    return state !== 'base';
  });
  _texts = store || {};
  _texts = {
    base: ''
  };

  for (i = 0, len = states.length; i < len; i++) {
    state = states[i];
    _texts[state] = texts['$' + state];
  }

  return {
    _texts: _texts,
    _providedStates: _providedStates
  };
};

var _applyOptions = function _applyOptions() {
  var _this = this;

  var event, handler, method, ref, ref1, ref2, value;

  if (ref = this.options.id || this.options.ref) {
    this.attr('data-ref', this.ref = ref);
  }

  if (this.options.id) {
    this.el.id = this.options.id;
  }

  if (this.options.className) {
    this.el.className = this.options.className;
  }

  if (this.options.src) {
    this.el.src = this.options.src;
  }

  if (this.options.href) {
    this.el.href = this.options.href;
  }

  if (this.options.type) {
    this.el.type = this.options.type;
  }

  if (this.options.name) {
    this.el.name = this.options.name;
  }

  if (this.options.value) {
    this.el.value = this.options.value;
  }

  if (this.options.selected) {
    this.el.selected = this.options.selected;
  }

  if (this.options.checked) {
    this.el.checked = this.options.checked;
  }

  if (this.options.props) {
    this.prop(this.options.props);
  }

  if (this.options.attrs) {
    this.attr(this.options.attrs);
  }

  this._applyRegisteredStyle(this._styles.base, null, null, this.options.styleAfterInsert);

  if (this._texts) {
    this.text = this._texts.base;
  }

  this.on('inserted', CACHED_FN_INSERTED, false, true);

  if (this.options.invokeComputersOnce) {
    this._invokedComputers = {};
  }

  if (this.options.recalcOnResize) {
    window.addEventListener('resize', function () {
      return _this.recalcStyle();
    });
  }

  if (this.options.events) {
    ref1 = this.options.events;

    for (event in ref1) {
      handler = ref1[event];
      this.on(event, handler);
    }
  }

  if (this.options.methods) {
    ref2 = this.options.methods;

    for (method in ref2) {
      value = ref2[method];

      if (!this[method]) {
        if (IS$1.function(value)) {
          this[method] = value;
        } else if (IS$1.object(value)) {
          Object.defineProperty(this, method, {
            configurable: true,
            get: value.get,
            set: value.set
          });
        }
      }
    }
  }

  if (this.type !== 'text' && IS$1.object(this.options.text)) {
    this.append(_quickdom('text', {
      text: this.options.text
    }));
  }
};

var _postCreation = function _postCreation(data) {
  if (this.options.computers) {
    if (data && this.options.data) {
      data = primaryBuilder$1.clone(this.options.data, data);
    }

    data || (data = this.options.data);
    this.applyData(data, false);

    if (this.options.computers._init) {
      this._runComputer('_init', data);
    }
  }

  if (this.options.state) {
    this.state(this.options.state);
  }
};

var _attachStateEvents = function _attachStateEvents(force) {
  var _this2 = this;

  var states;
  states = Object.keys(this.options.stateTriggers);
  states.forEach(function (state) {
    var disabler, enabler, trigger;
    trigger = _this2.options.stateTriggers[state];

    if (!includes$1(_this2._providedStates, state) && !force && !trigger.force) {
      return;
    }

    enabler = IS$1.string(trigger) ? trigger : trigger.on;

    if (IS$1.object(trigger)) {
      disabler = trigger.off;
    }

    _this2._listenTo(enabler, function () {
      return _this2.state(state, true, trigger.bubbles);
    });

    if (disabler) {
      return _this2._listenTo(disabler, function () {
        return _this2.state(state, false, trigger.bubbles);
      });
    }
  });
};

var _proxyParent = function _proxyParent() {
  var parent;
  parent = void 0;
  return Object.defineProperty(this, '_parent', {
    get: function get() {
      return parent;
    },
    set: function set(newParent) {
      var _this3 = this;

      var lastParent;

      if (parent = newParent) {
        lastParent = this.parents.slice(-1)[0];

        if (lastParent.raw === document.documentElement) {
          this._unproxyParent(newParent);
        } else {
          parent.on('inserted', function () {
            if (parent === newParent) {
              return _this3._unproxyParent(newParent);
            }
          });
        }
      }
    }
  });
};

var _unproxyParent = function _unproxyParent(newParent) {
  delete this._parent;
  this._parent = newParent;
  this.emitPrivate('inserted', newParent);
};

CACHED_FN_INSERTED = function CACHED_FN_INSERTED() {
  var i, len, mediaStates, queryString, results;
  this._inserted = this;

  if (this.options.styleAfterInsert) {
    this.recalcStyle();
  }

  if ((mediaStates = this._mediaStates) && this._mediaStates.length) {
    this._mediaStates = Object.create(null);
    results = [];

    for (i = 0, len = mediaStates.length; i < len; i++) {
      queryString = mediaStates[i];
      results.push(this._mediaStates[queryString] = MediaQuery$1.register(this, queryString));
    }

    return results;
  }
};

function init$1(QuickElement) {
  QuickElement.prototype._normalizeOptions = _normalizeOptions;
  QuickElement.prototype._parseStyles = _parseStyles;
  QuickElement.prototype._parseTexts = _parseTexts;
  QuickElement.prototype._applyOptions = _applyOptions;
  QuickElement.prototype._postCreation = _postCreation;
  QuickElement.prototype._attachStateEvents = _attachStateEvents;
  QuickElement.prototype._proxyParent = _proxyParent;
  return QuickElement.prototype._unproxyParent = _unproxyParent;
}

function aliases(QuickElement) {
  return Object.defineProperties(QuickElement.prototype, {
    'raw': {
      get: function get() {
        return this.el;
      }
    },
    '0': {
      get: function get() {
        return this.el;
      }
    },
    'css': {
      get: function get() {
        return this.style;
      }
    },
    'replaceWith': {
      get: function get() {
        return this.replace;
      }
    },
    'removeListener': {
      get: function get() {
        return this.off;
      }
    }
  });
}

var parentsUntil = function parentsUntil(filter) {
  return _getParents(this, filter);
};

var parentMatching = function parentMatching(filter) {
  var isRef, nextParent;

  if (IS$1.function(filter) || (isRef = IS$1.string(filter))) {
    nextParent = this.parent;

    while (nextParent) {
      if (isRef) {
        if (nextParent.ref === filter) {
          return nextParent;
        }
      } else {
        if (filter(nextParent)) {
          return nextParent;
        }
      }

      nextParent = nextParent.parent;
    }
  }
};

var query = function query(selector) {
  return _quickdom(this.raw.querySelector(selector));
};

var queryAll = function queryAll(selector) {
  var i, item, len, output, result;
  result = this.raw.querySelectorAll(selector);
  output = [];

  for (i = 0, len = result.length; i < len; i++) {
    item = result[i];
    output.push(item);
  }

  return _quickdom.batch(output);
};

var _getParents = function _getParents(targetEl, filter) {
  var isRef, nextParent, parents;

  if (!IS$1.function(filter) && !(isRef = IS$1.string(filter))) {
    filter = void 0;
  }

  parents = [];
  nextParent = targetEl.parent;

  while (nextParent) {
    parents.push(nextParent);
    nextParent = nextParent.parent;

    if (isRef) {
      if (nextParent && nextParent.ref === filter) {
        nextParent = null;
      }
    } else if (filter) {
      if (filter(nextParent)) {
        nextParent = null;
      }
    }
  }

  return parents;
};

var _getChildRefs = function _getChildRefs(target, freshCopy) {
  var child, childRefs, children, el, i, len, ref, refs;

  if (freshCopy || !target._childRefs) {
    target._childRefs = {};
  }

  refs = target._childRefs;

  if (target.ref) {
    refs[target.ref] = target;
  }

  children = target.children;

  if (children.length) {
    for (i = 0, len = children.length; i < len; i++) {
      child = children[i];
      childRefs = _getChildRefs(child, freshCopy);

      for (ref in childRefs) {
        el = childRefs[ref];
        refs[ref] || (refs[ref] = el);
      }
    }
  }

  return refs;
};

var _getIndexByProp = function _getIndexByProp(main, prop) {
  var parent;

  if (!(parent = main.parent)) {
    return null;
  } else {
    return parent.children.filter(function (child) {
      return child[prop] === main[prop];
    }).indexOf(main);
  }
};

var _filterElements = function _filterElements(array) {
  var i, item, len, output;

  if (!array.length) {
    return array;
  } else {
    output = [];

    for (i = 0, len = array.length; i < len; i++) {
      item = array[i];

      if (item.type !== 'text') {
        output.push(item);
      }
    }

    return output;
  }
};

function traversing(QuickElement) {
  QuickElement.prototype.parentsUntil = parentsUntil;
  QuickElement.prototype.parentMatching = parentMatching;
  QuickElement.prototype.query = query;
  QuickElement.prototype.queryAll = queryAll;
  return Object.defineProperties(QuickElement.prototype, {
    'children': {
      get: function get() {
        var child, i, len, ref1;

        if (this.el.childNodes.length !== this._children.length) {
          // Re-collect children	
          this._children.length = 0; // Empty out children array

          ref1 = this.el.childNodes;

          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];

            if (child.nodeType < 4) {
              this._children.push(_quickdom(child));
            }
          }
        }

        return this._children;
      }
    },
    'elementChildren': {
      get: function get() {
        return _filterElements(this.children);
      }
    },
    'parent': {
      get: function get() {
        if ((!this._parent || this._parent.el !== this.el.parentNode) && !IS$1.domDoc(this.el.parentNode)) {
          this._parent = _quickdom(this.el.parentNode);
        }

        return this._parent;
      }
    },
    'parents': {
      get: function get() {
        return _getParents(this);
      }
    },
    'next': {
      get: function get() {
        return _quickdom(this.el.nextSibling);
      }
    },
    'nextEl': {
      get: function get() {
        return _quickdom(this.el.nextElementSibling);
      }
    },
    'nextElAll': {
      get: function get() {
        return _filterElements(this.nextAll);
      }
    },
    'nextAll': {
      get: function get() {
        var nextSibling, siblings;
        siblings = [];
        nextSibling = _quickdom(this.el.nextSibling);

        while (nextSibling) {
          siblings.push(nextSibling);
          nextSibling = nextSibling.next;
        }

        return siblings;
      }
    },
    'prev': {
      get: function get() {
        return _quickdom(this.el.previousSibling);
      }
    },
    'prevEl': {
      get: function get() {
        return _quickdom(this.el.previousElementSibling);
      }
    },
    'prevElAll': {
      get: function get() {
        return _filterElements(this.prevAll);
      }
    },
    'prevAll': {
      get: function get() {
        var prevSibling, siblings;
        siblings = [];
        prevSibling = _quickdom(this.el.previousSibling);

        while (prevSibling) {
          siblings.push(prevSibling);
          prevSibling = prevSibling.prev;
        }

        return siblings;
      }
    },
    'siblings': {
      get: function get() {
        return this.prevAll.reverse().concat(this.nextAll);
      }
    },
    'elementSiblings': {
      get: function get() {
        return _filterElements(this.siblings);
      }
    },
    'child': {
      get: function get() {
        return this._childRefs || _getChildRefs(this);
      }
    },
    'childf': {
      get: function get() {
        return _getChildRefs(this, true);
      }
    },
    'firstChild': {
      get: function get() {
        return this.children[0];
      }
    },
    'lastChild': {
      get: function get() {
        var children;
        children = this.children;
        return children[children.length - 1];
      }
    },
    'index': {
      get: function get() {
        var parent;

        if (!(parent = this.parent)) {
          return null;
        } else {
          return parent.children.indexOf(this);
        }
      }
    },
    'indexType': {
      get: function get() {
        return _getIndexByProp(this, 'type');
      }
    },
    'indexRef': {
      get: function get() {
        return _getIndexByProp(this, 'ref');
      }
    }
  });
}

_quickdom.query = function (target) {
  return _quickdom(document).query(target);
};

_quickdom.queryAll = function (target) {
  return _quickdom(document).queryAll(target);
};

var DUMMY_ARRAY;
DUMMY_ARRAY = [];

var state = function state(targetState, value, bubbles, source) {
  var activeStates, child, desiredValue, i, j, key, keys, len, prop, ref, toggle;

  if (arguments.length === 0) {
    return this._state.slice();
  }

  if (arguments.length === 1) {
    if (IS$1.string(targetState)) {
      return includes$1(this._state, targetState);
    } else if (IS$1.object(targetState)) {
      keys = Object.keys(targetState);
      i = -1;

      while (key = keys[++i]) {
        this.state(key, targetState[key]);
      }

      return this;
    }
  } else if (this._statePipeTarget && source !== this) {
    this._statePipeTarget.state(targetState, value, bubbles, this);

    return this;
  } else if (IS$1.string(targetState)) {
    if (targetState[0] === '$') {
      targetState = targetState.slice(1);
    }

    if (targetState === 'base') {
      return this;
    }

    desiredValue = !!value; // Convert the value to a boolean

    activeStates = this._getActiveStates(targetState, false); // ==== Toggle styles for this state =================================================================================

    if (this.state(targetState) !== desiredValue) {
      prop = this.type === 'text' ? 'Text' : 'Style';

      if (desiredValue) {
        //is on
        this._state.push(targetState);

        toggle = 'ON';
      } else {
        removeItem(this._state, targetState);
        toggle = 'OFF';
      }

      this['_turn' + prop + toggle](targetState, activeStates);
      this.emitPrivate("stateChange:".concat(targetState), desiredValue);
    } // ==== Pass state to parent/children =================================================================================


    if (!includes$1(this.options.unpassableStates, targetState)) {
      if (bubbles) {
        if (this.parent) {
          this._parent.state(targetState, value, true, source || this);
        }
      } else if (this.options.passStateToChildren) {
        ref = this._children;

        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.state(targetState, value, false, source || this);
        }
      }
    }

    return this;
  }
};

var toggleState = function toggleState(targetState) {
  return this.state(targetState, !this.state(targetState));
};

var resetState = function resetState() {
  var activeState, j, len, ref;
  ref = this._state.slice();

  for (j = 0, len = ref.length; j < len; j++) {
    activeState = ref[j];
    this.state(activeState, false);
  }

  return this;
};

var pipeState = function pipeState(targetEl) {
  var activeState, j, len, ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      this._statePipeTarget = targetEl;
      ref = this._state;

      for (j = 0, len = ref.length; j < len; j++) {
        activeState = ref[j];
        targetEl.state(activeState, true);
      }
    }
  } else if (targetEl === false) {
    delete this._statePipeTarget;
  }

  return this;
};

var _applyRegisteredStyle = function _applyRegisteredStyle(targetStyle, superiorStates, includeBase, skipFns) {
  var className, entry, j, k, len, len1, ref, ref1, superiorStyles;

  if (targetStyle) {
    ref = targetStyle.className;

    for (j = 0, len = ref.length; j < len; j++) {
      className = ref[j];
      this.addClass(className);
    }

    if (targetStyle.fns.length && !skipFns) {
      if (superiorStates) {
        superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
      }

      ref1 = targetStyle.fns;

      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];

        if (!(superiorStyles && superiorStyles[entry[0]])) {
          this.style(entry[0], entry[1]);
        }
      }
    }
  }
};

var _removeRegisteredStyle = function _removeRegisteredStyle(targetStyle, superiorStates, includeBase) {
  var className, entry, j, k, len, len1, ref, ref1, resetValue, superiorStyles;
  ref = targetStyle.className;

  for (j = 0, len = ref.length; j < len; j++) {
    className = ref[j];
    this.removeClass(className);
  }

  if (targetStyle.fns.length) {
    if (superiorStates) {
      superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
    }

    ref1 = targetStyle.fns;

    for (k = 0, len1 = ref1.length; k < len1; k++) {
      entry = ref1[k];
      resetValue = superiorStyles && superiorStyles[entry[0]] || null;
      this.style(entry[0], resetValue);
    }
  }
};

var _turnStyleON = function _turnStyleON(targetState, activeStates) {
  var j, len, sharedStates, skipFns, stateChain;
  skipFns = this.options.styleAfterInsert && !this._inserted;

  if (this._styles[targetState]) {
    this._applyRegisteredStyle(this._styles[targetState], this._getSuperiorStates(targetState, activeStates), false, skipFns);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];

      if (!includes$1(this._stateShared, stateChain.string)) {
        this._stateShared.push(stateChain.string);
      }

      this._applyRegisteredStyle(this._styles[stateChain.string], null, null, skipFns);
    }
  }
};

var _turnStyleOFF = function _turnStyleOFF(targetState, activeStates) {
  var activeSharedStates, j, len, sharedStates, stateChain, targetStyle;

  if (this._styles[targetState]) {
    this._removeRegisteredStyle(this._styles[targetState], activeStates, true);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    if (sharedStates.length === 0) {
      return;
    }

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];
      removeItem(this._stateShared, stateChain.string);
      targetStyle = this._styles[stateChain.string];

      if (targetStyle.fns.length && this._stateShared.length && !activeSharedStates) {
        activeSharedStates = this._stateShared.filter(function (state) {
          return !includes$1(state, targetState);
        });
        activeStates = activeStates.concat(activeSharedStates);
      }

      this._removeRegisteredStyle(targetStyle, activeStates, true);
    }
  }
};

var _turnTextON = function _turnTextON(targetState, activeStates) {
  var superiorStates, targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    superiorStates = this._getSuperiorStates(targetState, activeStates);

    if (!superiorStates.length) {
      this.text = targetText;
    }
  }
};

var _turnTextOFF = function _turnTextOFF(targetState, activeStates) {
  var targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    activeStates = activeStates.filter(function (state) {
      return state !== targetState;
    });
    targetText = this._texts[activeStates[activeStates.length - 1]];

    if (targetText == null) {
      targetText = this._texts.base;
    }

    this.text = targetText;
  }
};

var _getActiveStates = function _getActiveStates(stateToExclude) {
  var includeSharedStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var activeStates, j, len, plainStates;

  if (!this._providedStates) {
    return DUMMY_ARRAY;
  }

  activeStates = plainStates = this._state;

  if (stateToExclude) {
    plainStates = [];

    for (j = 0, len = activeStates.length; j < len; j++) {
      state = activeStates[j];

      if (state !== stateToExclude) {
        plainStates.push(state);
      }
    }
  }

  if (!includeSharedStates || !this._providedStatesShared) {
    return plainStates;
  } else {
    return plainStates.concat(this._stateShared);
  }
};

var _getSuperiorStates = function _getSuperiorStates(targetState, activeStates) {
  var candidate, j, len, superior, targetStateIndex;
  targetStateIndex = this._providedStates.indexOf(targetState);

  if (targetStateIndex === this._providedStates.length - 1) {
    return DUMMY_ARRAY;
  }

  superior = [];

  for (j = 0, len = activeStates.length; j < len; j++) {
    candidate = activeStates[j];

    if (this._providedStates.indexOf(candidate) > targetStateIndex) {
      superior.push(candidate);
    }
  }

  return superior;
};

var _getSharedStates = function _getSharedStates(targetState) {
  var activeStates, j, len, ref, sharedStates, stateChain;
  activeStates = this._state;
  sharedStates = [];
  ref = this._providedStatesShared;

  for (j = 0, len = ref.length; j < len; j++) {
    stateChain = ref[j];

    if (stateChain.includes(targetState) && stateChain.isApplicable(targetState, activeStates)) {
      sharedStates.push(stateChain);
    }
  }

  return sharedStates;
};

var _resolveFnStyles = function _resolveFnStyles(states, includeBase) {
  var entry, j, k, len, len1, output, ref;

  if (includeBase) {
    states = ['base'].concat(states);
  }

  output = {};

  for (j = 0, len = states.length; j < len; j++) {
    state = states[j];

    if (this._styles[state] && this._styles[state].fns.length) {
      ref = this._styles[state].fns;

      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        output[entry[0]] = entry[1];
      }
    }
  }

  return output;
};

function state$1(QuickElement) {
  QuickElement.prototype.state = state;
  QuickElement.prototype.toggleState = toggleState;
  QuickElement.prototype.resetState = resetState;
  QuickElement.prototype.pipeState = pipeState;
  QuickElement.prototype._applyRegisteredStyle = _applyRegisteredStyle;
  QuickElement.prototype._removeRegisteredStyle = _removeRegisteredStyle;
  QuickElement.prototype._turnStyleON = _turnStyleON;
  QuickElement.prototype._turnStyleOFF = _turnStyleOFF;
  QuickElement.prototype._turnTextON = _turnTextON;
  QuickElement.prototype._turnTextOFF = _turnTextOFF;
  QuickElement.prototype._getActiveStates = _getActiveStates;
  QuickElement.prototype._getSuperiorStates = _getSuperiorStates;
  QuickElement.prototype._getSharedStates = _getSharedStates;
  return QuickElement.prototype._resolveFnStyles = _resolveFnStyles;
}

var toTemplate = function toTemplate() {
  return _quickdom.template(this);
};

var clone = function clone() {
  var activeState, callback, callbacks, child, elClone, eventName, i, j, k, len, len1, len2, newEl, options, ref, ref1, ref2;
  elClone = this.el.cloneNode(false);
  options = primaryBuilder$1.clone(this.options, {
    existing: elClone
  });
  newEl = new this.constructor(this.type, options);
  ref = this._state;

  for (i = 0, len = ref.length; i < len; i++) {
    activeState = ref[i];
    newEl.state(activeState, true);
  }

  ref1 = this.children;

  for (j = 0, len1 = ref1.length; j < len1; j++) {
    child = ref1[j];
    newEl.append(child.clone());
  }

  ref2 = this._eventCallbacks;

  for (eventName in ref2) {
    callbacks = ref2[eventName];

    for (k = 0, len2 = callbacks.length; k < len2; k++) {
      callback = callbacks[k];
      newEl.on(eventName, callback);
    }
  }

  return newEl;
};

var append = function append(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.push(targetEl);

      this.el.appendChild(targetEl.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var appendTo = function appendTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.append(this);
    }
  }

  return this;
};

var prepend = function prepend(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.unshift(targetEl);

      this.el.insertBefore(targetEl.el, this.el.firstChild);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var prependTo = function prependTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.prepend(this);
    }
  }

  return this;
};

var after = function after(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex + 1, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el.nextSibling);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertAfter = function insertAfter(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.after(this);
    }
  }

  return this;
};

var before = function before(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertBefore = function insertBefore(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.before(this);
    }
  }

  return this;
};

var detach = function detach() {
  var ref;

  if ((ref = this.parent) != null) {
    ref._removeChild(this);
  }

  return this;
};

var remove = function remove() {
  var eventName;
  this.detach();
  this.resetState();

  if (this._eventCallbacks) {
    for (eventName in this._eventCallbacks) {
      this._eventCallbacks[eventName].length = 0;
    }
  }

  return this;
};

var empty = function empty() {
  var child, i, len, ref;
  ref = this.children.slice();

  for (i = 0, len = ref.length; i < len; i++) {
    child = ref[i];

    this._removeChild(child);
  }

  return this;
};

var wrap = function wrap(targetEl) {
  var currentParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);
    currentParent = this.parent;

    if (IS$1.quickDomEl(targetEl) && targetEl !== this && targetEl !== this.parent) {
      if (currentParent) {
        currentParent._removeChild(this, !targetEl.parent ? targetEl : void 0);
      }

      targetEl.append(this);
    }
  }

  return this;
};

var unwrap = function unwrap() {
  var grandParent, parent, parentChildren, parentSibling;
  parent = this.parent;

  if (parent) {
    parentChildren = _quickdom.batch(parent.children);
    parentSibling = parent.next;
    grandParent = parent.parent;

    if (grandParent) {
      parent.detach();

      if (parentSibling) {
        parentChildren.insertBefore(parentSibling);
      } else {
        parentChildren.appendTo(grandParent);
      }
    }
  }

  return this;
};

var replace = function replace(targetEl) {
  var ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      targetEl.detach();

      if ((ref = this.parent) != null) {
        ref._removeChild(this, targetEl);
      }

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var hasClass = function hasClass(target) {
  return includes$1(this.classList, target);
};

var addClass = function addClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex === -1) {
    classList.push(target);
    this.className = classList.length > 1 ? classList.join(' ') : classList[0];
  }

  return this;
};

var removeClass = function removeClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex !== -1) {
    classList.splice(targetIndex, 1);
    this.className = classList.length ? classList.join(' ') : '';
  }

  return this;
};

var toggleClass = function toggleClass(target) {
  if (this.hasClass(target)) {
    this.removeClass(target);
  } else {
    this.addClass(target);
  }

  return this;
};

var setRef = function setRef(target) {
  this.ref = this.options.ref = target;
  this.attr('data-ref', target);
  return this;
};

var _refreshParent = function _refreshParent() {
  return this.parent;
};

var _removeChild = function _removeChild(targetChild, replacementChild) {
  var indexOfChild;
  indexOfChild = this.children.indexOf(targetChild);

  if (indexOfChild !== -1) {
    if (replacementChild) {
      this.el.replaceChild(replacementChild.el, targetChild.el);

      this._children.splice(indexOfChild, 1, replacementChild);
    } else {
      this.el.removeChild(targetChild.el);

      this._children.splice(indexOfChild, 1);
    }
  }

  return this;
};

function manipulation(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'html': {
      get: function get() {
        return this.el.innerHTML;
      },
      set: function set(newValue) {
        return this.el.innerHTML = newValue;
      }
    },
    'text': {
      get: function get() {
        return this.el.textContent;
      },
      set: function set(newValue) {
        return this.el.textContent = newValue;
      }
    },
    'className': {
      get: function get() {
        if (this.svg) {
          return this.attr('class') || '';
        } else {
          return this.raw.className;
        }
      },
      set: function set(newValue) {
        if (this.svg) {
          return this.attr('class', newValue);
        } else {
          return this.raw.className = newValue;
        }
      }
    },
    'classList': {
      get: function get() {
        var list;
        list = this.className.split(/\s+/);

        if (list[list.length - 1] === '') {
          list.pop();
        }

        if (list[0] === '') {
          list.shift();
        }

        return list;
      }
    }
  });
  QuickElement.prototype.toTemplate = toTemplate;
  QuickElement.prototype.clone = clone;
  QuickElement.prototype.append = append;
  QuickElement.prototype.appendTo = appendTo;
  QuickElement.prototype.prepend = prepend;
  QuickElement.prototype.prependTo = prependTo;
  QuickElement.prototype.after = after;
  QuickElement.prototype.insertAfter = insertAfter;
  QuickElement.prototype.before = before;
  QuickElement.prototype.insertBefore = insertBefore;
  QuickElement.prototype.detach = detach;
  QuickElement.prototype.remove = remove;
  QuickElement.prototype.empty = empty;
  QuickElement.prototype.wrap = wrap;
  QuickElement.prototype.unwrap = unwrap;
  QuickElement.prototype.replace = replace;
  QuickElement.prototype.hasClass = hasClass;
  QuickElement.prototype.addClass = addClass;
  QuickElement.prototype.removeClass = removeClass;
  QuickElement.prototype.toggleClass = toggleClass;
  QuickElement.prototype.setRef = setRef;
  QuickElement.prototype._refreshParent = _refreshParent;
  return QuickElement.prototype._removeChild = _removeChild;
}

var updateOptions = function updateOptions(options) {
  if (IS$1.object(options)) {
    this.options = options;

    this._normalizeOptions();

    this._applyOptions(this.options);
  }

  return this;
};

var updateStateStyles = function updateStateStyles(styles) {
  var i, len, parsed, state, updatedStates;

  if (IS$1.objectPlain(styles)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseStyles(styles));

    if (parsed._styles) {
      updatedStates = Object.keys(parsed._styles);

      for (i = 0, len = updatedStates.length; i < len; i++) {
        state = updatedStates[i];

        if (this.state(state) || state === 'base') {
          this._applyRegisteredStyle(this._styles[state], this._getActiveStates(state), false);
        }
      }
    }
  }

  return this;
};

var updateStateTexts = function updateStateTexts(texts) {
  var parsed;

  if (IS$1.objectPlain(texts)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseTexts(texts));
  }

  return this;
};

var applyData = function applyData(data, passThrough) {
  var child, computers, defaults, i, j, key, keys, len, len1, ref;

  if (this.options.passDataToChildren && this._children.length && (passThrough != null ? passThrough : passThrough = true)) {
    ref = this._children;

    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      child.applyData(data);
    }
  }

  if (computers = this.options.computers) {
    defaults = this.options.defaults;
    keys = Object.keys(computers);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];

      if (this.options.invokeComputersOnce) {
        if (this._invokedComputers[key]) {
          continue;
        }

        this._invokedComputers[key] = 1;
      }

      if (data && data.hasOwnProperty(key)) {
        this._runComputer(key, data[key], data);
      } else if (defaults && defaults.hasOwnProperty(key)) {
        this._runComputer(key, defaults[key], data);
      }
    }
  }

  return this;
};

var _runComputer = function _runComputer(computer, arg, data) {
  return this.options.computers[computer].call(this, arg, data);
};

function application(QuickElement) {
  QuickElement.prototype.updateOptions = updateOptions;
  QuickElement.prototype.updateStateStyles = updateStateStyles;
  QuickElement.prototype.updateStateTexts = updateStateTexts;
  QuickElement.prototype.applyData = applyData;
  return QuickElement.prototype._runComputer = _runComputer;
}

var attr = function attr(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el.getAttribute(target);
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.attr(key, target[key]);
      }
    }
  } else if (newValue === null) {
    return this.el.removeAttribute(target);
  } else {
    this.el.setAttribute(target, newValue);
  }

  return this;
};

var prop = function prop(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el[target];
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.prop(key, target[key]);
      }
    }
  } else {
    this.el[target] = newValue;
  }

  return this;
};

function attributesAndProperties(QuickElement) {
  QuickElement.prototype.attr = attr;
  return QuickElement.prototype.prop = prop;
}

var QuickElement$1, svgNamespace;
svgNamespace = 'http://www.w3.org/2000/svg';

var QuickElement$2 = QuickElement$1 = function () {
  var QuickElement =
  /*#__PURE__*/
  function () {
    function QuickElement(type, options) {
      _classCallCheck$1(this, QuickElement);

      this.type = type;
      this.options = options;
      QuickElement.count++;

      if (this.type[0] === '*') {
        this.svg = true;
      }

      this.el = this.options.existing || (this.type === 'text' ? document.createTextNode(typeof this.options.text === 'string' ? this.options.text : '') : this.svg ? document.createElementNS(svgNamespace, this.type.slice(1)) : document.createElement(this.type));

      if (this.type === 'text') {
        this.append = this.prepend = this.attr = function () {};
      } // @_texts = {} # defined conditionally


      this._parent = null;
      this._styles = {};
      this._state = [];
      this._children = []; // @_providedStates = []				# defined conditionally
      // @_providedStatesShared = []		# defined conditionally
      // @_eventCallbacks = {__refs:{}}	# defined conditionally

      this._normalizeOptions();

      this._applyOptions();

      this._attachStateEvents();

      this._proxyParent();

      if (this.options.existing) {
        this._refreshParent();
      }

      this.el._quickElement = this;
    }

    _createClass$1(QuickElement, [{
      key: "toJSON",
      value: function toJSON() {
        var child, children, i, len, output;
        output = [this.type, primaryBuilder$1.clone.keys(element)(this.options)];
        children = this.children;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          output.push(child.toJSON());
        }

        return output;
      }
    }]);

    return QuickElement;
  }();

  QuickElement.count = 0;
  return QuickElement;
}.call(undefined);
/* istanbul ignore next */


if (QuickElement$1.name == null) {
  QuickElement$1.name = 'QuickElement';
}

init$1(QuickElement$1);
aliases(QuickElement$1);
traversing(QuickElement$1);
events(QuickElement$1);
state$1(QuickElement$1);
style$1(QuickElement$1);
manipulation(QuickElement$1);
application(QuickElement$1);
attributesAndProperties(QuickElement$1);
var schema = {
  type: 'div',
  ref: void 0,
  options: {},
  children: []
};

var matchesSchema = function matchesSchema(object) {
  return typeof object.type !== 'undefined' || typeof object.ref !== 'undefined' || typeof object.options !== 'undefined' || typeof object.children !== 'undefined';
};

var PARSE_ERROR_PREFIX, parseTree;
PARSE_ERROR_PREFIX = 'Template Parse Error: expected';

var parseTree$1 = parseTree = function parseTree(tree, parseChildren) {
  var output;

  switch (false) {
    case !IS$1.array(tree):
      output = {};

      if (!IS$1.string(tree[0])) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " string for 'type', got '").concat(String(tree[0]), "'"));
      } else {
        output.type = tree[0];
      }

      if (tree.length > 1 && !IS$1.object(tree[1]) && tree[1] !== null) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " object for 'options', got '").concat(String(tree[1]), "'"));
      } else {
        output.options = tree[1] ? primaryBuilder$1.deep.clone(tree[1]) : schema.options;

        if (tree[1]) {
          output.ref = tree[1].id || tree[1].ref;
        }
      }

      output.children = tree.slice(2);

      if (parseChildren === false) {
        if (tree.length === 3 && IS$1.objectPlain(tree[2]) && !IS$1.template(tree[2])) {
          output.children = tree[2];
        }
      } else {
        output.children = output.children.map(quickdom.template);
      }

      return output;

    case !(IS$1.string(tree) || IS$1.domText(tree)):
      return {
        type: 'text',
        options: {
          text: tree.textContent || tree
        },
        children: schema.children
      };

    case !IS$1.domEl(tree):
      return {
        type: tree.nodeName.toLowerCase(),
        ref: tree.id,
        options: primaryBuilder$1.clone.keys(template)(tree),
        children: schema.children.map.call(tree.childNodes, quickdom.template)
      };

    case !IS$1.quickDomEl(tree):
      return {
        type: tree.type,
        ref: tree.ref,
        options: primaryBuilder$1.clone.deep.notKeys(['relatedInstance', 'related'])(tree.options),
        children: tree.children.map(quickdom.template)
      };

    case !IS$1.template(tree):
      return tree;

    default:
      throw new Error("".concat(PARSE_ERROR_PREFIX, " (array || string || domEl || quickDomEl || template), got ").concat(String(tree)));
  }
};

var NOT_DEEP_KEYS, NOT_KEYS, _extendByRef, extendTemplate;

NOT_DEEP_KEYS = ['relatedInstance', 'related', 'data'];
NOT_KEYS = ['children', '_childRefs'];

var extendTemplate$1 = extendTemplate = function extendTemplate(currentOpts, newOpts, globalOpts) {
  var currentChild, currentChildren, globalOptsTransform, index$$1, maxLength, needsTemplateWrap, newChild, newChildProcessed, newChildren, noChanges, output, ref, remainingNewChildren;

  if (globalOpts) {
    globalOptsTransform = {
      options: function options(opts) {
        return primaryBuilder$1(opts, globalOpts);
      }
    };
  }

  if (IS$1.array(newOpts)) {
    newOpts = parseTree$1(newOpts, false);
  } else if (newOpts && !matchesSchema(newOpts)) {
    newOpts = {
      options: newOpts
    };
  }

  output = primaryBuilder$1.deep.nullDeletes.notKeys(NOT_KEYS).notDeep(NOT_DEEP_KEYS).transform(globalOptsTransform).clone(currentOpts, newOpts);
  currentChildren = currentOpts.children;
  newChildren = (newOpts != null ? newOpts.children : void 0) || [];
  output.children = [];
  /* istanbul ignore next */

  if (IS$1.array(newChildren)) {
    maxLength = Math.max(currentChildren.length, newChildren.length);
    index$$1 = -1;

    while (++index$$1 !== maxLength) {
      needsTemplateWrap = noChanges = false;
      currentChild = currentChildren[index$$1];
      newChild = newChildren[index$$1];

      newChildProcessed = function () {
        switch (false) {
          case !IS$1.template(newChild):
            return newChild;

          case !IS$1.array(newChild):
            return needsTemplateWrap = parseTree$1(newChild);

          case !IS$1.string(newChild):
            return needsTemplateWrap = {
              type: 'text',
              options: {
                text: newChild
              }
            };

          case !(!newChild && !globalOpts):
            return noChanges = true;

          default:
            return needsTemplateWrap = newChild || true;
        }
      }();

      if (noChanges) {
        newChildProcessed = currentChild;
      } else if (needsTemplateWrap) {
        newChildProcessed = currentChild ? currentChild.extend(newChildProcessed, globalOpts) : new QuickTemplate$1(primaryBuilder$1.clone(schema, newChildProcessed));
      }

      output.children.push(newChildProcessed);
    }
  } else if (IS$1.object(newChildren)) {
    newChildren = primaryBuilder$1.allowNull.clone(newChildren);
    output.children = _extendByRef(newChildren, currentChildren, globalOpts);
    remainingNewChildren = newChildren;

    for (ref in remainingNewChildren) {
      newChild = remainingNewChildren[ref];
      newChildProcessed = IS$1.objectPlain(newChild) && !IS$1.template(newChild) ? newChild : parseTree$1(newChild);
      output.children.push(new QuickTemplate$1(newChildProcessed));
      delete remainingNewChildren[ref];
    }
  }

  return output;
};

_extendByRef = function extendByRef(newChildrenRefs, currentChildren, globalOpts) {
  var currentChild, i, len, newChild, newChildProcessed, output;

  if (!currentChildren.length) {
    return currentChildren;
  } else {
    output = [];

    for (i = 0, len = currentChildren.length; i < len; i++) {
      currentChild = currentChildren[i];
      newChild = newChildrenRefs[currentChild.ref];

      if (newChild) {
        newChildProcessed = currentChild.extend(newChild, globalOpts);
        delete newChildrenRefs[currentChild.ref];
      } else if (newChild === null) {
        delete newChildrenRefs[currentChild.ref];
        continue;
      } else {
        newChildProcessed = function () {
          switch (false) {
            case !globalOpts:
              return currentChild.extend(null, globalOpts);

            case !Object.keys(newChildrenRefs).length:
              return currentChild.extend();

            default:
              return currentChild;
          }
        }();
      }

      newChildProcessed.children = _extendByRef(newChildrenRefs, newChildProcessed.children);
      output.push(newChildProcessed);
    }

    return output;
  }
};

var QuickTemplate;

var QuickTemplate$1 = QuickTemplate =
/*#__PURE__*/
function () {
  function QuickTemplate(config, isTree) {
    _classCallCheck$1(this, QuickTemplate);

    if (IS$1.template(config)) {
      return config;
    }

    config = isTree ? parseTree$1(config) : config;
    primaryBuilder$1(this, config);
  }

  _createClass$1(QuickTemplate, [{
    key: "extend",
    value: function extend$$1(newValues, globalOpts) {
      return new QuickTemplate(extendTemplate$1(this, newValues, globalOpts));
    }
  }, {
    key: "spawn",
    value: function spawn(newValues, globalOpts, data) {
      var child, childData, children, element, i, len, options, type;

      if (newValues && newValues.data) {
        data = newValues.data;

        if (Object.keys(newValues).length === 1) {
          newValues = null;
        }
      }

      if (newValues || globalOpts) {
        var _extendTemplate = extendTemplate$1(this, newValues, globalOpts);

        options = _extendTemplate.options;
        children = _extendTemplate.children;
        type = _extendTemplate.type;
      } else {
        options = this.options;
        children = this.children;
        type = this.type;
        options = primaryBuilder$1.clone(options);
      }

      element = _quickdom.create([type, options]);

      if (children) {
        childData = options.passDataToChildren ? data || options.data : void 0;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          element.append(child.spawn(null, null, childData));
        }
      }

      element._postCreation(data);

      return element;
    }
  }]);

  return QuickTemplate;
}();
/* istanbul ignore next */


if (QuickTemplate.name == null) {
  QuickTemplate.name = 'QuickTemplate';
}

Object.defineProperty(QuickTemplate.prototype, 'child', {
  get: function get() {
    return this._childRefs || _getChildRefs(this);
  }
});

_quickdom.template = function (tree) {
  return new QuickTemplate(tree, true);
};

_quickdom.isTemplate = function (target) {
  return IS$1.template(target);
};

var QuickBatch;

var QuickBatch$1 = QuickBatch =
/*#__PURE__*/
function () {
  function QuickBatch(elements, returnResults1) {
    _classCallCheck$1(this, QuickBatch);

    this.returnResults = returnResults1;
    this.elements = elements.map(function (el) {
      return _quickdom(el);
    });
  }

  _createClass$1(QuickBatch, [{
    key: "reverse",
    value: function reverse() {
      this.elements = this.elements.reverse();
      return this;
    }
  }, {
    key: "return",
    value: function _return(returnNext) {
      if (returnNext) {
        this.returnResults = true;
        return this;
      } else {
        return this.lastResults;
      }
    }
  }]);

  return QuickBatch;
}();
/* istanbul ignore next */


if (QuickBatch.name == null) {
  QuickBatch.name = 'QuickBatch';
}

Object.keys(QuickElement$2.prototype).concat('css', 'replaceWith', 'html', 'text').forEach(function (method) {
  return QuickBatch.prototype[method] = function (newValue) {
    var element, results;

    results = this.lastResults = function () {
      var i, len, ref, results1;
      ref = this.elements;
      results1 = [];

      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];

        if (method === 'html' || method === 'text') {
          if (newValue) {
            results1.push(element[method] = newValue);
          } else {
            results1.push(element[method]);
          }
        } else {
          var _element;

          results1.push((_element = element)[method].apply(_element, arguments));
        }
      }

      return results1;
    }.apply(this, arguments);

    if (this.returnResults) {
      return results;
    } else {
      return this;
    }
  };
});

_quickdom.batch = function (elements, returnResults) {
  if (!IS$1.iterable(elements)) {
    throw new Error("Batch: expected an iterable, got ".concat(String(elements)));
  }

  return new QuickBatch(elements, returnResults);
};

var version$2 = "1.0.93";
var SHORTCUTS, i, len, shortcut;
SHORTCUTS = ['link:a', 'anchor:a', 'a', 'text', 'div', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'footer', 'section', 'button', 'br', 'ul', 'ol', 'li', 'fieldset', 'input', 'textarea', 'select', 'option', 'form', 'frame', 'hr', 'iframe', 'img', 'picture', 'main', 'nav', 'meta', 'object', 'pre', 'style', 'table', 'tbody', 'th', 'tr', 'td', 'tfoot', // 'template'
'video'];

for (i = 0, len = SHORTCUTS.length; i < len; i++) {
  shortcut = SHORTCUTS[i];

  (function (shortcut) {
    var prop, split, type;
    prop = type = shortcut;

    if (includes$1(shortcut, ':')) {
      split = shortcut.split(':');
      prop = split[0];
      type = split[1];
    }

    return _quickdom[prop] = function () {
      return _quickdom.apply(void 0, [type].concat(Array.prototype.slice.call(arguments)));
    };
  })(shortcut);
}

init(QuickElement$2, QuickWindow$2);
_quickdom.QuickElement = QuickElement$2;
_quickdom.QuickTemplate = QuickTemplate$1;
_quickdom.QuickWindow = QuickWindow$2;
_quickdom.QuickBatch = QuickBatch$1;
_quickdom.version = version$2;
_quickdom.CSS = index;
var quickdom = _quickdom; // export {quickdom as default, QuickElement, QuickTemplate, QuickWindow, QuickBatch}
var restartSandbox;
var restartSandbox$1 = restartSandbox = function () {
  var field, id, ref;

  if (window.sandbox) {
    ref = quickfield.instances;

    for (id in ref) {
      field = ref[id];
      delete quickfield.instances[id];
    }

    window.sandbox.remove();
  }

  return window.sandbox = quickdom.div({
    id: 'sandbox',
    style: {
      border: '1px solid',
      padding: '20px',
      boxSizing: 'border-box'
    }
  }).appendTo(document.body);
};function addTitle (title, margin = 20) {
  return quickdom.div({
    ref: 'testTitle',
    style: {
      marginTop: margin,
      marginBottom: margin,
      fontSize: 16,
      fontWeight: 600,
      fontFamily: 'system-ui, sans-serif'
    }
  }, title).appendTo(sandbox);
}function addDivider () {
  var margin;
  margin = arguments[0];

  if (isNaN(margin)) {
    margin = 20;
  }

  return quickdom.div({
    ref: 'testTitle',
    style: {
      marginTop: margin,
      marginBottom: margin
    }
  }).appendTo(sandbox);
}function getBorderSides (el) {
  return {
    top: el.style('borderTopWidth'),
    bottom: el.style('borderBottomWidth'),
    left: el.style('borderLeftWidth'),
    right: el.style('borderRightWidth')
  };
}var pFinally = (promise, onFinally) => {
  onFinally = onFinally || (() => {});

  return promise.then(val => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => val), err => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => {
    throw err;
  }));
};class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'TimeoutError';
  }

}

var pTimeout = (promise, ms, fallback) => new Promise((resolve, reject) => {
  if (typeof ms !== 'number' && ms >= 0) {
    throw new TypeError('Expected `ms` to be a positive number');
  }

  const timer = setTimeout(() => {
    if (typeof fallback === 'function') {
      resolve(fallback());
      return;
    }

    const message = typeof fallback === 'string' ? fallback : `Promise timed out after ${ms} milliseconds`;
    const err = fallback instanceof Error ? fallback : new TimeoutError(message);
    reject(err);
  }, ms);
  pFinally(promise.then(resolve, reject), () => {
    clearTimeout(timer);
  });
});

var TimeoutError_1 = TimeoutError;
pTimeout.TimeoutError = TimeoutError_1;var pEvent = (emitter, event, opts) => {
  let cancel;
  const ret = new Promise((resolve, reject) => {
    if (typeof opts === 'function') {
      opts = {
        filter: opts
      };
    }

    opts = Object.assign({
      rejectionEvents: ['error'],
      multiArgs: false
    }, opts);
    let addListener = emitter.on || emitter.addListener || emitter.addEventListener;
    let removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;

    if (!addListener || !removeListener) {
      throw new TypeError('Emitter is not compatible');
    }

    addListener = addListener.bind(emitter);
    removeListener = removeListener.bind(emitter);

    const resolveHandler = function (value) {
      if (opts.multiArgs) {
        value = [].slice.apply(arguments);
      }

      if (opts.filter && !opts.filter(value)) {
        return;
      }

      cancel();
      resolve(value);
    };

    const rejectHandler = function (reason) {
      cancel();

      if (opts.multiArgs) {
        reject([].slice.apply(arguments));
      } else {
        reject(reason);
      }
    };

    cancel = () => {
      removeListener(event, resolveHandler);

      for (const rejectionEvent of opts.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };

    addListener(event, resolveHandler);

    for (const rejectionEvent of opts.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
  });
  ret.cancel = cancel;

  if (typeof opts.timeout === 'number') {
    return pTimeout(ret, opts.timeout);
  }

  return ret;
};var COLORS = {
  red: '#cc4820',
  green: '#72c322',
  orange: '#ff9c00',
  black: '#181818',
  grey_dark: '#5e5e5e',
  grey: '#909090',
  grey_semi_light: '#bebebe',
  grey_light: '#d3d3d3',
  grey_light2: '#dddddd',
  grey_light3: '#f2f5f7',
  grey_light4: '#e5e5e5'
};var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
function exclude() {
  var excludes = [].slice.call(arguments);

  function excludeProps(res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude() {
    var args = [].slice.call(arguments),
        i = 0,
        res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
}
/*!
 * Primary Exports
 */

var assertionError = AssertionError;
/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError(message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),
      props = extend(_props || {}); // default values

  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false; // copy from properties

  for (var key in props) {
    this[key] = props[key];
  } // capture stack trace


  ssf = ssf || arguments.callee;

  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch (e) {
      this.stack = e.stack;
    }
  }
}
/*!
 * Inherit from Error.prototype
 */


AssertionError.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';
/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;
/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack'),
      props = extend({
    name: this.name
  }, this); // include stack if exists and not turned off

  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  } // The `in` operator does not work with primitives.


  return name in Object(obj);
}
/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */


function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;

    if (mArr) {
      parsed = {
        i: parseFloat(mArr[1])
      };
    } else {
      parsed = {
        p: value.replace(/\\([.\[\]])/g, '$1')
      };
    }

    return parsed;
  });
}
/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */


function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];

    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }

  return res;
}
/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */


function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null; // Here we iterate through every part of the path

  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i]; // If it's the last part of the path, we set the 'propName' value with the property name

    if (i === pathDepth - 1) {
      propName = typeof part.p === 'undefined' ? part.i : part.p; // Now we set the property with the name held by 'propName' on object with the desired val

      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1]; // Here we set the name of the property which will be defined

      propName = typeof part.p === 'undefined' ? part.i : part.p; // Here we decide if this property will be an array or a new object

      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}
/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */


function getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */


function getPathValue(obj, path) {
  var info = getPathInfo(obj, path);
  return info.value;
}
/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */


function setPathValue(obj, path, val) {
  var parsed = parsePath(path);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

var pathval = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue
};/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */
var flag = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));

  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

var test$1 = function test(obj, args) {
  var negate = flag(obj, 'negate'),
      expr = args[0];
  return negate ? !expr : expr;
};var typeDetect = createCommonjsModule(function (module) {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var promiseExists = typeof Promise === 'function';
  var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line

  var isDom = 'location' in globalObject && 'document' in globalObject;
  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  module.exports = function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
     */


    if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
      return 'Array';
    }

    if (isDom) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (obj === globalObject.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (obj === globalObject.document) {
        return 'Document';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */


      if (obj === (globalObject.navigator || {}).mimeTypes) {
        return 'MimeTypeArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */


      if (obj === (globalObject.navigator || {}).plugins) {
        return 'PluginArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
       * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
       *  - IE <=10 === "[object HTMLBlockElement]"
       */


      if (obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (obj instanceof HTMLElement && obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (obj instanceof HTMLElement && obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    var objPrototype = Object.getPrototypeOf(obj);
    /* ! Speed optimisation
    * Pre:
    *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
    *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
    * Post:
    *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
    *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
    */

    if (objPrototype === RegExp.prototype) {
      return 'RegExp';
    }
    /* ! Speed optimisation
    * Pre:
    *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
    * Post:
    *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
    */


    if (objPrototype === Date.prototype) {
      return 'Date';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
     * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
     * Test: `Object.prototype.toString.call(Promise.resolve())``
     *  - Chrome <=47 === "[object Object]"
     *  - Edge <=20 === "[object Object]"
     *  - Firefox 29-Latest === "[object Promise]"
     *  - Safari 7.1-Latest === "[object Promise]"
     */


    if (promiseExists && objPrototype === Promise.prototype) {
      return 'Promise';
    }
    /* ! Speed optimisation
    * Pre:
    *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
    * Post:
    *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
    */


    if (setExists && objPrototype === Set.prototype) {
      return 'Set';
    }
    /* ! Speed optimisation
    * Pre:
    *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
    * Post:
    *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
    */


    if (mapExists && objPrototype === Map.prototype) {
      return 'Map';
    }
    /* ! Speed optimisation
    * Pre:
    *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
    * Post:
    *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
    */


    if (weakSetExists && objPrototype === WeakSet.prototype) {
      return 'WeakSet';
    }
    /* ! Speed optimisation
    * Pre:
    *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
    * Post:
    *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
    */


    if (weakMapExists && objPrototype === WeakMap.prototype) {
      return 'WeakMap';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
     * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
     * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
     *  - Edge <=13 === "[object Object]"
     */


    if (dataViewExists && objPrototype === DataView.prototype) {
      return 'DataView';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
     * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
     * Test: `Object.prototype.toString.call(new Map().entries())``
     *  - Edge <=13 === "[object Object]"
     */


    if (mapExists && objPrototype === mapIteratorPrototype) {
      return 'Map Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
     * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
     * Test: `Object.prototype.toString.call(new Set().entries())``
     *  - Edge <=13 === "[object Object]"
     */


    if (setExists && objPrototype === setIteratorPrototype) {
      return 'Set Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
     * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
     * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */


    if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
      return 'Array Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
     * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
     * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */


    if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
      return 'String Iterator';
    }
    /* ! Speed optimisation
    * Pre:
    *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
    * Post:
    *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
    */


    if (objPrototype === null) {
      return 'Object';
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  };

  module.exports.typeDetect = module.exports;
});
var typeDetect_1 = typeDetect.typeDetect;/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var expectTypes = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');
  flagMsg = flagMsg ? flagMsg + ': ' : '';
  obj = flag(obj, 'object');
  types = types.map(function (t) {
    return t.toLowerCase();
  });
  types.sort(); // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'

  var str = types.map(function (t, index) {
    var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');
  var objType = typeDetect(obj).toLowerCase();

  if (!types.some(function (expected) {
    return objType === expected;
  })) {
    throw new assertionError(flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given', undefined, ssfi);
  }
};/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */
var getActual = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;

function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';

  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);

    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

var getFuncName_1 = getFuncName;/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */
var getProperties = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);

  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */
var getEnumerableProperties = function getEnumerableProperties(object) {
  var result = [];

  for (var name in object) {
    result.push(name);
  }

  return result;
};var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */
  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */
  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */
  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */
  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */
  proxyExcludedKeys: ['then', 'inspect', 'toJSON']
};var inspect_1 = createCommonjsModule(function (module, exports) {
  // This is (almost) directly from Node.js utils
  // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js
  module.exports = inspect;
  /**
   * ### .inspect(obj, [showHidden], [depth], [colors])
   *
   * Echoes the value of a value. Tries to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
   *    properties of objects. Default is false.
   * @param {Number} depth Depth in which to descend in object. Default is 2.
   * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
   *    output. Default is false (no coloring).
   * @namespace Utils
   * @name inspect
   */

  function inspect(obj, showHidden, depth, colors) {
    var ctx = {
      showHidden: showHidden,
      seen: [],
      stylize: function (str) {
        return str;
      }
    };
    return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);
  } // Returns true if object is a DOM element.


  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object && typeof object === 'object' && 'nodeType' in object && object.nodeType === 1 && typeof object.nodeName === 'string';
    }
  };

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (typeof ret !== 'string') {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // If this is a DOM element, try to get the outer HTML.


    if (isDOMElement(value)) {
      if ('outerHTML' in value) {
        return value.outerHTML; // This value does not have an outerHTML attribute,
        //   it could still be an XML element
      } else {
        // Attempt to serialize it
        try {
          if (document.xmlVersion) {
            var xmlSerializer = new XMLSerializer();
            return xmlSerializer.serializeToString(value);
          } else {
            // Firefox 11- do not support outerHTML
            //   It does, however, support innerHTML
            //   Use the following to render the element
            var ns = "http://www.w3.org/1999/xhtml";
            var container = document.createElementNS(ns, '_');
            container.appendChild(value.cloneNode(false));
            var html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');
            container.innerHTML = '';
            return html;
          }
        } catch (err) {// This could be a non-native DOM implementation,
          //   continue with the normal flow:
          //   printing the element as if it is an object.
        }
      }
    } // Look up the keys of the object.


    var visibleKeys = getEnumerableProperties(value);
    var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
    var name, nameSuffix; // Some type of object without properties can be shortcutted.
    // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
    // a `stack` plus `description` property; ignore those for consistency.

    if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {
      if (typeof value === 'function') {
        name = getFuncName_1(value);
        nameSuffix = name ? ': ' + name : '';
        return ctx.stylize('[Function' + nameSuffix + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        typedArray = false,
        braces = ['{', '}'];

    if (isTypedArray(value)) {
      typedArray = true;
      braces = ['[', ']'];
    } // Make Array say that they are Array


    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (typeof value === 'function') {
      name = getFuncName_1(value);
      nameSuffix = name ? ': ' + name : '';
      base = ' [Function' + nameSuffix + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      return formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else if (typedArray) {
      return formatTypedArray(value);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');

      case 'number':
        if (value === 0 && 1 / value === -Infinity) {
          return ctx.stylize('-0', 'number');
        }

        return ctx.stylize('' + value, 'number');

      case 'boolean':
        return ctx.stylize('' + value, 'boolean');

      case 'symbol':
        return ctx.stylize(value.toString(), 'symbol');
    } // For some reason typeof null is "object", so special case here.


    if (value === null) {
      return ctx.stylize('null', 'null');
    }
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (Object.prototype.hasOwnProperty.call(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatTypedArray(value) {
    var str = '[ ';

    for (var i = 0; i < value.length; ++i) {
      if (str.length >= config.truncateThreshold - 7) {
        str += '...';
        break;
      }

      str += value[i] + ', ';
    }

    str += ' ]'; // Removing trailing `, ` if the array was not truncated

    if (str.indexOf(',  ]') !== -1) {
      str = str.replace(',  ]', ' ]');
    }

    return str;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name;
    var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
    var str;

    if (propDescriptor) {
      if (propDescriptor.get) {
        if (propDescriptor.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (propDescriptor.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
    }

    if (visibleKeys.indexOf(key) < 0) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(value[key]) < 0) {
        if (recurseTimes === null) {
          str = formatValue(ctx, value[key], null);
        } else {
          str = formatValue(ctx, value[key], recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (typeof name === 'undefined') {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }

  function isTypedArray(ar) {
    // Unfortunately there's no way to check if an object is a TypedArray
    // We have to check if it's one of these types
    return typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar));
  }

  function isArray(ar) {
    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
  }

  function isRegExp(re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  }

  function isDate(d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return typeof e === 'object' && objectToString(e) === '[object Error]';
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

var objDisplay = function objDisplay(obj) {
  var str = inspect_1(obj),
      type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj),
          kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

var getMessage = function getMessage(obj, args) {
  var negate = flag(obj, 'negate'),
      val = flag(obj, 'object'),
      expected = args[3],
      actual = getActual(obj, args),
      msg = negate ? args[2] : args[1],
      flagMsg = flag(obj, 'message');
  if (typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg.replace(/#\{this\}/g, function () {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function () {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function () {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ': ' + msg : msg;
};/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */
var transferFlags = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message') {
      object.__flags[flag] = flags[flag];
    }
  }
};/* globals Symbol: false, Uint8Array: false, WeakMap: false */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true
      });
    }
  }
};
var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/

function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql = deepEqual;
var MemoizeMap_1 = MemoizeMap;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect(leftHandOperand);

  if (leftHandType !== typeDetect(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive(value) {
  return value === null || typeof value !== 'object';
}
deepEql.MemoizeMap = MemoizeMap_1;/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */

var isProxyEnabled = function isProxyEnabled() {
  return config.useProxy && typeof Proxy !== 'undefined' && typeof Reflect !== 'undefined';
};/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

var addProperty = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;
  Object.defineProperty(ctx, name, {
    get: function propertyGetter() {
      // Setting the `ssfi` flag to `propertyGetter` causes this function to
      // be the starting point for removing implementation frames from the
      // stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', propertyGetter);
      }

      var result = getter.call(this);
      if (result !== undefined) return result;
      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

var addLengthGuard = function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;
  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' + ' to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' + ' docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
};/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 * 
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */

var builtins = ['__flags', '__methods', '_obj', 'assert'];

var proxify = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        }

        var orderedProperties = getProperties(target).filter(function (property) {
          return !Object.prototype.hasOwnProperty(property) && builtins.indexOf(property) === -1;
        }).sort(function (a, b) {
          return stringDistance(property, a) - stringDistance(property, b);
        });

        if (orderedProperties.length && stringDistance(orderedProperties[0], property) < 4) {
          // If the property is reasonably close to an existing Chai property,
          // suggest that property to the user.
          throw Error('Invalid Chai property: ' + property + '. Did you mean "' + orderedProperties[0] + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      } // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.


      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};
/**
 * # stringDistance(strA, strB)
 * Return the Levenshtein distance between two strings.
 * @param {string} strA
 * @param {string} strB
 * @return {number} the string distance between strA and strB
 * @api private
 */


function stringDistance(strA, strB, memo) {
  if (!memo) {
    // `memo` is a two-dimensional array containing a cache of distances
    // memo[i][j] is the distance between strA.slice(0, i) and
    // strB.slice(0, j).
    memo = [];

    for (var i = 0; i <= strA.length; i++) {
      memo[i] = [];
    }
  }

  if (!memo[strA.length] || !memo[strA.length][strB.length]) {
    if (strA.length === 0 || strB.length === 0) {
      memo[strA.length][strB.length] = Math.max(strA.length, strB.length);
    } else {
      memo[strA.length][strB.length] = Math.min(stringDistance(strA.slice(0, -1), strB, memo) + 1, stringDistance(strA, strB.slice(0, -1), memo) + 1, stringDistance(strA.slice(0, -1), strB.slice(0, -1), memo) + (strA.slice(-1) === strB.slice(-1) ? 0 : 1));
    }
  }

  return memo[strA.length][strB.length];
}/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */

var addMethod = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined) return result;
    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

var overwriteProperty = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name),
      _super = function () {};

  if (_get && 'function' === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: function overwritingPropertyGetter() {
      // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
      // function to be the starting point for removing implementation frames
      // from the stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', overwritingPropertyGetter);
      } // Setting the `lockSsfi` flag to `true` prevents the overwritten
      // assertion from changing the `ssfi` flag. By this point, the `ssfi`
      // flag is already set to the correct starting point for this assertion.


      var origLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      var result = getter(_super).call(this);
      flag(this, 'lockSsfi', origLockSsfi);

      if (result !== undefined) {
        return result;
      }

      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

var overwriteMethod = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name],
      _super = function () {
    throw new Error(name + ' is not a function');
  };

  if (_method && 'function' === typeof _method) _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    } // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.


    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/*!
 * Module variables
 */
// Check whether `Object.setPrototypeOf` is supported

var canSetPrototype = typeof Object.setPrototypeOf === 'function'; // Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.

var testFn = function () {};

var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name); // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.

  if (typeof propDesc !== 'object') return true;
  return !propDesc.configurable;
}); // Cache `Function` properties

var call = Function.prototype.call,
    apply = Function.prototype.apply;
/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

var addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () {};
  }

  var chainableBehavior = {
    method: method,
    chainingBehavior: chainingBehavior
  }; // save the methods so we can overwrite them later, if we need to.

  if (!ctx.__methods) {
    ctx.__methods = {};
  }

  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);

      var chainableMethodWrapper = function () {
        // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
        // function to be the starting point for removing implementation
        // frames from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then this assertion is being
        // invoked from inside of another assertion. In this case, the `ssfi`
        // flag has already been set by the outer assertion.
        //
        // Note that overwriting a chainable method merely replaces the saved
        // methods in `ctx.__methods` instead of completely replacing the
        // overwritten assertion. Therefore, an overwriting assertion won't
        // set the `ssfi` or `lockSsfi` flags.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', chainableMethodWrapper);
        }

        var result = chainableBehavior.method.apply(this, arguments);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai$1.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(chainableMethodWrapper, name, true); // Use `Object.setPrototypeOf` if available

      if (canSetPrototype) {
        // Inherit all properties from the object by replacing the `Function` prototype
        var prototype = Object.create(this); // Restore the `call` and `apply` methods from `Function`

        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } // Otherwise, redefine all properties (slow!)
      else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

      transferFlags(this, chainableMethodWrapper);
      return proxify(chainableMethodWrapper);
    },
    configurable: true
  });
};/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

var overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;

  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;

  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1 
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */

var compareByInspect = function compareByInspect(a, b) {
  return inspect_1(a) < inspect_1(b) ? -1 : 1;
};/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */
var getOwnEnumerablePropertySymbols = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];
  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */

var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}
/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */


function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}
/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */


function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;

  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}
/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */


var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;

function getFunctionName(constructorFn) {
  var name = '';

  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch$1);

    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}
/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */


function getConstructorName(errorLike) {
  var constructorName = errorLike;

  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() || getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}
/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */


function getMessage$1(errorLike) {
  var msg = '';

  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

var checkError = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage$1,
  getConstructorName: getConstructorName
};/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */
function isNaN$1(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
} // If ECMAScript 6's Number.isNaN is present, prefer that.


var _isNaN = Number.isNaN || isNaN$1;/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */

/*!
 * test utility
 */

var test$2 = test$1;
/*!
 * type utility
 */

var type = typeDetect;
/*!
 * expectTypes utility
 */

var expectTypes$1 = expectTypes;
/*!
 * message utility
 */

var getMessage$2 = getMessage;
/*!
 * actual utility
 */

var getActual$1 = getActual;
/*!
 * Inspect util
 */

var inspect = inspect_1;
/*!
 * Object Display util
 */

var objDisplay$1 = objDisplay;
/*!
 * Flag utility
 */

var flag$1 = flag;
/*!
 * Flag transferring utility
 */

var transferFlags$1 = transferFlags;
/*!
 * Deep equal utility
 */

var eql = deepEql;
/*!
 * Deep path info
 */

var getPathInfo$1 = pathval.getPathInfo;
/*!
 * Check if a property exists
 */

var hasProperty$1 = pathval.hasProperty;
/*!
 * Function name
 */

var getName = getFuncName_1;
/*!
 * add Property
 */

var addProperty$1 = addProperty;
/*!
 * add Method
 */

var addMethod$1 = addMethod;
/*!
 * overwrite Property
 */

var overwriteProperty$1 = overwriteProperty;
/*!
 * overwrite Method
 */

var overwriteMethod$1 = overwriteMethod;
/*!
 * Add a chainable method
 */

var addChainableMethod$1 = addChainableMethod;
/*!
 * Overwrite chainable method
 */

var overwriteChainableMethod$1 = overwriteChainableMethod;
/*!
 * Compare by inspect method
 */

var compareByInspect$1 = compareByInspect;
/*!
 * Get own enumerable property symbols method
 */

var getOwnEnumerablePropertySymbols$1 = getOwnEnumerablePropertySymbols;
/*!
 * Get own enumerable properties method
 */

var getOwnEnumerableProperties$1 = getOwnEnumerableProperties;
/*!
 * Checks error against a given set of criteria
 */

var checkError$1 = checkError;
/*!
 * Proxify util
 */

var proxify$1 = proxify;
/*!
 * addLengthGuard util
 */

var addLengthGuard$1 = addLengthGuard;
/*!
 * isProxyEnabled helper
 */

var isProxyEnabled$1 = isProxyEnabled;
/*!
 * isNaN method
 */

var isNaN$2 = _isNaN;
var utils = {
  test: test$2,
  type: type,
  expectTypes: expectTypes$1,
  getMessage: getMessage$2,
  getActual: getActual$1,
  inspect: inspect,
  objDisplay: objDisplay$1,
  flag: flag$1,
  transferFlags: transferFlags$1,
  eql: eql,
  getPathInfo: getPathInfo$1,
  hasProperty: hasProperty$1,
  getName: getName,
  addProperty: addProperty$1,
  addMethod: addMethod$1,
  overwriteProperty: overwriteProperty$1,
  overwriteMethod: overwriteMethod$1,
  addChainableMethod: addChainableMethod$1,
  overwriteChainableMethod: overwriteChainableMethod$1,
  compareByInspect: compareByInspect$1,
  getOwnEnumerablePropertySymbols: getOwnEnumerablePropertySymbols$1,
  getOwnEnumerableProperties: getOwnEnumerableProperties$1,
  checkError: checkError$1,
  proxify: proxify$1,
  addLengthGuard: addLengthGuard$1,
  isProxyEnabled: isProxyEnabled$1,
  isNaN: isNaN$2
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var assertion = function (_chai, util) {
  /*!
   * Module dependencies.
   */
  var AssertionError = _chai.AssertionError,
      flag = util.flag;
  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;
  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion(obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
    return util.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function () {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function (value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });
  Object.defineProperty(Assertion, 'showDiff', {
    get: function () {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function (value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */


  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
        actual: actual,
        expected: expected,
        showDiff: showDiff
      }, config.includeStack ? this.assert : flag(this, 'ssfi'));
    }
  };
  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */


  Object.defineProperty(Assertion.prototype, '_obj', {
    get: function () {
      return flag(this, 'object');
    },
    set: function (val) {
      flag(this, 'object', val);
    }
  });
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assertions = function (chai, _) {
  var Assertion = chai.Assertion,
      AssertionError = chai.AssertionError,
      flag = _.flag;
  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same', 'but', 'does'].forEach(function (chain) {
    Assertion.addProperty(chain);
  });
  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });
  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });
  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });
  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b').but.not.own.property('b'); 
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });
  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });
  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });
  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });
  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions. 
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an(type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object'),
        article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';
    this.assert(type === _.type(obj).toLowerCase(), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);
  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   * 
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return _.isNaN(a) && _.isNaN(b) || a === b;
  }

  function includeChainingBehavior() {
    flag(this, 'contains', true);
  }

  function include(val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate'),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(flagMsg + 'unable to use .deep.include with WeakSet', undefined, ssfi);
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }

        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }

        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + 'object tested must be an array, a map, an object,' + ' a set, a string, or a weakset, but ' + objType + ' given', undefined, ssfi);
        }

        var props = Object.keys(val),
            firstErr = null,
            numErrs = 0;
        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);

          _.transferFlags(this, propAssertion, true);

          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }

            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this); // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.

        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }

        return;
    } // Assert inclusion in collection or substring in a string.


    this.assert(included, 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val), 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);
  /**
   * ### .ok
   *
   * Asserts that the target is loosely (`==`) equal to `true`. However, it's
   * often best to assert that the target is strictly (`===`) or deeply equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
  });
  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', flag(this, 'negate') ? false : true);
  });
  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', flag(this, 'negate') ? true : false);
  });
  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');
  });
  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');
  });
  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(_.isNaN(flag(this, 'object')), 'expected #{this} to be NaN', 'expected #{this} not to be NaN');
  });
  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    var val = flag(this, 'object');
    this.assert(val !== null && val !== undefined, 'expected #{this} to exist', 'expected #{this} to not exist');
  });
  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        itemsCount;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;

      case 'map':
      case 'set':
        itemsCount = val.size;
        break;

      case 'weakmap':
      case 'weakset':
        throw new AssertionError(flagMsg + '.empty was passed a weak collection', undefined, ssfi);

      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);

        throw new AssertionError(msg.trim(), undefined, ssfi);

      default:
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + '.empty was passed non-string primitive ' + _.inspect(val), undefined, ssfi);
        }

        itemsCount = Object.keys(val).length;
    }

    this.assert(0 === itemsCount, 'expected #{this} to be empty', 'expected #{this} not to be empty');
  });
  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments() {
    var obj = flag(this, 'object'),
        type = _.type(obj);

    this.assert('Arguments' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);
  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   * 
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual(val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);
  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);
  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len > n, 'expected #{this} to have a length above #{exp} but got #{act}', 'expected #{this} to not have a length above #{exp}', n, len);
    } else {
      this.assert(obj > n, 'expected #{this} to be above #{exp}', 'expected #{this} to be at most #{exp}', n);
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);
  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is greater than or equal to the given number
   * `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The alias `.gte` can be used interchangeably with `.least`.
   *
   * @name least
   * @alias gte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len >= n, 'expected #{this} to have a length at least #{exp} but got #{act}', 'expected #{this} to have a length below #{exp}', n, len);
    } else {
      this.assert(obj >= n, 'expected #{this} to be at least #{exp}', 'expected #{this} to be below #{exp}', n);
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);
  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len < n, 'expected #{this} to have a length below #{exp} but got #{act}', 'expected #{this} to not have a length below #{exp}', n, len);
    } else {
      this.assert(obj < n, 'expected #{this} to be below #{exp}', 'expected #{this} to be at least #{exp}', n);
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);
  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The alias `.lte` can be used interchangeably with `.most`.
   *
   * @name most
   * @alias lte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len <= n, 'expected #{this} to have a length at most #{exp} but got #{act}', 'expected #{this} to have a length above #{exp}', n, len);
    } else {
      this.assert(obj <= n, 'expected #{this} to be at most #{exp}', 'expected #{this} to be above #{exp}', n);
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);
  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is greater than or equal to the given number
   * `start`, and less than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        startType = _.type(start).toLowerCase(),
        finishType = _.type(finish).toLowerCase(),
        shouldThrow = true,
        range = startType === 'date' && finishType === 'date' ? start.toUTCString() + '..' + finish.toUTCString() : start + '..' + finish;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && (startType !== 'date' || finishType !== 'date')) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len >= start && len <= finish, 'expected #{this} to have a length within ' + range, 'expected #{this} to not have a length within ' + range);
    } else {
      this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);
    }
  });
  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf(constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var target = flag(this, 'object');
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(flagMsg + 'The instanceof assertion needs a constructor but ' + _.type(constructor) + ' was given.', undefined, ssfi);
      }

      throw err;
    }

    var name = _.getName(constructor);

    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(isInstanceOf, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);
  }
  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);
  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b').but.not.own.property('b'); 
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   * 
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   * 
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty(name, val, msg) {
    if (msg) flag(this, 'message', msg);
    var isNested = flag(this, 'nested'),
        isOwn = flag(this, 'own'),
        flagMsg = flag(this, 'message'),
        obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi');

    if (isNested && isOwn) {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', undefined, ssfi);
    }

    if (obj === null || obj === undefined) {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'Target cannot be null or undefined.', undefined, ssfi);
    }

    var isDeep = flag(this, 'deep'),
        negate = flag(this, 'negate'),
        pathInfo = isNested ? _.getPathInfo(obj, name) : null,
        value = isNested ? pathInfo.value : obj[name];
    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';
    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);else if (isNested) hasProperty = pathInfo.exists;else hasProperty = _.hasProperty(obj, name); // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.

    if (!negate || arguments.length === 1) {
      this.assert(hasProperty, 'expected #{this} to have ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}', val, value);
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty(name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);
  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   * 
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   * 
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);

    if (actualDescriptor && descriptor) {
      this.assert(_.eql(descriptor, actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor), descriptor, actualDescriptor, true);
    } else {
      this.assert(actualDescriptor, 'expected #{this} to have an own property descriptor for ' + _.inspect(name), 'expected #{this} to not have an own property descriptor for ' + _.inspect(name));
    }

    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);
  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` property is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain() {
    flag(this, 'doLength', true);
  }

  function assertLength(n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    var len = obj.length;
    this.assert(len == n, 'expected #{this} to have a length of #{exp} but got #{act}', 'expected #{this} to not have a length of #{act}', n, len);
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);
  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);
  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string(/taco/);
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');
    this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));
  });
  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search. 
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys(keys) {
    var obj = flag(this, 'object'),
        objType = _.type(obj),
        keysType = _.type(keys),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        str,
        deepStr = '',
        ok = true,
        flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = []; // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.

      obj.forEach(function (val, key) {
        actual.push(key);
      });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          break;

        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          keys = Object.keys(keys);
          break;

        default:
          keys = Array.prototype.slice.call(arguments);
      } // Only stringify non-Symbols because Symbols would become "Symbol()"


      keys = keys.map(function (val) {
        return typeof val === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length,
        any = flag(this, 'any'),
        all = flag(this, 'all'),
        expected = keys,
        actual;

    if (!any && !all) {
      all = true;
    } // Has any


    if (any) {
      ok = expected.some(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    } // Has all


    if (all) {
      ok = expected.every(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    } // Key string


    if (len > 1) {
      keys = keys.map(function (key) {
        return _.inspect(key);
      });
      var last = keys.pop();

      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }

      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    } // Form


    str = (len > 1 ? 'keys ' : 'key ') + str; // Have / include

    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str; // Assertion

    this.assert(ok, 'expected #{this} to ' + deepStr + str, 'expected #{this} to not ' + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), true);
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);
  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   * 
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *     
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   * 
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;

    try {
      obj();
    } catch (err) {
      caughtErr = err;
    } // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria


    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined; // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub

    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false; // Checking if error was thrown

    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';

      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(caughtErr, 'expected #{this} to throw ' + errorLikeString, 'expected #{this} to not throw an error but #{act} was thrown', errorLike && errorLike.toString(), caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === 'string' ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : ''), errorLike.toString(), caughtErr.toString());
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);

      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';

      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching';
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);

      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
          errMsgMatcherFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}', 'expected #{this} to throw error not ' + placeholder + ' #{exp}', errMsgMatcher, _.checkError.getMessage(caughtErr));
        }
      }
    } // If both assertions failed and both should've matched we throw an error


    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    flag(this, 'object', caughtErr);
  }
  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);
  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo(method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        itself = flag(this, 'itself'),
        context = 'function' === typeof obj && !itself ? obj.prototype[method] : obj[method];
    this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);
  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });
  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0; 
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy(matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), flag(this, 'negate') ? false : true, result);
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);
  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('number');

    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'the arguments to closeTo or approximately must be numbers', undefined, ssfi);
    }

    this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo); // Note: Duplicates are ignored if testing for inclusion instead of sameness.

  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function (elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function (elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }
  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */


  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');
    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');
    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;
    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
  });
  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf(list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');
    this.assert(list.indexOf(expected) > -1, 'expected #{this} to be one of #{exp}', 'expected #{this} to not be one of #{exp}', list, expected);
  }

  Assertion.addMethod('oneOf', oneOf);
  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop; // This gets flagged because of the .by(delta) assertion

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);
    this.assert(initial !== final, 'expected ' + msgObj + ' to change', 'expected ' + msgObj + ' to not change');
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);
  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   * 
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);
    this.assert(final - initial > 0, 'expected ' + msgObj + ' to increase', 'expected ' + msgObj + ' to not increase');
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);
  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand. 
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   * 
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);
    this.assert(final - initial < 0, 'expected ' + msgObj + ' to decrease', 'expected ' + msgObj + ' to not decrease');
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);
  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);
    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');
    var expression;

    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(expression, 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta, 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta);
  }

  Assertion.addMethod('by', assertDelta);
  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(isExtensible, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
  });
  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(isSealed, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
  });
  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(isFrozen, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
  });
  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function (msg) {
    var obj = flag(this, 'object');
    this.assert(typeof obj === "number" && isFinite(obj), 'expected #{this} to be a finite number', 'expected #{this} to not be a finite number');
  });
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var expect = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */


  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, chai.expect.fail);
  };
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var should = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould() {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === 'function' && this instanceof Symbol) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }

      return new Assertion(this, null, shouldGetter);
    }

    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } // modify Object.prototype to have `should`


    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter,
      get: shouldGetter,
      configurable: true
    });
    var should = {};
    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
        actual: actual,
        expected: expected,
        operator: operator
      }, should.fail);
    };
    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */


    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };
    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */


    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }; // negation


    should.not = {};
    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */


    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    };

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];
    return should;
  }
  chai.should = loadShould;
  chai.Should = loadShould;
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assert = function (chai, util) {
  /*!
   * Chai dependencies.
   */
  var Assertion = chai.Assertion,
      flag = util.flag;
  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(express, errmsg, '[ negation message unavailable ]');
  };
  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */


  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, assert.fail);
  };
  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };
  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };
  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);
    test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act, true);
  };
  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);
    test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act, true);
  };
  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };
  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };
  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */


  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };
  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };
  /**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };
  /**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };
  /**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };
  /**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };
  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };
  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };
  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };
  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };
  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };
  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };
  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };
  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };
  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };
  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };
  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };
  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };
  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };
  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };
  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };
  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };
  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };
  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };
  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };
  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };
  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };
  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };
  /**
  * ### .isFinite(value, [message])
  *
  * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };
  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };
  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };
  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };
  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };
  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };
  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type);
  };
  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and stricty equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };
  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, 'array doesn't contain value');
   *     assert.notInclude('foobar', 'baz', 'string doesn't contain substring');
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };
  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };
  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };
  /**
   * ### .nestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'. 
   * Can be used to assert the inclusion of a subset of properties in an 
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   * 
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };
  /**
   * ### .notNestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' does not include 'needle'. 
   * Can be used to assert the absence of a subset of properties in an 
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties. 
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   * 
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
  };
  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an 
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *    
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.deepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
  };
  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an 
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *    
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.notDeepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
  };
  /**
   * ### .ownInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an 
   * object while ignoring inherited properties.
   * 
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   * 
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.ownInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };
  /**
   * ### .notOwnInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an 
   * object while ignoring inherited properties.
   * 
   *     Object.prototype.b = 2;
   * 
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   * 
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };
  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an 
   * object while ignoring inherited properties and checking for deep equality.
   * 
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *      
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
  };
  /**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  * 
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an 
  * object while ignoring inherited properties and checking for deep equality.
  * 
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *      
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.notDeepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
  };
  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };
  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };
  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };
  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
  };
  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
  };
  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
  };
  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
  };
  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
  };
  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
  };
  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
  };
  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value);
  };
  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
  };
  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
  };
  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
  };
  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
  };
  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
  };
  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
  };
  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
  };
  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
  };
  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
  };
  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };
  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };
  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };
  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
  };
  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
  };
  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
  };
  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
  };
  /**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has all and only all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
  };
  /**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` contains all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has none of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` does not have at least one of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
  };
  /**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
    * instance of `errorLike`.
    * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
    * instance as `errorLike`.
    * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
    * message matching `errMsgMatcher`.
    *
    *     assert.throws(fn, 'function throws a reference error');
    *     assert.throws(fn, /function throws a reference error/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */


  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };
  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */


  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
  };
  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.operator = function (val, operator, val2, msg) {
    var ok;

    switch (operator) {
      case '==':
        ok = val == val2;
        break;

      case '===':
        ok = val === val2;
        break;

      case '>':
        ok = val > val2;
        break;

      case '>=':
        ok = val >= val2;
        break;

      case '<':
        ok = val < val2;
        break;

      case '<=':
        ok = val <= val2;
        break;

      case '!=':
        ok = val != val2;
        break;

      case '!==':
        ok = val !== val2;
        break;

      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', undefined, assert.operator);
    }

    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));
  };
  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };
  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
  };
  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
  };
  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
  };
  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
  };
  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
  };
  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
  };
  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
  };
  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
  };
  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
  };
  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
  };
  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
  };
  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
  };
  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
  };
  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
  };
  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
  };
  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };
  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };
  /**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
  };
  /**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
  };
  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
  };
  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
  };
  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
  };
  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
  };
  /**
   * ### .increasesButNotBy(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
  };
  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
  };
  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
  };
  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
  };
  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
  };
  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
  };
  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */


  assert.ifError = function (val) {
    if (val) {
      throw val;
    }
  };
  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };
  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };
  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };
  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };
  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };
  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };
  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };
  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };
  /*!
   * Aliases.
   */


  (function alias(name, as) {
    assert[as] = assert[name];
    return alias;
  })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')('isEmpty', 'empty')('isNotEmpty', 'notEmpty');
};var chai$1 = createCommonjsModule(function (module, exports) {
  /*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   */
  var used = [];
  /*!
   * Chai version
   */

  exports.version = '4.1.2';
  /*!
   * Assertion Error
   */

  exports.AssertionError = assertionError;
  /*!
   * Utils for plugins (not exported)
   */

  /**
   * # .use(function)
   *
   * Provides a way to extend the internals of Chai.
   *
   * @param {Function}
   * @returns {this} for chaining
   * @api public
   */

  exports.use = function (fn) {
    if (!~used.indexOf(fn)) {
      fn(exports, utils);
      used.push(fn);
    }

    return exports;
  };
  /*!
   * Utility Functions
   */


  exports.util = utils;
  /*!
   * Configuration
   */

  exports.config = config;
  /*!
   * Primary `Assertion` prototype
   */

  exports.use(assertion);
  /*!
   * Core Assertions
   */

  exports.use(assertions);
  /*!
   * Expect interface
   */

  exports.use(expect);
  /*!
   * Should interface
   */

  exports.use(should);
  /*!
   * Assert interface
   */

  exports.use(assert);
});
var chai_1 = chai$1.version;
var chai_2 = chai$1.AssertionError;
var chai_3 = chai$1.use;
var chai_4 = chai$1.util;
var chai_5 = chai$1.config;var chai$2 = chai$1;var chaiDom = createCommonjsModule(function (module, exports) {
  (function (chaiDom) {
    if (typeof commonjsRequire === 'function' && 'object' === 'object' && 'object' === 'object') {
      module.exports = chaiDom;
    } else {
      chai.use(chaiDom);
    }
  })(function (chai, utils) {
    var flag = utils.flag,
        elToString = function (el) {
      var desc;

      if (el instanceof window.NodeList) {
        if (el.length === 0) return 'empty NodeList';
        desc = Array.prototype.slice.call(el, 0, 5).map(elToString).join(', ');
        return el.length > 5 ? desc + '... (+' + (el.length - 5) + ' more)' : desc;
      }

      if (!(el instanceof window.HTMLElement)) {
        return String(el);
      }

      desc = el.tagName.toLowerCase();

      if (el.id) {
        desc += '#' + el.id;
      }

      if (el.className) {
        desc += '.' + String(el.className).replace(/\s+/g, '.');
      }

      Array.prototype.forEach.call(el.attributes, function (attr) {
        if (attr.name !== 'class' && attr.name !== 'id') {
          desc += '[' + attr.name + (attr.value ? '="' + attr.value + '"]' : ']');
        }
      });
      return desc;
    },
        attrAssert = function (name, val) {
      var el = flag(this, 'object'),
          actual = el.getAttribute(name);

      if (!flag(this, 'negate') || undefined === val) {
        this.assert(!!el.attributes[name], 'expected ' + elToString(el) + ' to have an attribute #{exp}', 'expected ' + elToString(el) + ' not to have an attribute #{exp}', name);
      }

      if (undefined !== val) {
        this.assert(val === actual, 'expected ' + elToString(el) + ' to have an attribute ' + utils.inspect(name) + ' with the value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have an attribute ' + utils.inspect(name) + ' with the value #{act}', val, actual);
      }

      flag(this, 'object', actual);
    };

    utils.elToString = elToString;
    chai.Assertion.addMethod('attr', attrAssert);
    chai.Assertion.addMethod('attribute', attrAssert);
    chai.Assertion.addMethod('class', function (className) {
      var el = flag(this, 'object');
      this.assert(el.classList.contains(className), 'expected ' + elToString(el) + ' to have class #{exp}', 'expected ' + elToString(el) + ' not to have class #{exp}', className);
    });
    chai.Assertion.addMethod('id', function (id) {
      var el = flag(this, 'object');
      this.assert(el.id == id, 'expected ' + elToString(el) + ' to have id #{exp}', 'expected ' + elToString(el) + ' not to have id #{exp}', id);
    });
    chai.Assertion.addMethod('html', function (html) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').innerHTML;

      if (flag(this, 'contains')) {
        this.assert(actual.indexOf(html) >= 0, 'expected #{act} to contain HTML #{exp}', 'expected #{act} not to contain HTML #{exp}', html, actual);
      } else {
        this.assert(actual === html, 'expected ' + elToString(el) + ' to have HTML #{exp}, but the HTML was #{act}', 'expected ' + elToString(el) + ' not to have HTML #{exp}', html, actual);
      }
    });
    chai.Assertion.addMethod('text', function (text) {
      var obj = flag(this, 'object'),
          contains = flag(this, 'contains'),
          actual,
          result;

      if (obj instanceof window.NodeList) {
        actual = Array.prototype.map.call(obj, function (el) {
          return el.textContent;
        });

        if (Array.isArray(text)) {
          result = contains ? text[flag(this, 'negate') ? 'some' : 'every'](function (t) {
            return Array.prototype.some.call(obj, function (el) {
              return el.textContent === t;
            });
          }) : utils.eql(actual, text);
          actual = actual.join();
          text = text.join();
        } else {
          actual = actual.join('');
          result = contains ? actual.indexOf(text) >= 0 : actual === text;
        }
      } else {
        actual = flag(this, 'object').textContent;
        result = contains ? actual.indexOf(text) >= 0 : actual === text;
      }

      var objDesc = elToString(obj);

      if (contains) {
        this.assert(result, 'expected ' + objDesc + ' to contain #{exp}, but the text was #{act}', 'expected ' + objDesc + ' not to contain #{exp}, but the text was #{act}', text, actual);
      } else {
        this.assert(result, 'expected ' + objDesc + ' to have text #{exp}, but the text was #{act}', 'expected ' + objDesc + ' not to have text #{exp}', text, actual);
      }
    });
    chai.Assertion.addMethod('value', function (value) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').value;
      this.assert(flag(this, 'object').value === value, 'expected ' + elToString(el) + ' to have value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have value #{exp}', value, actual);
    });
    chai.Assertion.overwriteProperty('exist', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (obj instanceof window.NodeList) {
          this.assert(obj.length > 0, 'expected an empty NodeList to have nodes', 'expected ' + elToString(obj) + ' to not exist');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteProperty('empty', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (obj instanceof window.HTMLElement) {
          this.assert(obj.children.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else if (obj instanceof window.NodeList) {
          this.assert(obj.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('length', function (_super) {
      return function (length) {
        var obj = flag(this, 'object');

        if (obj instanceof window.NodeList || obj instanceof window.HTMLElement) {
          var actualLength = obj.children ? obj.children.length : obj.length;
          this.assert(actualLength === length, 'expected ' + elToString(obj) + ' to have #{exp} children but it had #{act} children', 'expected ' + elToString(obj) + ' to not have #{exp} children', length, actualLength);
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.overwriteMethod('match', function (_super) {
      return function (selector) {
        var obj = flag(this, 'object');

        if (obj instanceof window.HTMLElement) {
          this.assert(obj.matches(selector), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else if (obj instanceof window.NodeList) {
          this.assert(!!obj.length && Array.prototype.every.call(obj, function (el) {
            return el.matches(selector);
          }), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('contain', function (_super) {
      return function (subitem) {
        var obj = flag(this, 'object');

        if (obj instanceof window.HTMLElement) {
          if (typeof subitem === 'string') {
            this.assert(!!obj.querySelector(subitem), 'expected ' + elToString(obj) + ' to contain #{exp}', 'expected ' + elToString(obj) + ' to not contain #{exp}', subitem);
          } else {
            this.assert(obj.contains(subitem), 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem), 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
          }
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.addProperty('displayed', function () {
      var el = flag(this, 'object'),
          actual = document.body.contains(el) ? window.getComputedStyle(el).display : el.style.display;
      this.assert(actual !== 'none', 'expected ' + elToString(el) + ' to be displayed, but it was not', 'expected ' + elToString(el) + ' to not be displayed, but it was as ' + actual, actual);
    });
  });
});var sources = chaiStyle;

function chaiStyle(chai, utils) {
  const {
    Assertion
  } = chai;
  const {
    flag
  } = utils;
  Assertion.addMethod('style', function (property, value = '') {
    const element = flag(this, 'object');
    const style = window.getComputedStyle(element);
    value = value.trim();
    const isNonColors = style[property] === 'rgba(0, 0, 0, 0)' // webkit
    || style[property] === 'transparent'; // firefox

    const propertyValue = isNonColors ? '' : style[property];
    const assertion = value ? compareCSSValue(propertyValue, value) : Boolean(propertyValue);
    const elementTag = element.tagName.toLowerCase();
    const throwMessage = `expect ${elementTag} to have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    const throwMessageNegative = `expect ${elementTag} to not have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    this.assert(assertion, throwMessage, throwMessageNegative, value);

    function compareCSSValue(computed, expected) {
      const propertyHifenCase = property.replace(/[A-Z]/g, match => '-' + match.toLowerCase());
      const fake = document.createElement('div');
      fake.style.fontSize = style.fontSize;
      fake.style.setProperty(propertyHifenCase, expected, 'important');
      const iframe = document.createElement('iframe');
      iframe.style.visibility = 'hidden';
      document.body.appendChild(iframe);
      iframe.appendChild(fake);
      const fakeStyle = window.getComputedStyle(fake);
      const value = fakeStyle[property];
      const hasAutoValue = value.includes('auto');
      const reg = new RegExp(escapeRegExp(value).replace(/auto/g, '(\\d+(.\\d+)?px|auto)'));
      return hasAutoValue ? reg.test(computed) : computed === value;
    }
  });
} // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js


function escapeRegExp(value) {
  return String(value).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
}var typeDetect$1 = createCommonjsModule(function (module) {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var getPrototypeOfExists = typeof Object.getPrototypeOf === 'function';
  var promiseExists = typeof Promise === 'function';
  var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line

  var isDom = 'location' in globalObject && 'document' in globalObject;
  var htmlElementExists = typeof HTMLElement !== 'undefined';
  var isArrayExists = typeof Array.isArray === 'function';
  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = getPrototypeOfExists && setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = getPrototypeOfExists && mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  module.exports = function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
     */


    if (isArrayExists && Array.isArray(obj)) {
      return 'Array';
    }

    if (isDom) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (obj === globalObject.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (obj === globalObject.document) {
        return 'Document';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */


      if (obj === (globalObject.navigator || {}).mimeTypes) {
        return 'MimeTypeArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */


      if (obj === (globalObject.navigator || {}).plugins) {
        return 'PluginArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
       * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
       *  - IE <=10 === "[object HTMLBlockElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    if (getPrototypeOfExists) {
      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  };

  module.exports.typeDetect = module.exports;
});
var typeDetect_1$1 = typeDetect$1.typeDetect;/* globals Symbol: true, Uint8Array: true, WeakMap: true */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */


function FakeMap$1() {
  this.clear();
}

FakeMap$1.prototype = {
  clear: function clearMap() {
    this.keys = [];
    this.values = [];
    return this;
  },
  set: function setMap(key, value) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values[index] = value;
    } else {
      this.keys.push(key);
      this.values.push(value);
    }

    return this;
  },
  get: function getMap(key) {
    return this.values[this.keys.indexOf(key)];
  },
  delete: function deleteMap(key) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values = this.values.slice(0, index).concat(this.values.slice(index + 1));
      this.keys = this.keys.slice(0, index).concat(this.keys.slice(index + 1));
    }

    return this;
  }
};
var MemoizeMap$1 = null;

if (typeof WeakMap === 'function') {
  MemoizeMap$1 = WeakMap;
} else {
  MemoizeMap$1 = FakeMap$1;
}
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/


function memoizeCompare$1(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet$1(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap$1();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql$1 = deepEqual$1;
var MemoizeMap_1$1 = MemoizeMap$1;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual$1(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual$1(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap$1();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare$1(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare$1(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect$1(leftHandOperand);

  if (leftHandType !== typeDetect$1(rightHandOperand)) {
    memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual$1(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual$1(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual$1(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual$1(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual$1(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual$1(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual$1(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual$1(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual$1(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual$1(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual$1(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual$1(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual$1(leftHandOperand, rightHandOperand, options) {
  return iterableEqual$1(getGeneratorEntries$1(leftHandOperand), getGeneratorEntries$1(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction$1(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries$1(target) {
  if (hasIteratorFunction$1(target)) {
    try {
      return getGeneratorEntries$1(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries$1(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys$1(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual$1(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual$1(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual$1(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys$1(leftHandOperand);
  var rightHandKeys = getEnumerableKeys$1(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual$1(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual$1(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries$1(leftHandOperand);
  var rightHandEntries = getIteratorEntries$1(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual$1(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive$1(value) {
  return value === null || typeof value !== 'object';
}
deepEql$1.MemoizeMap = MemoizeMap_1$1;var DEFAULT_TOLERANCE = 1e-6;
/**
 * small utility functions
 */

function isNumber(val) {
  return typeDetect(val) === 'number';
}

function bothNumbers(left, right) {
  return isNumber(right) && isNumber(left);
}

function almostEqual(left, right, tol) {
  return Math.abs(left - right) <= tol;
}
/**
 * Makes a comparator function to be passed to deepEqual.
 * The returned function will return null if both arguments are not numbers,
 * indicating that deepEqual should proceed with other equality checks
 */


function comparator(tolerance) {
  return function (left, right) {
    if (bothNumbers(left, right)) {
      return almostEqual(left, right, tolerance);
    }

    return null;
  };
}
/**
 * Sets global tolerance and returns a function to be passed to chai.use
 * @see http://chaijs.com/guide/plugins/
 */


function chaiAlmost(customTolerance) {
  var standardTolerance = customTolerance || DEFAULT_TOLERANCE;
  return function (chai, utils) {
    var Assertion = chai.Assertion;
    var flag = utils.flag;
    /**
     * Returns a new shallow equality function to override
     * .equal, .equals, .eq that tests 'almost' equality
     * if both values are numbers and a 'tolerance' flag is set.
     * Sends to deep equality check if deep flag is set
     */

    function overrideAssertEqual(_super) {
      return function assertEqual(val, msg) {
        if (msg) flag(this, 'message', msg);
        var deep = flag(this, 'deep');
        var tolerance = flag(this, 'tolerance');

        if (deep) {
          return this.eql(val);
        } else if (tolerance && bothNumbers(val, this._obj)) {
          this.assert(almostEqual(val, this._obj, tolerance), 'expected #{this} to almost equal #{exp}', 'expected #{this} to not almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * Returns a new deep equality function to override
     * .eql, .eqls that tests 'almost' equality if both corresponding
     * values are numbers and tolerance flag is set
     */


    function overrideAssertEql(_super) {
      return function assertEql(val, msg) {
        if (msg) flag(this, 'message', msg);
        var tolerance = flag(this, 'tolerance');

        if (tolerance) {
          this.assert(deepEql$1(val, this._obj, {
            comparator: comparator(tolerance)
          }), 'expected #{this} to deeply almost equal #{exp}', 'expected #{this} to not deeply almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * .almost() method. To be used at the end of the chain like:
     * expect(4).to.not.be.almost(5, 1.5). Simply adds tolerance flag then calls
     * .equal. This will redirect to .eql if deep flag set
     */


    function method(val, toleranceOverride) {
      var tolerance = toleranceOverride || standardTolerance;
      flag(this, 'tolerance', tolerance);
      return this.equal(val);
    }
    /**
     * .almost chainable property to be used like:
     * expect(3.99999999).to.almost.equal(4). Simply adds
     * tolerance flag to be read by equality checking methods
     */


    function chainingBehavior() {
      flag(this, 'tolerance', standardTolerance);
    }

    Assertion.addChainableMethod('almost', method, chainingBehavior);
    Assertion.overwriteMethod('equal', overrideAssertEqual);
    Assertion.overwriteMethod('equals', overrideAssertEqual);
    Assertion.overwriteMethod('eq', overrideAssertEqual);
    Assertion.overwriteMethod('eql', overrideAssertEql);
    Assertion.overwriteMethod('eqls', overrideAssertEql);
  };
}

var chaiAlmost_1 = chaiAlmost;var checkTypes = createCommonjsModule(function (module) {
  /*globals define, module, Symbol */

  /*jshint -W056 */
  (function (globals) {

    var strings, messages, predicates, functions, assert, not, maybe, collections, slice, neginf, posinf, isArray, haveSymbols;
    strings = {
      v: 'value',
      n: 'number',
      s: 'string',
      b: 'boolean',
      o: 'object',
      t: 'type',
      a: 'array',
      al: 'array-like',
      i: 'iterable',
      d: 'date',
      f: 'function',
      l: 'length'
    };
    messages = {};
    predicates = {};
    [{
      n: 'equal',
      f: equal,
      s: 'v'
    }, {
      n: 'undefined',
      f: isUndefined,
      s: 'v'
    }, {
      n: 'null',
      f: isNull,
      s: 'v'
    }, {
      n: 'assigned',
      f: assigned,
      s: 'v'
    }, {
      n: 'primitive',
      f: primitive,
      s: 'v'
    }, {
      n: 'includes',
      f: includes,
      s: 'v'
    }, {
      n: 'zero',
      f: zero
    }, {
      n: 'infinity',
      f: infinity
    }, {
      n: 'number',
      f: number
    }, {
      n: 'integer',
      f: integer
    }, {
      n: 'even',
      f: even
    }, {
      n: 'odd',
      f: odd
    }, {
      n: 'greater',
      f: greater
    }, {
      n: 'less',
      f: less
    }, {
      n: 'between',
      f: between
    }, {
      n: 'greaterOrEqual',
      f: greaterOrEqual
    }, {
      n: 'lessOrEqual',
      f: lessOrEqual
    }, {
      n: 'inRange',
      f: inRange
    }, {
      n: 'positive',
      f: positive
    }, {
      n: 'negative',
      f: negative
    }, {
      n: 'string',
      f: string,
      s: 's'
    }, {
      n: 'emptyString',
      f: emptyString,
      s: 's'
    }, {
      n: 'nonEmptyString',
      f: nonEmptyString,
      s: 's'
    }, {
      n: 'contains',
      f: contains,
      s: 's'
    }, {
      n: 'match',
      f: match,
      s: 's'
    }, {
      n: 'boolean',
      f: boolean,
      s: 'b'
    }, {
      n: 'object',
      f: object,
      s: 'o'
    }, {
      n: 'emptyObject',
      f: emptyObject,
      s: 'o'
    }, {
      n: 'nonEmptyObject',
      f: nonEmptyObject,
      s: 'o'
    }, {
      n: 'instanceStrict',
      f: instanceStrict,
      s: 't'
    }, {
      n: 'instance',
      f: instance,
      s: 't'
    }, {
      n: 'like',
      f: like,
      s: 't'
    }, {
      n: 'array',
      f: array,
      s: 'a'
    }, {
      n: 'emptyArray',
      f: emptyArray,
      s: 'a'
    }, {
      n: 'nonEmptyArray',
      f: nonEmptyArray,
      s: 'a'
    }, {
      n: 'arrayLike',
      f: arrayLike,
      s: 'al'
    }, {
      n: 'iterable',
      f: iterable,
      s: 'i'
    }, {
      n: 'date',
      f: date,
      s: 'd'
    }, {
      n: 'function',
      f: isFunction,
      s: 'f'
    }, {
      n: 'hasLength',
      f: hasLength,
      s: 'l'
    }].map(function (data) {
      var n = data.n;
      messages[n] = 'Invalid ' + strings[data.s || 'n'];
      predicates[n] = data.f;
    });
    functions = {
      apply: apply,
      map: map,
      all: all,
      any: any
    };
    collections = ['array', 'arrayLike', 'iterable', 'object'];
    slice = Array.prototype.slice;
    neginf = Number.NEGATIVE_INFINITY;
    posinf = Number.POSITIVE_INFINITY;
    isArray = Array.isArray;
    haveSymbols = typeof Symbol === 'function';
    functions = mixin(functions, predicates);
    assert = createModifiedPredicates(assertModifier, assertImpl);
    not = createModifiedPredicates(notModifier, notImpl);
    maybe = createModifiedPredicates(maybeModifier, maybeImpl);
    assert.not = createModifiedModifier(assertModifier, not);
    assert.maybe = createModifiedModifier(assertModifier, maybe);
    collections.forEach(createOfPredicates);
    createOfModifiers(assert, assertModifier);
    createOfModifiers(not, notModifier);
    collections.forEach(createMaybeOfModifiers);
    exportFunctions(mixin(functions, {
      assert: assert,
      not: not,
      maybe: maybe
    }));
    /**
     * Public function `equal`.
     *
     * Returns true if `lhs` and `rhs` are strictly equal, without coercion.
     * Returns false otherwise.
     */

    function equal(lhs, rhs) {
      return lhs === rhs;
    }
    /**
     * Public function `undefined`.
     *
     * Returns true if `data` is undefined, false otherwise.
     */


    function isUndefined(data) {
      return data === undefined;
    }
    /**
     * Public function `null`.
     *
     * Returns true if `data` is null, false otherwise.
     */


    function isNull(data) {
      return data === null;
    }
    /**
     * Public function `assigned`.
     *
     * Returns true if `data` is not null or undefined, false otherwise.
     */


    function assigned(data) {
      return data !== undefined && data !== null;
    }
    /**
     * Public function `primitive`.
     *
     * Returns true if `data` is a primitive type, false otherwise.
     */


    function primitive(data) {
      var type;

      switch (data) {
        case null:
        case undefined:
        case false:
        case true:
          return true;
      }

      type = typeof data;
      return type === 'string' || type === 'number' || haveSymbols && type === 'symbol';
    }
    /**
     * Public function `zero`.
     *
     * Returns true if `data` is zero, false otherwise.
     */


    function zero(data) {
      return data === 0;
    }
    /**
     * Public function `infinity`.
     *
     * Returns true if `data` is positive or negative infinity, false otherwise.
     */


    function infinity(data) {
      return data === neginf || data === posinf;
    }
    /**
     * Public function `number`.
     *
     * Returns true if `data` is a number, false otherwise.
     */


    function number(data) {
      return typeof data === 'number' && data > neginf && data < posinf;
    }
    /**
     * Public function `integer`.
     *
     * Returns true if `data` is an integer, false otherwise.
     */


    function integer(data) {
      return typeof data === 'number' && data % 1 === 0;
    }
    /**
     * Public function `even`.
     *
     * Returns true if `data` is an even number, false otherwise.
     */


    function even(data) {
      return typeof data === 'number' && data % 2 === 0;
    }
    /**
     * Public function `odd`.
     *
     * Returns true if `data` is an odd number, false otherwise.
     */


    function odd(data) {
      return integer(data) && data % 2 !== 0;
    }
    /**
     * Public function `greater`.
     *
     * Returns true if `lhs` is a number greater than `rhs`, false otherwise.
     */


    function greater(lhs, rhs) {
      return number(lhs) && lhs > rhs;
    }
    /**
     * Public function `less`.
     *
     * Returns true if `lhs` is a number less than `rhs`, false otherwise.
     */


    function less(lhs, rhs) {
      return number(lhs) && lhs < rhs;
    }
    /**
     * Public function `between`.
     *
     * Returns true if `data` is a number between `x` and `y`, false otherwise.
     */


    function between(data, x, y) {
      if (x < y) {
        return greater(data, x) && data < y;
      }

      return less(data, x) && data > y;
    }
    /**
     * Public function `greaterOrEqual`.
     *
     * Returns true if `lhs` is a number greater than or equal to `rhs`, false
     * otherwise.
     */


    function greaterOrEqual(lhs, rhs) {
      return number(lhs) && lhs >= rhs;
    }
    /**
     * Public function `lessOrEqual`.
     *
     * Returns true if `lhs` is a number less than or equal to `rhs`, false
     * otherwise.
     */


    function lessOrEqual(lhs, rhs) {
      return number(lhs) && lhs <= rhs;
    }
    /**
     * Public function `inRange`.
     *
     * Returns true if `data` is a number in the range `x..y`, false otherwise.
     */


    function inRange(data, x, y) {
      if (x < y) {
        return greaterOrEqual(data, x) && data <= y;
      }

      return lessOrEqual(data, x) && data >= y;
    }
    /**
     * Public function `positive`.
     *
     * Returns true if `data` is a positive number, false otherwise.
     */


    function positive(data) {
      return greater(data, 0);
    }
    /**
     * Public function `negative`.
     *
     * Returns true if `data` is a negative number, false otherwise.
     */


    function negative(data) {
      return less(data, 0);
    }
    /**
     * Public function `string`.
     *
     * Returns true if `data` is a string, false otherwise.
     */


    function string(data) {
      return typeof data === 'string';
    }
    /**
     * Public function `emptyString`.
     *
     * Returns true if `data` is the empty string, false otherwise.
     */


    function emptyString(data) {
      return data === '';
    }
    /**
     * Public function `nonEmptyString`.
     *
     * Returns true if `data` is a non-empty string, false otherwise.
     */


    function nonEmptyString(data) {
      return string(data) && data !== '';
    }
    /**
     * Public function `contains`.
     *
     * Returns true if `data` is a string that contains `substring`, false
     * otherwise.
     */


    function contains(data, substring) {
      return string(data) && data.indexOf(substring) !== -1;
    }
    /**
     * Public function `match`.
     *
     * Returns true if `data` is a string that matches `regex`, false otherwise.
     */


    function match(data, regex) {
      return string(data) && !!data.match(regex);
    }
    /**
     * Public function `boolean`.
     *
     * Returns true if `data` is a boolean value, false otherwise.
     */


    function boolean(data) {
      return data === false || data === true;
    }
    /**
     * Public function `object`.
     *
     * Returns true if `data` is a plain-old JS object, false otherwise.
     */


    function object(data) {
      return Object.prototype.toString.call(data) === '[object Object]';
    }
    /**
     * Public function `emptyObject`.
     *
     * Returns true if `data` is an empty object, false otherwise.
     */


    function emptyObject(data) {
      return object(data) && Object.keys(data).length === 0;
    }
    /**
     * Public function `nonEmptyObject`.
     *
     * Returns true if `data` is a non-empty object, false otherwise.
     */


    function nonEmptyObject(data) {
      return object(data) && Object.keys(data).length > 0;
    }
    /**
     * Public function `instanceStrict`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     */


    function instanceStrict(data, prototype) {
      try {
        return data instanceof prototype;
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `instance`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     * Falls back to testing constructor.name and Object.prototype.toString
     * if the initial instanceof test fails.
     */


    function instance(data, prototype) {
      try {
        return instanceStrict(data, prototype) || data.constructor.name === prototype.name || Object.prototype.toString.call(data) === '[object ' + prototype.name + ']';
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `like`.
     *
     * Tests whether `data` 'quacks like a duck'. Returns true if `data` has all
     * of the properties of `archetype` (the 'duck'), false otherwise.
     */


    function like(data, archetype) {
      var name;

      for (name in archetype) {
        if (archetype.hasOwnProperty(name)) {
          if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof archetype[name]) {
            return false;
          }

          if (object(data[name]) && like(data[name], archetype[name]) === false) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * Public function `array`.
     *
     * Returns true if `data` is an array, false otherwise.
     */


    function array(data) {
      return isArray(data);
    }
    /**
     * Public function `emptyArray`.
     *
     * Returns true if `data` is an empty array, false otherwise.
     */


    function emptyArray(data) {
      return array(data) && data.length === 0;
    }
    /**
     * Public function `nonEmptyArray`.
     *
     * Returns true if `data` is a non-empty array, false otherwise.
     */


    function nonEmptyArray(data) {
      return array(data) && greater(data.length, 0);
    }
    /**
     * Public function `arrayLike`.
     *
     * Returns true if `data` is an array-like object, false otherwise.
     */


    function arrayLike(data) {
      return assigned(data) && greaterOrEqual(data.length, 0);
    }
    /**
     * Public function `iterable`.
     *
     * Returns true if `data` is an iterable, false otherwise.
     */


    function iterable(data) {
      if (!haveSymbols) {
        // Fall back to `arrayLike` predicate in pre-ES6 environments.
        return arrayLike(data);
      }

      return assigned(data) && isFunction(data[Symbol.iterator]);
    }
    /**
     * Public function `includes`.
     *
     * Returns true if `data` contains `value`, false otherwise.
     */


    function includes(data, value) {
      var iterator, iteration, keys, length, i;

      if (!assigned(data)) {
        return false;
      }

      if (haveSymbols && data[Symbol.iterator] && isFunction(data.values)) {
        iterator = data.values();

        do {
          iteration = iterator.next();

          if (iteration.value === value) {
            return true;
          }
        } while (!iteration.done);

        return false;
      }

      keys = Object.keys(data);
      length = keys.length;

      for (i = 0; i < length; ++i) {
        if (data[keys[i]] === value) {
          return true;
        }
      }

      return false;
    }
    /**
     * Public function `hasLength`.
     *
     * Returns true if `data` has a length property that equals `length`, false
     * otherwise.
     */


    function hasLength(data, length) {
      return assigned(data) && data.length === length;
    }
    /**
     * Public function `date`.
     *
     * Returns true if `data` is a valid date, false otherwise.
     */


    function date(data) {
      return instanceStrict(data, Date) && integer(data.getTime());
    }
    /**
     * Public function `function`.
     *
     * Returns true if `data` is a function, false otherwise.
     */


    function isFunction(data) {
      return typeof data === 'function';
    }
    /**
     * Public function `apply`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result array. If the same function is to be applied across all of the
     * data, a single predicate function may be passed in.
     *
     */


    function apply(data, predicates) {
      assert.array(data);

      if (isFunction(predicates)) {
        return data.map(function (value) {
          return predicates(value);
        });
      }

      assert.array(predicates);
      assert.hasLength(data, predicates.length);
      return data.map(function (value, index) {
        return predicates[index](value);
      });
    }
    /**
     * Public function `map`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result object. Supports nested objects. If the `data` is not nested and
     * the same function is to be applied across all of it, a single predicate
     * function may be passed in.
     *
     */


    function map(data, predicates) {
      assert.object(data);

      if (isFunction(predicates)) {
        return mapSimple(data, predicates);
      }

      assert.object(predicates);
      return mapComplex(data, predicates);
    }

    function mapSimple(data, predicate) {
      var result = {};
      Object.keys(data).forEach(function (key) {
        result[key] = predicate(data[key]);
      });
      return result;
    }

    function mapComplex(data, predicates) {
      var result = {};
      Object.keys(predicates).forEach(function (key) {
        var predicate = predicates[key];

        if (isFunction(predicate)) {
          if (not.assigned(data)) {
            result[key] = !!predicate.m;
          } else {
            result[key] = predicate(data[key]);
          }
        } else if (object(predicate)) {
          result[key] = mapComplex(data[key], predicate);
        }
      });
      return result;
    }
    /**
     * Public function `all`
     *
     * Check that all boolean values are true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function all(data) {
      if (array(data)) {
        return testArray(data, false);
      }

      assert.object(data);
      return testObject(data, false);
    }

    function testArray(data, result) {
      var i;

      for (i = 0; i < data.length; i += 1) {
        if (data[i] === result) {
          return result;
        }
      }

      return !result;
    }

    function testObject(data, result) {
      var key, value;

      for (key in data) {
        if (data.hasOwnProperty(key)) {
          value = data[key];

          if (object(value) && testObject(value, result) === result) {
            return result;
          }

          if (value === result) {
            return result;
          }
        }
      }

      return !result;
    }
    /**
     * Public function `any`
     *
     * Check that at least one boolean value is true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function any(data) {
      if (array(data)) {
        return testArray(data, true);
      }

      assert.object(data);
      return testObject(data, true);
    }

    function mixin(target, source) {
      Object.keys(source).forEach(function (key) {
        target[key] = source[key];
      });
      return target;
    }
    /**
     * Public modifier `assert`.
     *
     * Throws if `predicate` returns false.
     */


    function assertModifier(predicate, defaultMessage) {
      return function () {
        return assertPredicate(predicate, arguments, defaultMessage);
      };
    }

    function assertPredicate(predicate, args, defaultMessage) {
      var argCount = predicate.l || predicate.length;
      var message = args[argCount];
      var ErrorType = args[argCount + 1];
      assertImpl(predicate.apply(null, args), nonEmptyString(message) ? message : defaultMessage, isFunction(ErrorType) ? ErrorType : TypeError);
      return args[0];
    }

    function assertImpl(value, message, ErrorType) {
      if (value) {
        return value;
      }

      throw new (ErrorType || Error)(message || 'Assertion failed');
    }
    /**
     * Public modifier `not`.
     *
     * Negates `predicate`.
     */


    function notModifier(predicate) {
      var modifiedPredicate = function () {
        return notImpl(predicate.apply(null, arguments));
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function notImpl(value) {
      return !value;
    }
    /**
     * Public modifier `maybe`.
     *
     * Returns true if predicate argument is  null or undefined,
     * otherwise propagates the return value from `predicate`.
     */


    function maybeModifier(predicate) {
      var modifiedPredicate = function () {
        if (not.assigned(arguments[0])) {
          return true;
        }

        return predicate.apply(null, arguments);
      };

      modifiedPredicate.l = predicate.length; // Hackishly indicate that this is a maybe.xxx predicate.
      // Without this flag, the alternative would be to iterate
      // through the maybe predicates or use indexOf to check,
      // which would be time-consuming.

      modifiedPredicate.m = true;
      return modifiedPredicate;
    }

    function maybeImpl(value) {
      if (assigned(value) === false) {
        return true;
      }

      return value;
    }
    /**
     * Public modifier `of`.
     *
     * Applies the chained predicate to members of the collection.
     */


    function ofModifier(target, type, predicate) {
      var modifiedPredicate = function () {
        var collection, args;
        collection = arguments[0];

        if (target === 'maybe' && not.assigned(collection)) {
          return true;
        }

        if (!type(collection)) {
          return false;
        }

        collection = coerceCollection(type, collection);
        args = slice.call(arguments, 1);

        try {
          collection.forEach(function (item) {
            if ((target !== 'maybe' || assigned(item)) && !predicate.apply(null, [item].concat(args))) {
              // TODO: Replace with for...of when ES6 is required.
              throw 0;
            }
          });
        } catch (ignore) {
          return false;
        }

        return true;
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function coerceCollection(type, collection) {
      switch (type) {
        case arrayLike:
          return slice.call(collection);

        case object:
          return Object.keys(collection).map(function (key) {
            return collection[key];
          });

        default:
          return collection;
      }
    }

    function createModifiedPredicates(modifier, object) {
      return createModifiedFunctions([modifier, predicates, object]);
    }

    function createModifiedFunctions(args) {
      var modifier, object, functions, result;
      modifier = args.shift();
      object = args.pop();
      functions = args.pop();
      result = object || {};
      Object.keys(functions).forEach(function (key) {
        Object.defineProperty(result, key, {
          configurable: false,
          enumerable: true,
          writable: false,
          value: modifier.apply(null, args.concat(functions[key], messages[key]))
        });
      });
      return result;
    }

    function createModifiedModifier(modifier, modified) {
      return createModifiedFunctions([modifier, modified, null]);
    }

    function createOfPredicates(key) {
      predicates[key].of = createModifiedFunctions([ofModifier.bind(null, null), predicates[key], predicates, null]);
    }

    function createOfModifiers(base, modifier) {
      collections.forEach(function (key) {
        base[key].of = createModifiedModifier(modifier, predicates[key].of);
      });
    }

    function createMaybeOfModifiers(key) {
      maybe[key].of = createModifiedFunctions([ofModifier.bind(null, 'maybe'), predicates[key], predicates, null]);
      assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
      assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
    }

    function exportFunctions(functions) {
      if (module !== null && module.exports) {
        module.exports = functions;
      } else {
        globals.check = functions;
      }
    }
  })(commonjsGlobal);
});var asserttype = chai => {
  const types = ['number', 'string', 'boolean', 'object', 'array', 'date', 'function'];
  types.forEach(type => {
    chai.Assertion.addMethod(type, function () {
      this.assert(checkTypes[type](this._obj), `expected #{this} to be ${type}`, `expected #{this} not to be ${type}`);
    });
  });
};var chaiEvents = createCommonjsModule(function (module, exports) {
  function plugin(chai, utils) {
    var Assertion = chai.Assertion;
    /**
     * Checks if a given entry is an event emitter.
     * Uses EventEmitter or EventTarget if available to quickly check `instanceof`.  Otherwise, checks that common methods
     * to event emitters are available.
     *
     * Gracefully handles custom implementations of event emitters even if EventEmitter or EventTarget are available,
     * checking methods if the emitter doesn't inherit from the global emitter.
    */

    function isEmitter() {
      // Easy check: if Node's EventEmitter or window.EventEmitter exist, check if this is an instance of it.
      if (typeof EventEmitter !== "undefined" && EventEmitter !== null && this._obj instanceof EventEmitter) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Easy check: if the browser's EventTarget exists, check if this is an instance of it.


      if (typeof EventTarget !== "undefined" && EventTarget !== null && this._obj instanceof EventTarget) {
        return this.assert(true, "", "expected #{this} to not be an EventTarget");
      }

      var obj = this._obj; // Check for Node.js style event emitters with "on", "emit", etc.

      var node = ["on", "emit"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (node) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Check for Browser-based event emitters with "addEventListener", etc.


      var browser = ["addEventListener", "dispatchEvent", "removeEventListener"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (browser) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      }

      this.assert(false, "expected #{this} to be an EventEmitter", "");
    }
    Assertion.addProperty("emitter", isEmitter);
    Assertion.addProperty("target", isEmitter);
    Assertion.addMethod("emit", function (name, args) {
      new Assertion(this._obj).to.be.an.emitter;
      new Assertion(name).to.be.a("string");
      var obj = this._obj;

      var _this = this;

      var assert = function () {
        _this.assert.apply(_this, arguments);
      };

      var timeout = utils.flag(this, 'timeout') || 1500;

      if (utils.flag(this, 'negate')) {
        // Ensure that the event doesn't fire before timeout
        return new Promise(function (resolve, reject) {
          var done = false;
          obj.on(name, function () {
            if (done) {
              return;
            }

            done = true;
            assert(false, "expected #{this} to not emit " + name + ".");
            resolve();
          });
          setTimeout(function () {
            if (done) {
              return;
            }

            done = true;
            resolve();
          }, timeout);
        });
      } else {
        // Ensure that the event fires
        return new Promise(function (resolve, reject) {
          var done = false;
          obj.on(name, function () {
            if (done) {
              return;
            }

            done = true;
            resolve();
          });
          setTimeout(function () {
            if (done) {
              return;
            }

            done = true;
            assert(false, "expected #{this} to emit " + name + ".");
            resolve();
          }, timeout);
        });
      }
    });
  }

  if (typeof commonjsRequire === "function" && 'object' === "object" && 'object' === "object") {
    module.exports = plugin;
  } else {
    // Other environment (usually <script> tag): plug in to global chai instance directly.
    chai.use(plugin);
  }
});var registered;
registered = false;

function registerAnimations() {
  if (registered) {
    return;
  }

  registered = true;
  index.animation('checkmarkAnimateSuccessTip', {
    '0%, 54%': {
      width: 0,
      left: 0,
      top: 3
    },
    '70%': {
      width: 14,
      left: -2,
      top: 8
    },
    '84%': {
      width: 5,
      left: 5,
      top: 10
    },
    '100%': {
      width: 8,
      left: 3,
      top: 10
    }
  });
  index.animation('checkmarkAnimateSuccessLong', {
    '0%, 65%': {
      width: 0,
      right: 12,
      top: 12
    },
    '84%': {
      width: 14,
      right: 0,
      top: 7
    },
    '100%': {
      width: 12,
      right: 2,
      top: 8
    }
  });
  index.animation('checkmarkAnimateError', {
    '0%, 65%': {
      transform: 'scale(0.4)',
      opacity: 0
    },
    '84%': {
      transform: 'scale(1.15)'
    },
    '100%': {
      transform: 'scale(1)'
    }
  });
  index.animation('checkmarkRotatePlaceholder', {
    '0%, 5%': {
      transform: 'rotate(-45deg)'
    },
    '12%, 100%': {
      transform: 'rotate(-405deg)'
    }
  });
  return index.animation('fieldErrorShake', {
    '0%, 50%': {
      transform: 'translateX(-10px)'
    },
    '25%, 75%': {
      transform: 'translateX(10px)'
    },
    '100%': {
      transform: 'translateX(0px)'
    }
  });
}var IS$2;
IS$2 = index$1.create('natives', 'dom');
IS$2.load({
  // field: (target)-> target and target instanceof Field
  regex: function (target) {
    return target instanceof RegExp;
  },
  objectable: function (target) {
    return IS$2.object(target) || IS$2.function(target);
  }
});
var IS$1$1 = IS$2;/* istanbul ignore next */
if (window.console == null) {
  window.console = {};
}
/* istanbul ignore next */


if (console.log == null) {
  console.log = function () {};
}
/* istanbul ignore next */


if (console.warn == null) {
  console.warn = console.log;
}var simplybind = createCommonjsModule(function (module) {
  (function (t) {
    if (t = function (e, i, s) {
      return function (n) {
        if (!i[n]) throw Error(n + " is not a module");
        return e[n] ? e[n].exports : (e[n] = {
          exports: {}
        }, e[n].exports = i[n].call(s, t, e[n], e[n].exports));
      };
    }({}, {
      0: function (t, e, i) {
        var s = 0,
            n = "push pop shift unshift splice reverse sort".split(" "),
            r = {},
            h = {},
            o = ["{{", "}}"],
            u = Object.create({
          silent: !1
        }, {
          placeholder: {
            get: function () {
              return o;
            },
            set: function (t) {
              O.iA(t) && 2 === t.length && (o = t, C());
            }
          }
        }),
            c = {
          delay: !1,
          throttle: !1,
          simpleSelector: !1,
          promiseTransforms: !1,
          dispatchEvents: !1,
          sendArrayCopies: !1,
          updateEvenIfSame: !1,
          updateOnBind: !0
        },
            a = Object.defineProperty,
            f = Object.getOwnPropertyDescriptor,
            l = null,
            p = function () {
          if (!l) {
            var t = l = document.createEvent("Event");
            t.initEvent("change", !0, !1), t._sb = !0;
          }

          return l;
        },
            d = !("className" in Element.prototype && f(Element.prototype, "className").get),
            v = "innerWidth innerHeight outerWidth outerHeight scrollX scrollY pageXOffset pageYOffset screenX screenY screenLeft screenTop".split(" "),
            b = function (t, e) {
          return this.uAS(e || this);
        },
            g = function () {
          return "" + ++s;
        },
            y = function () {
          return Object.create(null);
        },
            _ = function (t, e) {
          return function (i, s, n) {
            return H(i, s, n, t, e);
          };
        },
            m = function (t, e) {
          return t.sU || (t.sU = new R(function () {
            return e ? t.sV(t.fDV(), t, !0) : t.uAS(t);
          }, "Func", {}));
        },
            D = function (t, e) {
          return t && -1 !== t.indexOf(e);
        },
            O = {
          iD: function (t) {
            return void 0 !== t;
          },
          iA: function (t) {
            return t instanceof Array;
          },
          iO: function (t) {
            return "object" == typeof t && t;
          },
          iS: function (t) {
            return "string" == typeof t;
          },
          iN: function (t) {
            return "number" == typeof t;
          },
          iF: function (t) {
            return "function" == typeof t;
          },
          iBI: function (t) {
            return t instanceof X;
          },
          iB: function (t) {
            return t instanceof R;
          },
          isI: function (t) {
            return O.iO(t) && O.iN(t.length);
          },
          DM: function (t) {
            return t.nodeName && 1 === t.nodeType;
          },
          dI: function (t) {
            return "INPUT" === (t = t.nodeName) || "TEXTAREA" === t || "SELECT" === t;
          },
          dR: function (t) {
            return "radio" === t.type;
          },
          dC: function (t) {
            return "checkbox" === t.type;
          },
          eC: function (t) {
            return t instanceof NodeList || t instanceof HTMLCollection || window.jQuery && t instanceof jQuery;
          },
          eAS: function (t) {
            var e = t[0].type;
            return [].filter.call(t, function (t) {
              return t.type === e;
            }).length === t.length;
          },
          dN: function (t) {
            return O.DM(t) || t === window || t === document;
          }
        },
            M = function (t, e, i) {
          var s;
          return (s = f(t, e)) ? (i && (s.configurable = !0), s) : (t = Object.getPrototypeOf(t)) ? M(t, e, !0) : void 0;
        },
            I = function (t, e, i) {
          var s;
          if (t.OD || (t.OD = M(e, t.pr)), i) n.forEach(function (i) {
            return a(e, i, {
              configurable: !0,
              value: function () {
                var s = Array.prototype[i].apply(e, arguments);
                return t.uAS(t), s;
              }
            });
          });else if ("Proxy" === t.type) {
            var h = t.oR = t.value;

            if (t.value = {
              result: null,
              args: null
            }, O.iF(h)) {
              var o = [].slice,
                  u = s = function () {
                var i = o.call(arguments);
                return t.value.args = i = t.tfS ? t.tfS(i) : i, t.value.result = i = h.apply(e, i), t.uAS(t), i;
              };

              a(e, t.pr, {
                configurable: t.isL = !0,
                get: function () {
                  return u;
                },
                set: function (e) {
                  O.iF(e) ? e !== h && (e !== s && (h = t.oR = e), u !== s && (u = s)) : u = e;
                }
              });
            }
          } else if (!(D(t.type, "DOM") || t.object === window && D(v, t.pr))) {
            (i = t.OD || r).get && (t.OG = i.get.bind(e)), i.set && (t.OS = i.set.bind(e));
            var c = (c = i.configurable) && e.constructor !== CSSStyleDeclaration;

            if (d && t.DM && t.pr in e.cloneNode(!1) && (t.OD = c = !1, t.isL = !0, t.OG = function () {
              return t.object[t.pr];
            }, t.OS = function (e) {
              return t.object[t.pr] = e;
            }), c) {
              c = "Array" === t.type;
              var f = !t.OS && !c;
              a(e, t.pr, {
                configurable: t.isL = !0,
                enumerable: i.enumerable,
                get: t.OG || function () {
                  return t.value;
                },
                set: function (e) {
                  t.sV(e, t, f);
                }
              }), c && I(t, e[t.pr], !0);
            }
          }
        },
            j = function (t, e, i) {
          if (i) {
            var s = [];

            for (t = 0, i = n.length; t < i; t++) {
              var r = n[t];
              s.push(delete e[r]);
            }

            return s;
          }

          return (i = t.OD).set || i.get || (i.value = t.oR || t.value), a(e, t.pr, i);
        },
            S = function (t) {
          var e,
              i = y();

          for (e in t) i[e] = t[e];

          return i;
        },
            E = function (t, e) {
          var i,
              s = Object.keys(e),
              n = 0;

          for (i = s.length; n < i; n++) {
            var r = s[n];
            t[r] = e[r];
          }
        },
            P = {
          get: function (t, e, i, s) {
            return e ? h[t._sb_ID] : s && t[0]._sb_map && (e = h[t[0]._sb_map[i]]).gB ? e.gB : t._sb_map && t._sb_map[i] ? h[t._sb_map[i]] : void 0;
          },
          set: function (t, e) {
            if (e) a(t.object, "_sb_ID", {
              configurable: !0,
              value: t.ID
            });else {
              var i = t.se;
              t.object._sb_map ? t.object._sb_map[i] = t.ID : (e = {}, e[i] = t.ID, a(t.object, "_sb_map", {
                configurable: !0,
                value: e
              }));
            }
          }
        },
            V,
            N = /[.*+?^${}()|[\]\\]/g,
            A = V = null,
            C = function () {
          var t = u.placeholder[0].replace(N, "\\$&"),
              e = u.placeholder[1].replace(N, "\\$&"),
              i = "[^" + e + "]+";
          A = new RegExp(t + "(" + i + ")" + e, "g"), V = new RegExp("" + t + i + e, "g");
        };

        C();

        var x = function (t, e, i) {
          var s,
              n,
              r = "",
              h = s = 0;

          for (n = t.length; s < n; h = ++s) r += t[h], i[h] && (r += e[i[h]]);

          return r;
        },
            k = function (t, e, i) {
          null == t[i] && (t[i] = []), t[i].push(e);
        },
            B = function (t, e) {
          var i,
              s,
              n,
              r = 0;

          for (s = (t = Array.prototype.slice.call(t.childNodes)).length; r < s; r++) {
            var h = t[r];
            if (3 !== h.nodeType) B(h, e);else if (h.textContent.match(V)) {
              var o = h.textContent.split(A);
              if (3 === o.length && "" === o[0] + o[2]) k(e, h, o[1]);else {
                var u = document.createDocumentFragment(),
                    c = i = 0;

                for (n = o.length; i < n; c = ++i) {
                  var a = o[c],
                      f = u.appendChild(document.createTextNode(a));
                  c % 2 && k(e, f, a);
                }

                h.parentNode.replaceChild(u, h);
              }
            }
          }
        },
            F = function (t) {
          throw Error("SimplyBind: " + (T[t] || t));
        },
            G = function (t, e) {
          u.silent || (e = L(e), t = T[t], console.warn("SimplyBind: " + t + "\n\n" + e));
        },
            w = function (t) {
          F("Invalid argument/s (" + t + ")", !0);
        },
            L = function (t) {
          return (Error().stack || "").split("\n").slice(t + 3).join("\n");
        },
            T = {
          erIP: "SimplyBind() and .to() only accept a function, an array, a bound object, a string, or a number.",
          erFN: "Only functions are allowed for .transform/.condition/All()",
          erEV: "Invalid argument number in .ofEvent()",
          emptyList: "Empty collection provided",
          erOD: "You can only pass a single DOM element to a binding",
          erMX: "'checked' of Mixed list of element cannot be bound"
        },
            H = function (t, e, i, s, n) {
          return (t || 0 === t) && (O.iS(t) || O.iN(t) || O.iF(t) || t instanceof Array) || O.iBI(t) || F("erIP"), !O.iO(t) || t instanceof Array ? (e = new X(e), e.so = i, e.IS = s, e.cC = n, t = O.iF(t) ? e.sS(t, !0) : e.sP(t)) : t = n ? n(t) : t.sC(), t;
        };

        H.version = "1.15.8", H.settings = u, H.defaultOptions = c, H.unBindAll = function (t, e) {
          var i;

          if (t && (O.iO(t) || O.iF(t))) {
            O.isI(t) && !t._sb_ID && t[0] && O.DM(t[0]) && (t = t[0]);
            var s = t._sb_map;
            if (t._sb_ID && h[t._sb_ID].rAS(e), s) for (i in s) t = s[i], h[t].rAS(e);
          }
        };

        var R = function (t, e, i) {
          return E(this, i), this.oD = this.so ? this.options : c, this.type = e, this.object = t, this.ID = g(), this.subs = [], this.sM = y(), this.pM = y(), this.atEV = [], "Proxy" === this.type && (this.sV = b), this.mC && (this.cH = y(), this.object.forEach(function (t) {
            return function (e) {
              var i = t.cH[e.value] = H("checked").of(e)._;

              i.aS(t), i.sM[t.ID].tF = function () {
                return i;
              }, i.gB = t;
            };
          }(this))), "Event" === this.type || "Func" === this.type && this.IS || ("Pholder" === this.type ? (e = this.de && !D(this.de, "multi") ? this.de + ":" + this.pr : this.pr, (t = this.pB = H(e).of(t)._).sPH(), this.value = t.pVL[this.Ph], t.txN && (this.txN = t.txN[this.Ph])) : (this.value = t = this.fDV(), "ObjectProp" !== this.type || O.iD(t) || f(this.object, this.pr) || (this.object[this.pr] = t), I(this, this.object))), this.aEV(), h[this.ID] = this;
        };

        R.prototype = {
          aS: function (t, e, i, s) {
            var n;

            if (t.isMulti) {
              var r = t.bindings;

              for (t = 0, n = r.length; t < n; t++) {
                var h = r[t];
                this.aS(h, e, i, s);
              }
            } else if (this.sM[t.ID]) var o = !0;else t.pM[this.ID] = this, this.subs.unshift(t), (n = this.sM[t.ID] = y()).uO = i, n.opts = S(e), (s || "Event" === this.type || "Proxy" === this.type || "Array" === this.type) && (n.opts.updateEvenIfSame = !0), n.VR = "Func" === t.type ? "ps" : "value";

            return o;
          },
          rS: function (t, e) {
            var i;

            if (t.isMulti) {
              var s = t.bindings;

              for (t = 0, i = s.length; t < i; t++) {
                var n = s[t];
                this.rS(n, e);
              }
            } else this.sM[t.ID] && (this.subs.splice(this.subs.indexOf(t), 1), delete this.sM[t.ID], delete t.pM[this.ID]), e && (t.rS(this), delete this.pM[t.ID]);

            0 === this.subs.length && 0 === Object.keys(this.pM).length && this.DES();
          },
          rAS: function (t) {
            var e,
                i = this.subs.slice(),
                s = 0;

            for (e = i.length; s < e; s++) {
              var n = i[s];
              this.rS(n, t);
            }
          },
          DES: function () {
            var t;

            if (delete h[this.ID], this.rPI(), "Event" === this.type) {
              var e = this.atEV,
                  i = 0;

              for (t = e.length; i < t; i++) {
                var s = e[i];
                this.urEVE(s);
              }
            } else "Func" === this.type && delete this.object._sb_ID;

            this.isL && this.OD && j(this, this.object), "Array" === this.type && j(this, this.value, !0), this.object._sb_map && (delete this.object._sb_map[this.se], 0 === Object.keys(this.object._sb_map).length && delete this.object._sb_map);
          },
          fDV: function () {
            var t,
                e = this.type;

            switch (!1) {
              case "Func" !== e:
                return this.object();

              case "DOMAttr" !== e:
                return this.object.getAttribute(this.pr) || "";

              case !this.mC:
                var i = [],
                    s = this.cH;

                for (t in s) if (s[t].object.checked) {
                  if ("DOMRadio" === e) return t;
                  i.push(t);
                }

                return i;

              default:
                return this.object[this.pr];
            }
          },
          sV: function (t, e, i, s) {
            if (e || (e = this), this.tfS && (t = this.tfS(t)), !i) switch (this.type) {
              case "ObjectProp":
                if (this.isL) {
                  if (this.dI) {
                    if (s) {
                      if (t !== this.OG()) {
                        var n = this.object.selectionStart;
                        this.OS(t), n && this.object.setSelectionRange(n, n);
                      }
                    } else this.OS(t), u.dispatchEvents && this.object.dispatchEvent(p());
                  } else this.OS && this.OS(t);
                } else t !== this.value && (this.object[this.pr] = t);
                break;

              case "Pholder":
                if (s = this.pB, s.pVL[this.Ph] = t, n = x(s.pCT, s.pVL, s.pIM), this.txN && t !== this.value) {
                  var r = this.txN,
                      h = 0;

                  for (i = r.length; h < i; h++) {
                    var o = r[h];
                    o.textContent = t;
                  }
                }

                "textContent" !== this.pr && s.sV(n, e);
                break;

              case "Array":
                t !== this.value && (O.iA(t) || (t = Array.prototype.concat(t)), j(this, this.value, !0), I(this, t = t.slice(), !0), this.OS && this.OS(t));
                break;

              case "Func":
                n = this.ps, this.ps = t, t = this.object(t, n);
                break;

              case "Event":
                this.iE = !0, this.eE(t), this.iE = !1;
                break;

              case "DOMRadio":
                if (this.mC) {
                  if (s = O.iB(t) ? t : this.cH[t]) for (h in t = s.object.value, n = this.cH) (i = n[h]).sV(i.ID === s.ID, e);else t = this.value;
                } else {
                  if ((t = !!t) === this.value) return;
                  this.object.checked !== t && (this.object.checked = t), t && u.dispatchEvents && this.object.dispatchEvent(p());
                }
                break;

              case "DOMCheckbox":
                if (this.mC) {
                  for (h = !O.iB(t), i = s = 0, r = (t = [].concat(t)).length; s < r; i = ++s) o = t[i], t[i] = O.iB(o) ? o : this.cH[o];

                  r = [], o = this.cH;

                  for (n in o) i = o[n], s = h ? D(t, i) : i.value, i.sV(s, e), s && r.push(n);

                  t = r;
                } else {
                  if ((t = !!t) === this.value) return;
                  this.object.checked !== t && (this.object.checked = t, u.dispatchEvents && this.object.dispatchEvent(p()));
                }

                break;

              case "DOMAttr":
                this.object.setAttribute(this.pr, t);
            }
            this.value = t, this.uAS(e);
          },
          uAS: function (t) {
            var e, i;
            if (i = (e = this.subs).length) for (; i--;) this.uS(e[i], t);
          },
          uS: function (t, e, i) {
            var s;

            if (!(e === t || e !== this && e.sM[t.ID])) {
              var n = this.sM[t.ID];

              if (!n.dL || !n.dL[e.ID]) {
                if (n.opts.throttle) {
                  var r = (i = +new Date()) - n.lU;
                  if (r < n.opts.throttle) return clearTimeout(n.uT), n.uT = setTimeout(function (i) {
                    return function () {
                      if (i.sM[t.ID]) return i.uS(t, e);
                    };
                  }(this), n.opts.throttle - r);
                  n.lU = i;
                } else if (n.opts.delay && !i) return setTimeout(function (i) {
                  return function () {
                    if (i.sM[t.ID]) return i.uS(t, e, !0);
                  };
                }(this), n.opts.delay);

                i = "Array" === this.type && n.opts.sendArrayCopies ? this.value.slice() : this.value, r = t[n.VR], (i = (s = n.tF) ? s(i, r, t.object) : i) === r && !n.opts.updateEvenIfSame || n.cN && !n.cN(i, r, t.object) || (n.opts.promiseTransforms && i && O.iF(i.then) ? i.then(function (i) {
                  t.sV(i, e);
                }) : t.sV(i, e), n.uO && this.rS(t));
              }
            }
          },
          aM: function (t, e, i, s) {
            var n, r;

            if (O.iF(i)) {
              var h = 0;

              for (r = e.length; h < r; h++) {
                var o = e[h],
                    u = o._ || o;
                u.isMulti ? this.aM(t, u.bindings, i, s) : (o = this.sM[u.ID], o[t] = i, s = s && !o.uO, this.pM[u.ID] && ((n = u.sM[this.ID])[t] || (n[t] = i)), !s && "Func" !== this.type || "tF" !== t || this.uS(u, this));
              }

              return !0;
            }

            return G("erFN", 2);
          },
          ss: function (t, e) {
            this.tfS = t, e && this.sV(this.value);
          },
          aD: function (t, e) {
            var i;
            (null != (i = this.sM[t.ID]).dL ? i.dL : i.dL = y())[e.ID] = 1;
          },
          sPH: function () {
            if (!this.pVL) {
              if (this.pVL = y(), this.pIM = y(), this.pCT = [], O.iS(this.value)) {
                this.pCT = this.value.split(V);
                var t = 0;
                this.value = this.value.replace(A, function (e) {
                  return function (i, s) {
                    return e.pIM[t++] = s, e.pVL[s] = s;
                  };
                }(this));
              }

              this.DM && "textContent" === this.pr && B(this.object, this.txN = y());
            }
          },
          aPI: function (t) {
            if ("Event" !== this.type) return this.rPI(), this.PI = setInterval(function (t) {
              return function () {
                var e = t.fDV();
                return t.sV(e, t, !0);
              };
            }(this), t);
          },
          rPI: function () {
            return clearInterval(this.PI), this.PI = null;
          },
          aUV: function (t, e) {
            this.object.addEventListener(t, function (t) {
              return function (i) {
                i._sb || (i = t.tfS && t.dI, t.sV(t.object[e], null, !i, !0));
              };
            }(this), !1);
          },
          aEV: function () {
            this.evN ? this.rEVE(this.evN) : this.dI ? (this.aUV("input", "value"), this.aUV("change", "value")) : this.mC || "DOMRadio" !== this.type && "DOMCheckbox" !== this.type || this.aUV("change", "checked");
          },
          rEVE: function (t) {
            this.atEV.push(t), this.evH || (this.evH = U.bind(this)), this.object[this.eM.listen](t, this.evH);
          },
          urEVE: function (t) {
            this.atEV.splice(this.atEV.indexOf(t), 1), this.object[this.eM.remove](t, this.evH);
          },
          eE: function (t) {
            var e = this.evN;
            "dispatchEvent" === this.eM.emit && (this.evO || (this.evO = document.createEvent("Event"), this.evO.initEvent(this.evN, !0, !0)), this.evO.bindingData = t, e = this.evO), this.object[this.eM.emit](e, t);
          }
        };

        var U = function () {
          this.iE || this.sV(arguments[this.pr], null, !0);
        },
            X = function (t, e) {
          var i;
          if (e) E(this, e), this.sG = 1;else for (i in this.sG = 0, this.subs = [], this.oP = t || (t = {}), this.options = {}, c) this.options[i] = null != t[i] ? t[i] : c[i];
          return this;
        };

        t = {
          sC: function () {
            return new X(null, this);
          },
          dM: function (t) {
            return this._ = t, Object.defineProperties(this, {
              value: {
                get: function () {
                  return t.value;
                }
              },
              original: {
                get: function () {
                  return t.objects || t.object;
                }
              },
              subscribers: {
                get: function () {
                  return t.subs.slice().map(function (t) {
                    return t.object;
                  });
                }
              }
            });
          },
          createBP: function (t, e, i, s) {
            var n;
            return this.object = t, (n = P.get(t, s, this.se, this.mC)) ? this.patchCachedBP(n) : (t = new R(t, e, i), P.set(t, s), t);
          },
          patchCachedBP: function (t) {
            var e;

            if ("ObjectProp" !== t.type || this.pr in this.object || I(t, this.object), this.so) {
              var i = this.oP;

              for (n in i) {
                var s = i[n];
                t.oD[n] = s;
              }
            }

            var n = t.oD;

            for (e in n) s = n[e], this.options[e] = O.iD(this.oP[e]) ? this.oP[e] : s;

            return t;
          },
          sP: function (t) {
            if (O.iN(t) && (t = t.toString()), this.se = this.pr = t, !this.options.simpleSelector) {
              if (D(t, ":")) {
                var e = t.split(":");
                this.de = e.slice(0, -1).join(":"), this.pr = e[e.length - 1];
              }

              D(t, ".") && (e = this.pr.split("."), this.pr = e[0], this.Ph = e.slice(1).join(".")), D(this.de, "event") && (D(t, "#") ? (e = this.pr.split("#"), this.evN = e[0], this.pr = e[1]) : (this.evN = this.pr, this.pr = 0), isNaN(parseInt(this.pr)) && G("erEV", 1));
            }

            return this;
          },
          sS: function (t, e) {
            this.sG = 1;
            var i,
                s = (i = t !== window && O.isI(t) && !t.nodeType) ? t[0] : t;

            if (s) {
              if (this.DM = O.DM(s)) {
                if ("checked" === this.pr) var n = s && O.dR(s),
                    r = !n && s && O.dC(s);else "value" === this.pr && (this.dI = O.dI(s));
                if (i && !D(this.de, "multi")) if (1 === t.length) t = t[0];else {
                  if ((n || r) && !O.eAS(t)) return G("erMX", 3);
                  n || r ? (this.mC = !0, t = [].slice.call(t)) : (t = t[0], G("erOD", 3));
                }
              }
            } else i && O.eC(t) && F("emptyList");

            switch (!1) {
              case !e:
                r = "Func";
                break;

              case !this.Ph:
                r = "Pholder";
                break;

              case !(D(this.de, "array") && O.iA(t[this.pr])):
                r = "Array";
                break;

              case !D(this.de, "event"):
                r = "Event", this.eM = {
                  listen: this.oP.listenMethod,
                  remove: this.oP.removeMethod,
                  emit: this.oP.emitMethod
                }, t[this.eM.listen] || (this.eM.listen = O.dN(t) ? "addEventListener" : "on"), t[this.eM.remove] || (this.eM.remove = O.dN(t) ? "removeEventListener" : "removeListener"), t[this.eM.emit] || (this.eM.emit = O.dN(t) ? "dispatchEvent" : "emit");
                break;

              case !D(this.de, "func"):
                r = "Proxy";
                break;

              case !n:
                r = "DOMRadio";
                break;

              case !r:
                r = "DOMCheckbox";
                break;

              case !D(this.de, "attr"):
                r = "DOMAttr";
                break;

              default:
                r = "ObjectProp";
            }

            return D(this.de, "multi") ? (t.length || F("emptyList"), this.dM(new nt(this, t, r))) : this.dM(this.createBP(t, r, this, e)), D(this._.type, "Event") || D(this._.type, "Proxy") ? this.options.updateOnBind = !1 : D(this._.type, "Func") && (this.options.updateOnBind = !0), this.cC ? this.cC(this) : this;
          },
          aP: function (t) {
            var e;
            t.sG = 2, t.subs.push(this);

            var i = t._.aS(this._, t.options, t.uO);

            if (t.uO) delete t.uO;else if (t.options.updateOnBind && !i) if (this._.isMulti) {
              var s = this._.bindings,
                  n = 0;

              for (e = s.length; n < e; n++) i = s[n], t._.uS(i, t._);
            } else t._.uS(this._, t._);
          }
        }, X.prototype = Object.create(t, {
          of: {
            get: function () {
              if (!this.sG) return W;
            }
          },
          set: {
            get: function () {
              if (this.sG) return $;
            }
          },
          chainTo: {
            get: function () {
              if (2 === this.sG) return Y;
            }
          },
          transformSelf: {
            get: function () {
              if (1 === this.sG) return Q;
            }
          },
          transform: {
            get: function () {
              if (2 === this.sG) return q;
            }
          },
          transformAll: {
            get: function () {
              if (2 === this.sG) return z;
            }
          },
          condition: {
            get: function () {
              if (2 === this.sG) return J;
            }
          },
          conditionAll: {
            get: function () {
              if (2 === this.sG) return K;
            }
          },
          bothWays: {
            get: function () {
              if (2 === this.sG) return Z;
            }
          },
          unBind: {
            get: function () {
              if (2 === this.sG) return tt;
            }
          },
          pollEvery: {
            get: function () {
              if (this.sG) return et;
            }
          },
          stopPolling: {
            get: function () {
              if (this.sG) return it;
            }
          },
          setOption: {
            get: function () {
              if (2 === this.sG) return st;
            }
          },
          disallowFrom: {
            get: function () {
              var t;
              if (2 === this.sG && (t = this)) return _(!1, function (e) {
                return t._.aD(t.subs[t.subs.length - 1]._, e._), t;
              });
            }
          },
          updateOn: {
            get: function () {
              var t;
              if (this.sG && (t = this)) return _(!1, function (e) {
                return e._ !== t._ && (t._.pM[e._.ID] = e._, e._.aS(m(t._, !0), e.options, !1, !0)), t;
              });
            }
          },
          removeUpdater: {
            get: function () {
              var t, e;
              if (this.sG && (e = this) && (t = this._.sU)) return _(!1, function (i) {
                i._.sM[t.ID] && (delete e._.pM[i._.ID], i._.rS(t));
              });
            }
          },
          to: {
            get: function () {
              var t;
              if (1 === this.sG && (t = this)) return _(!0, function (e) {
                return e._ !== t._ && e.aP(t), t;
              });
            }
          },
          and: {
            get: function () {
              var t = this.sC();
              if (2 === this.sG) return t;

              if (1 === this.sG) {
                if (!t._.isMulti) {
                  var e = t._;
                  t._ = t._ = new nt(t), t._.addBP(e);
                }

                return _(!1, function (e) {
                  return t._.addBP(e._), t;
                });
              }
            }
          },
          once: {
            get: function () {
              if (1 === this.sG) {
                var t = this.sC();
                return t.uO = !0, t;
              }
            }
          },
          update: {
            get: function () {
              return this.set;
            }
          },
          twoWay: {
            get: function () {
              return this.bothWays;
            }
          },
          pipe: {
            get: function () {
              return this.chainTo;
            }
          }
        });

        var W = function (t) {
          return O.iO(t) || O.iF(t) || w(t), O.iBI(t) && (t = t.object), this.sG = 1, this.sS(t);
        },
            Y = function (t, e, i) {
          return H(this.subs[this.subs.length - 1]).to(t, e, i);
        },
            $ = function (t) {
          return this._.sV(t), this;
        },
            Q = function (t) {
          return O.iF(t) ? this._.ss(t, this.options.updateOnBind) : G("erFN", 1), this;
        },
            q = function (t) {
          return this._.aM("tF", this.subs.slice(-1), t, this.options.updateOnBind), this;
        },
            z = function (t) {
          return this._.aM("tF", this.subs, t, this.options.updateOnBind), this;
        },
            J = function (t) {
          return this._.aM("cN", this.subs.slice(-1), t), this;
        },
            K = function (t) {
          return this._.aM("cN", this.subs, t), this;
        },
            Z = function (t) {
          var e,
              i = this.subs[this.subs.length - 1],
              s = i._,
              n = this._.isMulti ? this._.bindings : [this._];

          for (s.aS(this._, i.options), i = 0, e = n.length; i < e; i++) {
            var r = n[i],
                h = r.sM[s.ID].tF;
            r = r.sM[s.ID].cN, (h || t) && (h = O.iF(t) ? t : h) && !1 !== t && (s.sM[this._.ID].tF = h), r && (s.sM[this._.ID].cN = r);
          }

          return this;
        },
            tt = function (t) {
          var e,
              i = this.subs,
              s = 0;

          for (e = i.length; s < e; s++) {
            var n = i[s];

            this._.rS(n._, t);
          }

          return this;
        },
            et = function (t) {
          return this._.aPI(t), this;
        },
            it = function () {
          return this._.rPI(), this;
        },
            st = function (t, e) {
          return this._.sM[this.subs[this.subs.length - 1]._.ID].opts[t] = e, this;
        },
            nt = function (t, e, i) {
          var s, n;
          if (t.se = t.se.slice(6), E(this, this.In = t), this.isMulti = !0, this.bindings = s = [], e) for (t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            this.addBP(r, i);
          }
          return Object.defineProperties(this, {
            type: {
              get: function () {
                return s.map(function (t) {
                  return t.type;
                });
              }
            },
            value: {
              get: function () {
                return s.map(function (t) {
                  return t.value;
                });
              }
            }
          });
        },
            rt = nt.prototype = Object.create(t);

        return Object.keys(R.prototype).forEach(function (t) {
          return rt[t] = function (e, i, s, n) {
            var r,
                h = this.bindings,
                o = 0;

            for (r = h.length; o < r; o++) {
              var u = h[o];
              "uS" === t && (i = u), u[t](e, i, s, n);
            }
          };
        }), rt.addBP = function (t, e) {
          this.bindings.push(e ? this.createBP(t, e, this.In) : t);
        }, e.exports = H, e.exports;
      }
    }, this), "function" == typeof undefined && undefined.umd) ;else {
      if (!module.exports) return this.simplybind = t(0);
      module.exports = t(0);
    }
  }).call(commonjsGlobal, null);
});var REGEX = {
  any: /./,
  whiteSpace: /\s+/,
  numeric: /^\d$/,
  letter: /^[a-zA-Z]$/,
  // alphanumeric: /[\da-zA-Z]/
  widenumeric: /^[0-9\!#\$\%\*\+\/\=\?\^\{\|\}\(\)\~\-\.]$/,
  alphanumeric: /^[0-9A-Za-z\!#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\(\)\~\-\ ]$/,
  email: /^[\w\-\.]+@[\w\-\.]+\.[A-Za-z]{2,10}$/
};var noop = function () {};

var includes$2 = function (target, item) {
  return target && target.indexOf(item) !== -1;
};

var repeat = function (string, count) {
  var i;
  return function () {
    var j, ref, results1;
    results1 = [];

    for (i = j = 1, ref = count; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results1.push(string);
    }

    return results1;
  }().join('');
};

var removeItem$1 = function (target, item) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    return target.splice(itemIndex, 1);
  }
};

var insertAfter$1 = function (target, item, newItem) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    return target.splice(itemIndex, 0, newItem);
  }
};

var hexToRGBA = function (hex, alpha) {
  var B, G, R;

  if (hex[0] === '#') {
    hex = hex.slice(1);
  }

  R = parseInt(hex.slice(0, 2), 16);
  G = parseInt(hex.slice(2, 4), 16);
  B = parseInt(hex.slice(4, 6), 16);
  return `rgba(${R}, ${G}, ${B}, ${alpha})`;
};

var defaultColor = function (color, defaultColor) {
  if (color === 'transparent' || !color) {
    return defaultColor;
  } else {
    return color;
  }
};

var calcPadding = function (desiredHeight, fontSize) {
  return Math.ceil((desiredHeight - fontSize * 1.231) / 2);
};

var unlockScroll = function (excludedEl) {
  window._isLocked = false;
  return quickdom(window).off('wheel.lock');
};

var lockScroll = function (excludedEl) {
  if (!window._isLocked) {
    window._isLocked = true;
    return quickdom(window).on('wheel.lock', function (event) {
      if (event.target === excludedEl.raw || quickdom(event.target).parentMatching(function (parent) {
        return parent === excludedEl;
      })) {
        if (event.wheelDelta > 0 && excludedEl.raw.scrollTop === 0) {
          return event.preventDefault();
        }

        if (event.wheelDelta < 0 && excludedEl.raw.scrollHeight - excludedEl.raw.scrollTop === excludedEl.raw.clientHeight) {
          return event.preventDefault();
        }
      } else {
        return event.preventDefault();
      }
    });
  }
};

var fuzzyMatch = function (needle, haystack, caseSensitive) {
  var hI, hLength, matchedCount, nI, nLength, needleChar;
  nLength = needle.length;
  hLength = haystack.length;

  if (!caseSensitive) {
    needle = needle.toUpperCase();
    haystack = haystack.toUpperCase();
  }

  if (nLength > hLength) {
    return false;
  }

  if (nLength === hLength) {
    return needle === haystack;
  }

  nI = hI = matchedCount = 0;

  while (nI < nLength) {
    needleChar = needle[nI++];

    while (hI < hLength) {
      if (haystack[hI++] === needleChar) {
        matchedCount++;
        break;
      }
    }
  }

  return matchedCount === nLength;
};

var startsWith = function (needle, haystack, caseSensitive) {
  var i;

  if (!caseSensitive) {
    needle = needle.toUpperCase();
    haystack = haystack.toUpperCase();
  }

  if (needle.length > haystack.length) {
    return false;
  }

  if (needle.length === haystack.length) {
    return needle === haystack;
  }

  i = -1;

  while (needle[++i]) {
    if (needle[i] !== haystack[i]) {
      return false;
    }
  }

  return true;
};

var getIndexOfFirstDiff = function (sourceString, compareString) {
  var currentPos, maxLength;
  currentPos = 0;
  maxLength = Math.max(sourceString.length, compareString.length);

  while (currentPos < maxLength) {
    if (sourceString[currentPos] !== compareString[currentPos]) {
      return currentPos;
    }

    currentPos++;
  }

  return null;
};

var parseCssShorthandValue = function (string) {
  var result, values;
  values = string.split(REGEX.whiteSpace).map(parseFloat);
  result = {};

  switch (values.length) {
    case 1:
      result.top = result.right = result.bottom = result.left = values[0];
      break;

    case 2:
      result.top = result.bottom = values[0];
      result.right = result.left = values[1];
      break;

    case 3:
      result.top = values[0];
      result.right = result.left = values[1];
      result.bottom = values[2];
      break;

    case 4:
      result.top = values[0];
      result.right = values[1];
      result.bottom = values[2];
      result.left = values[3];
  }

  return result;
};

var shorthandSideValue = function (value, side) {
  var values;

  switch (typeof value) {
    case 'number':
      return value;

    case 'string':
      values = parseCssShorthandValue(value);
      return values[side];

    default:
      return 0;
  }
};

var updateShorthandValue = function (value, side, newValue) {
  var values;
  values = parseCssShorthandValue('' + (value || 0));

  switch (side) {
    case 'top':
      values.top += newValue;
      break;

    case 'right':
      values.right += newValue;
      break;

    case 'bottom':
      values.bottom += newValue;
      break;

    case 'left':
      values.left += newValue;
      break;

    default:
      Object.keys(values).forEach(function (side) {
        return values[side] += newValue;
      });
  }

  return `${values.top}px ${values.right}px ${values.bottom}px ${values.left}px`;
};

var inheritProto = function (child, parent, keys) {
  var j, key, len, ref;
  ref = Object.getOwnPropertyNames(parent.prototype);

  for (j = 0, len = ref.length; j < len; j++) {
    key = ref[j];

    if (keys && !keys.includes(key)) {
      continue;
    }

    if (!child.prototype[key]) {
      child.prototype[key] = parent.prototype[key];
    }
  }

  return child;
};var REQUIRED_FIELD_METHODS = ['_getValue', '_setValue', '_validate'];var fastdom = createCommonjsModule(function (module) {
  !function (win) {
    /**
     * Mini logger
     *
     * @return {Function}
     */

    var debug = function () {};
    /**
     * Normalized rAF
     *
     * @type {Function}
     */

    var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || function (cb) {
      return setTimeout(cb, 16);
    };
    /**
     * Initialize a `FastDom`.
     *
     * @constructor
     */


    function FastDom() {
      var self = this;
      self.reads = [];
      self.writes = [];
      self.raf = raf.bind(win); // test hook
    }

    FastDom.prototype = {
      constructor: FastDom,

      /**
       * Adds a job to the read batch and
       * schedules a new frame if need be.
       *
       * @param  {Function} fn
       * @public
       */
      measure: function (fn, ctx) {
        var task = !ctx ? fn : fn.bind(ctx);
        this.reads.push(task);
        scheduleFlush(this);
        return task;
      },

      /**
       * Adds a job to the
       * write batch and schedules
       * a new frame if need be.
       *
       * @param  {Function} fn
       * @public
       */
      mutate: function (fn, ctx) {
        var task = !ctx ? fn : fn.bind(ctx);
        this.writes.push(task);
        scheduleFlush(this);
        return task;
      },

      /**
       * Clears a scheduled 'read' or 'write' task.
       *
       * @param {Object} task
       * @return {Boolean} success
       * @public
       */
      clear: function (task) {
        return remove(this.reads, task) || remove(this.writes, task);
      },

      /**
       * Extend this FastDom with some
       * custom functionality.
       *
       * Because fastdom must *always* be a
       * singleton, we're actually extending
       * the fastdom instance. This means tasks
       * scheduled by an extension still enter
       * fastdom's global task queue.
       *
       * The 'super' instance can be accessed
       * from `this.fastdom`.
       *
       * @example
       *
       * var myFastdom = fastdom.extend({
       *   initialize: function() {
       *     // runs on creation
       *   },
       *
       *   // override a method
       *   measure: function(fn) {
       *     // do extra stuff ...
       *
       *     // then call the original
       *     return this.fastdom.measure(fn);
       *   },
       *
       *   ...
       * });
       *
       * @param  {Object} props  properties to mixin
       * @return {FastDom}
       */
      extend: function (props) {
        if (typeof props != 'object') throw new Error('expected object');
        var child = Object.create(this);
        mixin(child, props);
        child.fastdom = this; // run optional creation hook

        if (child.initialize) child.initialize();
        return child;
      },
      // override this with a function
      // to prevent Errors in console
      // when tasks throw
      catch: null
    };
    /**
     * Schedules a new read/write
     * batch if one isn't pending.
     *
     * @private
     */

    function scheduleFlush(fastdom) {
      if (!fastdom.scheduled) {
        fastdom.scheduled = true;
        fastdom.raf(flush.bind(null, fastdom));
      }
    }
    /**
     * Runs queued `read` and `write` tasks.
     *
     * Errors are caught and thrown by default.
     * If a `.catch` function has been defined
     * it is called instead.
     *
     * @private
     */


    function flush(fastdom) {
      var writes = fastdom.writes;
      var reads = fastdom.reads;
      var error;

      try {
        debug('flushing reads', reads.length);
        runTasks(reads);
        debug('flushing writes', writes.length);
        runTasks(writes);
      } catch (e) {
        error = e;
      }

      fastdom.scheduled = false; // If the batch errored we may still have tasks queued

      if (reads.length || writes.length) scheduleFlush(fastdom);

      if (error) {
        debug('task errored', error.message);
        if (fastdom.catch) fastdom.catch(error);else throw error;
      }
    }
    /**
     * We run this inside a try catch
     * so that if any jobs error, we
     * are able to recover and continue
     * to flush the batch until it's empty.
     *
     * @private
     */


    function runTasks(tasks) {
      var task;

      while (task = tasks.shift()) task();
    }
    /**
     * Remove an item from an Array.
     *
     * @param  {Array} array
     * @param  {*} item
     * @return {Boolean}
     */


    function remove(array, item) {
      var index = array.indexOf(item);
      return !!~index && !!array.splice(index, 1);
    }
    /**
     * Mixin own properties of source
     * object into the target.
     *
     * @param  {Object} target
     * @param  {Object} source
     */


    function mixin(target, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) target[key] = source[key];
      }
    } // There should never be more than
    // one instance of `FastDom` in an app


    var exports = win.fastdom = win.fastdom || new FastDom(); // jshint ignore:line
    // Expose to CJS & AMD

    module.exports = exports;
  }(typeof window !== 'undefined' ? window : commonjsGlobal);
});var Condition;
Condition = class Condition {
  constructor(field1, settings, callback1) {
    var property, target;
    this.field = field1;
    this.settings = settings;
    this.callback = callback1;
    this.satisfied = false;
    this.value = this.settings.value;
    this.property = this.settings.property || '_value';

    if (this.settings.property === 'value') {
      this.property = '_value';
    }

    target = this.field.allFields[this.settings.target];

    if (target) {
      this.target = target;
    } else {
      return console.warn(`condition target not found for the provided ID '${this.settings.target}'`, this.field);
    }

    property = IS$1$1.array(this.target[this.property]) ? `array:${this.property}` : this.property;
    simplybind(property, {
      updateOnBind: false
    }).of(this.target).and('visible').of(this.target.state).to(this.callback);
    simplybind('satisfied', {
      updateOnBind: false
    }).of(this).to((newValue, oldValue) => {
      var base;

      if (oldValue != null) {
        return typeof (base = this.field).emit === "function" ? base.emit('conditionChange', this) : void 0;
      }
    });
  }

  test() {
    var comparison, comparisonOperators, passedComparisons, ref, targetValue;

    if (!((ref = this.target) != null ? ref.state.visible : void 0)) {
      return false;
    }

    comparison = function () {
      switch (false) {
        case !IS$1$1.objectPlain(this.value):
          return this.value;

        case !IS$1$1.regex(this.value):
          return {
            '$regex': this.value
          };

        case !(this.value === 'valid' && !this.settings.property || !IS$1$1.defined(this.value)):
          return 'valid';

        default:
          return {
            '$eq': this.value
          };
      }
    }.call(this);

    if (comparison === 'valid') {
      return this.target.validate();
    }

    targetValue = (() => {
      var nestedObject, propertyChain;

      if (this.property === '_value') {
        return this.target.value;
      }

      propertyChain = this.property.split('.');

      switch (false) {
        case propertyChain.length !== 1:
          return this.target[this.property];

        case !IS$1$1.defined(this.target[this.property]):
          return this.target[this.property];

        default:
          nestedObject = this.target;

          while (IS$1$1.object(nestedObject)) {
            nestedObject = nestedObject[propertyChain.pop()];
          }

          return nestedObject;
      }
    })();

    comparisonOperators = Object.keys(comparison);
    passedComparisons = comparisonOperators.filter(function (operator) {
      var seekedValue;
      seekedValue = comparison[operator];

      switch (operator) {
        case '$eq':
          return targetValue === seekedValue;

        case '$ne':
          return targetValue !== seekedValue;

        case '$gt':
          return targetValue > seekedValue;

        case '$gte':
          return targetValue >= seekedValue;

        case '$lt':
          return targetValue < seekedValue;

        case '$lte':
          return targetValue <= seekedValue;

        case '$ct':
          return helpers.includes(targetValue, seekedValue);

        case '$nct':
          return !helpers.includes(targetValue, seekedValue);

        case '$regex':
          return seekedValue.test(targetValue);

        case '$nregex':
          return !seekedValue.test(targetValue);

        case '$mask':
          return helpers.testMask(targetValue, seekedValue);

        default:
          return false;
      }
    });
    return passedComparisons.length === comparisonOperators.length;
  }

  static validate(conditions) {
    var validConditions;

    if (conditions) {
      validConditions = conditions.filter(function (condition) {
        return condition.satisfied = condition.test();
      });
      return validConditions.length === conditions.length;
    }
  }

  static init(field, conditions, callback) {
    return setTimeout(() => {
      if (callback == null) {
        callback = () => {
          return field.validateConditions();
        };
      }

      field.conditions = conditions.map(function (condition) {
        return new Condition(field, condition, callback);
      });
      return callback();
    });
  }

};
var Condition$1 = Condition;var transformSettings = {
  conditions: function (conditions) {
    var results, target, value;

    if (IS$1$1.objectPlain(conditions)) {
      results = [];

      for (target in conditions) {
        value = conditions[target];
        results.push({
          target,
          value
        });
      }

      return results;
    } else if (IS$1$1.array(conditions)) {
      return conditions.map(function (item) {
        if (IS$1$1.string(item)) {
          return {
            target: item
          };
        } else {
          return item;
        }
      });
    }
  },
  choices: function (choices) {
    var label, results, value;

    if (IS$1$1.objectPlain(choices)) {
      results = [];

      for (label in choices) {
        value = choices[label];
        results.push({
          label,
          value
        });
      }

      return results;
    } else if (IS$1$1.array(choices)) {
      return choices.map(function (item) {
        if (!IS$1$1.objectPlain(item)) {
          return {
            label: item,
            value: item
          };
        } else {
          return item;
        }
      });
    }
  },
  validWhenRegex: function (regex) {
    if (IS$1$1.string(regex)) {
      return new RegExp(regex);
    } else {
      return regex;
    }
  }
};var globalDefaults = {
  fontFamily: 'system-ui, sans-serif',
  templates: {},
  events: null,
  label: false,
  error: '',
  help: '',
  required: false,
  disabled: false,
  defaultValue: null,
  width: '100%',
  mobileWidth: null,
  mobileThreshold: 736,
  border: 1,
  margin: null,
  padding: null,
  distance: null,
  inputPadding: 12,
  fontSize: 14,
  labelSize: null,
  icon: null,
  iconSize: 22,
  getter: null,
  setter: null,
  validator: null,
  clearErrorOnValid: true,
  makeRoomForHelp: true
};var Field, currentID;
currentID = 0;

Field = function () {
  class Field {
    constructor(settings, builder, settingOverrides, templateOverrides) {
      var ref, shallowSettings, transformSettings_;
      this.builder = builder;

      if (settingOverrides) {
        if (settingOverrides.globalDefaults) {
          this.globalDefaults = settingOverrides.globalDefaults;
        }

        if (settingOverrides[settings.type]) {
          this.defaults = settingOverrides[settings.type];
        }
      }

      if (templateOverrides && templateOverrides[settings.type]) {
        this.templates = templateOverrides[settings.type];
        this.template = templateOverrides[settings.type].default;
      }

      shallowSettings = this.shallowSettings ? Field.shallowSettings.concat(this.shallowSettings) : Field.shallowSettings;
      transformSettings_ = this.transformSettings ? Field.transformSettings.concat(this.transformSettings) : Field.transformSettings;
      this.settings = primaryBuilder$1.deep.clone.notDeep(shallowSettings).transform(transformSettings_)(this.globalDefaults, this.defaults, settings);
      this.ID = this.settings.ID || currentID++ + '';
      this.type = settings.type;
      this.name = settings.name;
      this.allFields = this.settings.fieldInstances || Field.instances;
      this._value = null;
      this._eventCallbacks = {};
      this.state = {
        valid: true,
        visible: true,
        focused: false,
        hovered: false,
        filled: false,
        interacted: false,
        isMobile: false,
        disabled: this.settings.disabled,
        margin: this.settings.margin,
        padding: this.settings.padding,
        width: this.settings.width,
        showLabel: this.settings.label,
        label: this.settings.label,
        showHelp: this.settings.help,
        help: this.settings.help,
        showError: false,
        error: this.settings.error
      };

      if (IS$1$1.defined(this.settings.placeholder)) {
        this.state.placeholder = this.settings.placeholder;
      }

      if (IS$1$1.number(this.settings.width) && this.settings.width <= 1) {
        this.state.width = `${this.settings.width * 100}%`;
      }

      if ((ref = this.settings.conditions) != null ? ref.length : void 0) {
        this.state.visible = false;
        Condition$1.init(this, this.settings.conditions);
      }

      if (this.allFields[this.ID]) {
        if (typeof console !== "undefined" && console !== null) {
          console.warn(`Duplicate field IDs found: '${this.ID}'`);
        }
      }

      this.allFields[this.ID] = this;
    }

    _constructorEnd() {
      var base, handler, ref, target;
      this.el.childf; //.field.on 'inserted', ()=> @emit('inserted')

      if (this.settings.ID) {
        this.el.raw.id = this.ID;
      }

      if (this.settings.value != null) {
        if ((base = this.settings).defaultValue == null) {
          base.defaultValue = this.settings.value;
        }
      }

      if (this.settings.defaultValue != null) {
        this.value = this.settings.multiple ? [].concat(this.settings.defaultValue) : this.settings.defaultValue;
      }

      simplybind('showError', {
        updateOnBind: false
      }).of(this.state).to('help').of(this.state).transform(show => {
        if (show && this.state.error && IS$1$1.string(this.state.error)) {
          return this.state.error;
        } else {
          return this.settings.help || this.state.help;
        }
      });
      simplybind('error', {
        updateOnBind: false
      }).of(this.state).to('help').of(this.state).condition(error => {
        return error && this.state.showError;
      });
      simplybind('help').of(this.state).to('html').of(this.el.child.help).and.to('showHelp').of(this.state);
      simplybind('label').of(this.state).to('text').of(this.el.child.label).and.to('showLabel').of(this.state);
      simplybind('margin').of(this.state).to(this.el.style.bind(this.el, 'margin'));
      simplybind('padding').of(this.state).to(this.el.style.bind(this.el, 'padding'));
      simplybind('showHelp').of(this.state).to((show, prevShow) => {
        var changeAmount;

        if (this.settings.makeRoomForHelp) {
          changeAmount = !!show === !!prevShow ? 0 : show ? 25 : prevShow ? -25 : void 0;

          if (changeAmount) {
            return this.state.margin = updateShorthandValue(this.state.margin, 'bottom', changeAmount);
          }
        }
      });
      simplybind('focused', {
        updateOnBind: false
      }).of(this.state).to(focused => {
        return this.emit(focused ? 'focus' : 'blur');
      });

      if (this.settings.mobileWidth) {
        simplybind(() => {
          return fastdom.measure(() => {
            return this.state.isMobile = window.innerWidth <= this.settings.mobileThreshold;
          });
        }).updateOn('event:resize').of(window);
      }

      if (IS$1$1.object(this.settings.events)) {
        ref = this.settings.events;

        for (target in ref) {
          handler = ref[target];
          this.on(target, handler);
        }
      }

      this.emit('created', this);
      return this.el.raw._quickField = this;
    }

    _formatWidth(width) {
      width = this.state.isMobile ? this.settings.mobileWidth || width : width;

      if (this.settings.distance && width !== '100%') {
        width = `calc(${width} - ${this.settings.distance}px)`;
      }

      return width;
    }

    appendTo(target) {
      this.el.appendTo(target);
      return this;
    }

    prependTo(target) {
      this.el.prependTo(target);
      return this;
    }

    insertAfter(target) {
      this.el.insertAfter(target);
      return this;
    }

    insertBefore(target) {
      this.el.insertBefore(target);
      return this;
    }

    detach(target) {
      this.el.detach(target);
      return this;
    }

    remove() {
      this.el.remove();
      return this.destroy(false);
    }

    destroy(removeFromDOM = true) {
      var child, i, len, ref;
      simplybind.unBindAll(this);
      simplybind.unBindAll(this.state);
      simplybind.unBindAll(this.el);
      ref = this.el.child;

      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        simplybind.unBindAll(child);
      }

      if (removeFromDOM) {
        this.el.remove();
      }

      if (this._destroy) {
        this._destroy();
      }

      delete this.allFields[this.ID];
      return true;
    }

    on(eventNames, callback, useCapture) {
      this.el.on.call(this.el, eventNames, callback, useCapture, true);
      return this;
    }

    once(eventNames, callback, useCapture) {
      return this.on(eventNames, () => {
        this.off(eventNames, callback);
        return callback.apply(this.el, arguments);
      }, useCapture);
    }

    off() {
      this.el.off.apply(this.el, arguments);
      return this;
    }

    emit() {
      this.el.emitPrivate.apply(this.el, arguments);
      return this;
    }

    validate(providedValue = this[this.coreValueProp], testUnrequired, report) {
      var isValid;

      isValid = function () {
        switch (false) {
          case !this.settings.validator:
            return this.settings.validator(providedValue);

          case !(!this.settings.required && !testUnrequired):
            return true;

          case this._validate(providedValue, testUnrequired, report) !== false:
            return false;

          case !this.settings.required:
            switch (false) {
              case !this.settings.multiple:
                return !!(providedValue != null ? providedValue.length : void 0);

              case typeof providedValue !== 'string':
                return !!providedValue;

              default:
                return providedValue != null;
            }

            break;

          default:
            return true;
        }
      }.call(this);

      if (isValid && this.settings.clearErrorOnValid) {
        this.state.showError = false;
      }

      return isValid;
    }

    validateConditions(conditions) {
      var passedConditions, toggleVisibility;

      if (conditions) {
        toggleVisibility = false;
      } else {
        conditions = this.conditions;
        toggleVisibility = true;
      }

      passedConditions = Condition$1.validate(conditions);

      if (toggleVisibility) {
        return this.state.visible = passedConditions;
      } else {
        return passedConditions;
      }
    }

    validateAndReport(providedValue, testUnrequired) {
      var isValid;
      isValid = this.validate(providedValue, testUnrequired, true);
      this.state.showError = !isValid;
      return isValid;
    }

  }

  Field.instances = Object.create(null);
  Field.shallowSettings = ['templates', 'fieldInstances', 'value', 'defaultValue'];
  Field.transformSettings = transformSettings;
  Field.prototype.globalDefaults = globalDefaults;
  Field.prototype.coreValueProp = '_value';
  Object.defineProperties(Field.prototype, {
    'removeListener': {
      get: function () {
        return this.off;
      }
    },
    'els': {
      get: function () {
        return this.el.child;
      }
    },
    'valueRaw': {
      get: function () {
        return this._value;
      }
    },
    'value': {
      get: function () {
        if (this.settings.getter) {
          return this.settings.getter(this._getValue());
        } else {
          return this._getValue();
        }
      },
      set: function (value) {
        return this._setValue(this.settings.setter ? this.settings.setter(value) : value);
      }
    }
  });
  return Field;
}.call(undefined);

var Field$1 = Field;var keyCodes;
var KEYCODES = keyCodes = {
  delete: 8,
  enter: 13,
  esc: 27,
  ctrl: 17,
  alt: 18,
  shift: 16,
  super: 91,
  super2: 93,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  hyphen: 45,
  underscore: 95,
  question: 63,
  exclamation: 33,
  frontslash: 47,
  backslash: 92,
  comma: 44,
  period: 46,
  space: 32,
  anyArrow: function (code) {
    return code === keyCodes.up || code === keyCodes.down || code === keyCodes.left || code === keyCodes.right;
  },
  anyModifier: function (code) {
    return code === keyCodes.ctrl || code === keyCodes.alt || code === keyCodes.shift || code === keyCodes.super || code === keyCodes.super2;
  },
  anyAlpha: function (code) {
    return 97 <= code && code <= 122 || 65 <= code && code <= 90;
  },
  anyNumeric: function (code) {
    return 48 <= code && code <= 57;
  },
  anyAlphaNumeric: function (code) {
    return keyCodes.anyAlpha(code) || keyCodes.anyNumeric(code);
  },
  anyPrintable: function (code) {
    return keyCodes.anyAlpha(code) || keyCodes.anyNumeric(code) || code === keyCodes.hyphen || code === keyCodes.underscore || code === keyCodes.question || code === keyCodes.exclamation || code === keyCodes.frontslash || code === keyCodes.backslash || code === keyCodes.comma || code === keyCodes.period || code === keyCodes.space;
  }
};var checkmark = quickdom.template(['*svg', {
  attrs: {
    width: '12px',
    height: '12px',
    viewBox: '5 7 12 12',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '9px',
    height: '9px'
  }
}, ['*polyline', {
  attrs: {
    'stroke-width': '2',
    'stroke-linecap': 'round',
    'stroke-linejoin': 'round',
    fill: 'none',
    points: '7 13.8888889 9.66666667 17 15 9',
    tabindex: -1,
    focusable: false
  }
}]]);var angleDown = quickdom.template(['*svg', {
  attrs: {
    width: '1792px',
    height: '1792px',
    viewBox: '0 0 1792 1792',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M1395 736q0 13-10 23l-466 466q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l50-50q10-10 23-10t23 10l393 393 393-393q10-10 23-10t23 10l50 50q10 10 10 23z'
  }
}]]);var caretUp = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 512 512',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M402 347c0 5-2 10-5 13-4 4-8 6-13 6h-256c-5 0-9-2-13-6-3-3-5-8-5-13s2-9 5-12l128-128c4-4 8-6 13-6s9 2 13 6l128 128c3 3 5 7 5 12z'
  }
}]]);var caretDown = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 512 512',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M402 201c0 5-2 9-5 13l-128 128c-4 4-8 5-13 5s-9-1-13-5l-128-128c-3-4-5-8-5-13s2-9 5-13c4-3 8-5 13-5h256c5 0 9 2 13 5 3 4 5 8 5 13z'
  }
}]]);var plus = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 15 15',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*polygon', {
  attrs: {
    tabindex: -1,
    focusable: false,
    points: '9 0 6 0 6 6 0 6 0 9 6 9 6 15 9 15 9 9 15 9 15 6 9 6'
  }
}]]);var clone$1 = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 18 20',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M13.414,0 L6,0 C4.897,0 4,0.898 4,2 L4,14 C4,15.103 4.897,16 6,16 L16,16 C17.103,16 18,15.103 18,14 L18,4.586 L13.414,0 Z M16.001,14 L6,14 L6,2 L12,2 L12,6 L16,6 L16.001,14 Z'
  }
}], ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M2,6.42379282 L0,6.42379282 L0,18 C0,19.103 0.897,20 2,20 L14,20 L14,18 L2,18 L2,6.42379282 Z'
  }
}]]);var remove$1 = plus.extend({
  options: {
    style: {
      transform: 'rotate(45deg)'
    }
  }
});var template$1 = quickdom.template(['div', {
  ref: 'dropdown',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 10,
    overflow: 'hidden',
    top: function (dropdown) {
      if (dropdown.field.type === 'text') {
        return this.parent.raw.style.height;
      } else {
        return '-7px';
      }
    },
    left: function () {
      if (this.parent.rect.left - 5 < 0) {
        return 0;
      } else {
        return -5;
      }
    },
    display: 'none',
    // backgroundColor: hexToRGBA('f6f6f6', 0.9)
    backgroundColor: '#f6f6f6',
    boxShadow: `0px 6px 10px ${hexToRGBA('000000', 0.32)}`,
    borderWidth: '1px',
    borderStyle: 'solid',
    borderColor: '#d1d1d1',
    borderRadius: '5px',
    boxSizing: 'border-box',
    padding: '4px 0',
    $isOpen: {
      $hasVisibleChoices: {
        display: 'block'
      }
    }
  }
}]);
var list = quickdom.template(['div', {
  ref: 'list',
  passStateToChildren: false,
  style: {
    position: 'relative',
    overflow: 'scroll',
    overflowScrolling: 'touch',
    overflowStyle: '-ms-autohiding-scrollbar'
  }
}]);
var choice = quickdom.template(['div', {
  style: {
    display: 'none',
    fontSize: '0',
    color: '#000000',
    userSelect: 'none',
    lineHeight: '1em',
    cursor: 'pointer',
    $visible: {
      display: 'block'
    },
    $unavailable: {
      display: 'none'
    },
    $hover: {
      color: '#ffffff',
      backgroundColor: '#4C96FF'
    }
  }
}, ['div', // Checkmark
{
  style: {
    display: 'inline-block',
    verticalAlign: 'top',
    width: '20px',
    // height: ()-> @parent.raw.style.height
    // lineHeight: ()-> @parent.style('height')
    // fontSize: ()-> @parent.style('height')
    lineHeight: '20px',
    fontSize: '13px',
    textAlign: 'center',
    color: 'inherit',
    stroke: 'currentColor',
    visibility: 'hidden',
    $selected: {
      visibility: 'visible'
    }
  }
}, checkmark], ['div', // Text
{
  styleAfterInsert: true,
  style: {
    display: 'inline-block',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    wordWrap: 'normal',
    maxWidth: function () {
      return `calc(100% - ${this.prev.styleSafe('width', true)})`;
    },
    paddingRight: '10px',
    lineHeight: '20px',
    fontSize: '11px',
    fontFamily: function (dropdown) {
      return dropdown.settings.fontFamily;
    },
    color: 'inherit',
    boxSizing: 'border-box'
  }
}]]);
var scrollIndicatorUp = quickdom.template(['div', {
  ref: 'scrollIndicatorUp',
  style: {
    position: 'absolute',
    top: 0,
    left: 0,
    display: 'none',
    width: '100%',
    height: '20px',
    backgroundColor: '#f6f6f6',
    color: '#000000',
    textAlign: 'center',
    $visible: {
      display: 'block'
    }
  }
}, ['div', {
  style: {
    position: 'absolute',
    top: '50%',
    left: 0,
    right: 0,
    width: '15px',
    height: '15px',
    display: 'block',
    margin: '0 auto',
    transform: 'translateY(-50%)'
  }
}, caretUp]]);
var scrollIndicatorDown = quickdom.template(['div', {
  ref: 'scrollIndicatorDown',
  style: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    display: 'none',
    width: '100%',
    height: '20px',
    backgroundColor: '#f6f6f6',
    color: '#000000',
    textAlign: 'center',
    $visible: {
      display: 'block'
    }
  }
}, ['div', {
  style: {
    position: 'absolute',
    top: '50%',
    left: 0,
    right: 0,
    width: '15px',
    height: '15px',
    display: 'block',
    margin: '0 auto',
    transform: 'translateY(-50%)'
  }
}, caretDown]]);
var help = quickdom.template(['div', {
  ref: 'help',
  style: {
    display: 'none',
    borderTop: '2px solid rgba(0,0,0,0.05)',
    padding: '4px 12px 1px',
    color: 'rgba(0,0,0,0.5)',
    fontWeight: '500',
    fontSize: '11px',
    userSelect: 'none',
    $showHelp: {
      display: 'block'
    }
  }
}]);
var template$1$1 =
/*#__PURE__*/
Object.freeze({
  default: template$1,
  list: list,
  choice: choice,
  scrollIndicatorUp: scrollIndicatorUp,
  scrollIndicatorDown: scrollIndicatorDown,
  help: help
});var defaults = {
  maxHeight: 300,
  multiple: false,
  lockScroll: true,
  typeBuffer: false,
  help: '',
  templates: {}
};var Choice, Dropdown, List;

Dropdown = function () {
  class Dropdown {
    constructor(initialChoices, field) {
      this.initialChoices = initialChoices;
      this.field = field;
      this.isOpen = false;
      this.typeBuffer = '';
      this.settings = primaryBuilder$1.deep.clone.filter(this._settingFilters)(globalDefaults, this.defaults, this.field.settings.dropdown);
      this.selected = this.settings.multiple ? [] : null;
      this.lastSelected = null;
      this.choices = [];
      this.currentHighlighted = null;
      this.visibleChoicesCount = 0;
      this.visibleChoices = [];
      this.els = {};
      this._selectedCallback = noop;

      this._createElements();

      this._attachBindings();

      return this;
    }

    _createElements() {
      var choice$$1, globalOpts, i, len, ref;
      globalOpts = {
        relatedInstance: this
      };
      this.els.container = this.template.default.spawn(this.settings.templates.default, primaryBuilder$1({
        passStateToChildren: false
      }, globalOpts));
      this.els.list = this.template.list.spawn(this.settings.templates.list, globalOpts).appendTo(this.els.container);
      this.els.help = this.template.help.spawn(this.settings.templates.help, globalOpts).appendTo(this.els.container);
      this.els.scrollIndicatorUp = this.template.scrollIndicatorUp.spawn(this.settings.templates.scrollIndicatorUp, globalOpts).appendTo(this.els.container);
      this.els.scrollIndicatorDown = this.template.scrollIndicatorDown.spawn(this.settings.templates.scrollIndicatorDown, globalOpts).appendTo(this.els.container);
      this.list = new List(this);
      ref = this.initialChoices;

      for (i = 0, len = ref.length; i < len; i++) {
        choice$$1 = ref[i];
        this.addChoice(choice$$1);
      }
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      return this._attachBindings_scrollIndicators();
    }

    _attachBindings_elState() {
      simplybind('help').of(this.settings).to('text').of(this.els.help).and.to(showHelp => {
        return this.els.help.state('showHelp', showHelp);
      });
      simplybind('visibleChoicesCount').of(this).to(count => {
        return this.els.container.state('hasVisibleChoices', !!count);
      });
      return simplybind('currentHighlighted').of(this).to((current, prev) => {
        if (prev) {
          prev.el.state('hover', false);
        }

        if (current) {
          return current.el.state('hover', true);
        }
      });
    }

    _attachBindings_display() {
      simplybind('isOpen', {
        updateOnBind: false
      }).of(this).to(isOpen => {
        this.els.container.state('isOpen', isOpen);

        if (!isOpen) {
          this.currentHighlighted = null;
        }

        if (this.settings.lockScroll) {
          if (isOpen) {
            lockScroll(this.els.list);
          } else {
            unlockScroll();
          }
        }

        if (isOpen) {
          this.list.appendChoices();
          this.list.calcDisplay();

          if (this.selected && !this.settings.multiple) {
            return this.list.scrollToChoice(this.selected);
          }
        } else {
          return this.list.setTranslate(0);
        }
      });
      simplybind('lastSelected', {
        updateOnBind: false,
        updateEvenIfSame: true
      }).of(this).to((newChoice, prevChoice) => {
        return this._selectedCallback(newChoice, prevChoice);
      });
      simplybind('focused', {
        updateOnBind: false
      }).of(this.field.state).to(focused => {
        if (!focused) {
          return this.field.el.child.input.off('keydown.dropdownNav');
        } else {
          return this.field.el.child.input.on('keydown.dropdownNav', event => {
            if (this.isOpen) {
              switch (event.keyCode) {
                case KEYCODES.up:
                  event.preventDefault();
                  return this.highlightPrev();

                case KEYCODES.down:
                  event.preventDefault();
                  return this.highlightNext();

                case KEYCODES.enter:
                  event.preventDefault();

                  if (this.currentHighlighted) {
                    return this.lastSelected = this.currentHighlighted;
                  }

                  break;

                case KEYCODES.esc:
                  event.preventDefault();
                  return this.isOpen = false;
              }
            }
          });
        }
      });

      if (!this.settings.typeBuffer) {
        return;
      }

      simplybind('focused', {
        updateOnBind: false
      }).of(this.field.state).to(focused => {
        if (!focused) {
          return quickdom(document).off('keypress.dropdownTypeBuffer');
        } else {
          return quickdom(document).on('keypress.dropdownTypeBuffer', event => {
            if (this.isOpen) {
              event.preventDefault();

              if (!KEYCODES.anyPrintable(event.keyCode)) {
                return;
              }

              return this.typeBuffer += event.key;
            }
          });
        }
      });
      return simplybind('typeBuffer', {
        updateOnBind: false
      }).of(this).to(() => {
        clearTimeout(this.typeBufferTimeout);
        return this.typeBufferTimeout = setTimeout(() => {
          return this.typeBuffer = '';
        }, 1500);
      }).and.to(buffer => {
        var choice$$1, i, len, ref;

        if (buffer) {
          ref = this.visibleChoices;

          for (i = 0, len = ref.length; i < len; i++) {
            choice$$1 = ref[i];

            if (startsWith(buffer, choice$$1.label)) {
              this.currentHighlighted = choice$$1;

              if (!this.list.choiceInView(choice$$1)) {
                this.list.scrollToChoice(choice$$1);
              }

              return;
            }
          }
        }
      });
    }

    _attachBindings_scrollIndicators() {
      simplybind('scrollTop', {
        updateEvenIfSame: true
      }).of(this.els.list.raw).to(scrollTop => {
        return this._updateScrollIndicatorVisibility();
      }).condition(() => {
        return this.isOpen && !this.settings.help && this.els.list.raw.scrollHeight !== this.els.list.raw.clientHeight && this.els.list.raw.clientHeight >= 100;
      }).updateOn('event:scroll').of(this.els.list.raw).updateOn('isOpen').of(this);
      this.els.scrollIndicatorUp.on('mouseenter', () => {
        return this.list.startScrolling('up');
      });
      this.els.scrollIndicatorUp.on('mouseleave', () => {
        return this.list.stopScrolling();
      });
      this.els.scrollIndicatorDown.on('mouseenter', () => {
        return this.list.startScrolling('down');
      });
      return this.els.scrollIndicatorDown.on('mouseleave', () => {
        return this.list.stopScrolling();
      });
    }

    _updateScrollIndicatorVisibility() {
      var scrollTop, showBottomIndicator, showTopIndicator;
      scrollTop = this.els.list.raw;
      showTopIndicator = scrollTop > 0;
      showBottomIndicator = this.els.list.raw.scrollHeight - this.els.list.raw.clientHeight > scrollTop;
      this.els.scrollIndicatorUp.state('visible', showTopIndicator);
      return this.els.scrollIndicatorDown.state('visible', showBottomIndicator);
    }

    addChoice(config) {
      var i, item, len, newChoice;

      if (IS$1$1.array(config)) {
        for (i = 0, len = config.length; i < len; i++) {
          item = config[i];
          this.addChoice(item);
        }

        return;
      } else if (IS$1$1.string(config)) {
        config = {
          label: config,
          value: config
        };
      } else if (IS$1$1.objectPlain(config)) {
        if (config.value == null) {
          config.value = config.label;
        }

        if (config.label == null) {
          config.label = config.value;
        }
      } else {
        return;
      }

      newChoice = new Choice(this, config, this.list, this.choices.length);

      if (this.list.appendedChoices) {
        newChoice.init();
      }

      this.choices.push(newChoice);
      return newChoice;
    }

    removeChoice(choice$$1) {
      var i, item, len;

      if (IS$1$1.array(choice$$1)) {
        for (i = 0, len = choice$$1.length; i < len; i++) {
          item = choice$$1[i];
          this.removeChoice(item);
        }

        return;
      } else {
        choice$$1 = this.findChoiceAny(choice$$1);
      }

      if (!choice$$1) {
        return;
      }

      choice$$1.remove();
      return this.choices.splice(this.choices.indexOf(choice$$1), 1);
    }

    replaceChoices(newChoices) {
      this.removeChoice(this.choices.slice());
      this.addChoice(newChoices);
    }

    appendTo(target) {
      return this.els.container.appendTo(target);
    }

    onSelected(callback) {
      return this._selectedCallback = callback;
    }

    findChoice(providedValue, byLabel) {
      var matches;
      matches = this.choices.filter(function (choice$$1) {
        switch (false) {
          case !IS$1$1.object(providedValue):
            return providedValue === choice$$1;

          case !byLabel:
            return providedValue === choice$$1.label;

          default:
            return providedValue === choice$$1.value;
        }
      });
      return matches[0];
    }

    findChoiceAny(providedValue) {
      return this.findChoice(providedValue) || this.findChoice(providedValue, true);
    }

    highlightPrev() {
      var choice$$1, currentIndex;
      currentIndex = this.visibleChoices.indexOf(this.currentHighlighted);

      if (currentIndex > 0) {
        this.currentHighlighted = choice$$1 = this.visibleChoices[currentIndex - 1];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollUp(choice$$1);
        }
      } else {
        this.currentHighlighted = choice$$1 = this.visibleChoices[this.visibleChoices.length - 1];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollToChoice(choice$$1, 1);
        }
      }
    }

    highlightNext() {
      var choice$$1, currentIndex;
      currentIndex = this.visibleChoices.indexOf(this.currentHighlighted);

      if (currentIndex < this.visibleChoices.length - 1) {
        this.currentHighlighted = choice$$1 = this.visibleChoices[currentIndex + 1];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollDown(choice$$1);
        }
      } else {
        this.currentHighlighted = choice$$1 = this.visibleChoices[0];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollToChoice(choice$$1, 1);
        }
      }
    }

  }

  Dropdown.prototype.template = template$1$1;
  Dropdown.prototype.defaults = defaults;
  Dropdown.prototype._settingFilters = {
    maxHeight: function (value) {
      return IS$1$1.number(value);
    }
  };
  return Dropdown;
}.call(undefined);

List = class List {
  constructor(dropdown) {
    this.choiceInView = this.choiceInView.bind(this);
    this.dropdown = dropdown;
    ({
      els: this.els,
      field: this.field,
      settings: this.settings
    } = this.dropdown);
    this.el = this.els.list;
    this.container = this.els.container;
    this.appendedChoices = false;
  }

  appendChoices() {
    var choice$$1, i, len, ref;

    if (this.appendedChoices) {
      return;
    }

    ref = this.dropdown.choices;

    for (i = 0, len = ref.length; i < len; i++) {
      choice$$1 = ref[i];
      choice$$1.init();
    }

    return this.appendedChoices = true;
  }

  calcDisplay() {
    var bottomCutoff, clippingParent, clippingRect, cutoff, height, isBottomCutoff, isTopCutoff, needsNewHeight, padding, scrollHeight, selfRect, topCutoff, translation, windowCutoff, windowHeight;
    windowHeight = window.innerHeight;
    translation = this.translation || 0;
    clippingParent = this.container.parentMatching(function (parent) {
      var overflow;
      overflow = parent.style('overflowY');
      return overflow === 'hidden' || overflow === 'scroll';
    });
    scrollHeight = this.el.raw.scrollHeight || 2e308;
    selfRect = primaryBuilder$1.clone(this.container.rect);
    padding = selfRect.height - this.el.height;
    height = Math.min(scrollHeight, this.settings.maxHeight, window.innerHeight - 40);
    selfRect.bottom = selfRect.top + height;

    if (clippingParent) {
      clippingRect = clippingParent.rect;
      bottomCutoff = selfRect.bottom - clippingRect.bottom;
      topCutoff = clippingRect.top - selfRect.top;
      isBottomCutoff = bottomCutoff > 0;
      isTopCutoff = topCutoff > 0;

      if (selfRect.top >= clippingRect.bottom || clippingRect.top >= selfRect.bottom) {
        console.warn(`The dropdown for element '${this.field.ID}' cannot be displayed as it's hidden by the parent overflow`);
      } else if (isBottomCutoff || isTopCutoff) {
        needsNewHeight = true;

        if (selfRect.top - bottomCutoff > clippingRect.top && !isTopCutoff) {
          translation = bottomCutoff;
          selfRect.top -= translation;
          selfRect.bottom -= translation;
          cutoff = clippingRect.top - selfRect.top;
        } else if (selfRect.bottom - topCutoff < clippingRect.bottom) {
          translation = topCutoff * -1;
          selfRect.top += translation;
          selfRect.bottom += translation;
          cutoff = selfRect.bottom - clippingRect.bottom;
        }

        if (needsNewHeight = cutoff > 0) {
          height = cutoff - padding;
        }
      }
    }

    windowCutoff = selfRect.top + height - windowHeight;

    if (windowCutoff > 0 && height < windowHeight) {
      translation += windowCutoff + 10;
    }

    this.setDimensions(height, this.field.el.child.innerwrap.width + 10);
    return this.setTranslate(translation);
  }

  setDimensions(height, width) {
    if (height != null) {
      this.el.style('maxHeight', height);
    }

    if (width != null) {
      return this.el.style('minWidth', width);
    }
  }

  setTranslate(translation) {
    this.translation = translation;
    translation *= -1;
    return this.container.style('transform', `translateY(${translation}px)`);
  }

  scrollToChoice(choice$$1, offset = 3) {
    var distaneFromTop, selectedHeight;
    distaneFromTop = choice$$1.el.raw.offsetTop;
    selectedHeight = choice$$1.el.height;
    return this.el.raw.scrollTop = distaneFromTop - selectedHeight * offset;
  }

  scrollDown(choice$$1) {
    return this.el.raw.scrollTop += choice$$1.el.height;
  }

  scrollUp(choice$$1) {
    return this.el.raw.scrollTop -= choice$$1.el.height;
  }

  choiceInView(choice$$1) {
    var choiceRect, downPadding, listRect, upPadding;
    choiceRect = choice$$1.el.rect;
    listRect = this.el.rect;
    upPadding = this.els.scrollIndicatorUp.state('visible') ? parseFloat(this.els.scrollIndicatorUp.styleSafe('height', true)) : void 0;
    downPadding = this.els.scrollIndicatorDown.state('visible') ? parseFloat(this.els.scrollIndicatorDown.styleSafe('height', true)) : void 0;
    return choiceRect.bottom <= listRect.bottom - downPadding && choiceRect.top >= listRect.top + upPadding;
  }

  startScrolling(direction) {
    return this.scrollIntervalID = setInterval(() => {
      return this.el.raw.scrollTop += direction === 'up' ? -20 : 20;
    }, 50);
  }

  stopScrolling() {
    return clearInterval(this.scrollIntervalID);
  }

};
Choice = class Choice {
  constructor(dropdown, settings, list$$1, index) {
    var ref;
    this.dropdown = dropdown;
    this.settings = settings;
    this.list = list$$1;
    this.index = index;
    ({
      label: this.label,
      value: this.value,
      conditions: this.conditions
    } = this.settings);

    if (this.label == null) {
      this.label = this.value;
    }

    if (this.value == null) {
      this.value = this.label;
    }

    this.field = this.dropdown.field;
    this.visible = true;
    this.selected = false;
    this.unavailable = false;
    this.initialized = false;

    if ((ref = this.conditions) != null ? ref.length : void 0) {
      this.unavailable = true;
      this.allFields = this.field.allFields;
      Condition$1.init(this, this.conditions, () => {
        return this.unavailable = !Condition$1.validate(this.conditions);
      });
    }
  }

  init() {
    if (this.initialized) {
      return;
    }

    this.initialized = true;
    this.el = this.dropdown.template.choice.spawn(null, {
      relatedInstance: this.dropdown
    });
    this.el.children[1].text = this.label;
    this.el.appendTo(this.list.el);
    return this._attachBindings();
  }

  remove() {
    if (!this.initialized) {
      return;
    }

    return this.el.remove();
  }

  _attachBindings() {
    return (() => {
      simplybind('visible').of(this).to((visible, prev) => {
        this.dropdown.visibleChoicesCount += visible ? 1 : -1;
        this.el.state('visible', visible);

        if (visible) {
          this.dropdown.visibleChoices.push(this);

          if (IS$1$1.defined(prev)) {
            // indicates state has changed
            return this.dropdown.visibleChoices.sort(function (a$$1, b) {
              return a$$1.index - b.index;
            });
          }
        } else {
          return removeItem$1(this.dropdown.visibleChoices, this);
        }
      });
      simplybind('selected').of(this).to(selected => {
        return this.el.state('selected', selected);
      });
      simplybind('unavailable').of(this).to(unavailable => {
        return this.el.state('unavailable', unavailable);
      }).and.to(unavailable => {
        if (unavailable) {
          return this.toggle(false, true);
        }
      });
      simplybind('event:click').of(this.el).to(() => {
        return this.dropdown.lastSelected = this;
      });
      simplybind('event:mousedown').of(this.el).to(event => {
        event.preventDefault();
        return event.stopPropagation();
      });
      return simplybind('event:mouseenter').of(this.el).to(() => {
        return this.dropdown.currentHighlighted = this;
      });
    })();
  }

  toggle(newValue, unavailable) {
    var newState, prevState, ref, wasSelected;
    prevState = this.selected;
    newState = IS$1$1.defined(newValue) ? newValue : !this.selected;

    if (!newState) {
      if (this.dropdown.settings.multiple && prevState) {
        this.selected = newState;
        return removeItem$1(this.field._value, this);
      } else {
        wasSelected = this.selected;

        if (IS$1$1.defined(newValue)) {
          this.selected = newState;
        }

        if (unavailable && wasSelected) {
          return this.field._value = null;
        }
      }
    } else {
      this.selected = newState;

      if (this.field.settings.multiple) {
        this.field._value.push(this);
      } else {
        if ((ref = this.field._value) != null) {
          ref.toggle(false);
        }

        this.field._value = this;
      }

      return this.field.lastSelected = this;
    }
  }

};
var Dropdown$1 = Dropdown;var textMaskCore = createCommonjsModule(function (module, exports) {
  !function (e, r) {
    module.exports = r();
  }(commonjsGlobal, function () {
    return function (e) {
      function r(n) {
        if (t[n]) return t[n].exports;
        var o = t[n] = {
          exports: {},
          id: n,
          loaded: !1
        };
        return e[n].call(o.exports, o, o.exports, r), o.loaded = !0, o.exports;
      }

      var t = {};
      return r.m = e, r.c = t, r.p = "", r(0);
    }([function (e, r, t) {

      function n(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var o = t(3);
      Object.defineProperty(r, "conformToMask", {
        enumerable: !0,
        get: function () {
          return n(o).default;
        }
      });
      var i = t(2);
      Object.defineProperty(r, "adjustCaretPosition", {
        enumerable: !0,
        get: function () {
          return n(i).default;
        }
      });
      var a = t(5);
      Object.defineProperty(r, "createTextMaskInputElement", {
        enumerable: !0,
        get: function () {
          return n(a).default;
        }
      });
    }, function (e, r) {

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.placeholderChar = "_";
    }, function (e, r) {

      function t(e) {
        var r = e.previousConformedValue,
            t = void 0 === r ? o : r,
            i = e.previousPlaceholder,
            a = void 0 === i ? o : i,
            u = e.currentCaretPosition,
            l = void 0 === u ? 0 : u,
            s = e.conformedValue,
            f = e.rawValue,
            d = e.placeholderChar,
            c = e.placeholder,
            v = e.indexesOfPipedChars,
            p = void 0 === v ? n : v,
            h = e.caretTrapIndexes,
            g = void 0 === h ? n : h;
        if (0 === l) return 0;
        var m = f.length,
            y = t.length,
            b = c.length,
            C = s.length,
            P = m - y,
            x = P > 0,
            O = 0 === y,
            k = P > 1 && !x && !O;
        if (k) return l;
        var j = x && (t === s || s === c),
            M = 0,
            T = void 0,
            w = void 0;
        if (j) M = l - P;else {
          var _ = s.toLowerCase(),
              V = f.toLowerCase(),
              S = V.substr(0, l).split(o),
              N = S.filter(function (e) {
            return _.indexOf(e) !== -1;
          });

          w = N[N.length - 1];
          var E = a.substr(0, N.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
              A = c.substr(0, N.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
              R = A !== E,
              I = void 0 !== a[N.length - 1] && void 0 !== c[N.length - 2] && a[N.length - 1] !== d && a[N.length - 1] !== c[N.length - 1] && a[N.length - 1] === c[N.length - 2];
          !x && (R || I) && E > 0 && c.indexOf(w) > -1 && void 0 !== f[l] && (T = !0, w = f[l]);

          for (var J = p.map(function (e) {
            return _[e];
          }), q = J.filter(function (e) {
            return e === w;
          }).length, F = N.filter(function (e) {
            return e === w;
          }).length, L = c.substr(0, c.indexOf(d)).split(o).filter(function (e, r) {
            return e === w && f[r] !== e;
          }).length, W = L + F + q + (T ? 1 : 0), z = 0, B = 0; B < C; B++) {
            var D = _[B];
            if (M = B + 1, D === w && z++, z >= W) break;
          }
        }

        if (x) {
          for (var G = M, H = M; H <= b; H++) if (c[H] === d && (G = H), c[H] === d || g.indexOf(H) !== -1 || H === b) return G;
        } else if (T) {
          for (var K = M - 1; K >= 0; K--) if (s[K] === w || g.indexOf(K) !== -1 || 0 === K) return K;
        } else for (var Q = M; Q >= 0; Q--) if (c[Q - 1] === d || g.indexOf(Q) !== -1 || 0 === Q) return Q;
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = t;
      var n = [],
          o = "";
    }, function (e, r, t) {

      function n() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a,
            t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            n = t.guide,
            u = void 0 === n || n,
            l = t.previousConformedValue,
            s = void 0 === l ? a : l,
            f = t.placeholderChar,
            d = void 0 === f ? i.placeholderChar : f,
            c = t.placeholder,
            v = void 0 === c ? (0, o.convertMaskToPlaceholder)(r, d) : c,
            p = t.currentCaretPosition,
            h = t.keepCharPositions,
            g = u === !1 && void 0 !== s,
            m = e.length,
            y = s.length,
            b = v.length,
            C = r.length,
            P = m - y,
            x = P > 0,
            O = p + (x ? -P : 0),
            k = O + Math.abs(P);

        if (h === !0 && !x) {
          for (var j = a, M = O; M < k; M++) v[M] === d && (j += d);

          e = e.slice(0, O) + j + e.slice(O, m);
        }

        for (var T = e.split(a).map(function (e, r) {
          return {
            char: e,
            isNew: r >= O && r < k
          };
        }), w = m - 1; w >= 0; w--) {
          var _ = T[w].char;

          if (_ !== d) {
            var V = w >= O && y === C;
            _ === v[V ? w - P : w] && T.splice(w, 1);
          }
        }

        var S = a,
            N = !1;

        e: for (var E = 0; E < b; E++) {
          var A = v[E];

          if (A === d) {
            if (T.length > 0) for (; T.length > 0;) {
              var R = T.shift(),
                  I = R.char,
                  J = R.isNew;

              if (I === d && g !== !0) {
                S += d;
                continue e;
              }

              if (r[E].test(I)) {
                if (h === !0 && J !== !1 && s !== a && u !== !1 && x) {
                  for (var q = T.length, F = null, L = 0; L < q; L++) {
                    var W = T[L];
                    if (W.char !== d && W.isNew === !1) break;

                    if (W.char === d) {
                      F = L;
                      break;
                    }
                  }

                  null !== F ? (S += I, T.splice(F, 1)) : E--;
                } else S += I;

                continue e;
              }

              N = !0;
            }
            g === !1 && (S += v.substr(E, b));
            break;
          }

          S += A;
        }

        if (g && x === !1) {
          for (var z = null, B = 0; B < S.length; B++) v[B] === d && (z = B);

          S = null !== z ? S.substr(0, z + 1) : a;
        }

        return {
          conformedValue: S,
          meta: {
            someCharsRejected: N
          }
        };
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = n;
      var o = t(4),
          i = t(1),
          a = "";
    }, function (e, r, t) {

      function n() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : u.placeholderChar;
        if (e.indexOf(r) !== -1) throw new Error("Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.\n\n" + ("The placeholder character that was received is: " + JSON.stringify(r) + "\n\n") + ("The mask that was received is: " + JSON.stringify(e)));
        return e.map(function (e) {
          return e instanceof RegExp ? r : e;
        }).join("");
      }

      function o(e) {
        return "string" == typeof e || e instanceof String;
      }

      function i(e) {
        return "number" == typeof e && void 0 === e.length && !isNaN(e);
      }

      function a(e) {
        for (var r = [], t = void 0; t = e.indexOf(s), t !== -1;) r.push(t), e.splice(t, 1);

        return {
          maskWithoutCaretTraps: e,
          indexes: r
        };
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.convertMaskToPlaceholder = n, r.isString = o, r.isNumber = i, r.processCaretTraps = a;
      var u = t(1),
          l = [],
          s = "[]";
    }, function (e, r, t) {

      function n(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function o(e) {
        var r = {
          previousConformedValue: void 0,
          previousPlaceholder: void 0
        };
        return {
          state: r,
          update: function (t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e,
                o = n.inputElement,
                s = n.mask,
                d = n.guide,
                m = n.pipe,
                b = n.placeholderChar,
                C = void 0 === b ? p.placeholderChar : b,
                P = n.keepCharPositions,
                x = void 0 !== P && P,
                O = n.showMask,
                k = void 0 !== O && O;

            if ("undefined" == typeof t && (t = o.value), t !== r.previousConformedValue) {
              ("undefined" == typeof s ? "undefined" : l(s)) === y && void 0 !== s.pipe && void 0 !== s.mask && (m = s.pipe, s = s.mask);
              var j = void 0,
                  M = void 0;

              if (s instanceof Array && (j = (0, v.convertMaskToPlaceholder)(s, C)), s !== !1) {
                var T = a(t),
                    w = o.selectionEnd,
                    _ = r.previousConformedValue,
                    V = r.previousPlaceholder,
                    S = void 0;

                if (("undefined" == typeof s ? "undefined" : l(s)) === h) {
                  if (M = s(T, {
                    currentCaretPosition: w,
                    previousConformedValue: _,
                    placeholderChar: C
                  }), M === !1) return;
                  var N = (0, v.processCaretTraps)(M),
                      E = N.maskWithoutCaretTraps,
                      A = N.indexes;
                  M = E, S = A, j = (0, v.convertMaskToPlaceholder)(M, C);
                } else M = s;

                var R = {
                  previousConformedValue: _,
                  guide: d,
                  placeholderChar: C,
                  pipe: m,
                  placeholder: j,
                  currentCaretPosition: w,
                  keepCharPositions: x
                },
                    I = (0, c.default)(T, M, R),
                    J = I.conformedValue,
                    q = ("undefined" == typeof m ? "undefined" : l(m)) === h,
                    F = {};
                q && (F = m(J, u({
                  rawValue: T
                }, R)), F === !1 ? F = {
                  value: _,
                  rejected: !0
                } : (0, v.isString)(F) && (F = {
                  value: F
                }));
                var L = q ? F.value : J,
                    W = (0, f.default)({
                  previousConformedValue: _,
                  previousPlaceholder: V,
                  conformedValue: L,
                  placeholder: j,
                  rawValue: T,
                  currentCaretPosition: w,
                  placeholderChar: C,
                  indexesOfPipedChars: F.indexesOfPipedChars,
                  caretTrapIndexes: S
                }),
                    z = L === j && 0 === W,
                    B = k ? j : g,
                    D = z ? B : L;
                r.previousConformedValue = D, r.previousPlaceholder = j, o.value !== D && (o.value = D, i(o, W));
              }
            }
          }
        };
      }

      function i(e, r) {
        document.activeElement === e && (b ? C(function () {
          return e.setSelectionRange(r, r, m);
        }, 0) : e.setSelectionRange(r, r, m));
      }

      function a(e) {
        if ((0, v.isString)(e)) return e;
        if ((0, v.isNumber)(e)) return String(e);
        if (void 0 === e || null === e) return g;
        throw new Error("The 'value' provided to Text Mask needs to be a string or a number. The value received was:\n\n " + JSON.stringify(e));
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      });

      var u = Object.assign || function (e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = arguments[r];

          for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        }

        return e;
      },
          l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      };

      r.default = o;
      var s = t(2),
          f = n(s),
          d = t(3),
          c = n(d),
          v = t(4),
          p = t(1),
          h = "function",
          g = "",
          m = "none",
          y = "object",
          b = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
          C = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : setTimeout;
    }]);
  });
});
var maskCore = unwrapExports(textMaskCore);
var textMaskCore_1 = textMaskCore.textMaskCore;var textMaskAddons = createCommonjsModule(function (module, exports) {
  !function (e, t) {
    module.exports = t();
  }(commonjsGlobal, function () {
    return function (e) {
      function t(r) {
        if (n[r]) return n[r].exports;
        var o = n[r] = {
          exports: {},
          id: r,
          loaded: !1
        };
        return e[r].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports;
      }

      var n = {};
      return t.m = e, t.c = n, t.p = "", t(0);
    }([function (e, t, n) {

      function r(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      var o = n(1);
      Object.defineProperty(t, "createAutoCorrectedDatePipe", {
        enumerable: !0,
        get: function () {
          return r(o).default;
        }
      });
      var i = n(2);
      Object.defineProperty(t, "createNumberMask", {
        enumerable: !0,
        get: function () {
          return r(i).default;
        }
      });
      var u = n(3);
      Object.defineProperty(t, "emailMask", {
        enumerable: !0,
        get: function () {
          return r(u).default;
        }
      });
    }, function (e, t) {

      function n() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "mm dd yyyy";
        return function (t) {
          var n = [],
              r = e.split(/[^dmy]+/),
              o = {
            dd: 31,
            mm: 12,
            yy: 99,
            yyyy: 9999
          },
              i = {
            dd: 1,
            mm: 1,
            yy: 0,
            yyyy: 1
          },
              u = t.split("");
          r.forEach(function (t) {
            var r = e.indexOf(t),
                i = parseInt(o[t].toString().substr(0, 1), 10);
            parseInt(u[r], 10) > i && (u[r + 1] = u[r], u[r] = 0, n.push(r));
          });
          var c = r.some(function (n) {
            var r = e.indexOf(n),
                u = n.length,
                c = t.substr(r, u).replace(/\D/g, ""),
                l = parseInt(c, 10);
            return l > o[n] || c.length === u && l < i[n];
          });
          return !c && {
            value: u.join(""),
            indexesOfPipedChars: n
          };
        };
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.default = n;
    }, function (e, t) {

      function n() {
        function e() {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
              t = e.length;
          if (e === c || e[0] === h[0] && 1 === t) return h.split(c).concat([v]).concat(m.split(c));
          if (e === S && M) return h.split(c).concat(["0", S, v]).concat(m.split(c));
          var n = e.lastIndexOf(S),
              u = n !== -1,
              l = e[0] === s && I,
              a = void 0,
              g = void 0,
              b = void 0;

          if (e.slice(V * -1) === m && (e = e.slice(0, V * -1)), u && (M || D) ? (a = e.slice(e.slice(0, $) === h ? $ : 0, n), g = e.slice(n + 1, t), g = r(g.replace(f, c))) : a = e.slice(0, $) === h ? e.slice($) : e, N && ("undefined" == typeof N ? "undefined" : i(N)) === p) {
            var O = "." === _ ? "[.]" : "" + _,
                j = (a.match(new RegExp(O, "g")) || []).length;
            a = a.slice(0, N + j * q);
          }

          return a = a.replace(f, c), A || (a = a.replace(/^0+(0$|[^0])/, "$1")), a = x ? o(a, _) : a, b = r(a), (u && M || D === !0) && (e[n - 1] !== S && b.push(y), b.push(S, y), g && (("undefined" == typeof C ? "undefined" : i(C)) === p && (g = g.slice(0, C)), b = b.concat(g)), D === !0 && e[n - 1] === S && b.push(v)), $ > 0 && (b = h.split(c).concat(b)), l && (b.length === $ && b.push(v), b = [d].concat(b)), m.length > 0 && (b = b.concat(m.split(c))), b;
        }

        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            n = t.prefix,
            h = void 0 === n ? u : n,
            g = t.suffix,
            m = void 0 === g ? c : g,
            b = t.includeThousandsSeparator,
            x = void 0 === b || b,
            O = t.thousandsSeparatorSymbol,
            _ = void 0 === O ? l : O,
            j = t.allowDecimal,
            M = void 0 !== j && j,
            P = t.decimalSymbol,
            S = void 0 === P ? a : P,
            w = t.decimalLimit,
            C = void 0 === w ? 2 : w,
            k = t.requireDecimal,
            D = void 0 !== k && k,
            E = t.allowNegative,
            I = void 0 !== E && E,
            R = t.allowLeadingZeroes,
            A = void 0 !== R && R,
            L = t.integerLimit,
            N = void 0 === L ? null : L,
            $ = h && h.length || 0,
            V = m && m.length || 0,
            q = _ && _.length || 0;

        return e.instanceOf = "createNumberMask", e;
      }

      function r(e) {
        return e.split(c).map(function (e) {
          return v.test(e) ? v : e;
        });
      }

      function o(e, t) {
        return e.replace(/\B(?=(\d{3})+(?!\d))/g, t);
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      };
      t.default = n;
      var u = "$",
          c = "",
          l = ",",
          a = ".",
          s = "-",
          d = /-/,
          f = /\D+/g,
          p = "number",
          v = /\d/,
          y = "[]";
    }, function (e, t, n) {

      function r(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function o(e, t) {
        e = e.replace(O, v);
        var n = t.placeholderChar,
            r = t.currentCaretPosition,
            o = e.indexOf(y),
            s = e.lastIndexOf(p),
            d = s < o ? -1 : s,
            f = i(e, o + 1, y),
            h = i(e, d - 1, p),
            g = u(e, o, n),
            m = c(e, o, d, n),
            b = l(e, d, n, r);
        g = a(g), m = a(m), b = a(b, !0);
        var x = g.concat(f).concat(m).concat(h).concat(b);
        return x;
      }

      function i(e, t, n) {
        var r = [];
        return e[t] === n ? r.push(n) : r.push(h, n), r.push(h), r;
      }

      function u(e, t) {
        return t === -1 ? e : e.slice(0, t);
      }

      function c(e, t, n, r) {
        var o = v;
        return t !== -1 && (o = n === -1 ? e.slice(t + 1, e.length) : e.slice(t + 1, n)), o = o.replace(new RegExp("[\\s" + r + "]", m), v), o === y ? f : o.length < 1 ? g : o[o.length - 1] === p ? o.slice(0, o.length - 1) : o;
      }

      function l(e, t, n, r) {
        var o = v;
        return t !== -1 && (o = e.slice(t + 1, e.length)), o = o.replace(new RegExp("[\\s" + n + ".]", m), v), 0 === o.length ? e[t - 1] === p && r !== e.length ? f : v : o;
      }

      function a(e, t) {
        return e.split(v).map(function (e) {
          return e === g ? e : t ? x : b;
        });
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      var s = n(4),
          d = r(s),
          f = "*",
          p = ".",
          v = "",
          y = "@",
          h = "[]",
          g = " ",
          m = "g",
          b = /[^\s]/,
          x = /[^.\s]/,
          O = /\s/g;
      t.default = {
        mask: o,
        pipe: d.default
      };
    }, function (e, t) {

      function n(e, t) {
        var n = t.currentCaretPosition,
            i = t.rawValue,
            f = t.previousConformedValue,
            p = t.placeholderChar,
            v = e;
        v = r(v);
        var y = v.indexOf(c),
            h = null === i.match(new RegExp("[^@\\s." + p + "]"));
        if (h) return u;
        if (v.indexOf(a) !== -1 || y !== -1 && n !== y + 1 || i.indexOf(o) === -1 && f !== u && i.indexOf(l) !== -1) return !1;
        var g = v.indexOf(o),
            m = v.slice(g + 1, v.length);
        return (m.match(d) || s).length > 1 && v.substr(-1) === l && n !== i.length && (v = v.slice(0, v.length - 1)), v;
      }

      function r(e) {
        var t = 0;
        return e.replace(i, function () {
          return t++, 1 === t ? o : u;
        });
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.default = n;
      var o = "@",
          i = /@/g,
          u = "",
          c = "@.",
          l = ".",
          a = "..",
          s = [],
          d = /\./g;
    }]);
  });
});
var maskAddons = unwrapExports(textMaskAddons);
var textMaskAddons_1 = textMaskAddons.textMaskAddons;var Mask, defaultPatternChars;
defaultPatternChars = {
  '1': REGEX.numeric,
  '#': REGEX.widenumeric,
  'a': REGEX.letter,
  '*': REGEX.any
};
Mask = class Mask {
  constructor(field, config) {
    this.field = field;
    this.config = config;
    this.value = '';
    this.prevValue = '';
    this.cursor = 0;
    this.prevCursor = 0;
    this.pattern = this.patternRaw = this.config.pattern;
    this.patternSetter = this.config.setter;
    this.placeholderChar = this.config.placeholder;
    this.placeholderRegex = new RegExp('\\' + (this.placeholderChar || '_'), 'g');
    this.guide = this.config.guide;
    this.keepCharPositions = this.config.keepCharPositions;
    this.chars = primaryBuilder$1.clone(defaultPatternChars, this.config.customPatterns);
    this.setPattern(this.pattern);
  }

  getState(pattern, rawValue) {
    return {
      rawValue,
      guide: this.guide,
      placeholderChar: this.placeholderChar,
      keepCharPositions: this.keepCharPositions,
      currentCaretPosition: this.field.el ? this.field.selection().end : this.cursor,
      previousConformedValue: this.prevValue,
      placeholder: this.getPlaceholder(pattern)
    };
  }

  getPlaceholder(pattern) {
    var char, j, len, placeholder;
    if (IS$1$1.function(pattern)) ;else {
      placeholder = '';

      for (j = 0, len = pattern.length; j < len; j++) {
        char = pattern[j];

        if (IS$1$1.regex(char)) {
          placeholder += this.placeholderChar;
        } else {
          placeholder += char;
        }
      }

      return placeholder;
    }
  }

  resolvePattern(pattern, input, state) {
    var char, copy, i, j, len, offset, trapIndexes;
    pattern = typeof pattern === 'function' ? pattern(input, this.getState(pattern, input)) : pattern;
    offset = 0;
    trapIndexes = [];
    copy = pattern.slice();

    for (i = j = 0, len = copy.length; j < len; i = ++j) {
      char = copy[i];

      if (!(char === '[]')) {
        continue;
      }

      trapIndexes.push(i - offset);
      pattern.splice(i - offset, 1);
      offset++;
    }

    this.prevPattern = this.resolvedPattern;
    this.resolvedPattern = pattern;
    return {
      pattern,
      caretTrapIndexes: trapIndexes
    };
  }

  setPattern(string, updateValue = true, updateField) {
    this.patternRaw = string;
    this.pattern = this.parsePattern(string);
    this.transform = this.parseTransform(string);

    if (updateValue) {
      this.value = this.setValue(this.value);

      if (updateField) {
        return this.field.value = this.value;
      }
    }
  }

  parsePattern(string) {
    var char, escaped, i, j, len, pattern;

    switch (false) {
      case string !== 'EMAIL':
        return maskAddons.emailMask.mask;

      case string !== 'PHONE':
        this.patternSetter = function (value) {
          return repeat('#', Math.max(7, value.length));
        };

        this.guide = false;
        return '#';

      case string !== 'NAME':
        this.patternSetter = function (value) {
          value = value.replace(this.placeholderRegex, '').trim();
          return repeat('a', Math.max(2, value.length));
        };

        return 'a';

      case string !== 'FULLNAME':
        this.patternSetter = function (value) {
          var split;

          if (value[value.length - 1] === ' ') {
            value += 'x';
          }

          split = value.replace(this.placeholderRegex, '').trim().split(/\s+/);

          if (split.length === 4) {
            return;
          }

          return split.map(function (part) {
            return repeat('a', Math.max(2, part.length));
          }).join(' ');
        };

        return 'a';

      case string !== 'DATE':
        return [/\d/, /\d/, '/', /\d/, /\d/, '/', /\d/, /\d/, /\d/, /\d/];

      case !(string[0] === 'DATE' && IS$1$1.string(string[1])):
        return string[1].split('').map(char => {
          if (REGEX.letter.test(char)) {
            return /\d/;
          } else {
            return char;
          }
        });

      case string !== 'NUMBER':
        return maskAddons.createNumberMask({
          prefix: this.config.prefix || '',
          suffix: this.config.suffix || '',
          includeThousandsSeparator: this.config.sep ? true : false,
          thousandsSeparatorSymbol: IS$1$1.string(this.config.sep) ? this.config.sep : void 0,
          allowDecimal: this.config.decimal,
          decimalLimit: IS$1$1.number(this.config.decimal) ? this.config.decimal : void 0,
          integerLimit: IS$1$1.number(this.config.limit) ? this.config.limit : void 0
        });

      case !IS$1$1.array(string):
        return string;

      default:
        pattern = [];

        for (i = j = 0, len = string.length; j < len; i = ++j) {
          char = string[i];

          if (char === '\\') {
            escaped = true;
            continue;
          }

          pattern.push(escaped ? char : this.chars[char] || char);
          escaped = false;
        }

        return pattern;
    }
  }

  parseTransform(string) {
    switch (false) {
      case string !== 'EMAIL':
        return maskAddons.emailMask.pipe;

      case string !== 'DATE':
        return maskAddons.createAutoCorrectedDatePipe('mm/dd/yyyy');

      case !(string[0] === 'DATE' && IS$1$1.string(string[1])):
        return maskAddons.createAutoCorrectedDatePipe(string[1]);

      case !this.config.transform:
        return this.config.transform;
    }
  }

  setValue(input) {
    var caretTrapIndexes, conformedValue, indexesOfPipedChars, newPattern, pattern, state, transformed;

    if (this.patternSetter) {
      newPattern = this.patternSetter(input) || this.pattern;

      if (newPattern !== this.patternRaw && newPattern !== this.pattern) {
        this.setPattern(newPattern, false);
      }
    }

    ({
      caretTrapIndexes,
      pattern
    } = this.resolvePattern(this.pattern, input));

    if (pattern === false) {
      return this.value;
    }

    this.prevValue = this.value;
    this.prevCursor = this.cursor;
    state = this.getState(pattern, input);
    ({
      conformedValue
    } = maskCore.conformToMask(input, pattern, state));

    if (this.transform) {
      transformed = this.transform(conformedValue, state);
    }

    if (transformed === false) {
      return this.value;
    }

    if (IS$1$1.string(transformed)) {
      conformedValue = transformed;
    } else if (IS$1$1.object(transformed)) {
      indexesOfPipedChars = transformed.indexesOfPipedChars;
      conformedValue = transformed.value;
    }

    this.cursor = maskCore.adjustCaretPosition(primaryBuilder$1(state, {
      indexesOfPipedChars,
      caretTrapIndexes,
      conformedValue
    }));
    return this.value = conformedValue;
  }

  validate(input) {
    var char, i, j, len, pattern;

    if (input !== this.value && this.patternSetter) {
      pattern = this.patternSetter(input) || this.pattern;
    } else {
      pattern = this.resolvedPattern;

      if (!pattern) {
        ({
          pattern
        } = this.resolvePattern(this.pattern, input));
      }
    }

    if (pattern === false) {
      return true;
    }

    for (i = j = 0, len = pattern.length; j < len; i = ++j) {
      char = pattern[i];

      switch (false) {
        case !!input[i]:
          return false;

        case !(IS$1$1.regex(char) && !char.test(input[i])):
          return false;

        case !(IS$1$1.string(char) && input[i] !== char):
          return false;
      }
    }

    return true;
  }

  isEmpty() {
    var char, i, input, j, len, pattern;
    input = this.value;
    pattern = this.resolvedPattern;

    if (!pattern) {
      if (this.patternSetter) {
        pattern = this.patternSetter(input);
      }

      ({
        pattern
      } = this.resolvePattern(pattern || this.pattern, input));
    }

    if (input === this.config.prefix || input === this.config.suffix) {
      return true;
    }

    for (i = j = 0, len = pattern.length; j < len; i = ++j) {
      char = pattern[i];

      switch (false) {
        case !!input[i]:
          return true;

        case !IS$1$1.regex(char):
          return !char.test(input[i]);
      }
    }

    return false;
  }

};
var Mask$1 = Mask;var COLORS$1 = {
  red: '#cc4820',
  green: '#72c322',
  orange: '#ff9c00',
  black: '#181818',
  grey_dark: '#5e5e5e',
  grey: '#909090',
  grey_semi_light: '#bebebe',
  grey_light: '#d3d3d3',
  grey_light2: '#dddddd',
  grey_light3: '#f2f5f7',
  grey_light4: '#e5e5e5'
};var textFieldTemplate = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    verticalAlign: 'top',
    display: 'none',
    boxSizing: 'border-box',
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    textAlign: 'left',
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    }
  }
}, ['div', {
  ref: 'label',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 1,
    top: function (field) {
      return this.styleParsed('fontSize', true) * 0.7;
    },
    left: function (field) {
      var ref;
      return shorthandSideValue(field.settings.padding, 'left') + (((ref = field.el.child.icon) != null ? ref.width : void 0) || 0);
    },
    padding: function (field) {
      return `0 ${field.settings.inputPadding}px`;
    },
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.labelSize || field.settings.fontSize * (11 / 14);
    },
    fontWeight: 600,
    lineHeight: 1,
    color: COLORS$1.grey,
    opacity: 0,
    transition: 'opacity 0.2s, color 0.2s',
    whiteSpace: 'nowrap',
    userSelect: 'none',
    cursor: 'default',
    pointerEvents: 'none',
    $filled: {
      $showLabel: {
        opacity: 1
      }
    },
    $focus: {
      color: COLORS$1.orange
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'innerwrap',
  style: {
    position: 'relative',
    height: function (field) {
      return field.settings.height;
    },
    backgroundColor: 'white',
    borderWidth: function (field) {
      return field.settings.border;
    },
    borderStyle: 'solid',
    borderColor: COLORS$1.grey_light,
    borderRadius: '2px',
    boxSizing: 'border-box',
    fontFamily: 'inherit',
    transition: 'border-color 0.2s',
    $focus: {
      borderColor: COLORS$1.orange
    },
    $showError: {
      borderColor: COLORS$1.red
    },
    $disabled: {
      borderColor: COLORS$1.grey_light,
      backgroundColor: COLORS$1.grey_light
    }
  }
}, ['input', {
  ref: 'input',
  type: 'text',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    zIndex: 3,
    display: 'inline-block',
    verticalAlign: 'top',
    height: function () {
      return this.parent.styleSafe('height', 1) || this.parent.styleSafe('height');
    },
    width: function (field) {
      var iconSibling, inputSibling, padding, paddingLeft, paddingRight, subtract, width;

      if (!field.settings.autoWidth) {
        subtract = 0;

        if (iconSibling = field.el.child.icon) {
          subtract += iconSibling.width;
        }

        if (inputSibling = field.el.child[field.settings.inputSibling]) {
          width = inputSibling.styleParsed('width', 1) || 0;
          padding = inputSibling.styleParsed('padding', 1) || 0;
          paddingLeft = inputSibling.styleParsed('paddingLeft', 1) || padding || 0;
          paddingRight = inputSibling.styleParsed('paddingRight', 1) || padding || 0;
          subtract += width + paddingLeft + paddingRight;
        }

        return `calc(100% - ${subtract}px)`;
      }
    },
    padding: function (field) {
      if (this.padding == null) {
        this.padding = Math.max(0, calcPadding(field.settings.height, 14) - 3);
      }

      return `${this.padding}px ${field.settings.inputPadding}px`;
    },
    margin: '0',
    backgroundColor: 'transparent',
    appearance: 'none',
    border: 'none',
    outline: 'none',
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.fontSize;
    },
    color: COLORS$1.black,
    boxSizing: 'border-box',
    boxShadow: 'none',
    whiteSpace: 'nowrap',
    backgroundClip: 'content-box',
    // semi-fix for yellow autofill background
    transform: 'translateY(0)',
    transition: 'transform 0.2s, -webkit-transform 0.2s',
    $disabled: {
      cursor: 'not-allowed'
    },
    $filled: {
      $showLabel: {
        transform: function (field) {
          var label, totalHeight, translation, workableHeight;

          if (this.translation != null || !(label = field.el.child.label) || label.styleSafe('position', 1) !== 'absolute') {
            return this.translation;
          }

          totalHeight = this.parent.styleParsed('height', 1);
          workableHeight = totalHeight - (label.styleParsed('fontSize', 1) + label.styleParsed('top', 1) * 2);
          translation = Math.max(0, Math.floor((totalHeight - workableHeight) / 4));
          return `translateY(${translation}px)`;
        }
      }
    }
  }
}], ['div', {
  ref: 'placeholder',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '0px',
    left: function (field) {
      var ref;
      return ((ref = field.el.child.icon) != null ? ref.width : void 0) || 0;
    },
    fontFamily: function (field) {
      return field.el.child.input.styleSafe('fontFamily', 1);
    },
    fontSize: function (field) {
      return field.el.child.input.styleSafe('fontSize', 1);
    },
    padding: function (field) {
      var horiz, verti;
      verti = field.el.child.input.styleParsed('paddingTop', 1) || field.el.child.input.styleParsed('paddingTop');
      horiz = field.el.child.input.styleParsed('paddingLeft', 1) || field.el.child.input.styleParsed('paddingLeft');
      return `${verti + 3}px ${horiz}px`;
    },
    color: COLORS$1.black,
    opacity: 0.5,
    pointerEvents: 'none',
    userSelect: 'none',
    whiteSpace: 'nowrap',
    transform: 'translateY(0)',
    transition: 'transform 0.2s, -webkit-transform 0.2s',
    $filled: {
      visibility: 'hidden',
      $showLabel: {
        transform: function (field) {
          return field.el.child.input.raw.style.transform;
        }
      }
    }
  }
}]], ['div', {
  ref: 'help',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    top: '110%',
    left: function (field) {
      return shorthandSideValue(field.settings.padding, 'left');
    },
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red
    },
    $showHelp: {
      display: 'block'
    }
  }
}]]);
var icon = quickdom.template(['div', {
  ref: 'icon',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    zIndex: 2,
    display: 'inline-block',
    boxSizing: 'border-box',
    width: function (field) {
      return field.settings.iconSize;
    },
    height: function (field) {
      return field.settings.iconSize;
    },
    fontSize: function (field) {
      return field.settings.iconSize;
    },
    paddingLeft: function (field) {
      return field.settings.inputPadding;
    },
    paddingTop: function (field) {
      return this.parent.styleParsed('height', 1) / 2 - field.settings.iconSize / 2;
    },
    lineHeight: '1em',
    userSelect: 'none'
  },
  methods: {
    width: {
      get: function () {
        if (this._inserted) {
          return this.raw.offsetWidth;
        } else {
          return this.styleParsed('width', 1) || this.related.settings.iconSize;
        }
      }
    }
  }
}]); // @styleParsed('width',1) or @raw.offsetWidth or @related.settings.iconSize or 0

var checkmark$1 = quickdom.template(['div', {
  ref: 'checkmark',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    zIndex: 4,
    display: 'none',
    width: 26,
    height: '100%',
    paddingTop: function () {
      return this.parent.styleParsed('height', 1) / 2 - 13;
    },
    paddingRight: function (field) {
      return field.settings.inputPadding;
    },
    verticalAlign: 'top',
    $filled: {
      display: 'inline-block'
    }
  }
}, ['div', {
  ref: 'checkmark_innerwrap',
  style: {
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    borderWidth: '3px',
    borderStyle: 'solid',
    borderColor: COLORS$1.green,
    transform: 'scale(0.8)',
    // transformOrigin: '100% 0'
    $showError: {
      borderColor: COLORS$1.red
    }
  }
}, ['div', {
  ref: 'checkmark_mask1',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    top: '-4px',
    left: '-10px',
    width: '15px',
    height: '30px',
    borderRadius: '30px 0 0 30px',
    backgroundColor: function (field) {
      return defaultColor(field.els.innerwrap.styleSafe('backgroundColor', 1), 'white');
    },
    transform: 'rotate(-45deg)',
    transformOrigin: '15px 15px 0'
  }
}], ['div', {
  ref: 'checkmark_mask2',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    top: '-5px',
    left: '8px',
    width: '15px',
    height: '30px',
    borderRadius: '0 30px 30px 0',
    backgroundColor: function (field) {
      return defaultColor(field.els.innerwrap.styleSafe('backgroundColor', 1), 'white');
    },
    transform: 'rotate(-45deg)',
    transformOrigin: '0 15px 0',
    $filled: {
      animation: '4.25s ease-in checkmarkRotatePlaceholder',
      $invalid: {
        animation: ''
      }
    }
  }
}], ['div', {
  ref: 'checkmark_lineWrapper',
  style: {
    $filled: {
      $invalid: {
        position: 'relative',
        zIndex: 2,
        animation: '0.55s checkmarkAnimateError',
        transformOrigin: '50% 10px'
      }
    }
  }
}, ['div', {
  ref: 'checkmark_lineShort',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '10px',
    left: '3px',
    display: 'block',
    width: '8px',
    height: '3px',
    borderRadius: '2px',
    backgroundColor: COLORS$1.green,
    transform: 'rotate(45deg)',
    $filled: {
      animation: '0.75s checkmarkAnimateSuccessTip'
    },
    $invalid: {
      backgroundColor: COLORS$1.red,
      left: '4px',
      top: '8px',
      width: '12px',
      $filled: {
        animation: ''
      }
    }
  }
}], ['div', {
  ref: 'checkmark_lineLong',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '8px',
    right: '2px',
    display: 'block',
    width: '12px',
    height: '3px',
    borderRadius: '2px',
    backgroundColor: COLORS$1.green,
    transform: 'rotate(-45deg)',
    $filled: {
      animation: '0.75s checkmarkAnimateSuccessLong'
    },
    $invalid: {
      backgroundColor: COLORS$1.red,
      top: '8px',
      left: '4px',
      right: 'auto',
      $filled: {
        animation: ''
      }
    }
  }
}]], ['div', {
  ref: 'checkmark_placeholder',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '-4px',
    left: '-3px',
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    borderWidth: '3px',
    borderStyle: 'solid',
    borderColor: hexToRGBA(COLORS$1.green, 0.4),
    $invalid: {
      borderColor: hexToRGBA(COLORS$1.red, 0.4)
    }
  }
}], ['div', {
  ref: 'checkmark_patch',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 1,
    top: '-2px',
    left: '6px',
    width: '4px',
    height: '28px',
    backgroundColor: function (field) {
      return defaultColor(field.els.innerwrap.styleSafe('backgroundColor', 1), 'white');
    },
    transform: 'rotate(-45deg)'
  }
}]]]);
var templates =
/*#__PURE__*/
Object.freeze({
  default: textFieldTemplate,
  icon: icon,
  checkmark: checkmark$1
});var defaults$1 = {
  placeholder: true,
  validWhenIsChoice: false,
  validWhenRegex: false,
  autoWidth: false,
  maxWidth: '100%',
  minWidth: 2,
  height: 46,
  checkmark: true,
  keyboard: 'text',
  dropdown: {
    lockScroll: false
  },
  choices: null,
  minLength: null,
  maxLength: null,
  inputSibling: 'checkmark',
  mask: {
    pattern: false,
    placeholder: '_',
    guide: true,
    customPatterns: false
  }
};var TextField;

TextField = function () {
  class TextField extends Field$1 {
    constructor() {
      super(...arguments);

      if (this._value == null) {
        this._value = '';
      }

      this.state.typing = false;
      this.cursor = {
        prev: 0,
        current: 0
      };

      if (!this.settings.validWhenRegex) {
        if (this.settings.keyboard === 'email' && this.settings.required) {
          this.settings.validWhenRegex = REGEX.email;
        } else if (this.settings.mask === 'NAME' || this.settings.mask.pattern === 'NAME') {
          this.settings.validWhenRegex = /^[a-zA-Z]{2}/;
        } else if (this.settings.mask === 'FULLNAME' || this.settings.mask.pattern === 'FULLNAME') {
          this.settings.validWhenRegex = /^[a-zA-Z]+\s+[a-zA-Z]+/;
        }
      }

      if (!this.settings.mask.pattern) {
        if (IS$1$1.string(this.settings.mask)) {
          this.settings.mask = primaryBuilder$1.deep.clone(this.defaults.mask, {
            pattern: this.settings.mask
          });
        } else if (IS$1$1.object(this.settings.mask)) {
          this.settings.mask.pattern = function () {
            switch (this.settings.keyboard) {
              case 'date':
                return 'DATE';

              case 'number':
                return 'NUMBER';

              case 'phone':
              case 'tel':
                return 'PHONE';

              case 'email':
                return 'EMAIL';
            }
          }.call(this);
        }
      }

      if (this.settings.mask.pattern) {
        this.mask = new Mask$1(this, this.settings.mask);
      }

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      if (this.dropdown && this.selected && this._value === this.selected.label) {
        return this.selected.value;
      } else {
        return this._value;
      }
    }

    _setValue(newValue) {
      if (IS$1$1.string(newValue) || IS$1$1.number(newValue)) {
        newValue = String(newValue);
        return this._value = this.mask ? this.mask.setValue(newValue) : newValue;
      }
    }

    _recalcDisplay() {
      if (this.settings.autoWidth) {
        return this._value = this._value;
      }
    }

    _createElements() {
      var globalOpts;
      globalOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, globalOpts);

      if (this.settings.choices) {
        this.dropdown = new Dropdown$1(this.settings.choices, this);
        this.dropdown.appendTo(this.el.child.innerwrap);
      }

      if (this.settings.icon) {
        this.templates.icon.spawn(this.settings.templates.icon, globalOpts).append(this.settings.icon).insertBefore(this.el.child.input);
      }

      if (this.settings.checkmark) {
        this.templates.checkmark.spawn(this.settings.templates.checkmark, globalOpts).insertAfter(this.el.child.input);
      }

      this.el.child.input.prop('type', function () {
        switch (this.settings.keyboard) {
          case 'number':
          case 'tel':
          case 'phone':
            return 'tel';

          case 'password':
            return 'password';

          case 'url':
            return 'url';

          default:
            // when 'email' then 'email'
            return 'text';
        }
      }.call(this));
      this.el.state('hasLabel', this.settings.label);
      this.el.child.innerwrap.raw._quickField = this.el.child.input.raw._quickField = this;
      return this.el.childf;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_value();

      this._attachBindings_autocomplete();

      this._attachBindings_stateTriggers();
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('hovered').of(this.state).to(hovered => {
        return this.el.state('hover', hovered);
      });
      simplybind('focused').of(this.state).to(focused => {
        return this.el.state('focus', focused);
      });
      simplybind('filled').of(this.state).to(filled => {
        return this.el.state('filled', filled);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_display() {
      simplybind('placeholder').of(this.state).to('text').of(this.el.child.placeholder).transform(placeholder => {
        switch (false) {
          case !(placeholder === true && this.settings.label):
            return this.settings.label;

          case !IS$1$1.string(placeholder):
            return placeholder;

          default:
            return '';
        }
      });
      simplybind('disabled', {
        updateOnBind: this.state.disabled
      }).of(this.state).to((disabled, prev) => {
        if (this.settings.checkmark) {
          if (disabled || !disabled && prev != null) {
            return setTimeout(() => {
              this.el.child.checkmark_mask1.recalcStyle();
              this.el.child.checkmark_mask2.recalcStyle();
              return this.el.child.checkmark_patch.recalcStyle();
            });
          }
        }
      });
    } // @el.child.checkmark.recalcStyle(true)


    _attachBindings_display_autoWidth() {
      simplybind('width', {
        updateEvenIfSame: true
      }).of(this.state).to(width => {
        return (this.settings.autoWidth ? this.el.child.input : this.el).style('width', width);
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);

      if (this.settings.autoWidth) {
        simplybind('_value', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('width').of(this.state).transform(() => {
          return `${this._getInputAutoWidth()}px`;
        }).updateOn('event:inserted').of(this.el).updateOn('visible').of(this.state);
      }
    }

    _attachBindings_value() {
      var input, resetInput;
      input = this.el.child.input.raw;

      resetInput = () => {
        var filled;
        filled = !this.mask.isEmpty();

        if (!filled) {
          this.selection(this.mask.cursor = 0);
          this._value = '';
          this.state.filled = false;
        }

        return filled;
      };

      simplybind('event:input').of(input).to(() => {
        this.value = input.value;

        if (this.mask) {
          this.selection(this.mask.cursor);
        }

        return this.emit('input', this.value);
      });
      simplybind('_value', {
        updateEvenIfSame: !!this.mask
      }).of(this).to('value').of(input).and.to(value => {
        var filled;
        filled = !!value;

        if (filled && this.mask && this.mask.guide && (!this.state.focused || this.mask.cursor === 0)) {
          filled = resetInput();
        }

        this.state.filled = filled;

        if (filled) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);

        if (!this.state.focused) {
          return this.emit('input', this.value);
        }
      });
      simplybind('event:keydown').of(this.el.child.input).to(event => {
        if (event.keyCode === KEYCODES.enter) {
          this.emit('submit');
        }

        return this.emit(`key-${event.keyCode}`);
      });

      if (this.mask && this.mask.guide) {
        simplybind('event:blur').of(this.el.child.input).to(resetInput);
      }
    }

    _attachBindings_autocomplete() {
      if (this.dropdown) {
        simplybind.defaultOptions.updateOnBind = false;
        simplybind('typing', {
          updateEvenIfSame: true
        }).of(this.state).to(isTyping => {
          if (isTyping) {
            if (!this._value) {
              return;
            }

            if (this.dropdown.isOpen) {
              return this.dropdown.list.calcDisplay();
            } else {
              this.dropdown.isOpen = true;
              return simplybind('event:click').of(document).once.to(() => {
                return this.dropdown.isOpen = false;
              }).condition(event => {
                return !quickdom(event.target).parentMatching(parent => {
                  return parent === this.el.child.innerwrap;
                });
              });
            }
          } else {
            return this.dropdown.isOpen = false;
          }
        });
        simplybind('_value').of(this).to(value => {
          var choice, i, len, ref, shouldBeVisible;
          ref = this.dropdown.choices;

          for (i = 0, len = ref.length; i < len; i++) {
            choice = ref[i];
            shouldBeVisible = !value ? true : fuzzyMatch(value, choice.label);

            if (choice.visible !== shouldBeVisible) {
              choice.visible = shouldBeVisible;
            }
          }

          if (this.dropdown.isOpen && !value) {
            this.dropdown.isOpen = false;
          }
        });
        this.dropdown.onSelected(selectedChoice => {
          this.selected = selectedChoice;
          this.value = selectedChoice.label;
          this.dropdown.isOpen = false;
          return this.selection(this.el.child.input.raw.value.length);
        });
        simplybind.defaultOptions.updateOnBind = true;
      }
    }

    _attachBindings_stateTriggers() {
      simplybind('event:mouseenter').of(this.el.child.input).to(() => {
        return this.state.hovered = true;
      });
      simplybind('event:mouseleave').of(this.el.child.input).to(() => {
        return this.state.hovered = false;
      });
      simplybind('event:focus').of(this.el.child.input).to(() => {
        this.state.focused = true;

        if (this.state.disabled) {
          return this.blur();
        }
      });
      simplybind('event:blur').of(this.el.child.input).to(() => {
        return this.state.typing = this.state.focused = false;
      });
      simplybind('event:input').of(this.el.child.input).to(() => {
        return this.state.typing = true;
      });
      simplybind('event:keydown').of(this.el.child.input).to(() => {
        return this.cursor.prev = this.selection().end;
      });
    }

    _scheduleCursorReset() {
      var currentCursor, diffIndex, newCursor;
      diffIndex = getIndexOfFirstDiff(this.mask.value, this.mask.prev.value);
      currentCursor = this.cursor.current;
      newCursor = this.mask.normalizeCursorPos(currentCursor, this.cursor.prev);

      if (newCursor !== currentCursor) {
        this.selection(newCursor);
      }
    }

    _setValueIfNotSet() {
      if (this.el.child.input.raw.value !== this._value) {
        this.el.child.input.raw.value = this._value;
      }
    }

    _getInputAutoWidth() {
      var inputWidth, labelWidth;

      if (this._value) {
        this._setValueIfNotSet();

        this.el.child.input.style('width', 0);
        this.el.child.input.raw.scrollLeft = 1e+10;
        inputWidth = Math.max(this.el.child.input.raw.scrollLeft + this.el.child.input.raw.offsetWidth, this.el.child.input.raw.scrollWidth) + 2;
        labelWidth = this.settings.label && this.el.child.label.styleSafe('position') === 'absolute' ? this.el.child.label.rect.width : 0;
      } else {
        inputWidth = this.el.child.placeholder.rect.width;
        labelWidth = 0;
      }

      return Math.min(this._getWidthSetting('max'), Math.max(this._getWidthSetting('min'), inputWidth, labelWidth));
    }

    _getWidthSetting(target) {
      var parent, parentWidth, result;

      if (target === 'min' || target === 'max') {
        target += 'Width';
      }

      if (typeof this.settings[target] === 'number') {
        result = this.settings[target];
      } else if (typeof this.settings[target] === 'string') {
        result = parseFloat(this.settings[target]);

        if (includes$2(this.settings[target], '%')) {
          if ((parent = this.el.parent) && parent.style('display') === 'block') {
            parentWidth = parent.styleParsed('width') - parent.styleParsed('paddingLeft') - parent.styleParsed('paddingRight') - 2;
            result = parentWidth * (result / 100);
          } else {
            result = 0;
          }
        }
      }

      return result || (target === 'minWidth' ? 0 : 2e308);
    }

    _validate(providedValue) {
      var matchingChoice, ref;

      if (this.settings.validWhenRegex && IS$1$1.regex(this.settings.validWhenRegex)) {
        if (!this.settings.validWhenRegex.test(providedValue)) {
          return false;
        }
      }

      if (this.settings.validWhenIsChoice && ((ref = this.settings.choices) != null ? ref.length : void 0)) {
        matchingChoice = this.settings.choices.filter(function (choice) {
          return choice.value === providedValue;
        });

        if (!matchingChoice.length) {
          return false;
        }
      }

      if (this.settings.minLength) {
        if (providedValue.length < this.settings.minLength) {
          return false;
        }
      }

      if (this.settings.maxLength) {
        if (providedValue.length >= this.settings.maxLength) {
          return false;
        }
      }

      if (this.mask) {
        if (!this.mask.validate(providedValue)) {
          return false;
        }
      }

      return true;
    }

    selection(arg) {
      var end, start;

      if (IS$1$1.object(arg)) {
        start = arg.start;
        end = arg.end;
      } else {
        start = arg;
        end = arguments[1];
      }

      if (start != null) {
        if (!end || end < start) {
          end = start;
        }

        this.el.child.input.raw.setSelectionRange(start, end);
      } else {
        return {
          'start': this.el.child.input.raw.selectionStart,
          'end': this.el.child.input.raw.selectionEnd
        };
      }
    }

    focus() {
      return this.el.child.input.raw.focus();
    }

    blur() {
      return this.el.child.input.raw.blur();
    }

  }

  TextField.prototype.template = textFieldTemplate;
  TextField.prototype.templates = templates;
  TextField.prototype.defaults = defaults$1;
  return TextField;
}.call(undefined);

var TextField$1 = TextField;var version$3 = "1.0.97";
var createBuilder, quickfield$1;

createBuilder = function (settingOverrides, templateOverrides) {
  var builder;

  builder = function (settings) {
    if (arguments.length > 1) {
      settings = primaryBuilder$1.clone(...arguments);
    }

    if (!IS$1$1.object(settings)) {
      settings = {};
    }

    if (settings.type == null) {
      settings.type = 'text';
    }

    if (!Field$1[settings.type]) {
      throw new Error(`QuickField: '${settings.type}' is not a valid/registered field type`);
    }

    registerAnimations();
    return new Field$1[settings.type](settings, builder, settingOverrides, templateOverrides);
  };

  builder.register = function (type, targetField) {
    var i, len, requiredMethod;

    if (!IS$1$1.string(type) || !IS$1$1.function(targetField)) {
      throw new Error("QuickField Registration: invalid arguments");
    }

    for (i = 0, len = REQUIRED_FIELD_METHODS.length; i < len; i++) {
      requiredMethod = REQUIRED_FIELD_METHODS[i];

      if (!targetField.prototype[requiredMethod]) {
        throw new Error(`QuickField Registration: '${requiredMethod}' method is required in order to register the field`);
      }
    }

    Field$1[type] = targetField;
    return this;
  };

  builder.config = function (newSettings, newTemplates) {
    var config, globalConfig, name$$1, originalTemplates, outputSettings, outputTemplates, ref, templates, type;

    if (!IS$1$1.object(newSettings)) {
      throw new Error(`QuickField Config: invalid config object provided ${String(newSettings)}`);
    }

    outputSettings = Object.create(null);

    for (type in newSettings) {
      config = newSettings[type];

      if (type === 'global') {
        outputSettings.globalDefaults = primaryBuilder$1.deep.notDeep(Field$1.shallowSettings).clone(Field$1.prototype.globalDefaults, config);
      } else if (Field$1[type]) {
        outputSettings[type] = primaryBuilder$1.clone.deep.notDeep(Field$1.shallowSettings)(Field$1[type].prototype.defaults, config);
      }
    }

    if (IS$1$1.object(newTemplates)) {
      outputTemplates = Object.create(null);
      globalConfig = newTemplates.global;

      if (globalConfig && globalConfig.field && !globalConfig.default) {
        globalConfig.default = globalConfig.field;
      }

      for (type in Field$1) {
        originalTemplates = (ref = Field$1[type].prototype) != null ? ref.templates : void 0;
        templates = newTemplates[type] || globalConfig;

        if (!originalTemplates) {
          continue;
        }

        if (!templates) {
          outputTemplates[type] = originalTemplates;
          continue;
        }

        if (templates.field && !templates.default) {
          templates.default = templates.field;
        }

        outputTemplates[type] = Object.create(null);

        for (name$$1 in templates) {
          config = templates[name$$1];

          if (name$$1 === 'field' || !originalTemplates[name$$1]) {
            continue;
          }

          if (globalConfig && globalConfig[name$$1]) {
            config = primaryBuilder$1.clone.deep.concat(globalConfig[name$$1], config);
          }

          outputTemplates[type][name$$1] = originalTemplates[name$$1].extend(config);
        }

        for (name$$1 in originalTemplates) {
          config = originalTemplates[name$$1];

          if (!outputTemplates[type][name$$1]) {
            outputTemplates[type][name$$1] = config;
          }
        }
      }
    }

    return createBuilder(outputSettings, outputTemplates);
  };

  Object.defineProperty(builder, 'fields', {
    get: function () {
      return primaryBuilder$1.clone.own.notKeys('instances')(Field$1);
    }
  });
  builder.settingOverrides = settingOverrides;
  builder.templateOverrides = templateOverrides;
  builder.version = version$3;
  builder.Field = Field$1;
  return builder;
}; // import NumberField from './fields/number'
// import SelectField from './fields/select'
// import ChoiceField from './fields/choice'
// import TruefalseField from './fields/truefalse'
// import ToggleField from './fields/toggle'
// import GroupField from './fields/group'
// import RepeaterField from './fields/repeater'
// import FileField from './fields/file'
// import CheckboxField from './fields/checkbox'


quickfield$1 = createBuilder();
quickfield$1.register('text', TextField$1); // quickfield.register 'textarea', TextareaField
// quickfield.register 'number', NumberField
// quickfield.register 'select', SelectField
// quickfield.register 'choice', ChoiceField
// quickfield.register 'truefalse', TruefalseField
// quickfield.register 'toggle', ToggleField
// quickfield.register 'group', GroupField
// quickfield.register 'repeater', RepeaterField
// quickfield.register 'checkbox', FileField
// quickfield.register 'file', CheckboxField

var quickfield$1$1 = quickfield$1;var defaults$2 = {
  placeholder: true,
  validWhenRegex: false,
  autoWidth: false,
  autoHeight: true,
  minHeight: 46,
  maxWidth: '100%',
  maxHeight: 2e308,
  minWidth: 2,
  minLength: null,
  maxLength: null,
  counter: false
}; // dropdown: {storeSelected:false, lockScroll:false}
var template$2 = textFieldTemplate.extend({
  children: {
    'innerwrap': {
      options: {
        style: {
          overflow: 'hidden',
          height: function (field) {
            return field.settings.minHeight || 46;
          },
          width: function (field) {
            if (!field.settings.autoWidth) {
              return '100%';
            }
          }
        }
      }
    },
    'label': {
      options: {
        style: {
          left: function (field) {
            return shorthandSideValue(field.settings.padding, 'left');
          },
          top: '7.6px'
        }
      }
    },
    'input': {
      type: 'textarea',
      options: {
        type: null,
        styleAfterInsert: true,
        style: {
          resize: 'none',
          whiteSpace: 'normal',
          width: '100%',
          height: function () {
            return `calc(100% - ${this.styleSafe('marginTop', true)} - ${this.styleSafe('marginBottom', true)})`;
          },
          margin: '0',
          marginTop: '15px',
          marginBottom: '12px',
          padding: '0 12px'
        }
      }
    },
    'placeholder': {
      options: {
        styleAfterInsert: true,
        style: {
          left: 0,
          padding: function (field) {
            var horiz, verti;
            horiz = field.el.child.input.styleSafe('paddingLeft', true) || field.el.child.input.styleSafe('paddingLeft');
            verti = field.el.child.input.styleSafe('marginTop', true) || field.el.child.input.styleSafe('marginTop');
            return `${verti} ${horiz}`;
          }
        }
      }
    }
  }
});
var counter = quickdom.template(['div', {
  ref: 'counter',
  style: {
    position: 'absolute',
    bottom: -10,
    right: 0,
    fontSize: 10,
    fontWeight: 500
  }
}]);
var templates$1 =
/*#__PURE__*/
Object.freeze({
  default: template$2,
  counter: counter
});var TextareaField;

TextareaField = function () {
  class TextareaField extends Field$1 {
    constructor() {
      super(...arguments);

      if (this._value == null) {
        this._value = '';
      }

      this.state.height = this.settings.autoHeight ? 'auto' : this.settings.height;
      this.state.typing = false;
      this.cursor = {
        prev: 0,
        current: 0
      };

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      return this._value;
    }

    _setValue(newValue) {
      if (IS$1$1.string(newValue) || IS$1$1.number(newValue)) {
        return this._value = String(newValue);
      }
    }

    _recalcDisplay() {
      if (this.settings.autoHeight || this.settings.autoWidth) {
        return this._value = this._value;
      }
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.defaults, forceOpts);
      this.el.state('hasLabel', this.settings.label);
      this.el.child.innerwrap.raw._quickField = this.el.child.input.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_display_autoHeight();

      this._attachBindings_value();

      this._attachBindings_autocomplete();

      this._attachBindings_stateTriggers();
    }

    _attachBindings_display_autoHeight() {
      simplybind('height', {
        updateEvenIfSame: true
      }).of(this.state).transformSelf(function (value) {
        if (isNaN(value) && isNaN(parseFloat(value))) {
          return 'auto';
        } else {
          return value;
        }
      }).to(height => {
        return this.el.child.innerwrap.style('height', height);
      }).updateOn('event:inserted').of(this);

      if (this.settings.autoHeight) {
        simplybind('_value', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('height').of(this.state).transform(() => {
          return this._getInputAutoHeight();
        }).updateOn('event:inserted').of(this);
      }
    }

    _attachBindings_display_autoWidth() {
      simplybind('width', {
        updateEvenIfSame: true
      }).of(this.state).to(width => {
        return (this.settings.autoWidth ? this.el.child.innerwrap : this.el).style('width', width);
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);

      if (this.settings.autoWidth) {
        simplybind('_value', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('width').of(this.state).transform(() => {
          return this._getInputAutoWidth();
        }).updateOn('event:inserted').of(this);
      }
    }

    _attachBindings_value() {
      var input;
      input = this.el.child.input.raw;
      simplybind('event:input').of(input).to(() => {
        return this.value = input.value;
      });
      simplybind('_value').of(this).to('value').of(input).and.to(value => {
        this.state.filled = !!value;

        if (value) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);
        return this.emit('input', value);
      });
    }

    _attachBindings_autocomplete() {}

    _getInputAutoHeight() {
      var inputHeight, prevHeight;
      prevHeight = this.el.child.input.raw.style.height;

      if (this._value) {
        this._setValueIfNotSet();

        this.el.child.input.style('height', 0);
        inputHeight = this.el.child.input.raw.scrollHeight + 2;
        inputHeight += this.el.child.input.styleParsed('marginTop') + this.el.child.input.styleParsed('marginBottom');
      } else {
        inputHeight = this.el.child.placeholder.height;
      }

      this.el.child.input.style('height', prevHeight);
      return Math.min(this.settings.maxHeight, Math.max(inputHeight, this.settings.minHeight));
    }

    _getInputAutoWidth() {
      var inputPadding, inputWidth, labelWidth;

      if (this._value) {
        this._setValueIfNotSet();

        this.el.child.input.style({
          width: 0,
          whiteSpace: 'nowrap'
        }).raw.scrollLeft = 1e+10;
        inputPadding = this.el.child.input.styleParsed('paddingLeft') || this.el.child.input.styleParsed('padding');
        inputWidth = Math.max(this.el.child.input.raw.scrollLeft + this.el.child.input.raw.offsetWidth, this.el.child.input.raw.scrollWidth) + 2 + inputPadding + 1;
        labelWidth = this.settings.label && this.el.child.label.styleSafe('position') === 'absolute' ? this.el.child.label.rect.width : 0;
      } else {
        inputWidth = this.el.child.placeholder.rect.width;
        labelWidth = 0;
      }

      this.el.child.input.style({
        width: '100%',
        whiteSpace: 'normal'
      });
      return Math.min(this._getWidthSetting('max'), Math.max(this._getWidthSetting('min'), inputWidth, labelWidth));
    }

  }

  TextareaField.prototype.template = template$2;
  TextareaField.prototype.templates = templates$1;
  TextareaField.prototype.defaults = defaults$2;
  inheritProto(TextareaField, TextField$1);
  return TextareaField;
}.call(undefined);

var TextareaField$1 = TextareaField;var defaults$3 = {
  placeholder: true,
  validWhenMin: false,
  validWhenMax: false,
  autoWidth: false,
  maxWidth: '100%',
  height: 46,
  buttons: true,
  minValue: -2e308,
  maxValue: 2e308,
  step: 1,
  enforce: false,
  inputSibling: 'buttons'
};var template$3 = textFieldTemplate.extend();
var stepButton = quickdom.template(['div', {
  stateTriggers: {
    'active': {
      on: 'mousedown',
      off: 'mouseup',
      bubbles: false
    }
  },
  attrs: {
    tabindex: -1
  },
  style: {
    display: 'inline-block',
    width: '100%',
    height: 17,
    boxSizing: 'border-box',
    verticalAlign: 'top',
    outline: 'none',
    cursor: 'pointer',
    fill: COLORS$1.grey,
    $active: {
      fill: COLORS$1.grey_dark
    }
  }
}]);
var buttons = quickdom.template(['div', {
  ref: 'buttons',
  style: {
    position: 'relative',
    zIndex: 3,
    top: '50%',
    transform: 'translateY(-50%)',
    display: 'inline-block',
    width: 17,
    paddingRight: function (field) {
      return field.settings.inputPadding;
    },
    outline: 'none'
  }
}, stepButton.extend({
  children: [caretUp],
  options: {
    ref: 'stepUp'
  }
}), stepButton.extend({
  children: [caretDown],
  options: {
    ref: 'stepDown'
  }
})]);
var templates$2 =
/*#__PURE__*/
Object.freeze({
  default: template$3,
  stepButton: stepButton,
  buttons: buttons
});var NumberField;

NumberField = function () {
  class NumberField extends Field$1 {
    constructor() {
      var ref;
      super(...arguments);

      if (this._value == null) {
        this._value = '';
      }

      if (this.settings.enforce && this.settings.minValue && this.settings.minValue !== -2e308) {
        this._value || (this._value = this.settings.minValue);
      }

      this.settings.step = Number(this.settings.step) || 1;
      this.state.typing = false;
      this.cursor = {
        prev: 0,
        current: 0
      };
      this.precision = ((ref = this.settings.step.toString().split('.')[1]) != null ? ref.length : void 0) || 0;

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      return Number(this._value) || 0;
    }

    _setValue(newValue) {
      return this._value = this._normalizeValue(newValue, this.settings.enforce);
    }

    _createElements() {
      var globalOpts;
      globalOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.defaults, globalOpts);

      if (this.settings.buttons) {
        buttons.spawn(this.settings.templates.buttons, globalOpts).insertAfter(this.el.child.input);
      }

      this.el.state('hasLabel', this.settings.label);
      this.el.child.innerwrap.raw._quickField = this.el.childf.input.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_value();

      this._attachBindings_stateTriggers();

      this._attachBindings_stepEvents();
    }

    _attachBindings_value() {
      var input;
      input = this.el.child.input.raw;
      simplybind('event:input').of(input).to(() => {
        var newValue, selectNumberPart;
        this.cursor.prev = this.cursor.current;
        this.cursor.current = this.selection().end;
        newValue = input.value;

        if (newValue[newValue.length - 1] === '-') {
          if (this.settings.minValue > -1) {
            newValue = this._value;
          } else {
            newValue = -1;
            selectNumberPart = true;
          }
        }

        this._setValue(newValue);

        if (this.state.focused) {
          if (selectNumberPart) {
            return this.selection(1, 2);
          } else {
            return this.selection(this.cursor.current, this.cursor.current + (String(this._value).length - newValue.length));
          }
        }
      });
      simplybind('_value').of(this).to('value').of(input).and.to(value => {
        this.state.filled = !!String(value);

        if (String(value)) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);
        return this.emit('input', value);
      });
      simplybind('event:blur').of(input).to(() => {
        var value;

        if (!this.settings.enforce) {
          value = Number(this._value) || 0;

          if (value === 0 || !this.state.interacted && value === this.settings.minValue) {
            return this._value = '';
          }
        }
      });
      simplybind('event:keydown').of(this.el.child.input).to(event => {
        if (event.keyCode === KEYCODES.enter) {
          this.emit('submit');
        }

        return this.emit(`key-${event.keyCode}`);
      });
    }

    _attachBindings_stepEvents() {
      var stopPropagation;
      simplybind('event:keydown').of(this.el.child.input).to(event => {
        switch (event.keyCode) {
          case KEYCODES.up:
            event.preventDefault();
            return this.stepUp();

          case KEYCODES.down:
            event.preventDefault();
            return this.stepDown();
        }
      });

      if (this.settings.buttons) {
        stopPropagation = function (event) {
          event.preventDefault();
          return event.stopPropagation();
        };

        simplybind('event:click').of(this.el.child.stepUp).to(this.stepUp.bind(this)).and.to(stopPropagation);
        simplybind('event:click').of(this.el.child.stepDown).to(this.stepDown.bind(this)).and.to(stopPropagation);
      }
    }

    _setValueIfNotSet() {
      if (Number(this.el.child.input.raw.value) !== this._value) {
        return this.el.child.input.raw.value = this._value;
      }
    }

    _normalizeValue(value, enforce) {
      value = value ? parseFloat(value) || 0 : 0;

      if (value % this.settings.step && enforce) {
        if (value < this.settings.step) {
          value = this.settings.step;
        } else {
          value = this._roundToNearest(value, this.settings.step);
        }
      }

      if (value < this.settings.minValue) {
        value = this.settings.minValue;
      }

      if (value > this.settings.maxValue) {
        value = this.settings.maxValue;
      }

      return value;
    }

    _roundToNearest(value, target) {
      var multiplier;
      value = (value || 0).toFixed(this.precision) * 1;
      multiplier = target < 1 ? 1 / target : 1;
      target *= multiplier;
      value *= multiplier;
      value = Math.ceil(value / target) * target / multiplier;
      return value;
    }

    stepUp() {
      var newValue, rounded;
      rounded = this._roundToNearest(this._value, this.settings.step);
      newValue = Math.min(rounded + this.settings.step, this._value + this.settings.step);
      return this._setValue(this._roundToNearest(newValue, this.settings.step));
    }

    stepDown() {
      var newValue, rounded;
      rounded = this._roundToNearest(this._value, this.settings.step);
      newValue = Math.max(rounded - this.settings.step, this._value - this.settings.step);
      return this._setValue(this._roundToNearest(newValue, this.settings.step));
    }

  }

  NumberField.prototype.template = template$3;
  NumberField.prototype.templates = templates$2;
  NumberField.prototype.defaults = defaults$3;
  inheritProto(NumberField, TextField$1);
  return NumberField;
}.call(undefined);

primaryBuilder$1.notKeys(NumberField.prototype)(NumberField.prototype, TextField$1.prototype);
var NumberField$1 = NumberField;var defaults$4 = {
  placeholder: true,
  validWhenIsChoice: false,
  validWhenRegex: false,
  validWhenChoseMin: 2e308,
  autoWidth: false,
  maxWidth: '100%',
  height: 46,
  labelFilter: null,
  choices: [],
  multiple: false,
  dropdown: {
    typeBuffer: true
  },
  inputSibling: 'caret'
};var template$4 = textFieldTemplate.extend({
  children: {
    innerwrap: {
      children: {
        'input': ['div', {
          props: {
            tabIndex: 0
          },
          style: {
            marginTop: 3,
            height: 'auto',
            cursor: 'default',
            userSelect: 'none',
            // overflow: 'scroll'
            overflow: 'hidden'
          }
        }],
        'caret': ['div', {
          ref: 'caret',
          styleAfterInsert: true,
          style: {
            position: 'relative',
            zIndex: 3,
            top: function (field) {
              return this.parent.styleParsed('height', true) / 2 - this.styleParsed('height') / 2;
            },
            display: 'inline-block',
            width: 17,
            height: 17,
            paddingRight: function (field) {
              return field.settings.inputPadding;
            },
            verticalAlign: 'top',
            outline: 'none',
            pointerEvents: 'none',
            fill: COLORS$1.grey
          }
        }, caretDown]
      }
    }
  }
});
var templates$3 =
/*#__PURE__*/
Object.freeze({
  default: template$4
});var SelectField;

SelectField = function () {
  class SelectField extends Field$1 {
    constructor() {
      var base;
      super(...arguments);
      this.settings.dropdown.multiple = this.settings.multiple;

      if (this.settings.multiple) {
        if ((base = this.settings.dropdown).help == null) {
          base.help = 'Tip: press ESC to close this menu';
        }
      }

      this._value = this.settings.multiple ? [] : null;
      this.dropdown = new Dropdown$1(this.settings.choices, this);

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var ref;

      if (!this.settings.multiple) {
        return (ref = this._value) != null ? ref.value : void 0;
      } else {
        return this._value.map(function (choice) {
          return choice.value;
        });
      }
    }

    _setValue(newValue) {
      var i, len, value;

      if (!this.settings.multiple || !IS$1$1.array(newValue)) {
        this.setChoice(newValue);
      } else {
        for (i = 0, len = newValue.length; i < len; i++) {
          value = newValue[i];
          this.setChoice(value);
        }
      }
    }

    _recalcDisplay() {
      if (this.settings.autoWidth) {
        return this.valueLabel = this.valueLabel;
      }
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);
      this.dropdown.appendTo(this.el.child.innerwrap);
      this.el.child.placeholder.insertBefore(this.el.child.input);

      if (this.settings.label) {
        this.el.child.label.text = this.settings.label;
        this.el.state('hasLabel', true);
      }

      this.el.child.innerwrap.raw._quickField = this.el.child.input.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_value();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_dropdown();

      this._attachBindings_stateTriggers();
    }

    _attachBindings_display_autoWidth() {
      simplybind('width', {
        updateEvenIfSame: true
      }).of(this.state).to(width => {
        return (this.settings.autoWidth ? this.el.child.input : this.el).style({
          width
        });
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);

      if (this.settings.autoWidth) {
        simplybind('valueLabel', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('width').of(this.state).transform(() => {
          return this._getInputAutoWidth();
        }).updateOn('event:inserted').of(this);
      }
    }

    _getInputAutoWidth() {
      var inputWidth, labelWidth;

      if (this.valueLabel) {
        this.el.child.input.style('width', 0);
        inputWidth = this.el.child.input.raw.scrollWidth + 2;
        labelWidth = this.el.child.label.styleSafe('position') === 'absolute' ? this.el.child.label.rect.width : 0;
      } else {
        inputWidth = this.el.child.placeholder.rect.width;
        labelWidth = 0;
      }

      return Math.max(inputWidth, labelWidth);
    }

    _attachBindings_value() {
      simplybind('array:_value').of(this).to(selected => {
        this.state.filled = this.settings.multiple ? !!(selected != null ? selected.length : void 0) : !!selected;

        if (this.state.filled) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);
        return this.emit('input', this.value);
      }).and.to('valueLabel').of(this).transform(selected => {
        if (!selected) {
          return '';
        } else {
          if (this.settings.multiple) {
            return selected.map(function (choice) {
              return choice.label;
            }).join(', ');
          } else {
            return selected.label;
          }
        }
      });
      simplybind('valueLabel').of(this).to('text').of(this.el.child.input).transform(label => {
        if (this.settings.labelFormat) {
          return this.settings.labelFormat(label);
        } else {
          return label;
        }
      });
    }

    _attachBindings_dropdown() {
      simplybind('event:click').of(this.el.child.input).to(event => {
        var escListener;

        if (!(this.state.disabled || this.dropdown.choices.length === 0)) {
          this.dropdown.isOpen = true;
          this.focus();
          quickdom(document).on('click.dropdown', event => {
            if (quickdom(event.target).parentMatching(parent => {
              return parent === this.el.child.innerwrap;
            })) {
              return;
            }

            return this.dropdown.isOpen = false;
          }, true);
          escListener = simplybind('event:keydown').of(document).once.to(() => {
            return this.dropdown.isOpen = false;
          }).condition(function (event) {
            return event.keyCode === 27;
          });
          return simplybind('isOpen', {
            updateOnBind: false
          }).of(this.dropdown).once.to(function () {
            escListener.unBind();
            return quickdom(document).off('click.dropdown');
          }).condition(function (isOpen) {
            return !isOpen;
          });
        }
      });
      simplybind('event:click').of(this.el.child.innerwrap).to(event => {
        event.stopPropagation();
        return this.el.child.input.emitPrivate('click');
      }).condition(event => {
        return event.target === this.el.child.innerwrap.raw;
      });
      simplybind('focused', {
        updateOnBind: false
      }).of(this.state).to(focused => {
        var triggeringKeycodes;

        if (!focused) {
          return this.el.child.input.off('keydown.dropdownTrigger');
        } else {
          triggeringKeycodes = [32, 37, 38, 39, 40];
          return this.el.child.input.on('keydown.dropdownTrigger', event => {
            var ref;

            if (includes$2(triggeringKeycodes, event.keyCode) && !this.dropdown.isOpen) {
              this.dropdown.isOpen = true;

              if ((ref = this.dropdown.lastSelected) != null ? ref.selected : void 0) {
                this.dropdown.currentHighlighted = this.dropdown.lastSelected;
              }

              return event.preventDefault();
            } else if (event.keyCode === 9 && this.dropdown.isOpen) {
              // Prevent tab key
              return event.preventDefault();
            }
          });
        }
      });
      this.dropdown.onSelected(choice => {
        if (!(choice.selected && !this.settings.multiple)) {
          this.value = choice;
        }

        if (!this.settings.multiple) {
          return this.dropdown.isOpen = false;
        }
      });
    }

    _attachBindings_stateTriggers() {
      //# ==========================================================================
      //# State event triggers
      //# ========================================================================== 
      simplybind('event:mouseenter').of(this.el.child.input).to(() => {
        return this.state.hovered = true;
      });
      simplybind('event:mouseleave').of(this.el.child.input).to(() => {
        return this.state.hovered = false;
      });
      simplybind('event:focus').of(this.el.child.input).to(() => {
        this.state.focused = true;

        if (this.state.disabled) {
          return this.blur();
        }
      });
      simplybind('event:blur').of(this.el.child.input).to(() => {
        return this.state.focused = false;
      });
    }

    _validate(providedValue) {
      var matchingChoice, ref, ref1;

      if (this.settings.validWhenRegex && IS$1$1.regex(this.settings.validWhenRegex)) {
        switch (false) {
          case !this.settings.multiple:
            if (!(() => {
              var validChoices;

              if (providedValue.length === 0) {
                return false;
              }

              validChoices = providedValue.filter(choice => {
                return this.settings.validWhenRegex.test(choice);
              });

              if (this.settings.validWhenChoseMin === 2e308 || !IS$1$1.number(this.settings.validWhenChoseMin)) {
                return validChoices.length === providedValue.length;
              } else {
                return validChoices.length >= this.settings.validWhenChoseMin;
              }
            })()) {
              return false;
            }

            break;

          default:
            if (!this.settings.validWhenRegex.test(providedValue)) {
              return false;
            }

        }
      }

      if (this.settings.validWhenIsChoice && ((ref = this.dropdown.choices) != null ? ref.length : void 0)) {
        matchingChoice = this.dropdown.choices.filter(function (option) {
          return option.value === providedValue;
        });

        if (!!!matchingChoice.length) {
          return false;
        }
      }

      if (this.settings.multiple && -1 > (ref1 = this.settings.validWhenChoseMin) && ref1 < 2e308) {
        if (!providedValue.length >= this.settings.validWhenChoseMin) {
          return false;
        }
      }

      if (this.settings.multiple && this.settings.required) {
        if (!providedValue.length) {
          return false;
        }
      }

      return true;
    }

    addChoice(choice) {
      return this.dropdown.addChoice(choice);
    }

    setChoice(choice) {
      var match, ref;

      if (IS$1$1.object(choice) && choice instanceof Choice) {
        return choice.toggle();
      } else if (match = this.dropdown.findChoiceAny(choice)) {
        return match.toggle(true);
      } else {
        return (ref = this.addChoice(choice)) != null ? ref.toggle(true) : void 0;
      }
    }

  }

  SelectField.prototype.template = template$4;
  SelectField.prototype.templates = templates$3;
  SelectField.prototype.defaults = defaults$4;
  SelectField.prototype.coreValueProp = 'value';
  return SelectField;
}.call(undefined);

inheritProto(SelectField, TextField$1, ['_getMaxWidth', '_attachBindings_elState', '_attachBindings_display', 'focus', 'blur']);
var SelectField$1 = SelectField;var template$5 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    boxSizing: 'border-box',
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    textAlign: 'left',
    $visible: {
      $hasVisibleChoices: {
        display: 'inline-block'
      }
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    marginBottom: '12px',
    fontFamily: 'inherit',
    fontSize: '13px',
    fontWeight: 600,
    color: COLORS$1.black,
    cursor: 'default',
    pointerEvents: 'none',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'innerwrap',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    fontFamily: 'inherit'
  }
}], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}]]);
var choiceGroup = quickdom.template(['div', {
  ref: 'choiceGroup',
  style: {
    marginBottom: function (field) {
      return field.settings.spacing;
    },
    userSelect: 'none',
    fontSize: '0',
    whiteSpace: 'nowrap'
  }
}]);
var choice$1 = quickdom.template(['div', {
  ref: 'choice',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    display: 'inline-block',
    width: 'auto',
    marginLeft: function (field) {
      if (this.index) {
        return `calc(100% - (100% - ${field.settings.spacing}px))`;
      }
    },
    // minHeight: '46px'
    padding: '0 12px',
    borderRadius: '2px',
    backgroundColor: 'white',
    fontFamily: 'inherit',
    textAlign: 'center',
    color: COLORS$1.black,
    boxSizing: 'border-box',
    verticalAlign: 'top',
    cursor: 'pointer',
    $definedWidth: {
      width: function (field) {
        return `calc((100% - ${field.settings.spacing * (field.settings.perGroup - 1)}px) / ${field.settings.perGroup})`;
      }
    },
    $selected: {
      color: COLORS$1.orange
    },
    $unavailable: {
      display: 'none'
    },
    $disabled: {
      cursor: 'not-allowed',
      opacity: 0.7,
      color: COLORS$1.grey
    }
  }
}, ['div', {
  ref: 'border',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    borderWidth: '1px',
    borderStyle: 'solid',
    borderColor: COLORS$1.grey_light,
    borderRadius: '2px',
    boxSizing: 'border-box',
    $selected: {
      borderColor: 'inherit',
      borderWidth: '2px'
    },
    $disabled: {
      borderColor: COLORS$1.grey_light
    }
  }
}], ['div', {
  ref: 'label',
  style: {
    position: 'relative',
    display: 'block',
    padding: '15px 0px',
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.fontSize;
    },
    fontWeight: '500'
  }
}]]);
var choiceIcon = quickdom.template(['div', {
  ref: 'icon',
  style: {
    position: 'absolute',
    top: '50%',
    display: 'block',
    fontSize: '20px',
    opacity: 0.16,
    transform: 'translateY(-50%)'
  }
}]);
var templates$4 =
/*#__PURE__*/
Object.freeze({
  default: template$5,
  choiceGroup: choiceGroup,
  choice: choice$1,
  choiceIcon: choiceIcon
});var defaults$5 = {
  validWhenSelected: false,
  validWhenIsChoice: false,
  showSelectAll: false,
  perGroup: 7,
  spacing: 8,
  choices: []
};var Choice$1, ChoiceField;

ChoiceField = function () {
  class ChoiceField extends Field$1 {
    constructor() {
      var ref;
      super(...arguments);

      if (!((ref = this.settings.choices) != null ? ref.length : void 0)) {
        throw new Error(`Choices were not provided for choice field '${this.settings.label || this.ID}'`);
      }

      this._value = this.settings.multiple ? [] : null;
      this.lastSelected = null;
      this.visibleChoicesCount = 0;
      this.choices = this.settings.choices;

      if (this.settings.validWhenSelected === true) {
        this.settings.validWhenSelected = 1;
      }

      this.settings.perGroup = Math.min(this.settings.perGroup, this.choices.length + (this.settings.multiple && this.settings.showSelectAll ? 1 : 0));

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var ref;

      if (!this.settings.multiple) {
        return (ref = this._value) != null ? ref.value : void 0;
      } else {
        return this._value.map(function (choice) {
          return choice.value;
        });
      }
    }

    _setValue(newValue) {
      var i, len, value;

      if (!this.settings.multiple || !IS$1$1.array(newValue)) {
        this.setChoice(newValue);
      } else {
        for (i = 0, len = newValue.length; i < len; i++) {
          value = newValue[i];
          this.setChoice(value);
        }
      }
    }

    _createElements() {
      var choiceGroups, choices, globalOpts, perGroup;
      globalOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, globalOpts);
      this.choices = [];
      choices = this.settings.choices;
      perGroup = this.settings.perGroup;
      choiceGroups = Array(Math.ceil(choices.length / perGroup)).fill().map(function (s, index) {
        return choices.slice(index * perGroup, index * perGroup + perGroup);
      });
      choiceGroups.forEach((choices, groupIndex) => {
        var groupEl;
        groupEl = this.templates.choiceGroup.spawn(this.settings.templates.choiceGroup, globalOpts).appendTo(this.el.child.innerwrap);
        return choices.forEach((choice, index) => {
          return this.choices.push(new Choice$1(this, choice, index, groupIndex, groupEl));
        });
      });
      this.el.child.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      var choice, i, len, ref;

      this._attachBindings_elState();

      this._attachBindings_stateTriggers();

      this._attachBindings_display();

      this._attachBindings_value();

      ref = this.choices;

      for (i = 0, len = ref.length; i < len; i++) {
        choice = ref[i];

        choice._attachBindings();
      }
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('hovered').of(this.state).to(hovered => {
        return this.el.state('hovered', hovered);
      });
      simplybind('filled').of(this.state).to(filled => {
        return this.el.state('filled', filled);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_stateTriggers() {
      simplybind('event:mouseenter').of(this.el).to(() => {
        return this.state.hovered = true;
      });
      simplybind('event:mouseleave').of(this.el).to(() => {
        return this.state.hovered = false;
      });
    }

    _attachBindings_display() {
      simplybind('width').of(this.state).to(width => {
        return this.el.style('width', width).state('definedWidth', width !== 'auto');
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);
      simplybind('visibleChoicesCount').of(this).to(count => {
        return this.el.state('hasVisibleChoices', !!count);
      });
    }

    _attachBindings_value() {
      simplybind('_value').of(this).to(selected => {
        this.state.filled = !!(selected != null ? selected.length : void 0);

        if (this.state.filled) {
          this.state.interacted = true;
        }

        return this.state.valid = this.validate(void 0, true);
      });
      simplybind('array:_value', {
        updateOnBind: false
      }).of(this).to(() => {
        return this.emit('input', this.value);
      });
    }

    _validate(providedValue) {
      if (this.settings.multiple) {
        if (!IS$1$1.array(providedValue)) {
          providedValue = [providedValue];
        }

        if (providedValue.length && !IS$1$1.object(providedValue[0])) {
          providedValue = providedValue.map(function (choice) {
            return choice.value;
          });
        }
      } else {
        if (IS$1$1.object(providedValue)) {
          providedValue = providedValue.value;
        }
      }

      if (IS$1$1.number(this.settings.validWhenSelected)) {
        if (!((providedValue != null ? providedValue.length : void 0) >= this.settings.validWhenSelected)) {
          return false;
        }
      }

      if (this.settings.validWhenIsChoice) {
        if (this.settings.multiple) {
          if (!includes$2(providedValue, this.settings.validWhenIsChoice)) {
            return false;
          }
        } else {
          if (providedValue !== this.settings.validWhenIsChoice) {
            return false;
          }
        }
      }

      return true;
    }

    findChoice(providedValue, byLabel) {
      var matches;
      matches = this.choices.filter(function (choice) {
        switch (false) {
          case !IS$1$1.object(providedValue):
            return providedValue === choice;

          case !byLabel:
            return providedValue === choice.label;

          default:
            return providedValue === choice.value;
        }
      });
      return matches[0];
    }

    findChoiceAny(providedValue) {
      return this.findChoice(providedValue) || this.findChoice(providedValue, true);
    }

    setChoice(choice) {
      if (IS$1$1.object(choice) && choice instanceof Choice$1) {
        return choice.toggle();
      } else if (choice = this.findChoiceAny(choice)) {
        return choice.toggle(true);
      }
    }

  }

  ChoiceField.prototype.template = template$5;
  ChoiceField.prototype.templates = templates$4;
  ChoiceField.prototype.defaults = defaults$5;
  return ChoiceField;
}.call(undefined);

Choice$1 = class Choice {
  constructor(field, settings, index1, groupIndex, groupEl) {
    var globalOpts, iconEl, ref;
    this.field = field;
    this.settings = settings;
    this.index = index1;
    globalOpts = {
      relatedInstance: this.field
    };
    ({
      label: this.label,
      value: this.value,
      conditions: this.conditions
    } = this.settings);

    if (this.label == null) {
      this.label = this.value;
    }

    if (this.value == null) {
      this.value = this.label;
    }

    this.el = this.field.templates.choice.spawn(this.field.settings.templates.choice, globalOpts).appendTo(groupEl);

    if (this.icon) {
      iconEl = this.templates.choiceIcon.spawn(this.field.settings.templates.choiceIcon, globalOpts).insertBefore(this.el.child.label);
      iconEl.text = this.icon;
    }

    if (this.el.index == null) {
      this.el.index = this.index;
    }

    this.el.totalIndex = this.index * groupIndex;
    this.el.prop('title', this.label);
    this.el.child.label.text = this.label;
    this.visible = true;
    this.selected = false;
    this.disabled = this.settings.disabled || false;
    this.unavailable = false;

    if ((ref = this.conditions) != null ? ref.length : void 0) {
      this.unavailable = true;
      this.allFields = this.field.allFields;
      Condition$1.init(this, this.conditions, () => {
        return this.unavailable = !Condition$1.validate(this.conditions);
      });
    }
  }

  _attachBindings() {
    return (() => {
      simplybind('visible').of(this).to(visible => {
        return this.el.state('visible', visible);
      }).and.to(visible => {
        return this.field.visibleChoicesCount += visible ? 1 : -1;
      });
      simplybind('selected', {
        updateOnBind: false
      }).of(this).to(selected => {
        return this.el.state('selected', selected);
      });
      simplybind('disabled', {
        updateOnBind: false
      }).of(this).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('unavailable', {
        updateOnBind: false
      }).of(this).to(unavailable => {
        return this.el.state('unavailable', unavailable);
      }).and.to(unavailable => {
        if (unavailable) {
          return this.toggle(false, true);
        }
      });
      return simplybind('event:click').of(this.el).to(() => {
        return this.field.value = this;
      }).condition(() => {
        return !this.disabled;
      });
    })();
  }

  toggle(newValue, unavailable) {
    var newState, prevState, ref;
    prevState = this.selected;
    newState = IS$1$1.defined(newValue) ? newValue : !this.selected;

    if (!newState) {
      if (this.field.settings.multiple && prevState) {
        this.selected = newState;
        return removeItem$1(this.field._value, this);
      } else {
        if (IS$1$1.defined(newValue)) {
          this.selected = newState;
        }

        if (unavailable) {
          return this.field._value = null;
        }
      }
    } else {
      this.selected = newState;

      if (this.field.settings.multiple) {
        this.field._value.push(this);
      } else {
        if (this.field._value !== this) {
          if ((ref = this.field._value) != null) {
            ref.toggle(false);
          }
        }

        this.field._value = this;
      }

      return this.field.lastSelected = this;
    }
  }

};
var ChoiceField$1 = ChoiceField;var template$1$2 = template$5.extend();
var choice$1$1 = choice$1.extend();
var choiceIcon$1 = choiceIcon.extend();
var choiceGroup$1 = choiceGroup.extend();
var templates$5 =
/*#__PURE__*/
Object.freeze({
  default: template$1$2,
  choice: choice$1$1,
  choiceIcon: choiceIcon$1,
  choiceGroup: choiceGroup$1
});var defaults$6 = {
  validWhenSelected: false,
  validWhenIsChoice: false,
  validWhenTrue: true,
  choiceLabels: ['True', 'False'],
  choices: [{
    value: true
  }, {
    value: false
  }],
  spacing: 8
};var TrueFalseField;

TrueFalseField = function () {
  class TrueFalseField extends Field$1 {
    constructor() {
      super(...arguments);
      this.lastSelected = null;
      this.visibleChoicesCount = 2;
      this.choices = this.settings.choices;
      this.choices[0].label = this.settings.choiceLabels[0];
      this.choices[1].label = this.settings.choiceLabels[1];
      this.settings.perGroup = 2;

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      if (this._value === null) {
        return null;
      } else {
        if (this._value.index === 0) {
          return true;
        } else {
          return false;
        }
      }
    }

    _setValue(newValue) {
      var ref;

      if (newValue === this.choices[0]) {
        newValue = this.choices[0].value;
      }

      if (newValue === this.choices[1]) {
        newValue = this.choices[1].value;
      }

      if (newValue === null) {
        this._value = null;

        if ((ref = this.lastSelected) != null) {
          ref.toggle(false);
        }

        return;
      }

      if (typeof newValue === 'string') {
        newValue = newValue.toLowerCase();

        if (newValue === 'false') {
          newValue = false;
        }
      }

      return (newValue ? this.choices[0] : this.choices[1]).toggle();
    }

    _validate(providedValue) {
      if (typeof providedValue === 'string') {
        providedValue = this.findChoice(providedValue);
      }

      if (this.settings.validWhenIsChoice) {
        if (providedValue) {
          if (this.settings.validWhenIsChoice !== providedValue.value) {
            return false;
          }
        } else {
          return false;
        }
      }

      if (this.settings.validWhenSelected) {
        if (!providedValue) {
          return false;
        }
      }

      if (this.settings.validWhenTrue) {
        if ((providedValue != null ? providedValue.index : void 0) !== 0) {
          return false;
        }
      }

      return true;
    }

  }

  TrueFalseField.prototype.template = template$1$2;
  TrueFalseField.prototype.templates = templates$5;
  TrueFalseField.prototype.defaults = defaults$6;
  return TrueFalseField;
}.call(undefined);

inheritProto(TrueFalseField, ChoiceField$1, ['_createElements', '_attachBindings', '_attachBindings_elState', '_attachBindings_stateTriggers', '_attachBindings_display', '_attachBindings_value']);
var TrueFalseField$1 = TrueFalseField;var defaults$7 = {
  validWhenTrue: true,
  size: 50,
  style: 'centered',
  color: COLORS$1.green,
  background: COLORS$1.grey_light,
  triggerEvent: 'mouseup'
};var template$6 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    boxSizing: 'border-box',
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    textAlign: 'left',
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    },
    $alignedStyle: {
      paddingRight: function (field) {
        return field.settings.size + 20;
      }
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    marginBottom: '12px',
    fontFamily: 'inherit',
    fontSize: '13px',
    fontWeight: 600,
    textAlign: 'center',
    color: COLORS$1.black,
    cursor: 'default',
    pointerEvents: 'none',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    },
    $alignedStyle: {
      marginBottom: '0',
      textAlign: 'left'
    }
  }
}], ['div', {
  ref: 'innerwrap',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    fontFamily: 'inherit',
    $alignedStyle: {
      position: 'absolute',
      right: 0,
      top: '50%',
      transform: 'translateY(-50%)'
    }
  }
}, ['div', {
  ref: 'input',
  style: {
    position: 'relative',
    zIndex: 2,
    width: function (field) {
      return field.settings.size;
    },
    height: function (field) {
      return field.settings.size / 2;
    },
    margin: '0 auto',
    backgroundColor: function (field) {
      return field.settings.background;
    },
    border: `1px solid ${COLORS$1.grey_semi_light}`,
    borderRadius: function (field) {
      return field.settings.size;
    },
    cursor: 'pointer'
  }
}, ['div', {
  ref: 'background',
  style: {
    position: 'absolute',
    zIndex: 1,
    left: 0,
    right: 0,
    width: function (field) {
      return field.settings.size / 2;
    },
    height: '100%',
    borderRadius: function (field) {
      var size;
      size = field.settings.size;
      return `${size}px 0 0 ${size}px`;
    },
    backgroundColor: function (field) {
      return field.settings.color;
    },
    opacity: 0,
    transition: 'opacity 0.2s, width 0.2s',
    $toggled: {
      opacity: 1,
      width: function (field) {
        return field.settings.size * 0.7;
      }
    }
  }
}], ['div', {
  ref: 'ball',
  style: {
    position: 'absolute',
    zIndex: 2,
    left: 0,
    right: 0,
    width: function (field) {
      return field.settings.size / 2;
    },
    height: function (field) {
      return field.settings.size / 2;
    },
    margin: '0 auto',
    backgroundColor: 'white',
    borderRadius: '50%',
    border: `1px solid ${COLORS$1.grey_light}`,
    boxSizing: 'border-box',
    transform: 'translateX(-55%)',
    transition: 'transform 0.2s',
    userSelect: 'none',
    $toggled: {
      transform: 'translateX(50%)',
      border: function (field) {
        return `1px solid ${field.settings.color}`;
      }
    }
  }
}]]], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}]]);
var templates$6 =
/*#__PURE__*/
Object.freeze({
  default: template$6
});var ToggleField;

ToggleField = function () {
  class ToggleField extends Field$1 {
    constructor() {
      super(...arguments);
      this._value = !!this._value;
      this.settings.size = parseFloat(this.settings.size) || defaults$7.size;

      if (this.settings.style !== 'centered' && this.settings.style !== 'aligned') {
        this.settings.style = defaults$7.style;
      }

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      return this._value;
    }

    _setValue(newValue) {
      return this._value = !!newValue;
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);
      this.el.state('alignedStyle', this.settings.style === 'aligned').child.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_stateTriggers();

      this._attachBindings_display();

      this._attachBindings_value();
    }

    _attachBindings_value() {
      simplybind('_value').of(this).to(value => {
        return this.el.state('toggled', value);
      });
      simplybind('_value', {
        updateOnBind: false
      }).of(this).to(value => {
        return this.emit('input', value);
      });
      simplybind(`event:${this.settings.triggerEvent}`).of(this.el.child.input).to(() => {
        return this.value = !this._value;
      });
    }

    _validate(providedValue) {
      if (this.settings.validWhenTrue) {
        if (!providedValue) {
          return false;
        }
      }

      return true;
    }

  }

  ToggleField.prototype.template = template$6;
  ToggleField.prototype.templates = templates$6;
  ToggleField.prototype.defaults = defaults$7;
  return ToggleField;
}.call(undefined);

inheritProto(ToggleField, TrueFalseField$1, ['_attachBindings_elState', '_attachBindings_stateTriggers', '_attachBindings_display']);
var ToggleField$1 = ToggleField;var defaults$8 = {
  fields: {},
  collapsable: true,
  startCollapsed: false,
  padding: 20,
  fieldMargin: 0,
  fieldAlign: 'top',
  labelSize: 16,
  color: COLORS$1.grey_light4
};var action = quickdom.template(['div', {
  events: {
    inserted: function () {
      if (this.index) {
        return this.style('marginLeft', 5);
      }
    }
  },
  style: {
    display: 'inline-block',
    boxSizing: 'border-box'
  }
}, [// verticalAlign: 'middle'
'div', {
  ref: 'icon',
  style: {
    width: 17,
    height: 17,
    color: COLORS$1.grey,
    fill: COLORS$1.grey,
    $hover: {
      color: COLORS$1.grey_dark,
      fill: COLORS$1.grey_dark
    }
  }
}]]);
var collapseIcons = [caretUp.extend({
  options: {
    style: {
      position: 'relative',
      top: -2,
      display: 'none',
      $collapsed: {
        display: 'block'
      }
    }
  }
}), caretDown.extend({
  options: {
    style: {
      display: 'block',
      $collapsed: {
        display: 'none'
      }
    }
  }
})];
var template$7 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    verticalAlign: 'top',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    // backgroundColor: (field)-> field.settings.color
    border: `1px solid ${COLORS$1.grey_light}`,
    borderRadius: 3,
    textAlign: 'left',
    // lineHeight: '1em'
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      $collapsed: {
        animation: '0.2s fieldErrorShake'
      }
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.labelSize;
    },
    fontWeight: 600,
    textAlign: 'left',
    color: COLORS$1.black,
    cursor: 'default',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'actions',
  style: {
    position: 'absolute',
    top: function (field) {
      return field.settings.padding * (12 / 20);
    },
    right: function (field) {
      return field.settings.padding * (12 / 20);
    },
    lineHeight: 0,
    fontSize: 0,
    textAlign: 'center',
    $showLabel: {
      top: function (field) {
        return field.settings.padding * (21 / 20);
      }
    }
  }
}], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    whiteSpace: 'pre-line',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}], ['div', {
  ref: 'innerwrap',
  unpassableStates: ['visible', 'hover', 'focus', 'disabled', 'showLabel', 'showError', 'showHelp', 'collapsed', 'valid', 'invalid'],
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    marginTop: 15,
    fontFamily: 'inherit',
    textAlign: 'justify',
    textJustify: 'distribute-all-lines',
    fontSize: 0,
    $collapsed: {
      display: 'none'
    }
  }
}]]);
var templates$7 =
/*#__PURE__*/
Object.freeze({
  action: action,
  collapseIcons: collapseIcons,
  default: template$7
});var GroupField;

GroupField = function () {
  class GroupField extends Field$1 {
    constructor() {
      super(...arguments);
      this._calcFocusState = this._calcFocusState.bind(this);
      this._calcBlurState = this._calcBlurState.bind(this);
      this._emitSubmit = this.emit.bind(this, 'submit');
      this.state.collapsed = this.settings.startCollapsed && this.settings.collapsable;

      if (this._value == null) {
        this._value = Object.create(null);
      }

      this.fields = Object.create(null);
      this.fieldsArray = [];

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var field, name, ref, values;
      values = Object.create(null);
      ref = this.fields;

      for (name in ref) {
        field = ref[name];
        values[name] = field.value;
      }

      return values;
    }

    _setValue(newValue) {
      var name, value;

      if (IS$1$1.object(newValue)) {
        for (name in newValue) {
          value = newValue[name];

          if (this.fields[name]) {
            this.fields[name].value = value;
          }
        }

        return newValue;
      }
    }

    _recalcDisplay() {
      var field, i, len, ref;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field._recalcDisplay) {
          field._recalcDisplay();
        }
      }
    }

    _createElements() {
      var config, field, fields, forceOpts, i, len, margin, name, ref, ref1;
      forceOpts = {
        relatedInstance: this
      };
      margin = `0 0 ${this.settings.fieldMargin}px 0`;
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);

      if (this.settings.collapsable) {
        this.addAction('collapse', this.templates.collapseIcons);
      }

      if (IS$1$1.array(this.settings.fields)) {
        fields = Object.create(null);
        ref = this.settings.fields;

        for (i = 0, len = ref.length; i < len; i++) {
          field = ref[i];

          if (!field.name) {
            throw new Error(`field ${this.name || this.ID}:group fields provided in array format must have a name`);
          }

          fields[field.name] = field;
        }

        this.settings.fields = fields;
      }

      ref1 = this.settings.fields;

      for (name in ref1) {
        field = ref1[name];
        config = primaryBuilder$1({
          margin,
          fieldInstances: this.fields
        }, field, {
          ID: name
        });
        this.fieldsArray.push(this.fields[name] = this.builder(config).appendTo(this.el.child.innerwrap));
        this.fields[name].on('focus', this._calcFocusState).on('blur', this._calcBlurState).on('submit', this._emitSubmit).el.style('verticalAlign', this.settings.fieldAlign).after(' ');
      }

      this.el.child.innerwrap.append(quickdom.div({
        style: {
          display: 'inline-block',
          width: '100%'
        }
      }));
      this.el.state('collapsable', this.settings.collapsable);
      this.el.raw._quickField = this.el.childf.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_stateTriggers();

      this._attachBindings_value();
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('hovered').of(this.state).to(hovered => {
        return this.el.state('hover', hovered);
      });
      simplybind('focused').of(this.state).to(focused => {
        return this.el.state('focus', focused);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('collapsed').of(this.state).to(collapsed => {
        return this.el.state('collapsed', collapsed);
      });
      return simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_display() {
      var field, i, len, ref;
      simplybind('width').of(this.state).to(width => {
        return this.el.style('width', width).state('definedWidth', width !== 'auto');
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        simplybind('disabled').of(this.state).to('disabled').of(field.state);
      }
    }

    _attachBindings_stateTriggers() {
      var toggleCollapse;

      if (this.settings.collapsable) {
        toggleCollapse = () => {
          this.state.collapsed = !this.state.collapsed;
          return this.emit('collapsed', this.state.collapsed);
        };

        simplybind('event:click').of(this.el.child.collapse).to(toggleCollapse);
        simplybind('event:click').of(this.el.child.label).to(toggleCollapse);
        simplybind('collapsed').of(this.state).once.to(() => {
          return this._recalcDisplay();
        }).condition(function (collapsed) {
          return !collapsed;
        });
      }
    }

    _attachBindings_value() {
      var field, fieldName, ref;
      ref = this.fields;

      for (fieldName in ref) {
        field = ref[fieldName];
        simplybind('_value').of(field).to(fieldName).of(this._value);
        simplybind('_value', {
          updateOnBind: false
        }).of(field).to(value => {
          if (value) {
            this.state.interacted = true;
          }

          this.state.valid = this.validate(void 0, true);
          return this.emit('input', this._value);
        });
      }
    }

    _validate(providedValue, testUnrequired, report) {
      var field, i, isValid, len, ref, someInvalid;
      someInvalid = false;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (!field.state.visible) {
          continue;
        }

        if (report) {
          isValid = field.validateAndReport(providedValue[field.name], testUnrequired);
        } else {
          isValid = field.validate(providedValue[field.name], testUnrequired);
        }

        if (!isValid) {
          someInvalid = true;
        }
      }

      return !someInvalid;
    }

    _calcFocusState() {
      return this.state.focused = this.fieldsArray.some(function (field) {
        return field.state.focused;
      });
    }

    _calcBlurState() {
      return setTimeout(this._calcFocusState);
    }

    focus() {
      var field, i, len, ref;
      this.state.collapsed = false;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field.focus) {
          return field.focus();
        }
      }
    }

    blur() {
      var field, i, len, ref;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field.blur) {
          return field.blur();
        }
      }
    }

    addAction(name, icons, callback, prepend) {
      var action$$1, i, icon, len;

      if (icons && !IS$1$1.array(icons)) {
        icons = [icons];
      }

      action$$1 = this.templates.action.spawn(this.settings.templates.action, {
        relatedInstance: this
      });
      action$$1.ref = action$$1.options.ref = name;

      for (i = 0, len = icons.length; i < len; i++) {
        icon = icons[i];
        action$$1.child.icon.append(icon);
      }

      this.el.child.actions[prepend ? 'prepend' : 'append'](action$$1);

      if (callback) {
        simplybind('event:click').of(action$$1).to(callback);
      }

      return action$$1;
    }

  }

  GroupField.prototype.template = template$7;
  GroupField.prototype.templates = templates$7;
  GroupField.prototype.defaults = defaults$8;
  GroupField.prototype.shallowSettings = ['fields'];
  return GroupField;
}.call(undefined);

var GroupField$1 = GroupField;var template$8 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    verticalAlign: 'top',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    borderRadius: 3,
    textAlign: 'left',
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    fontFamily: 'inherit',
    fontSize: '16px',
    fontWeight: 600,
    textAlign: 'left',
    color: COLORS$1.black,
    cursor: 'default',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'collapse',
  style: {
    position: 'absolute',
    top: 5,
    right: 0,
    lineHeight: 0,
    fontSize: 0,
    display: 'none',
    $showLabel: {
      $collapsable: {
        display: 'block'
      }
    }
  }
}, ['div', {
  ref: 'icon',
  style: {
    width: 17,
    height: 17,
    color: COLORS$1.grey,
    fill: COLORS$1.grey,
    $hover: {
      color: COLORS$1.grey_dark,
      fill: COLORS$1.grey_dark
    }
  }
}, ...collapseIcons]], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}], ['div', {
  ref: 'innerwrap',
  unpassableStates: ['visible', 'hover', 'focus', 'disabled', 'showLabel', 'showError', 'showHelp', 'collapsed', 'valid', 'invalid'],
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    marginTop: 15,
    fontFamily: 'inherit',
    textAlign: 'justify',
    textJustify: 'distribute-all-lines',
    fontSize: 0,
    $collapsed: {
      display: 'none'
    }
  }
}, ['div', {
  ref: 'addButton',
  style: {
    position: 'relative',
    verticalAlign: 'middle',
    boxSizing: 'border-box',
    padding: 12,
    backgroundColor: COLORS$1.grey_semi_light,
    borderRadius: 3,
    cursor: 'pointer',
    userSelect: 'none',
    lineHeight: '1em',
    textAlign: 'center',
    $disabled: {
      display: 'none'
    },
    $inlineStyle: {
      display: 'inline-block',
      top: function (field) {
        return field.settings.groupMargin / 2 * -1;
      }
    }
  }
}, ['div', {
  style: {
    display: 'inline-block',
    width: 15,
    height: 15,
    color: COLORS$1.black,
    fill: COLORS$1.black
  }
}, plus]]]]);
var cloneIcon = clone$1.extend({
  options: {
    style: {
      width: 11
    }
  }
});
var removeIcon = remove$1.extend({
  options: {
    style: {
      width: 11
    }
  }
});
var blockGroup = {};
var inlineGroup = {
  default: {
    // options: style:
    // 	verticalAlign: 'middle'
    children: {
      innerwrap: {
        options: {
          style: {
            display: 'inline-block',
            verticalAlign: 'middle',
            marginTop: 0
          }
        }
      },
      actions: {
        options: {
          events: {
            inserted: function () {
              return this.insertAfter(this.parent.child.innerwrap);
            }
          },
          style: {
            position: 'static',
            verticalAlign: 'middle',
            display: 'inline-table'
          }
        }
      }
    }
  },
  action: ['div', {
    events: {
      inserted: function () {
        if (this.index) {
          return this.style('borderTop', `1px solid ${COLORS$1.grey}`);
        }
      }
    },
    style: {
      boxSizing: 'border-box',
      display: 'table-row',
      padding: 4
    }
  }, ['div', {
    ref: 'icon',
    style: {
      verticalAlign: 'middle',
      display: 'table-cell',
      color: COLORS$1.black,
      fill: COLORS$1.black,
      opacity: 0.6,
      $hover: {
        opacity: 1
      }
    }
  }]]
};
var templates$8 =
/*#__PURE__*/
Object.freeze({
  default: template$8,
  cloneIcon: cloneIcon,
  removeIcon: removeIcon,
  blockGroup: blockGroup,
  inlineGroup: inlineGroup
});var defaults$9 = {
  fields: null,
  style: 'block',
  collapsable: true,
  startCollapsed: false,
  groupMargin: 10,
  groupWidth: '100%',
  autoWidth: true,
  autoRemoveEmpty: false,
  dynamicLabel: false,
  minItems: null,
  maxItems: null,
  draggable: false,
  cloneable: false,
  removeable: true,
  singleMode: false,
  numbering: false,
  multiple: true,
  dragdrop: true,
  groupSettings: {
    labelSize: 14,
    inline: {
      padding: 0,
      fieldMargin: 0,
      width: 'auto',
      collapsable: false,
      startCollapsed: false,
      templates: inlineGroup
    },
    block: {
      startCollapsed: false,
      templates: blockGroup
    }
  }
};var atoa = function atoa(a, n) {
  return Array.prototype.slice.call(a, n);
};var si = typeof setImmediate === 'function',
    tick;

if (si) {
  tick = function (fn) {
    setImmediate(fn);
  };
} else {
  tick = function (fn) {
    setTimeout(fn, 0);
  };
}

var tickyBrowser = tick;var debounce = function debounce(fn, args, ctx) {
  if (!fn) {
    return;
  }

  tickyBrowser(function run() {
    fn.apply(ctx || null, args || []);
  });
};var emitter = function emitter(thing, options) {
  var opts = options || {};
  var evt = {};

  if (thing === undefined) {
    thing = {};
  }

  thing.on = function (type, fn) {
    if (!evt[type]) {
      evt[type] = [fn];
    } else {
      evt[type].push(fn);
    }

    return thing;
  };

  thing.once = function (type, fn) {
    fn._once = true; // thing.off(fn) still works!

    thing.on(type, fn);
    return thing;
  };

  thing.off = function (type, fn) {
    var c = arguments.length;

    if (c === 1) {
      delete evt[type];
    } else if (c === 0) {
      evt = {};
    } else {
      var et = evt[type];

      if (!et) {
        return thing;
      }

      et.splice(et.indexOf(fn), 1);
    }

    return thing;
  };

  thing.emit = function () {
    var args = atoa(arguments);
    return thing.emitterSnapshot(args.shift()).apply(this, args);
  };

  thing.emitterSnapshot = function (type) {
    var et = (evt[type] || []).slice(0);
    return function () {
      var args = atoa(arguments);
      var ctx = this || thing;

      if (type === 'error' && opts.throws !== false && !et.length) {
        throw args.length === 1 ? args[0] : args;
      }

      et.forEach(function emitter(listen) {
        if (opts.async) {
          debounce(listen, args, ctx);
        } else {
          listen.apply(ctx, args);
        }

        if (listen._once) {
          thing.off(type, listen);
        }
      });
      return thing;
    };
  };

  return thing;
};var NativeCustomEvent = commonjsGlobal.CustomEvent;

function useNative() {
  try {
    var p = new NativeCustomEvent('cat', {
      detail: {
        foo: 'bar'
      }
    });
    return 'cat' === p.type && 'bar' === p.detail.foo;
  } catch (e) {}

  return false;
}
/**
 * Cross-browser `CustomEvent` constructor.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
 *
 * @public
 */


var customEvent = useNative() ? NativeCustomEvent : // IE >= 9
'function' === typeof document.createEvent ? function CustomEvent(type, params) {
  var e = document.createEvent('CustomEvent');

  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, void 0);
  }

  return e;
} : // IE <= 8
function CustomEvent(type, params) {
  var e = document.createEventObject();
  e.type = type;

  if (params) {
    e.bubbles = Boolean(params.bubbles);
    e.cancelable = Boolean(params.cancelable);
    e.detail = params.detail;
  } else {
    e.bubbles = false;
    e.cancelable = false;
    e.detail = void 0;
  }

  return e;
};var eventmap = [];
var eventname = '';
var ron = /^on/;

for (eventname in commonjsGlobal) {
  if (ron.test(eventname)) {
    eventmap.push(eventname.slice(2));
  }
}

var eventmap_1 = eventmap;var doc = commonjsGlobal.document;
var addEvent = addEventEasy;
var removeEvent = removeEventEasy;
var hardCache = [];

if (!commonjsGlobal.addEventListener) {
  addEvent = addEventHard;
  removeEvent = removeEventHard;
}

var crossvent = {
  add: addEvent,
  remove: removeEvent,
  fabricate: fabricateEvent
};

function addEventEasy(el, type, fn, capturing) {
  return el.addEventListener(type, fn, capturing);
}

function addEventHard(el, type, fn) {
  return el.attachEvent('on' + type, wrap$1(el, type, fn));
}

function removeEventEasy(el, type, fn, capturing) {
  return el.removeEventListener(type, fn, capturing);
}

function removeEventHard(el, type, fn) {
  var listener = unwrap$1(el, type, fn);

  if (listener) {
    return el.detachEvent('on' + type, listener);
  }
}

function fabricateEvent(el, type, model) {
  var e = eventmap_1.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();

  if (el.dispatchEvent) {
    el.dispatchEvent(e);
  } else {
    el.fireEvent('on' + type, e);
  }

  function makeClassicEvent() {
    var e;

    if (doc.createEvent) {
      e = doc.createEvent('Event');
      e.initEvent(type, true, true);
    } else if (doc.createEventObject) {
      e = doc.createEventObject();
    }

    return e;
  }

  function makeCustomEvent() {
    return new customEvent(type, {
      detail: model
    });
  }
}

function wrapperFactory(el, type, fn) {
  return function wrapper(originalEvent) {
    var e = originalEvent || commonjsGlobal.event;
    e.target = e.target || e.srcElement;

    e.preventDefault = e.preventDefault || function preventDefault() {
      e.returnValue = false;
    };

    e.stopPropagation = e.stopPropagation || function stopPropagation() {
      e.cancelBubble = true;
    };

    e.which = e.which || e.keyCode;
    fn.call(el, e);
  };
}

function wrap$1(el, type, fn) {
  var wrapper = unwrap$1(el, type, fn) || wrapperFactory(el, type, fn);
  hardCache.push({
    wrapper: wrapper,
    element: el,
    type: type,
    fn: fn
  });
  return wrapper;
}

function unwrap$1(el, type, fn) {
  var i = find$1(el, type, fn);

  if (i) {
    var wrapper = hardCache[i].wrapper;
    hardCache.splice(i, 1); // free up a tad of memory

    return wrapper;
  }
}

function find$1(el, type, fn) {
  var i, item;

  for (i = 0; i < hardCache.length; i++) {
    item = hardCache[i];

    if (item.element === el && item.type === type && item.fn === fn) {
      return i;
    }
  }
}var cache = {};
var start = '(?:^|\\s)';
var end = '(?:\\s|$)';

function lookupClass(className) {
  var cached = cache[className];

  if (cached) {
    cached.lastIndex = 0;
  } else {
    cache[className] = cached = new RegExp(start + className + end, 'g');
  }

  return cached;
}

function addClass$1(el, className) {
  var current = el.className;

  if (!current.length) {
    el.className = className;
  } else if (!lookupClass(className).test(current)) {
    el.className += ' ' + className;
  }
}

function rmClass(el, className) {
  el.className = el.className.replace(lookupClass(className), ' ').trim();
}

var classes = {
  add: addClass$1,
  rm: rmClass
};var doc$1 = document;
var documentElement = doc$1.documentElement;

function dragula(initialContainers, options) {
  var len = arguments.length;

  if (len === 1 && Array.isArray(initialContainers) === false) {
    options = initialContainers;
    initialContainers = [];
  }

  var _mirror; // mirror image


  var _source; // source container


  var _item; // item being dragged


  var _offsetX; // reference x


  var _offsetY; // reference y


  var _moveX; // reference move x


  var _moveY; // reference move y


  var _initialSibling; // reference sibling when grabbed


  var _currentSibling; // reference sibling now


  var _copy; // item used for copying


  var _renderTimer; // timer for setTimeout renderMirrorImage


  var _lastDropTarget = null; // last container item was over

  var _grabbed; // holds mousedown context until first mousemove


  var o = options || {};

  if (o.moves === void 0) {
    o.moves = always;
  }

  if (o.accepts === void 0) {
    o.accepts = always;
  }

  if (o.invalid === void 0) {
    o.invalid = invalidTarget;
  }

  if (o.containers === void 0) {
    o.containers = initialContainers || [];
  }

  if (o.isContainer === void 0) {
    o.isContainer = never;
  }

  if (o.copy === void 0) {
    o.copy = false;
  }

  if (o.copySortSource === void 0) {
    o.copySortSource = false;
  }

  if (o.revertOnSpill === void 0) {
    o.revertOnSpill = false;
  }

  if (o.removeOnSpill === void 0) {
    o.removeOnSpill = false;
  }

  if (o.direction === void 0) {
    o.direction = 'vertical';
  }

  if (o.ignoreInputTextSelection === void 0) {
    o.ignoreInputTextSelection = true;
  }

  if (o.mirrorContainer === void 0) {
    o.mirrorContainer = doc$1.body;
  }

  var drake = emitter({
    containers: o.containers,
    start: manualStart,
    end: end,
    cancel: cancel,
    remove: remove,
    destroy: destroy,
    canMove: canMove,
    dragging: false
  });

  if (o.removeOnSpill === true) {
    drake.on('over', spillOver).on('out', spillOut);
  }

  events();
  return drake;

  function isContainer(el) {
    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);
  }

  function events(remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousedown', grab);
    touchy(documentElement, op, 'mouseup', release);
  }

  function eventualMovements(remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);
  }

  function movements(remove) {
    var op = remove ? 'remove' : 'add';
    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8

    crossvent[op](documentElement, 'click', preventGrabbed);
  }

  function destroy() {
    events(true);
    release({});
  }

  function preventGrabbed(e) {
    if (_grabbed) {
      e.preventDefault();
    }
  }

  function grab(e) {
    _moveX = e.clientX;
    _moveY = e.clientY;
    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;

    if (ignore) {
      return; // we only care about honest-to-god left clicks and touch events
    }

    var item = e.target;
    var context = canStart(item);

    if (!context) {
      return;
    }

    _grabbed = context;
    eventualMovements();

    if (e.type === 'mousedown') {
      if (isInput(item)) {
        // see also: https://github.com/bevacqua/dragula/issues/208
        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176
      } else {
        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155
      }
    }
  }

  function startBecauseMouseMoved(e) {
    if (!_grabbed) {
      return;
    }

    if (whichMouseButton(e) === 0) {
      release({});
      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope
    } // truthy check fixes #239, equality fixes #207


    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {
      return;
    }

    if (o.ignoreInputTextSelection) {
      var clientX = getCoord('clientX', e);
      var clientY = getCoord('clientY', e);
      var elementBehindCursor = doc$1.elementFromPoint(clientX, clientY);

      if (isInput(elementBehindCursor)) {
        return;
      }
    }

    var grabbed = _grabbed; // call to end() unsets _grabbed

    eventualMovements(true);
    movements();
    end();
    start(grabbed);
    var offset = getOffset(_item);
    _offsetX = getCoord('pageX', e) - offset.left;
    _offsetY = getCoord('pageY', e) - offset.top;
    classes.add(_copy || _item, 'gu-transit');
    renderMirrorImage();
    drag(e);
  }

  function canStart(item) {
    if (drake.dragging && _mirror) {
      return;
    }

    if (isContainer(item)) {
      return; // don't drag container itself
    }

    var handle = item;

    while (getParent(item) && isContainer(getParent(item)) === false) {
      if (o.invalid(item, handle)) {
        return;
      }

      item = getParent(item); // drag target should be a top element

      if (!item) {
        return;
      }
    }

    var source = getParent(item);

    if (!source) {
      return;
    }

    if (o.invalid(item, handle)) {
      return;
    }

    var movable = o.moves(item, source, handle, nextEl(item));

    if (!movable) {
      return;
    }

    return {
      item: item,
      source: source
    };
  }

  function canMove(item) {
    return !!canStart(item);
  }

  function manualStart(item) {
    var context = canStart(item);

    if (context) {
      start(context);
    }
  }

  function start(context) {
    if (isCopy(context.item, context.source)) {
      _copy = context.item.cloneNode(true);
      drake.emit('cloned', _copy, context.item, 'copy');
    }

    _source = context.source;
    _item = context.item;
    _initialSibling = _currentSibling = nextEl(context.item);
    drake.dragging = true;
    drake.emit('drag', _item, _source);
  }

  function invalidTarget() {
    return false;
  }

  function end() {
    if (!drake.dragging) {
      return;
    }

    var item = _copy || _item;
    drop(item, getParent(item));
  }

  function ungrab() {
    _grabbed = false;
    eventualMovements(true);
    movements(true);
  }

  function release(e) {
    ungrab();

    if (!drake.dragging) {
      return;
    }

    var item = _copy || _item;
    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);

    if (dropTarget && (_copy && o.copySortSource || !_copy || dropTarget !== _source)) {
      drop(item, dropTarget);
    } else if (o.removeOnSpill) {
      remove();
    } else {
      cancel();
    }
  }

  function drop(item, target) {
    var parent = getParent(item);

    if (_copy && o.copySortSource && target === _source) {
      parent.removeChild(_item);
    }

    if (isInitialPlacement(target)) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, target, _source, _currentSibling);
    }

    cleanup();
  }

  function remove() {
    if (!drake.dragging) {
      return;
    }

    var item = _copy || _item;
    var parent = getParent(item);

    if (parent) {
      parent.removeChild(item);
    }

    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);
    cleanup();
  }

  function cancel(revert) {
    if (!drake.dragging) {
      return;
    }

    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;
    var item = _copy || _item;
    var parent = getParent(item);
    var initial = isInitialPlacement(parent);

    if (initial === false && reverts) {
      if (_copy) {
        if (parent) {
          parent.removeChild(_copy);
        }
      } else {
        _source.insertBefore(item, _initialSibling);
      }
    }

    if (initial || reverts) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, parent, _source, _currentSibling);
    }

    cleanup();
  }

  function cleanup() {
    var item = _copy || _item;
    ungrab();
    removeMirrorImage();

    if (item) {
      classes.rm(item, 'gu-transit');
    }

    if (_renderTimer) {
      clearTimeout(_renderTimer);
    }

    drake.dragging = false;

    if (_lastDropTarget) {
      drake.emit('out', item, _lastDropTarget, _source);
    }

    drake.emit('dragend', item);
    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;
  }

  function isInitialPlacement(target, s) {
    var sibling;

    if (s !== void 0) {
      sibling = s;
    } else if (_mirror) {
      sibling = _currentSibling;
    } else {
      sibling = nextEl(_copy || _item);
    }

    return target === _source && sibling === _initialSibling;
  }

  function findDropTarget(elementBehindCursor, clientX, clientY) {
    var target = elementBehindCursor;

    while (target && !accepted()) {
      target = getParent(target);
    }

    return target;

    function accepted() {
      var droppable = isContainer(target);

      if (droppable === false) {
        return false;
      }

      var immediate = getImmediateChild(target, elementBehindCursor);
      var reference = getReference(target, immediate, clientX, clientY);
      var initial = isInitialPlacement(target, reference);

      if (initial) {
        return true; // should always be able to drop it right back where it was
      }

      return o.accepts(_item, target, _source, reference);
    }
  }

  function drag(e) {
    if (!_mirror) {
      return;
    }

    e.preventDefault();
    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var x = clientX - _offsetX;
    var y = clientY - _offsetY;
    _mirror.style.left = x + 'px';
    _mirror.style.top = y + 'px';
    var item = _copy || _item;
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;

    if (changed || dropTarget === null) {
      out();
      _lastDropTarget = dropTarget;
      over();
    }

    var parent = getParent(item);

    if (dropTarget === _source && _copy && !o.copySortSource) {
      if (parent) {
        parent.removeChild(item);
      }

      return;
    }

    var reference;
    var immediate = getImmediateChild(dropTarget, elementBehindCursor);

    if (immediate !== null) {
      reference = getReference(dropTarget, immediate, clientX, clientY);
    } else if (o.revertOnSpill === true && !_copy) {
      reference = _initialSibling;
      dropTarget = _source;
    } else {
      if (_copy && parent) {
        parent.removeChild(item);
      }

      return;
    }

    if (reference === null && changed || reference !== item && reference !== nextEl(item)) {
      _currentSibling = reference;
      dropTarget.insertBefore(item, reference);
      drake.emit('shadow', item, dropTarget, _source);
    }

    function moved(type) {
      drake.emit(type, item, _lastDropTarget, _source);
    }

    function over() {
      if (changed) {
        moved('over');
      }
    }

    function out() {
      if (_lastDropTarget) {
        moved('out');
      }
    }
  }

  function spillOver(el) {
    classes.rm(el, 'gu-hide');
  }

  function spillOut(el) {
    if (drake.dragging) {
      classes.add(el, 'gu-hide');
    }
  }

  function renderMirrorImage() {
    if (_mirror) {
      return;
    }

    var rect = _item.getBoundingClientRect();

    _mirror = _item.cloneNode(true);
    _mirror.style.width = getRectWidth(rect) + 'px';
    _mirror.style.height = getRectHeight(rect) + 'px';
    classes.rm(_mirror, 'gu-transit');
    classes.add(_mirror, 'gu-mirror');
    o.mirrorContainer.appendChild(_mirror);
    touchy(documentElement, 'add', 'mousemove', drag);
    classes.add(o.mirrorContainer, 'gu-unselectable');
    drake.emit('cloned', _mirror, _item, 'mirror');
  }

  function removeMirrorImage() {
    if (_mirror) {
      classes.rm(o.mirrorContainer, 'gu-unselectable');
      touchy(documentElement, 'remove', 'mousemove', drag);
      getParent(_mirror).removeChild(_mirror);
      _mirror = null;
    }
  }

  function getImmediateChild(dropTarget, target) {
    var immediate = target;

    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {
      immediate = getParent(immediate);
    }

    if (immediate === documentElement) {
      return null;
    }

    return immediate;
  }

  function getReference(dropTarget, target, x, y) {
    var horizontal = o.direction === 'horizontal';
    var reference = target !== dropTarget ? inside() : outside();
    return reference;

    function outside() {
      // slower, but able to figure out any position
      var len = dropTarget.children.length;
      var i;
      var el;
      var rect;

      for (i = 0; i < len; i++) {
        el = dropTarget.children[i];
        rect = el.getBoundingClientRect();

        if (horizontal && rect.left + rect.width / 2 > x) {
          return el;
        }

        if (!horizontal && rect.top + rect.height / 2 > y) {
          return el;
        }
      }

      return null;
    }

    function inside() {
      // faster, but only available if dropped inside a child element
      var rect = target.getBoundingClientRect();

      if (horizontal) {
        return resolve(x > rect.left + getRectWidth(rect) / 2);
      }

      return resolve(y > rect.top + getRectHeight(rect) / 2);
    }

    function resolve(after) {
      return after ? nextEl(target) : target;
    }
  }

  function isCopy(item, container) {
    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);
  }
}

function touchy(el, op, type, fn) {
  var touch = {
    mouseup: 'touchend',
    mousedown: 'touchstart',
    mousemove: 'touchmove'
  };
  var pointers = {
    mouseup: 'pointerup',
    mousedown: 'pointerdown',
    mousemove: 'pointermove'
  };
  var microsoft = {
    mouseup: 'MSPointerUp',
    mousedown: 'MSPointerDown',
    mousemove: 'MSPointerMove'
  };

  if (commonjsGlobal.navigator.pointerEnabled) {
    crossvent[op](el, pointers[type], fn);
  } else if (commonjsGlobal.navigator.msPointerEnabled) {
    crossvent[op](el, microsoft[type], fn);
  } else {
    crossvent[op](el, touch[type], fn);
    crossvent[op](el, type, fn);
  }
}

function whichMouseButton(e) {
  if (e.touches !== void 0) {
    return e.touches.length;
  }

  if (e.which !== void 0 && e.which !== 0) {
    return e.which;
  } // see https://github.com/bevacqua/dragula/issues/261


  if (e.buttons !== void 0) {
    return e.buttons;
  }

  var button = e.button;

  if (button !== void 0) {
    // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575
    return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
}

function getOffset(el) {
  var rect = el.getBoundingClientRect();
  return {
    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),
    top: rect.top + getScroll('scrollTop', 'pageYOffset')
  };
}

function getScroll(scrollProp, offsetProp) {
  if (typeof commonjsGlobal[offsetProp] !== 'undefined') {
    return commonjsGlobal[offsetProp];
  }

  if (documentElement.clientHeight) {
    return documentElement[scrollProp];
  }

  return doc$1.body[scrollProp];
}

function getElementBehindPoint(point, x, y) {
  var p = point || {};
  var state = p.className;
  var el;
  p.className += ' gu-hide';
  el = doc$1.elementFromPoint(x, y);
  p.className = state;
  return el;
}

function never() {
  return false;
}

function always() {
  return true;
}

function getRectWidth(rect) {
  return rect.width || rect.right - rect.left;
}

function getRectHeight(rect) {
  return rect.height || rect.bottom - rect.top;
}

function getParent(el) {
  return el.parentNode === doc$1 ? null : el.parentNode;
}

function isInput(el) {
  return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable$1(el);
}

function isEditable$1(el) {
  if (!el) {
    return false;
  } // no parents were editable


  if (el.contentEditable === 'false') {
    return false;
  } // stop the lookup


  if (el.contentEditable === 'true') {
    return true;
  } // found a contentEditable element in the chain


  return isEditable$1(getParent(el)); // contentEditable is set to 'inherit'
}

function nextEl(el) {
  return el.nextElementSibling || manually();

  function manually() {
    var sibling = el;

    do {
      sibling = sibling.nextSibling;
    } while (sibling && sibling.nodeType !== 1);

    return sibling;
  }
}

function getEventHost(e) {
  // on touchend event, we have to use `e.changedTouches`
  // see http://stackoverflow.com/questions/7192563/touchend-event-properties
  // see https://github.com/bevacqua/dragula/issues/34
  if (e.targetTouches && e.targetTouches.length) {
    return e.targetTouches[0];
  }

  if (e.changedTouches && e.changedTouches.length) {
    return e.changedTouches[0];
  }

  return e;
}

function getCoord(coord, e) {
  var host = getEventHost(e);
  var missMap = {
    pageX: 'clientX',
    // IE8
    pageY: 'clientY' // IE8

  };

  if (coord in missMap && !(coord in host) && missMap[coord] in host) {
    coord = missMap[coord];
  }

  return host[coord];
}

var dragula_1 = dragula;(function () {
  var css = ".gu-mirror {\n  position: fixed !important;\n  margin: 0 !important;\n  z-index: 9999 !important;\n  opacity: 0.8;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";\n  filter: alpha(opacity=80);\n}\n.gu-hide {\n  display: none !important;\n}\n.gu-unselectable {\n  -webkit-user-select: none !important;\n  -moz-user-select: none !important;\n  -ms-user-select: none !important;\n  user-select: none !important;\n}\n.gu-transit {\n  opacity: 0.2;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";\n  filter: alpha(opacity=20);\n}\n";
  var head = document.getElementsByTagName('head')[0];
  var sheet = document.createElement('style');
  sheet.setAttribute('data-file', '/Users/danielkalen/sandbox/quickfield/node_modules/dragula/dist/dragula.css');
  sheet.innerHTML = css;
  head.appendChild(sheet);
})();

var RepeaterField;

RepeaterField = function () {
  class RepeaterField extends Field$1 {
    constructor() {
      var base, diff$$1;
      super(...arguments);
      this._calcFocusState = this._calcFocusState.bind(this);
      this._calcBlurState = this._calcBlurState.bind(this);
      this._emitSubmit = this.emit.bind(this, 'submit');
      this.groupLabel = IS$1$1.string(this.settings.numbering) ? this.settings.numbering : 'Item';
      this.labelRegex = new RegExp(`^${this.groupLabel} \\d+(?:\: )?`);
      this.state.collapsed = this.settings.startCollapsed && this.settings.collapsable;

      if (this._value == null) {
        this._value = [];
      }

      this.settings._groupSettings = primaryBuilder$1.notKeys(['inline', 'block']).clone(this.settings.groupSettings);
      this.settings.groupSettings = primaryBuilder$1.keys(['inline', 'block']).clone(this.settings.groupSettings);

      if (this.settings.style === 'block') {
        this.settings.autoWidth = true;
      }

      if (this.settings.field) {
        this.settings.singleMode = true;
      }

      if (this.settings.singleMode) {
        this.settings.fields = [this.settings.field || this.settings.fields];
      }

      if ((base = this.settings).value == null) {
        base.value = [];
      }

      if (this.settings.minItems && this.settings.value.length < this.settings.minItems) {
        diff$$1 = this.settings.minItems - this.settings.value.length;

        while (--diff$$1) {
          this.settings.value.push(null);
        }
      }

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var group, i, index, len, ref, values;
      values = [];
      ref = this._value;

      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        group = ref[index];
        values[index] = group.value;
      }

      return values;
    }

    _setValue(newValue) {
      var i, index, len, value;

      if (!IS$1$1.array(newValue)) {
        this.addItem(newValue, false, true);
      } else {
        for (index = i = 0, len = newValue.length; i < len; index = ++i) {
          value = newValue[index];

          if (this._value[index] != null) {
            this._value[index].value = value;
          } else {
            this.addItem(value, false, true);
          }
        }
      }

      return newValue;
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);
      this.el.state('collapsable', this.settings.collapsable);
      this.el.state(`${this.settings.style}Style`, true);
      this.el.raw._quickField = this.el.childf.innerwrap.raw._quickField = this;

      if (this.settings.dragdrop) {
        this.dragger = dragula_1([this.el.child.innerwrap.raw], {
          revertOnSpill: true,
          invalid: function (el) {
            var ref;
            return ((ref = el._quickElement) != null ? ref.ref : void 0) === 'addButton';
          }
        }); // moves: (_, __, el)-> el._quickElement?.ref is 'header'

        this.dragger.on('drop', () => {
          return this.reOrganize();
        });
      }
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_stateTriggers();

      this._attachBindings_value();
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('collapsed').of(this.state).to(collapsed => {
        return this.el.state('collapsed', collapsed);
      });
      return simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_display() {
      var group, i, len, ref;
      simplybind('width').of(this.state).to(width => {
        return this.el.style('width', width).state('definedWidth', width !== 'auto');
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);
      simplybind('showError', {
        updateOnBind: false
      }).of(this.state).to(showError => {
        var group, i, len, ref, results;
        ref = this._value;
        results = [];

        for (i = 0, len = ref.length; i < len; i++) {
          group = ref[i];
          results.push(group.state.showError = showError);
        }

        return results;
      });
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        simplybind('disabled').of(this.state).to('disabled').of(field.state);
      }
    }

    _attachBindings_stateTriggers() {
      var toggleCollapse;

      if (this.settings.collapsable) {
        toggleCollapse = () => {
          this.state.collapsed = !this.state.collapsed;
          return this.emit('collapsed', this.state.collapsed);
        };

        simplybind('event:click').of(this.el.child.collapse).to(toggleCollapse);
        simplybind('event:click').of(this.el.child.label).to(toggleCollapse);
        simplybind('collapsed').of(this.state).once.to(() => {
          return this._recalcDisplay();
        }).condition(function (collapsed) {
          return !collapsed;
        });
      }
    }

    _attachBindings_value() {
      simplybind('array:_value', {
        updateOnBind: true
      }).of(this).to((value, prevValue) => {
        if (value.length) {
          this._recalcLabels();
        }

        if (prevValue) {
          this.state.interacted = true;
          return this.state.valid = this.validate(void 0, true);
        }
      });
      simplybind('event:click').of(this.el.child.addButton).to(() => {
        return this.addItem().focus();
      });
    }

    _validate(providedValue, testUnrequired) {
      var group, i, isValid, len, ref;
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        isValid = group.validate(providedValue[group.name], testUnrequired);

        if (!isValid) {
          return false;
        }
      }

      return true;
    }

    _calcFocusState() {
      return this.state.focused = this._value.some(function (field) {
        return field.state.focused;
      });
    }

    _calcBlurState() {
      return setTimeout(this._calcFocusState);
    }

    focus() {
      var ref;
      return (ref = this._value[0]) != null ? ref.focus() : void 0;
    }

    blur() {
      var field, i, len, ref;
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field.blur) {
          field.blur();
        }
      }
    }

    _recalcLabels() {
      var group, i, index, len, ref;

      if (this.settings.style === 'block') {
        if (!this.settings.numbering && !this.settings.dynamicLabel) {
          return;
        }

        ref = this._value;

        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          group = ref[index];

          this._recalcLabel(group, index);
        }
      }
    }

    _recalcLabel(group, index) {
      var existingLabel, newLabel;

      if (this.settings.dynamicLabel && group.fields[this.settings.dynamicLabel]) {
        newLabel = group.fields[this.settings.dynamicLabel].value;
      } else {
        existingLabel = group.state.label || '';
        existingLabel = existingLabel.replace(this.labelRegex, '');
        newLabel = `${this.groupLabel} ${index + 1}`;

        if (existingLabel) {
          newLabel += `: ${existingLabel}`;
        }
      }

      return group.state.label = newLabel;
    }

    _recalcDisplay() {
      var group, i, len, ref;
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];

        if (group._recalcDisplay) {
          group._recalcDisplay();
        }
      }
    }

    addItem(value, skipInsert, skipEmit) {
      var firstField, group, margin, refreshChildren, required, settings;

      if (this.settings.maxItems && this._value.length === this.settings.maxItems || this.state.disabled) {
        return;
      }

      margin = this.settings.style === 'inline' ? `0 ${this.settings.groupMargin}px ${this.settings.groupMargin}px 0` : `0 0 ${this.settings.groupMargin}px 0`;
      required = this.settings.required;
      settings = primaryBuilder$1({
        type: 'group',
        fields: this.settings.fields,
        required,
        margin,
        value
      }, this.settings._groupSettings, this.settings.groupSettings[this.settings.style]);

      if (this.settings.singleMode) {
        firstField = this.settings.fields[0].name;

        settings.getter = function (fields) {
          return fields[firstField];
        };

        settings.setter = function (value) {
          return {
            [`${firstField}`]: value
          };
        };
      }

      group = this.builder(settings);
      group.el.child.actions.append(this.settings.groupSettings[this.settings.style]);

      if (this.settings.cloneable) {
        group.addAction('clone', this.templates.cloneIcon, this.cloneItem.bind(this, group), this.settings.style === 'block');
      }

      if (this.settings.removeable) {
        group.addAction('remove', this.templates.removeIcon, this.removeItem.bind(this, group), this.settings.style === 'block');
      }

      group.on('focus', this._calcFocusState);
      group.on('blur', this._calcBlurState);
      group.on('submit', this._emitSubmit);
      simplybind('event:input').of(group).to(() => {
        return this.emit('input', this._value, group);
      });
      simplybind('disabled').of(this.state).to('disabled').of(group.state);
      refreshChildren = group.el.childf;

      if (this.settings.dynamicLabel) {
        group.on('input', () => {
          return this._recalcLabel(group);
        });
      }

      if (this.settings.autoRemoveEmpty) {
        group.once('blur', () => {
          if (!group.state.interacted) {
            return this.removeItem(group);
          }
        });
      }

      if (!this.settings.autoWidth) {
        group.state.width = this.settings.groupWidth;
        group.el.child.innerwrap.once('inserted', function () {
          return this.style('width', `calc(100% - ${this.parent.child.actions.width || 17}px)`);
        });
      }

      if (!skipInsert) {
        group.insertBefore(this.el.child.addButton);

        if (!skipEmit) {
          this.emit('itemAdd', group);
        }

        this._value.push(group);
      }

      return group;
    }

    cloneItem(group) {
      var clone;

      if (this.settings.maxItems && this._value.length === this.settings.maxItems || this.state.disabled) {
        return;
      }

      if (!includes$2(this._value, group)) {
        return;
      }

      clone = this.addItem(group.value, true);
      clone.insertAfter(group.el);
      insertAfter$1(this._value, group, clone);
      this.emit('itemAdd', clone);
      this.emit('itemClone', clone);
      this.reOrganize();
      return clone;
    }

    removeItem(group) {
      var ref, removed, targetIndex;

      if (this.settings.minItems && this._value.length === this.settings.minItems || this.state.disabled) {
        return;
      }

      targetIndex = Math.max(1, this._value.indexOf(group));

      if (removed = removeItem$1(this._value, group)) {
        group.destroy();
        this.emit('itemRemove', group);

        if ((ref = this._value[targetIndex - 1]) != null) {
          ref.focus();
        }
      }

      this.reOrganize();
      return !!removed;
    }

    reOrganize() {
      var children;
      children = [].slice.call(this.el.child.innerwrap.raw.childNodes, 0, -1);
      return this._value = children.map(function (entry) {
        return entry._quickField;
      });
    }

  }

  RepeaterField.prototype.template = template$8;
  RepeaterField.prototype.templates = templates$8;
  RepeaterField.prototype.defaults = defaults$9;
  RepeaterField.prototype.shallowSettings = ['fields'];
  return RepeaterField;
}.call(undefined);

var RepeaterField$1 = RepeaterField;var defaults$a = {
  alwaysValid: false,
  labelClicks: false,
  size: 15,
  fontSize: 13,
  display: 'block',
  colors: {
    text: COLORS$1.grey,
    symbol: COLORS$1.orange,
    background: 'white'
  }
};var template$9 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    boxSizing: 'border-box',
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    textAlign: 'left',
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    }
  }
}, ['div', {
  ref: 'innerwrap',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    fontFamily: 'inherit',
    display: 'flex',
    flexWrap: 'nowrap',
    alignContent: 'flex-start',
    alignItems: 'flex-start'
  }
}, ['div', {
  ref: 'input',
  style: {
    position: 'relative',
    alignSelf: 'start',
    zIndex: 2,
    flexGrow: 0,
    flexShrink: 0,
    width: function (field) {
      return field.settings.size;
    },
    height: function (field) {
      return field.settings.size;
    },
    margin: '0 auto',
    backgroundColor: function (field) {
      return field.settings.colors.background;
    },
    border: `1px solid ${COLORS$1.grey_light}`,
    borderRadius: 3,
    cursor: 'pointer',
    $showError: {
      borderColor: COLORS$1.red
    }
  }
}, [// $toggled:
// 	borderColor: (field)-> field.settings.colors.symbol
'div', {
  ref: 'checkmark',
  style: {
    position: 'absolute',
    zIndex: 2,
    left: 0,
    right: 0,
    top: '50%',
    transform: 'translateY(-50%)',
    width: function (field) {
      return field.settings.size / 1.5;
    },
    height: function (field) {
      return field.settings.size / 1.5;
    },
    margin: '0 auto',
    boxSizing: 'border-box',
    lineHeight: 0,
    userSelect: 'none',
    display: 'none',
    $toggled: {
      display: 'block'
    }
  }
}, checkmark.extend({
  style: {
    width: '100%',
    height: '100%',
    stroke: function (field) {
      return field.settings.colors.symbol;
    },
    outline: 'none'
  }
})]], ['div', {
  ref: 'label',
  style: {
    display: 'none',
    marginLeft: 5,
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.fontSize;
    },
    color: COLORS$1.black,
    cursor: 'default',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    }
  }
}]], [// $showError:
// 	color: COLORS.red
'div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}]]);
var templates$9 =
/*#__PURE__*/
Object.freeze({
  default: template$9
});var CheckboxField;

CheckboxField = function () {
  class CheckboxField extends Field$1 {
    constructor() {
      super(...arguments);
      this._value = !!this._value;
      this.settings.size = parseFloat(this.settings.size) || defaults$a.size;

      if (this.settings.display !== 'block' && this.settings.display !== 'inline') {
        this.settings.display = defaults$a.display;
      }

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      return this._value;
    }

    _setValue(newValue) {
      return this._value = !!newValue;
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);
      this.el.child.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_stateTriggers();

      this._attachBindings_display();

      this._attachBindings_value();

      setTimeout(() => {
        return simplybind('label').of(this.state).to('html').of(this.el.child.label);
      });
    }

    _attachBindings_value() {
      simplybind('_value').of(this).to(value => {
        return this.el.state('toggled', value);
      });
      simplybind('_value', {
        updateOnBind: false
      }).of(this).to(value => {
        return this.emit('input', value);
      });
      simplybind("event:click").of(this.el.child.input).to(() => {
        return this.value = !this._value;
      });

      if (this.settings.labelClicks) {
        simplybind("event:click").of(this.el.child.label).to(() => {
          return this.value = !this._value;
        });
      }
    }

    _validate(providedValue) {
      if (this.settings.validWhenTrue) {
        if (!providedValue) {
          return false;
        }
      }

      return true;
    }

  }

  CheckboxField.prototype.template = template$9;
  CheckboxField.prototype.templates = templates$9;
  CheckboxField.prototype.defaults = defaults$a;
  return CheckboxField;
}.call(undefined);

inheritProto(CheckboxField, ChoiceField$1, ['_attachBindings_elState', '_attachBindings_stateTriggers', '_attachBindings_display']);
var CheckboxField$1 = CheckboxField;var assert$1, emitEvent, expect$1;
chai$2.use(chaiDom);
chai$2.use(sources);
chai$2.use(chaiAlmost_1);
chai$2.use(asserttype);
chai$2.use(chaiEvents);
chai$2.config.truncateThreshold = 1e3;
mocha.setup('tdd');
mocha.slow(400);
mocha.timeout(12000);

if (!window.__karma__) {
  mocha.bail();
}

assert$1 = chai$2.assert;
expect$1 = chai$2.expect;
window.sandbox = null;
quickfield$1$1.register('textarea', TextareaField$1);
quickfield$1$1.register('number', NumberField$1);
quickfield$1$1.register('select', SelectField$1);
quickfield$1$1.register('choice', ChoiceField$1);
quickfield$1$1.register('truefalse', TrueFalseField$1);
quickfield$1$1.register('toggle', ToggleField$1);
quickfield$1$1.register('group', GroupField$1);
quickfield$1$1.register('repeater', RepeaterField$1);
quickfield$1$1.register('checkbox', CheckboxField$1); // quickfield.register('file', FileField)

window.quickfield = quickfield$1$1;

emitEvent = function (target, event, trigger) {
  var promise;
  promise = pEvent(target, event);
  trigger();
  return promise;
};

suite("QuickField", function () {
  teardown(function () {
    var lastChild;
    lastChild = sandbox.children[sandbox.children.length - 1];

    if ((lastChild != null ? lastChild.ref : void 0) === 'testTitle') {
      return lastChild.remove();
    }
  });
  suiteSetup(function () {
    return restartSandbox$1();
  });
  suite("creation", function () {
    teardown(restartSandbox$1);
    test("text field", function () {
      var field;
      field = quickfield$1$1({
        type: 'text'
      }).appendTo(sandbox);
      assert$1.equal(field.el.parent, sandbox);
      return assert$1.equal(field.el.child.input.attr('type'), 'text');
    });
    test("textarea field", function () {
      var field;
      field = quickfield$1$1({
        type: 'textarea'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("number field", function () {
      var field;
      field = quickfield$1$1({
        type: 'number'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("select field", function () {
      var field;
      field = quickfield$1$1({
        type: 'select'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("choice field", function () {
      var field;
      field = quickfield$1$1({
        type: 'choice',
        choices: ['a', 'b']
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("truefalse field", function () {
      var field;
      field = quickfield$1$1({
        type: 'truefalse'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("toggle field", function () {
      var field;
      field = quickfield$1$1({
        type: 'toggle'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    return suite("misc", function () {
      return test("with multiple options object", function () {
        var config, field1, field2;
        config = {
          type: 'text',
          label: 'abc',
          value: '123'
        };
        field1 = quickfield$1$1(config);
        field2 = quickfield$1$1(config, {
          label: 'def'
        }, {
          height: 50,
          value: '456'
        });
        expect$1(config).to.eql({
          type: 'text',
          label: 'abc',
          value: '123'
        });
        expect$1(field1.settings.label).to.equal('abc');
        expect$1(field2.settings.label).to.equal('def');
        expect$1(field1.settings.height).to.equal(46);
        expect$1(field2.settings.height).to.equal(50);
        expect$1(field1.value).to.equal('123');
        return expect$1(field2.value).to.equal('456');
      });
    });
  });
  suite("text field", function () {
    suiteSetup(function () {
      addTitle("text field");
      return this.control = quickfield$1$1({
        type: 'text',
        label: 'Regular'
      }).appendTo(sandbox);
    });
    teardown(function () {
      return this.control.value = '';
    });
    test("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, setter;

      getter = function (value) {
        return `example.com/${value}`;
      };

      setter = function (value) {
        return value.toLowerCase();
      };

      fieldA = quickfield$1$1({
        type: 'text',
        label: 'path',
        getter
      });
      fieldB = quickfield$1$1({
        type: 'text',
        label: 'path',
        setter
      });
      fieldC = quickfield$1$1({
        type: 'text',
        label: 'path',
        getter,
        setter
      });
      expect$1(fieldA.value).to.equal('example.com/');
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldB.value).to.equal('');
      expect$1(fieldB.el.child.input.raw.value).to.equal('');
      expect$1(fieldC.value).to.equal('example.com/');
      expect$1(fieldC.el.child.input.raw.value).to.equal('');
      simulateKeys(fieldA.el.child.input.raw, 'AbC');
      simulateKeys(fieldB.el.child.input.raw, 'AbC');
      simulateKeys(fieldC.el.child.input.raw, 'AbC');
      expect$1(fieldA.value).to.equal('example.com/AbC');
      expect$1(fieldA.el.child.input.raw.value).to.equal('AbC');
      expect$1(fieldB.value).to.equal('abc');
      expect$1(fieldB.el.child.input.raw.value).to.equal('abc');
      expect$1(fieldC.value).to.equal('example.com/abc');
      expect$1(fieldC.el.child.input.raw.value).to.equal('abc');
      fieldA.value = 'DeF';
      fieldB.value = 'DeF';
      fieldC.value = 'DeF';
      expect$1(fieldA.value).to.equal('example.com/DeF');
      expect$1(fieldA.el.child.input.raw.value).to.equal('DeF');
      expect$1(fieldB.value).to.equal('def');
      expect$1(fieldB.el.child.input.raw.value).to.equal('def');
      expect$1(fieldC.value).to.equal('example.com/def');
      return expect$1(fieldC.el.child.input.raw.value).to.equal('def');
    });
    test("with help message", function () {
      var field;
      field = quickfield$1$1({
        type: 'text',
        label: 'With Help Message',
        help: 'help <b>message</b> here'
      }).appendTo(sandbox);
      expect$1(field.el.text).to.include('help message here');
      expect$1(field.els.help.html).to.equal('help <b>message</b> here');
      expect$1(this.control.els.help.html).to.equal('');
      expect$1(this.control.el.raw).to.have.style('marginBottom', '0px');
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      field.state.help = '';
      expect$1(field.el.raw).to.have.style('marginBottom', '0px');
      expect$1(field.els.help.html).to.equal('');
      field.state.error = 'abc123';
      expect$1(field.el.raw).to.have.style('marginBottom', '0px');
      expect$1(field.els.help.html).to.equal('');
      field.state.showError = true;
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      expect$1(field.els.help.html).to.equal('abc123');
      field.state.help = 'def456';
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      expect$1(field.els.help.html).to.equal('def456');
      field.state.help = '';
      field.state.showError = false;
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      return expect$1(field.els.help.html).to.equal('help <b>message</b> here');
    });
    test("without label", function () {
      var initialTop, withLabel, withoutLabel;
      withLabel = quickfield$1$1({
        type: 'text',
        label: 'With Label'
      }).appendTo(sandbox);
      withoutLabel = quickfield$1$1({
        type: 'text',
        placeholder: 'Without Label'
      }).appendTo(sandbox);
      quickdom.batch([withLabel.els.label, withLabel.els.innerwrap, withLabel.els.input, withoutLabel.els.label, withoutLabel.els.innerwrap, withoutLabel.els.input]).style('transition', null);
      assert$1.equal(withLabel.el.child.placeholder.html, 'With Label');
      assert$1.equal(withLabel.el.child.label.html, 'With Label');
      assert$1.equal(withLabel.el.child.label.style('opacity'), '0');
      assert$1.equal(withoutLabel.el.child.placeholder.html, 'Without Label');
      assert$1.notEqual(withoutLabel.el.child.label.html, 'Without Label');
      assert$1.equal(withoutLabel.el.child.label.style('opacity'), '0');
      initialTop = {
        withLabel: withLabel.el.child.input.rect.top,
        withoutLabel: withoutLabel.el.child.input.rect.top
      };
      withLabel.value = 'abc123';
      withoutLabel.value = 'abc123';
      assert$1.notEqual(withLabel.el.child.input.rect.top, initialTop.withLabel);
      assert$1.equal(withoutLabel.el.child.input.rect.top, initialTop.withoutLabel);
      assert$1.equal(withLabel.el.child.label.style('opacity'), '1');
      return assert$1.equal(withoutLabel.el.child.label.style('opacity'), '0');
    });
    test("with icon", function () {
      var iconField;
      return iconField = quickfield$1$1({
        type: 'text',
        label: 'With Icon',
        icon: 'B'
      }).appendTo(sandbox);
    });
    test("custom height/fontsize", function () {
      var fieldA, fieldB;
      fieldA = quickfield$1$1({
        type: 'text',
        label: 'Custom Height',
        height: 40,
        fontSize: 13,
        autoWidth: true
      }).appendTo(sandbox);
      fieldB = quickfield$1$1({
        type: 'text',
        label: 'Custom Height',
        height: 60,
        fontSize: 16,
        autoWidth: true
      }).appendTo(sandbox);
      assert$1.isAtLeast(this.control.el.height, this.control.settings.height);
      assert$1.isAtMost(this.control.el.height, this.control.settings.height + 5);
      assert$1.isAtLeast(fieldA.el.height, 40);
      assert$1.isAtMost(fieldA.el.height, 45);
      assert$1.isAtLeast(fieldB.el.height, 60);
      return assert$1.isAtMost(fieldB.el.height, 65);
    });
    test("custom border", function () {
      var custom;
      custom = quickfield$1$1({
        type: 'text',
        label: 'Custom Border',
        border: '0 0 2px 0'
      }).appendTo(sandbox);
      assert$1.deepEqual(getBorderSides(this.control.el.child.innerwrap), {
        top: '1px',
        left: '1px',
        right: '1px',
        bottom: '1px'
      });
      return assert$1.deepEqual(getBorderSides(custom.el.child.innerwrap), {
        top: '0px',
        left: '0px',
        right: '0px',
        bottom: '2px'
      });
    });
    test("default value", function () {
      var fieldA, fieldB, fieldC;
      fieldA = quickfield$1$1({
        type: 'text'
      });
      fieldB = quickfield$1$1({
        type: 'text',
        defaultValue: 'valueB'
      });
      fieldC = quickfield$1$1({
        type: 'text',
        value: 'valueC'
      });
      assert$1.equal(fieldA.value, '');
      assert$1.equal(fieldA.el.child.input.raw.value, '');
      assert$1.equal(fieldB.value, 'valueB');
      assert$1.equal(fieldB.el.child.input.raw.value, 'valueB');
      assert$1.equal(fieldC.value, 'valueC');
      return assert$1.equal(fieldC.el.child.input.raw.value, 'valueC');
    });
    test("disabled", function () {
      var fieldA, fieldB;
      fieldA = quickfield$1$1({
        type: 'text',
        label: 'Disabled',
        autoWidth: true,
        disabled: true
      }).appendTo(sandbox);
      fieldB = quickfield$1$1({
        type: 'text',
        label: 'Disabled w/ value',
        autoWidth: true,
        disabled: true,
        value: 'abc123'
      }).appendTo(sandbox);
      window.assert = assert$1;
      expect$1(this.control.value).to.equal('');
      expect$1(this.control.el.child.input.raw.value).to.equal('');
      expect$1(this.control.el.child.innerwrap.raw).to.have.style('backgroundColor', 'white');
      expect$1(fieldA.value).to.equal('');
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldA.el.child.innerwrap.raw).to.have.style('backgroundColor', COLORS.grey_light);
      expect$1(fieldB.value).to.equal('abc123');
      expect$1(fieldB.el.child.input.raw.value).to.equal('abc123');
      return expect$1(fieldB.el.child.innerwrap.raw).to.have.style('backgroundColor', COLORS.grey_light);
    }); // expect(@control.state.focused).to.equal false
    // @control.focus()
    // expect(@control.state.focused).to.equal true
    // expect(fieldA.state.focused).to.equal false
    // fieldA.focus()
    // Promise.delay(5).then ()->
    // 	expect(fieldA.state.focused).to.equal false

    test("conditions", function () {
      var master, slave;
      master = quickfield$1$1({
        type: 'text',
        label: 'Master Field',
        ID: 'masterField',
        mask: 'aaa-111',
        required: true,
        autoWidth: true
      }).appendTo(sandbox);
      return slave = quickfield$1$1({
        type: 'text',
        label: 'Slave Field',
        conditions: [{
          target: 'masterField'
        }],
        autoWidth: true
      }).appendTo(sandbox);
    });
    test("autowidth", function () {
      var field;
      return field = quickfield$1$1({
        type: 'text',
        label: 'Autowidth',
        autoWidth: true,
        checkmark: false
      }).appendTo(sandbox);
    });
    test("input event", function () {
      var count, field, input;
      count = 0;
      field = this.control;
      input = field.els.input.raw;
      field.on('input', function () {
        return count++;
      });
      return Promise.resolve().then(function () {
        return expect$1(count).to.equal(0);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return field.value = 'change';
        });
      }).then(function () {
        return expect$1(count).to.equal(1);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return field.value = 'change2';
        });
      }).then(function () {
        return expect$1(count).to.equal(2);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return simulateKeys(input, 'a');
        });
      }).then(function () {
        return expect$1(count).to.equal(3);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return simulateKeys(input, 'abc');
        });
      }).then(function () {
        return expect$1(count).to.equal(6);
      });
    });
    suite("options/autocomplete", function () {
      suiteSetup(function () {
        this.field = quickfield$1$1({
          type: 'text',
          label: 'My options field',
          choices: ['apple', 'banana', 'orange', 'banana republic', {
            label: 'orange split',
            value: 'split'
          }]
        }).appendTo(sandbox);
        this.choices = this.field.dropdown.choices;
        this.dropdownEl = this.field.dropdown.els.container.raw;
        return this.inputEl = this.field.el.child.input.raw;
      });
      teardown(function () {
        this.field.blur();
        return this.field.value = '';
      });
      test("triggering", function () {
        return Promise.bind(this).then(function () {
          var promise;
          expect$1(this.dropdownEl).not.to.be.displayed;
          promise = pEvent(this.field.el.child.input, 'focus');
          this.field.focus();
          return promise;
        }).then(function () {
          var promise;
          expect$1(this.dropdownEl).not.to.be.displayed;
          simulateKeys(this.inputEl, 'a');
          expect$1(this.dropdownEl).to.be.displayed;
          promise = pEvent(this.field.el.child.input, 'blur');
          this.field.blur();
          return promise;
        }).then(function () {
          expect$1(this.dropdownEl).not.to.be.displayed;
          this.field.focus();
          simulateAction(this.inputEl, 'down');
          return expect$1(this.dropdownEl).not.to.be.displayed;
        }).then(function () {
          simulateKeys(this.inputEl, 'a');
          return expect$1(this.dropdownEl).to.be.displayed;
        }).then(function () {
          var promise;
          promise = pEvent(this.field.el.child.input, 'blur');
          this.field.blur();
          return promise;
        }).then(function () {
          this.field.dropdown.isOpen = true;
          expect$1(this.dropdownEl).to.be.displayed;
          this.field.dropdown.isOpen = false;
          return expect$1(this.dropdownEl).not.to.be.displayed;
        });
      });
      test("highlighting", function () {
        this.field.focus();
        simulateKeys(this.inputEl, 'a');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(null);
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[0]);
        simulateAction(this.inputEl, 'down');
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[2]);
        simulateAction(this.inputEl, 'down');
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[4]);
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[0]);
        simulateAction(this.inputEl, 'up');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[4]);
        simulateAction(this.inputEl, 'up');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[3]);
        this.field.blur();
        return expect$1(this.field.dropdown.currentHighlighted).to.equal(null);
      });
      test("filtering", function () {
        var getVisible;

        getVisible = () => {
          return this.choices.filter(function (choice) {
            return choice.visible;
          }).map(function (choice) {
            return choice.value;
          });
        };

        this.field.focus();
        expect$1(getVisible()).to.eql(['apple', 'banana', 'orange', 'banana republic', 'split']);
        simulateKeys(this.inputEl, 'ban');
        expect$1(getVisible()).to.eql(['banana', 'banana republic']);
        simulateKeys(this.inputEl, 'ana');
        expect$1(getVisible()).to.eql(['banana', 'banana republic']);
        simulateKeys(this.inputEl, ' ');
        expect$1(getVisible()).to.eql(['banana republic']);
        this.field.value = 'ora';
        return expect$1(getVisible()).to.eql(['orange', 'split']);
      });
      return test("selecting", function () {
        this.field.focus();
        expect$1(this.field.value).to.equal('');
        this.choices[1].el.emit('click');
        expect$1(this.field.value).to.equal('banana');
        expect$1(this.inputEl.value).to.equal('banana');
        this.field.focus();
        this.field.state.typing = true;
        this.field.value = 'ora';
        simulateAction(this.inputEl, 'down');
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[4]);
        expect$1(this.field.value).to.equal('ora');
        expect$1(this.inputEl.value).to.equal('ora');
        simulateAction(this.inputEl, 'enter');
        expect$1(this.field.value).to.equal('split');
        expect$1(this.inputEl.value).to.equal('orange split');
        this.field.value = 'orange';
        expect$1(this.field.value).to.equal('orange');
        expect$1(this.inputEl.value).to.equal('orange');
        this.field.value = 'orange split';
        expect$1(this.field.value).to.equal('split');
        return expect$1(this.inputEl.value).to.equal('orange split');
      });
    });
    suite("keyboard/custom-type", function () {
      test("password", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Password',
          keyboard: 'password'
        }).appendTo(sandbox);
      });
      test("email", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Email',
          ID: 'email',
          keyboard: 'email',
          required: true
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Email',
          keyboard: 'email',
          mask: {
            guide: false
          },
          required: true
        }).appendTo(sandbox);
      });
      return test("number (simluated)", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Number (simluated)',
          keyboard: 'number',
          validWhenRegex: /[^0]/,
          autoWidth: true
        }).appendTo(sandbox);
      });
    });
    return suite("mask", function () {
      suiteSetup(function () {
        return addTitle('mask');
      });
      test("alpha", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Name',
          mask: 'NAME',
          width: '50%'
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Full Name',
          mask: 'FULLNAME',
          width: '50%'
        }).appendTo(sandbox);
      });
      test("numeric", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Phone',
          distance: 10,
          width: '50%',
          mobileWidth: '100%',
          mask: '(111) 111-1111'
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Phone',
          distance: 10,
          width: '50%',
          mobileWidth: '100%',
          keyboard: 'phone'
        }).appendTo(sandbox);
      });
      test("alphanumeric", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Licence Plate',
          mask: {
            pattern: 'aaa-111',
            transform: function (v) {
              return v.toUpperCase();
            }
          }
        }).appendTo(sandbox);
      });
      test("prefix", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Dollar',
          mask: {
            pattern: 'NUMBER',
            prefix: '$',
            decimal: true,
            sep: true
          }
        }).appendTo(sandbox);
      });
      test("date", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Date',
          keyboard: 'date',
          autoWidth: true
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Date',
          mask: {
            pattern: ['DATE', 'mm / yy']
          },
          autoWidth: true
        }).appendTo(sandbox);
      });
      test("literal", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Literal',
          mask: 'My N\\ame is a+ K\\alen'
        }).appendTo(sandbox);
      });
      test("optionals", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Optionals',
          mask: 'aaa[AAA]111'
        }).appendTo(sandbox);
      });
      return test("custom patterns", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Only specific chars',
          mask: {
            pattern: '&&+-aa-111-[ aa+]',
            customPatterns: {
              '&': /[ab12]/,
              'a': /[0-4]/
            }
          }
        }).appendTo(sandbox);
      });
    });
  });
  suite("number field", function () {
    suiteSetup(function () {
      return addTitle('number field');
    });
    test("basic", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: false
      }).appendTo(sandbox);
    });
    test.skip("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, setter;

      getter = function (value) {
        return (value || 0) * 10;
      };

      setter = function (value) {
        return (value || 0) * 2;
      };

      fieldA = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: true,
        getter
      });
      fieldB = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: true,
        setter
      });
      fieldC = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: true,
        getter,
        setter
      });
      expect$1(fieldA.value).to.equal(0);
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldB.value).to.equal(0);
      expect$1(fieldB.el.child.input.raw.value).to.equal('');
      expect$1(fieldC.value).to.equal(0);
      expect$1(fieldC.el.child.input.raw.value).to.equal('');
      simulateKeys(fieldA.el.child.input.raw, '3');
      simulateKeys(fieldB.el.child.input.raw, '3');
      simulateKeys(fieldC.el.child.input.raw, '3');
      expect$1(fieldA.value).to.equal(30);
      expect$1(fieldA.el.child.input.raw.value).to.equal('3');
      expect$1(fieldB.value).to.equal(6);
      expect$1(fieldB.el.child.input.raw.value).to.equal('6');
      expect$1(fieldC.value).to.equal(60);
      expect$1(fieldC.el.child.input.raw.value).to.equal('6');
      fieldA.value = 12;
      fieldB.value = 12;
      fieldC.value = 12;
      expect$1(fieldA.value).to.equal(120);
      expect$1(fieldA.el.child.input.raw.value).to.equal('12');
      expect$1(fieldB.value).to.equal(24);
      expect$1(fieldB.el.child.input.raw.value).to.equal('24');
      expect$1(fieldC.value).to.equal(240);
      return expect$1(fieldC.el.child.input.raw.value).to.equal('24');
    });
    test("min/max", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (min/max)',
        minValue: 10,
        maxValue: 1000,
        autoWidth: true
      }).appendTo(sandbox);
    });
    test("min/max/step", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (min/max/step)',
        minValue: 10,
        maxValue: 100,
        step: 3,
        autoWidth: true
      }).appendTo(sandbox);
    });
    test("min/max/step (enforced)", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (enforced)',
        minValue: 10,
        maxValue: 100,
        step: 12,
        enforce: true,
        autoWidth: true
      }).appendTo(sandbox);
    });
    return test("decimal step", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (decimal step)',
        minValue: 0.1,
        maxValue: 100,
        step: 0.1,
        autoWidth: true
      }).appendTo(sandbox);
    });
  });
  suite("textarea field", function () {
    suiteSetup(function () {
      return addTitle('textarea field');
    });
    test("basic", function () {
      var field;
      return field = quickfield$1$1({
        type: 'textarea',
        label: 'Textarea',
        width: '300px',
        height: '250px',
        autoHeight: false
      }).appendTo(sandbox);
    });
    test("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, setter;

      getter = function (value) {
        return `example.com/${value}`;
      };

      setter = function (value) {
        return value.toLowerCase();
      };

      fieldA = quickfield$1$1({
        type: 'textarea',
        label: 'path',
        getter
      });
      fieldB = quickfield$1$1({
        type: 'textarea',
        label: 'path',
        setter
      });
      fieldC = quickfield$1$1({
        type: 'textarea',
        label: 'path',
        getter,
        setter
      });
      expect$1(fieldA.value).to.equal('example.com/');
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldB.value).to.equal('');
      expect$1(fieldB.el.child.input.raw.value).to.equal('');
      expect$1(fieldC.value).to.equal('example.com/');
      expect$1(fieldC.el.child.input.raw.value).to.equal('');
      simulateKeys(fieldA.el.child.input.raw, 'AbC');
      simulateKeys(fieldB.el.child.input.raw, 'AbC');
      simulateKeys(fieldC.el.child.input.raw, 'AbC');
      expect$1(fieldA.value).to.equal('example.com/AbC');
      expect$1(fieldA.el.child.input.raw.value).to.equal('AbC');
      expect$1(fieldB.value).to.equal('abc');
      expect$1(fieldB.el.child.input.raw.value).to.equal('abc');
      expect$1(fieldC.value).to.equal('example.com/abc');
      expect$1(fieldC.el.child.input.raw.value).to.equal('abc');
      fieldA.value = 'DeF';
      fieldB.value = 'DeF';
      fieldC.value = 'DeF';
      expect$1(fieldA.value).to.equal('example.com/DeF');
      expect$1(fieldA.el.child.input.raw.value).to.equal('DeF');
      expect$1(fieldB.value).to.equal('def');
      expect$1(fieldB.el.child.input.raw.value).to.equal('def');
      expect$1(fieldC.value).to.equal('example.com/def');
      return expect$1(fieldC.el.child.input.raw.value).to.equal('def');
    });
    test("autoheight", function () {
      var field;
      return field = quickfield$1$1({
        type: 'textarea',
        label: 'Textarea (autoHeight)',
        width: '300px',
        maxHeight: 500
      }).appendTo(sandbox);
    });
    return test("autowidth", function () {
      var field;
      return field = quickfield$1$1({
        type: 'textarea',
        label: 'Textarea (autowidth)',
        autoWidth: true,
        maxWidth: 300
      }).appendTo(sandbox);
    });
  });
  suite("select field", function () {
    suiteSetup(function () {
      return addTitle('select field');
    });
    test("single selectable", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (single)',
        choices: ['Apple', 'Apple Juice', 'Banana', 'Orange', {
          label: 'Lemon',
          value: 'lime',
          conditions: {
            'email': 'valid'
          }
        }]
      }).appendTo(sandbox);
    });
    test("multi selectable", function () {
      var field;
      field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (multi)',
        choices: ['Apple', 'Banana', 'Orange', 'Lime', 'Kiwi'],
        multiple: true,
        defaultValue: 'Apple'
      }).appendTo(sandbox);
      return assert$1.equal(field.value, 'Apple');
    });
    test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (default)',
        choices: ['Apple', 'Banana', 'Orange', {
          label: 'Lemon',
          value: 'lime',
          conditions: {
            'email': 'valid'
          }
        }],
        value: 'Banana'
      }).appendTo(sandbox);
      assert$1.equal(field.value, 'Banana');
      field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (default)',
        value: 'Banana'
      }).appendTo(sandbox);
      return assert$1.equal(field.value, 'Banana');
    });
    test("cusotm border", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'Custom Border',
        choices: ['Apple', 'Banana', 'Orange'],
        border: '0 0 2px 0',
        margin: '0 0 30px'
      }).appendTo(sandbox);
    });
    test("no choices", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'No choices',
        autoWidth: true
      }).appendTo(sandbox);
    });
    return test("many choices", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'Many Choices',
        choices: companyNames,
        autoWidth: true
      }).appendTo(sandbox);
    });
  });
  suite("choice field", function () {
    suiteSetup(function () {
      addTitle('choice field');
      this.control = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true
      });
      return this.controlMulti = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true,
        multiple: true
      });
    });
    test("single selectable", function () {
      var field;
      return field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (single)',
        choices: ['Apple', 'Banana', 'Orange']
      }).appendTo(sandbox);
    });
    test("multi selectable", function () {
      var field;
      return field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (multi)',
        choices: ['Apple', 'Banana', 'Orange', 'Lime', 'Kiwi'],
        perGroup: 3,
        multiple: true
      }).appendTo(sandbox);
    });
    test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (single)',
        choices: ['Apple', 'Banana', 'Orange'],
        value: 'Orange'
      }).appendTo(sandbox);
      assert$1.equal(field.value, 'Orange');
      assert$1.equal(field.findChoice('Orange').selected, true);
      field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (multi)',
        choices: ['Apple', 'Banana', 'Orange', 'Lime', 'Kiwi'],
        multiple: true,
        value: ['Banana', 'Lime']
      }).appendTo(sandbox);
      assert$1.deepEqual(field.value, ['Banana', 'Lime']);
      assert$1.equal(field.findChoice('Banana').selected, true);
      return assert$1.equal(field.findChoice('Lime').selected, true);
    });
    test("conditions", function () {
      var field, master;
      master = quickfield$1$1({
        type: 'text',
        ID: 'master',
        required: true
      }).appendTo(sandbox);
      return field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (single)',
        choices: ['Apple', {
          label: 'Banana',
          value: 'banana',
          conditions: {
            'master': /^bana/
          }
        }, 'Orange', {
          label: 'Lemon',
          value: 'lime',
          conditions: {
            'master': 'valid'
          }
        }]
      }).appendTo(sandbox);
    });
    test("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, ref, ref1, ref2, ref3, ref4, ref5, setter;

      getter = function (value) {
        return (value != null ? value.toUpperCase() : void 0) || value;
      };

      setter = function (value) {
        if ((value != null ? value.value : void 0) === 'Banana') {
          return 'Apple';
        } else {
          return value;
        }
      };

      fieldA = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        getter
      }).appendTo(sandbox);
      fieldB = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        setter
      }).appendTo(sandbox);
      fieldC = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        getter,
        setter
      }).appendTo(sandbox);
      expect$1(fieldA.value).to.equal(void 0);
      expect$1(fieldA.valueRaw).to.equal(null);
      expect$1(fieldB.value).to.equal(void 0);
      expect$1(fieldB.valueRaw).to.equal(null);
      expect$1(fieldC.value).to.equal(void 0);
      expect$1(fieldC.valueRaw).to.equal(null);
      fieldA.choices[1].el.emit('click');
      fieldB.choices[1].el.emit('click');
      fieldC.choices[1].el.emit('click');
      expect$1(fieldA.value).to.equal('BANANA');
      expect$1((ref = fieldA.valueRaw) != null ? ref.value : void 0).to.equal('Banana');
      expect$1(fieldB.value).to.equal('Apple');
      expect$1((ref1 = fieldB.valueRaw) != null ? ref1.value : void 0).to.equal('Apple');
      expect$1(fieldC.value).to.equal('APPLE');
      expect$1((ref2 = fieldC.valueRaw) != null ? ref2.value : void 0).to.equal('Apple');
      fieldA.value = 'Orange';
      fieldB.value = 'Orange';
      fieldC.value = 'Orange';
      expect$1(fieldA.value).to.equal('ORANGE');
      expect$1((ref3 = fieldA.valueRaw) != null ? ref3.value : void 0).to.equal('Orange');
      expect$1(fieldB.value).to.equal('Orange');
      expect$1((ref4 = fieldB.valueRaw) != null ? ref4.value : void 0).to.equal('Orange');
      expect$1(fieldC.value).to.equal('ORANGE');
      return expect$1((ref5 = fieldC.valueRaw) != null ? ref5.value : void 0).to.equal('Orange');
    });
    return test("valid when selected", function () {
      var multiple, single;
      single = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true,
        validWhenSelected: true
      });
      multiple = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true,
        validWhenSelected: 2,
        multiple: true
      });
      expect$1(single.validate()).to.equal(false);
      expect$1(multiple.validate()).to.equal(false);
      expect$1(this.control.validate()).to.equal(false);
      expect$1(this.controlMulti.validate()).to.equal(false);
      single.value = multiple.value = this.control.value = this.controlMulti.value = 'Banana';
      expect$1(single.validate()).to.equal(true);
      expect$1(multiple.validate()).to.equal(false);
      expect$1(this.control.validate()).to.equal(true);
      expect$1(this.controlMulti.validate()).to.equal(true);
      multiple.value = ['Apple', 'Banana'];
      return expect$1(multiple.validate()).to.equal(true);
    });
  });
  suite("truefalse field", function () {
    suiteSetup(function () {
      return addTitle('truefalse field');
    });
    test("basic", function () {
      var field;
      field = quickfield$1$1({
        type: 'truefalse',
        label: 'Is it true or false?',
        width: 'auto'
      }).appendTo(sandbox).el.style('marginRight', 20);
      return assert$1.equal(field.value, null);
    });
    return test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'truefalse',
        label: 'It\'s false by default',
        width: 'auto',
        choiceLabels: ['Yes', 'No'],
        value: false
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      assert$1.equal(field.value, false);
      field = quickfield$1$1({
        type: 'truefalse',
        label: 'It\'s true by default',
        width: 'auto',
        choiceLabels: ['Yes', 'No'],
        value: true
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      return assert$1.equal(field.value, true);
    });
  });
  suite("toggle field", function () {
    suiteSetup(function () {
      return addTitle('toggle field');
    });
    test("basic", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'The toggle field',
        width: 'auto'
      }).appendTo(sandbox).el.style('marginRight', 20);
    });
    test("default value", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Toggled by default',
        width: '130px',
        defaultValue: 1
      }).appendTo(sandbox).el.style('marginRight', 20);
    });
    test("custom size", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Custom size toggle',
        width: 'auto',
        size: 40
      }).appendTo(sandbox).el.style('marginRight', 20);
    });
    test("aligned style", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Aligned style',
        style: 'aligned',
        width: 'auto'
      }).appendTo(sandbox);
    });
    return test("aligned style + defined width", function () {
      var field;
      field = quickfield$1$1({
        type: 'toggle',
        label: 'Aligned style with defined width',
        style: 'aligned',
        width: '400px'
      }).appendTo(sandbox);
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Aligned style with defined width',
        style: 'aligned',
        width: '200px'
      }).appendTo(sandbox);
    });
  });
  suite("checkbox field", function () {
    suiteSetup(function () {
      return addTitle('checkbox field');
    });
    test("basic", function () {
      var field;
      field = quickfield$1$1({
        type: 'checkbox',
        label: 'Is it true or false?',
        width: 'auto'
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      return assert$1.equal(field.value, false);
    });
    test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'checkbox',
        label: 'It\'s false by default',
        width: 'auto',
        value: false
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      assert$1.equal(field.value, false);
      field = quickfield$1$1({
        type: 'checkbox',
        label: 'It\'s true by default',
        width: 'auto',
        choiceLabels: ['Yes', 'No'],
        value: true
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      return assert$1.equal(field.value, true);
    });
    return test("multi-line display", function () {
      var field, label;
      label = 'Is it true or false? This is a fairly long text and can get even <b>longer</b> if we dont stop typing.';
      field = quickfield$1$1({
        type: 'checkbox',
        label,
        labelClicks: true,
        width: '150px'
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      assert$1.equal(field.value, false);
      field.el.child.label.raw.click();
      return assert$1.equal(field.value, true);
    });
  });
  suite("group field", function () {
    setup(addDivider);
    suiteSetup(function () {
      addTitle('group field');
      this.fields = {
        first: {
          type: 'text',
          label: 'First',
          width: '49%'
        },
        second: {
          type: 'text',
          label: 'Second',
          width: '49%'
        },
        third: {
          type: 'select',
          label: 'Third',
          width: '74%',
          choices: ['Apple', 'Banana', 'Kiwi'],
          value: 'Kiwi'
        },
        fourth: {
          type: 'toggle',
          label: 'Fourth',
          style: 'aligned',
          width: '24%',
          conditions: {
            third: 'Kiwi'
          }
        }
      };
      return this.control = quickfield$1$1({
        type: 'group',
        label: 'Basic Group',
        width: '70%',
        fieldMargin: 10,
        fieldAlign: 'middle',
        fields: this.fields
      }).appendTo(sandbox);
    });
    test("basic", function () {
      expect$1(this.control.value).to.eql({
        first: '',
        second: '',
        third: 'Kiwi',
        fourth: false
      });
      expect$1(this.control.state.interacted).to.equal(false);
      this.control.value = {
        first: 'valueA',
        third: 'Kawa',
        fourth: true,
        fifth: '5'
      };
      expect$1(this.control.value).to.eql({
        first: 'valueA',
        second: '',
        third: 'Kawa',
        fourth: true
      });
      expect$1(this.control.state.interacted).to.equal(true);
      this.control.value = {
        second: 'valueB',
        third: 'Apple'
      };
      expect$1(this.control.value).to.eql({
        first: 'valueA',
        second: 'valueB',
        third: 'Apple',
        fourth: true
      });
      this.control.value = null;
      return expect$1(this.control.value).to.eql({
        first: 'valueA',
        second: 'valueB',
        third: 'Apple',
        fourth: true
      });
    });
    test("collapsed by default", function () {
      var field;
      field = quickfield$1$1({
        type: 'group',
        width: '70%',
        fieldMargin: 10,
        startCollapsed: true,
        fields: this.fields
      }).appendTo(sandbox);
      expect$1(this.control.els.innerwrap.raw).to.be.displayed;
      expect$1(field.els.innerwrap.raw).not.to.be.displayed;
      this.control.state.collapsed = true;
      field.state.collapsed = false;
      expect$1(this.control.els.innerwrap.raw).not.to.be.displayed;
      expect$1(field.els.innerwrap.raw).to.be.displayed;
      this.control.els.collapse.emit('click');
      field.els.collapse.emit('click');
      expect$1(this.control.els.innerwrap.raw).to.be.displayed;
      return expect$1(field.els.innerwrap.raw).not.to.be.displayed;
    });
    return test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'group',
        width: '70%',
        fieldMargin: 10,
        fields: this.fields,
        value: {
          first: 'firstValue',
          third: 'Banana'
        }
      });
      return expect$1(field.value).to.eql({
        first: 'firstValue',
        second: '',
        third: 'Banana',
        fourth: false
      });
    });
  }); // test "inline mode", ()->
  // 	field = quickfield({type:'group', width:'70%', fieldMargin:10, @fields, value:{first:'firstValue', third:'Banana'}})
  // 	expect(field.value).to.eql {first:'firstValue', second:'', third:'Banana', fourth:false}

  suite("repeater field", function () {
    setup(addDivider);
    suiteSetup(function () {
      addDivider(40);
      this.fields = {
        first: {
          type: 'text',
          name: 'first',
          label: 'First',
          width: '49%'
        },
        second: {
          type: 'text',
          name: 'second',
          label: 'Second',
          width: '49%'
        }
      };
      return this.control = quickfield$1$1({
        type: 'repeater',
        label: 'Basic Repeater',
        width: '70%',
        fieldMargin: 10,
        numbering: true,
        cloneable: true,
        dragdrop: true,
        fields: this.fields
      }).appendTo(sandbox);
    });
    test("block", function () {
      expect$1(this.control.value).to.eql([]);
      expect$1(this.control.state.interacted).to.equal(false);
      this.control.els.addButton.emit('click');
      expect$1(this.control.value).to.eql([{
        first: '',
        second: ''
      }]);
      expect$1(this.control.state.interacted).to.equal(true);
      this.control.value = {
        first: 'abc',
        second: 'def'
      };
      expect$1(this.control.value).to.eql([{
        first: '',
        second: ''
      }, {
        first: 'abc',
        second: 'def'
      }]);
      expect$1(this.control._value[0].els.label.text).to.equal('Item 1');
      expect$1(this.control._value[1].els.label.text).to.equal('Item 2');

      this.control._value[0].els.remove.emit('click');

      expect$1(this.control.value).to.eql([{
        first: 'abc',
        second: 'def'
      }]);
      expect$1(this.control._value[0].els.label.text).to.equal('Item 1');
      this.control.value = [{
        first: 'ABC'
      }, {
        second: 'DEF'
      }];
      return expect$1(this.control.value).to.eql([{
        first: 'ABC',
        second: 'def'
      }, {
        first: '',
        second: 'DEF'
      }]);
    });
    test("inline", function () {
      var field;
      field = quickfield$1$1({
        type: 'repeater',
        label: 'Inline Repeater',
        width: '70%',
        fieldMargin: 10,
        numbering: true,
        autoRemoveEmpty: true,
        dragdrop: true,
        style: 'inline',
        value: [{
          first: 'abc',
          second: '123'
        }, {
          second: '456'
        }],
        fields: {
          first: primaryBuilder$1({
            autoWidth: true
          }, this.fields.first),
          second: primaryBuilder$1({
            autoWidth: true
          }, this.fields.second)
        }
      }).appendTo(sandbox);
      return expect$1(field.value).to.eql([{
        first: 'abc',
        second: '123'
      }, {
        first: '',
        second: '456'
      }]);
    });
    test("inline singleMode", function () {
      var field;
      field = quickfield$1$1({
        type: 'repeater',
        label: 'Inline Repeater',
        width: '70%',
        fieldMargin: 10,
        autoWidth: false,
        autoRemoveEmpty: true,
        numbering: true,
        style: 'inline',
        singleMode: true,
        dragdrop: true,
        groupSettings: {
          inline: {
            width: '100%'
          }
        },
        fields: primaryBuilder$1.clone(this.fields.first, {
          width: '100%'
        })
      }).appendTo(sandbox);
      expect$1(field.value).to.eql([]);
      field.value = ['abc', '123'];
      expect$1(field.value).to.eql(['abc', '123']);
      field.value = 'def';
      return expect$1(field.value).to.eql(['abc', '123', 'def']);
    });
    test("dynamicLabel", function () {
      var field;
      field = quickfield$1$1({
        type: 'repeater',
        label: 'Inline Repeater',
        width: '70%',
        dynamicLabel: 'first',
        fieldMargin: 10,
        autoRemoveEmpty: true,
        dragdrop: true,
        value: [{
          first: 'abc',
          second: '123'
        }, {
          second: '456'
        }],
        fields: {
          first: primaryBuilder$1({
            autoWidth: true
          }, this.fields.first),
          second: primaryBuilder$1({
            autoWidth: true
          }, this.fields.second)
        }
      }).appendTo(sandbox);
      expect$1(field._value[0].el.child.label.text).to.equal('abc');
      expect$1(field._value[1].el.child.label.text).to.equal('');
      field.value = [{
        first: 'def'
      }, {
        first: '123'
      }];
      expect$1(field._value[0].el.child.label.text).to.equal('def');
      return expect$1(field._value[1].el.child.label.text).to.equal('123');
    }); // expect(field.value).to.eql [
    // 	{first:'abc', second:'123'}
    // 	{first:'', second:'456'}

    return test("validate", function () {
      var field;
      field = quickfield$1$1({
        type: 'repeater',
        label: 'Inline Repeater',
        width: '70%',
        dynamicLabel: 'first',
        fieldMargin: 10,
        autoRemoveEmpty: true,
        dragdrop: true,
        required: true,
        // value: [{first:'abc', second:'123'}, {second:'456'}]
        fields: {
          first: primaryBuilder$1({
            autoWidth: true,
            required: true
          }, this.fields.first),
          second: primaryBuilder$1({
            autoWidth: true
          }, this.fields.second)
        }
      }).appendTo(sandbox);
      expect$1(field.validate()).to.equal(false);
      field.value = [{
        first: 'def'
      }, {
        second: '123'
      }];
      expect$1(field.validate()).to.equal(false);
      field.value = [{
        first: 'def'
      }, {
        first: '123'
      }];
      return expect$1(field.validate()).to.equal(true);
    });
  });
  return suite(".config()", function () {
    return test("creates a new copy of QuickField with setting overrides and template overrides", function () {
      var choice, quickfield2, textA, textB, textC, textD;
      quickfield2 = quickfield$1$1.config({
        global: {
          fontFamily: 'helvetica',
          width: '50%',
          required: true,
          border: '0 0 2px 0',
          margin: '0 10px 10px 0',
          fontSize: 13,
          inputPadding: 8
        },
        text: {
          height: 40,
          autoWidth: true,
          inputPadding: 0,
          checkmark: false,
          minLength: 2,
          mask: {
            placeholder: '*',
            decimal: true
          }
        }
      }, {
        global: {
          field: {
            options: {
              style: {
                verticalAlign: 'middle'
              }
            },
            children: {
              label: {
                options: {
                  style: {
                    $focus: {
                      color: COLORS.green
                    }
                  }
                }
              },
              innerwrap: {
                options: {
                  style: {
                    $focus: {
                      borderColor: COLORS.green
                    }
                  }
                }
              }
            }
          }
        },
        text: {
          default: {
            children: {
              label: {
                options: {
                  style: {
                    fontWeight: 700
                  }
                }
              }
            }
          }
        },
        choice: {
          choice: {
            options: {
              style: {
                $selected: {
                  color: COLORS.green
                }
              }
            }
          }
        }
      });
      expect$1(quickfield2).not.to.equal(quickfield$1$1);
      textA = quickfield$1$1({
        type: 'text',
        label: 'textA'
      }).appendTo(sandbox);
      textB = quickfield2({
        type: 'text',
        label: 'textB',
        autoWidth: false
      }).appendTo(sandbox);
      addDivider();
      textC = quickfield2({
        type: 'text',
        label: 'textC',
        mask: {
          pattern: 'NUMBER',
          suffix: '%'
        }
      }).appendTo(sandbox);
      textD = quickfield2({
        type: 'text',
        label: 'textD',
        mask: {
          pattern: 'DATE',
          suffix: '%'
        }
      }).appendTo(sandbox);
      choice = quickfield2({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange']
      }).appendTo(sandbox);
      expect$1(textA.el.style('fontFamily')).to.equal(quickfield$1$1.Field.prototype.globalDefaults.fontFamily);
      expect$1(textB.el.style('fontFamily')).to.equal('helvetica');
      expect$1(textA.el.style('verticalAlign')).to.equal('top');
      expect$1(textB.el.style('verticalAlign')).to.equal('middle');
      expect$1(textA.el.styleParsed('marginBottom')).to.equal(0);
      expect$1(textB.el.styleParsed('marginBottom')).to.equal(10);
      expect$1(textA.el.styleSafe('width', true)).to.equal('100%');
      expect$1(textB.el.styleSafe('width', true)).to.equal('50%');
      expect$1(textA.el.child.label.styleParsed('fontWeight', true)).to.equal(600);
      expect$1(textB.el.child.label.styleParsed('fontWeight', true)).to.equal(700);
      expect$1(textA.el.height).to.equal(quickfield$1$1.Field.text.prototype.defaults.height);
      expect$1(textB.el.height).to.equal(40);
      expect$1(textA.el.child.checkmark).to.be.object();
      expect$1(textB.el.child.checkmark).not.to.be.object();
      expect$1(getBorderSides(textA.els.innerwrap)).to.eql({
        top: '1px',
        left: '1px',
        right: '1px',
        bottom: '1px'
      });
      expect$1(getBorderSides(textB.els.innerwrap)).to.eql({
        top: '0px',
        left: '0px',
        right: '0px',
        bottom: '2px'
      });
      expect$1(textA.validate()).to.equal(true);
      expect$1(textB.validate()).to.equal(false);
      simulateKeys(textA.el.child.input.raw, 'abc');
      simulateKeys(textB.el.child.input.raw, 'abc');
      expect$1(textA.validate()).to.equal(true);
      expect$1(textB.validate()).to.equal(true);
      simulateKeys(textD.el.child.input.raw, '1');
      expect$1(textD.value).to.equal('1*/**/****');
      quickdom.batch([textA.els.label, textB.els.label, textA.els.innerwrap, textB.els.innerwrap]).style('transition', null);
      textA.state.focused = textB.state.focused = true;
      expect$1(textA.el.child.label.raw).to.have.style('color', COLORS.orange);
      expect$1(textB.el.child.label.raw).to.have.style('color', COLORS.green);
      expect$1(textA.el.child.innerwrap.raw).to.have.style('borderColor', COLORS.orange);
      expect$1(textB.el.child.innerwrap.raw).to.have.style('borderColor', COLORS.green);
      textA.blur();
      textB.blur();
      choice.value = 'Banana';
      expect$1(choice.valueRaw.label).to.equal('Banana');
      return expect$1(choice.valueRaw.el.raw).to.have.style('color', COLORS.green);
    });
  });
});}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5qcyIsInNvdXJjZXMiOlsiaGVscGVycy9jb21wYW55TmFtZXMuY29mZmVlIiwiLi4vbm9kZV9tb2R1bGVzL2tleXNpbS9kaXN0L2tleXNpbS5tanMiLCJoZWxwZXJzL3NpbXVsYXRlS2V5cy5jb2ZmZWUiLCJoZWxwZXJzL3NpbXVsYXRlQWN0aW9uLmNvZmZlZSIsIi4uL25vZGVfbW9kdWxlcy9xdWlja2Nzcy9kaXN0L3F1aWNrY3NzLmVzbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zbWFydC1leHRlbmQvZGlzdC9zbWFydC1leHRlbmQuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkYW5pZWxrYWxlbi9pcy9kaXN0L2lzLmVzbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9xdWlja2RvbS9kaXN0L3F1aWNrZG9tLmVzbS5qcyIsImhlbHBlcnMvcmVzdGFydFNhbmRib3guY29mZmVlIiwiaGVscGVycy9hZGRUaXRsZS5jb2ZmZWUiLCJoZWxwZXJzL2FkZERpdmlkZXIuY29mZmVlIiwiaGVscGVycy9nZXRCb3JkZXJTaWRlcy5jb2ZmZWUiLCIuLi9ub2RlX21vZHVsZXMvcC1maW5hbGx5L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3AtdGltZW91dC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wLWV2ZW50L2luZGV4LmpzIiwiLi4vc3JjL2NvbnN0YW50cy9jb2xvcnMuY29mZmVlIiwiLi4vbm9kZV9tb2R1bGVzL2Fzc2VydGlvbi1lcnJvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYXRodmFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Rlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtZnVuYy1uYW1lL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2lzUHJveHlFbmFibGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRMZW5ndGhHdWFyZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Byb3hpZnkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRNZXRob2QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2NvbXBhcmVCeUluc3BlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stZXJyb3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pc05hTi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2V4cGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9zaG91bGQuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2UvYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWRvbS9jaGFpLWRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLXN0eWxlL3NvdXJjZXMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWFsbW9zdC9ub2RlX21vZHVsZXMvZGVlcC1lcWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stdHlwZXMvc3JjL2NoZWNrLXR5cGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktYXNzZXJ0dHlwZS9hc3NlcnR0eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktZXZlbnRzL2NoYWktZXZlbnRzLmpzIiwiLi4vYnVpbGQvYW5pbWF0aW9ucy5qcyIsIi4uL2J1aWxkL2NoZWNrcy5qcyIsIi4uL2J1aWxkL2NvbnNvbGVQYXRjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AZGFuaWVsa2FsZW4vc2ltcGx5YmluZC9kaXN0L3NpbXBseWJpbmQuanMiLCIuLi9idWlsZC9jb25zdGFudHMvcmVnZXguanMiLCIuLi9idWlsZC9oZWxwZXJzLmpzIiwiLi4vYnVpbGQvY29uc3RhbnRzL3JlcUZpZWxkTWV0aG9kcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0ZG9tL2Zhc3Rkb20uanMiLCIuLi9idWlsZC9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyIsIi4uL2J1aWxkL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzIiwiLi4vYnVpbGQvZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMiLCIuLi9idWlsZC9maWVsZC9pbmRleC5qcyIsIi4uL2J1aWxkL2NvbnN0YW50cy9rZXlDb2Rlcy5qcyIsIi4uL2J1aWxkL3N2Zy9jaGVja21hcmsuanMiLCIuLi9idWlsZC9zdmcvYW5nbGVEb3duLmpzIiwiLi4vYnVpbGQvc3ZnL2NhcmV0VXAuanMiLCIuLi9idWlsZC9zdmcvY2FyZXREb3duLmpzIiwiLi4vYnVpbGQvc3ZnL3BsdXMuanMiLCIuLi9idWlsZC9zdmcvY2xvbmUuanMiLCIuLi9idWlsZC9zdmcvcmVtb3ZlLmpzIiwiLi4vYnVpbGQvY29tcG9uZW50cy9kcm9wZG93bi90ZW1wbGF0ZS1iOTYxZjgxZi5qcyIsIi4uL2J1aWxkL2NvbXBvbmVudHMvZHJvcGRvd24vZGVmYXVsdHMuanMiLCIuLi9idWlsZC9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RleHQtbWFzay1jb3JlL2Rpc3QvdGV4dE1hc2tDb3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RleHQtbWFzay1hZGRvbnMvZGlzdC90ZXh0TWFza0FkZG9ucy5qcyIsIi4uL2J1aWxkL2NvbXBvbmVudHMvbWFzay5qcyIsIi4uL2J1aWxkL2NvbnN0YW50cy9jb2xvcnMuanMiLCIuLi9idWlsZC9maWVsZHMvdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy90ZXh0L2RlZmF1bHRzLmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHQvaW5kZXguanMiLCIuLi9idWlsZC9xdWlja2ZpZWxkLmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHRhcmVhL2RlZmF1bHRzLmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHRhcmVhL3RlbXBsYXRlLTY1ZmVkYTA1LmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHRhcmVhL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL251bWJlci9kZWZhdWx0cy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy9udW1iZXIvdGVtcGxhdGUtYzkyMmUxNjMuanMiLCIuLi9idWlsZC9maWVsZHMvbnVtYmVyL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3NlbGVjdC9kZWZhdWx0cy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy9zZWxlY3QvdGVtcGxhdGUtNmJiY2RkZDAuanMiLCIuLi9idWlsZC9maWVsZHMvc2VsZWN0L2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL2Nob2ljZS90ZW1wbGF0ZS1jODhmYTk1Yi5qcyIsIi4uL2J1aWxkL2ZpZWxkcy9jaG9pY2UvZGVmYXVsdHMuanMiLCIuLi9idWlsZC9maWVsZHMvY2hvaWNlL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3RydWVmYWxzZS90ZW1wbGF0ZS0zZDZjNTRhMC5qcyIsIi4uL2J1aWxkL2ZpZWxkcy90cnVlZmFsc2UvZGVmYXVsdHMuanMiLCIuLi9idWlsZC9maWVsZHMvdHJ1ZWZhbHNlL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3RvZ2dsZS9kZWZhdWx0cy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy90b2dnbGUvdGVtcGxhdGUtYmY3Yjk5YzEuanMiLCIuLi9idWlsZC9maWVsZHMvdG9nZ2xlL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL2dyb3VwL2RlZmF1bHRzLmpzIiwiLi4vYnVpbGQvZmllbGRzL2dyb3VwL3RlbXBsYXRlLTA4NmE4MmUyLmpzIiwiLi4vYnVpbGQvZmllbGRzL2dyb3VwL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3JlcGVhdGVyL3RlbXBsYXRlLTdjMjg0ZTYxLmpzIiwiLi4vYnVpbGQvZmllbGRzL3JlcGVhdGVyL2RlZmF1bHRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2F0b2EvYXRvYS5qcyIsIi4uL25vZGVfbW9kdWxlcy90aWNreS90aWNreS1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvbnRyYS9kZWJvdW5jZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb250cmEvZW1pdHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jcm9zc3ZlbnQvbm9kZV9tb2R1bGVzL2N1c3RvbS1ldmVudC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jcm9zc3ZlbnQvc3JjL2V2ZW50bWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Nyb3NzdmVudC9zcmMvY3Jvc3N2ZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RyYWd1bGEvY2xhc3Nlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kcmFndWxhL2RyYWd1bGEuanMiLCIuLi9idWlsZC9maWVsZHMvcmVwZWF0ZXIvaW5kZXguanMiLCIuLi9idWlsZC9maWVsZHMvY2hlY2tib3gvZGVmYXVsdHMuanMiLCIuLi9idWlsZC9maWVsZHMvY2hlY2tib3gvdGVtcGxhdGUtZmFmYjVmNDEuanMiLCIuLi9idWlsZC9maWVsZHMvY2hlY2tib3gvaW5kZXguanMiLCJ0ZXN0LmNvZmZlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBbXG4gIFwiS2llaG4gSW5jXCJcbiAgXCJNYXJrcyBhbmQgU29uc1wiXG4gIFwiV2FlbGNoaSBTY2hpbGxlciBhbmQgRGVuZXNpa1wiXG4gIFwiT2xzb24gWmVtbGFrIGFuZCBNYWdnaW9cIlxuICBcIkphY29icyAtIFZvblwiXG4gIFwiQXVlciBMb3dlIGFuZCBHdXRtYW5uXCJcbiAgXCJGZWVuZXkgUmVtcGVsIGFuZCBDYXNzaW5cIlxuICBcIlNhd2F5biAtIE1hcmtzXCJcbiAgXCJKb2hucyBhbmQgU29uc1wiXG4gIFwiUm9kcmlndWV6IENoYW1wbGluIGFuZCBEYXJlXCJcbiAgXCJMb3dlIC0gUml0Y2hpZVwiXG4gIFwiR2xlaWNobmVyIEdvbGRuZXIgYW5kIEJlY2tlclwiXG4gIFwiSmVyZGUgLSBPc2luc2tpXCJcbiAgXCJCYXVtYmFjaCBHcm91cFwiXG4gIFwiU2Nocm9lZGVyIFp1bGF1ZiBhbmQgUmVtcGVsXCJcbiAgXCJPJ1JlaWxseSBNaWxscyBhbmQgRGVuZXNpa1wiXG4gIFwiS29obGVyIC0gVmV1bVwiXG4gIFwiTydIYXJhIEluY1wiXG4gIFwiT2JlcmJydW5uZXIgYW5kIFNvbnNcIlxuICBcIkVtbWVyaWNoIEdyb3VwXCJcbiAgXCJNdXJyYXkgWmllbWUgYW5kIEZyYW5lY2tpXCJcbiAgXCJNb2VuIC0gTHVldHRnZW5cIlxuICBcIkdvcmN6YW55IEhhcnZleSBhbmQgR3VsZ293c2tpXCJcbiAgXCJSZWlsbHkgLSBSdWVja2VyXCJcbiAgXCJNY0Rlcm1vdHQgLSBIeWF0dFwiXG4gIFwiU3BpbmthIC0gTWFya3NcIlxuICBcIkhheWVzIGFuZCBTb25zXCJcbiAgXCJLaWxiYWNrIEtpZWhuIGFuZCBNb25haGFuXCJcbiAgXCJEYXZpcyBhbmQgU29uc1wiXG4gIFwiSHVkc29uIC0gWXVuZHRcIlxuICBcIkdvb2R3aW4gLSBaZW1sYWtcIlxuICBcIkJlZXIgS3VobG1hbiBhbmQgV2Fsa2VyXCJcbiAgXCJKb25lcyBDYXJyb2xsIGFuZCBBbmRlcnNvblwiXG4gIFwiUnV0aGVyZm9yZCBJbmNcIlxuICBcIlByZWRvdmljIFdoaXRlIGFuZCBDb2xsaW5zXCJcbiAgXCJTcG9yZXIgQmF1bWJhY2ggYW5kIENyaXN0XCJcbiAgXCJHcmltZXMgYW5kIFNvbnNcIlxuICBcIkt1bmRlIGFuZCBTb25zXCJcbiAgXCJUaWxsbWFuIC0gQm9kZVwiXG4gIFwiQ3JvbmluIC0gS29lcHBcIlxuICBcIlNtaXRoYW0gWmllbWUgYW5kIERhbmllbFwiXG4gIFwiS3VuemUgV2VsY2ggYW5kIFJ1c3NlbFwiXG4gIFwiSm9obnMgTGFiYWRpZSBhbmQgSGFyYmVyXCJcbiAgXCJMZXNjaCAtIFdhdGVyc1wiXG4gIFwiQnJha3VzIC0gU21pdGhhbVwiXG4gIFwiQmlucyBhbmQgU29uc1wiXG4gIFwiTml0enNjaGUgSW5jXCJcbiAgXCJXdW5zY2ggSW5jXCJcbiAgXCJTY2hvd2FsdGVyIEZyYW5lY2tpIGFuZCBLdXBoYWxcIlxuICBcIlJleW5vbGRzIC0gU3dhbmlhd3NraVwiXG5dIiwidmFyIGlzRWRpdGFibGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5vd25lckRvY3VtZW50LmRlc2lnbk1vZGUgJiYgZWxlbWVudC5vd25lckRvY3VtZW50LmRlc2lnbk1vZGUudG9Mb3dlckNhc2UoKSA9PT0gJ29uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJldHVybiBpc0VkaXRhYmxlSW5wdXQoZWxlbWVudCk7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDb250ZW50RWRpdGFibGUoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuY29udGVudEVkaXRhYmxlICYmIGVsZW1lbnQuY29udGVudEVkaXRhYmxlLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSAmJiBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZS50b0xvd2VyQ2FzZSgpID09PSAnaW5oZXJpdCcgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQucGFyZW50Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VkaXRhYmxlSW5wdXQoaW5wdXQpIHtcbiAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgY2FzZSAndGV4dCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdlbWFpbCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdzZWFyY2gnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAndGVsJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3VybCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cbnZhciBDVFJMID0gMSA8PCAwO1xudmFyIE1FVEEgPSAxIDw8IDE7XG52YXIgQUxUID0gMSA8PCAyO1xudmFyIFNISUZUID0gMSA8PCAzO1xuXG4vLyBLZXkgRXZlbnRzXG52YXIgS2V5RXZlbnRzID0ge1xuICBET1dOOiAxIDw8IDAsXG4gIFBSRVNTOiAxIDw8IDEsXG4gIFVQOiAxIDw8IDIsXG4gIElOUFVUOiAxIDw8IDNcbn07XG5LZXlFdmVudHMuQUxMID0gS2V5RXZlbnRzLkRPV04gfCBLZXlFdmVudHMuUFJFU1MgfCBLZXlFdmVudHMuVVAgfCBLZXlFdmVudHMuSU5QVVQ7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGtleXN0cm9rZSwgb3IgYSBzaW5nbGUga2V5IGNvZGUgd2l0aCBhIHNldCBvZiBhY3RpdmUgbW9kaWZpZXJzLlxuICpcbiAqIEBjbGFzcyBLZXlzdHJva2VcbiAqL1xudmFyIEtleXN0cm9rZSA9XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RpZmllcnMgQSBiaXRtYXNrIGZvcm1lZCBieSBDVFJMLCBNRVRBLCBBTFQsIGFuZCBTSElGVC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBrZXlDb2RlXG4gKi9cbmZ1bmN0aW9uIEtleXN0cm9rZShtb2RpZmllcnMsIGtleUNvZGUpIHtcbiAgY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5c3Ryb2tlKTtcblxuICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgdGhpcy5jdHJsS2V5ID0gISEobW9kaWZpZXJzICYgQ1RSTCk7XG4gIHRoaXMubWV0YUtleSA9ICEhKG1vZGlmaWVycyAmIE1FVEEpO1xuICB0aGlzLmFsdEtleSA9ICEhKG1vZGlmaWVycyAmIEFMVCk7XG4gIHRoaXMuc2hpZnRLZXkgPSAhIShtb2RpZmllcnMgJiBTSElGVCk7XG4gIHRoaXMua2V5Q29kZSA9IGtleUNvZGU7XG59O1xuXG4vKipcbiAqIFNpbXVsYXRlcyBhIGtleWJvYXJkIHdpdGggYSBwYXJ0aWN1bGFyIGtleS10by1jaGFyYWN0ZXIgYW5kIGtleS10by1hY3Rpb25cbiAqIG1hcHBpbmcuIFVzZSBgVVNfRU5HTElTSGAgdG8gZ2V0IGEgcHJlLWNvbmZpZ3VyZWQga2V5Ym9hcmQuXG4gKi9cbktleXN0cm9rZS5DVFJMID0gQ1RSTDtcbktleXN0cm9rZS5NRVRBID0gTUVUQTtcbktleXN0cm9rZS5BTFQgPSBBTFQ7XG5LZXlzdHJva2UuU0hJRlQgPSBTSElGVDtcbnZhciBLZXlib2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxudW1iZXIsIEtleXN0cm9rZT59IGNoYXJDb2RlS2V5Q29kZU1hcFxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBhY3Rpb25LZXlDb2RlTWFwXG4gICAqL1xuICBmdW5jdGlvbiBLZXlib2FyZChjaGFyQ29kZUtleUNvZGVNYXAsIGFjdGlvbktleUNvZGVNYXApIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlib2FyZCk7XG5cbiAgICB0aGlzLl9jaGFyQ29kZUtleUNvZGVNYXAgPSBjaGFyQ29kZUtleUNvZGVNYXA7XG4gICAgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcCA9IGFjdGlvbktleUNvZGVNYXA7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgY2hhcmFjdGVyIGNvZGUgZ2VuZXJhdGVkIGJ5IHByZXNzaW5nIHRoZSBnaXZlbiBrZXlzdHJva2UuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5c3Ryb2tlfSBrZXlzdHJva2VcbiAgICogQHJldHVybiB7P251bWJlcn1cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhLZXlib2FyZCwgW3tcbiAgICBrZXk6ICdjaGFyQ29kZUZvcktleXN0cm9rZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYXJDb2RlRm9yS2V5c3Ryb2tlKGtleXN0cm9rZSkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX2NoYXJDb2RlS2V5Q29kZU1hcDtcbiAgICAgIGZvciAodmFyIGNoYXJDb2RlIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgY2hhckNvZGUpKSB7XG4gICAgICAgICAgdmFyIGtleXN0cm9rZUZvckNoYXJDb2RlID0gbWFwW2NoYXJDb2RlXTtcbiAgICAgICAgICBpZiAoa2V5c3Ryb2tlLmtleUNvZGUgPT09IGtleXN0cm9rZUZvckNoYXJDb2RlLmtleUNvZGUgJiYga2V5c3Ryb2tlLm1vZGlmaWVycyA9PT0ga2V5c3Ryb2tlRm9yQ2hhckNvZGUubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY2hhckNvZGUsIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgcmVhZHkgZm9yIGRpc3BhdGNoaW5nIG9udG8gdGhlIGdpdmVuIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIE9uZSBvZiBcImtleWRvd25cIiwgXCJrZXlwcmVzc1wiLCBcImtleXVwXCIsIFwidGV4dElucHV0XCIgb3IgXCJpbnB1dFwiLlxuICAgICAqIEBwYXJhbSB7S2V5c3Ryb2tlfSBrZXlzdHJva2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtFdmVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKHR5cGUsIGtleXN0cm9rZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIHZhciB3aW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgIHZhciBFdmVudCA9IHdpbmRvdy5FdmVudDtcblxuICAgICAgdmFyIGV2ZW50ID0gdm9pZCAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBldmVudCA9IG5ldyBFdmVudCh0eXBlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnVUlFdmVudHMnKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAndGV4dElucHV0JzpcbiAgICAgICAgICBldmVudC5kYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmNoYXJDb2RlRm9yS2V5c3Ryb2tlKGtleXN0cm9rZSkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2tleWRvd24nOmNhc2UgJ2tleXByZXNzJzpjYXNlICdrZXl1cCc6XG4gICAgICAgICAgZXZlbnQuc2hpZnRLZXkgPSBrZXlzdHJva2Uuc2hpZnRLZXk7XG4gICAgICAgICAgZXZlbnQuYWx0S2V5ID0ga2V5c3Ryb2tlLmFsdEtleTtcbiAgICAgICAgICBldmVudC5tZXRhS2V5ID0ga2V5c3Ryb2tlLm1ldGFLZXk7XG4gICAgICAgICAgZXZlbnQuY3RybEtleSA9IGtleXN0cm9rZS5jdHJsS2V5O1xuICAgICAgICAgIGV2ZW50LmtleUNvZGUgPSB0eXBlID09PSAna2V5cHJlc3MnID8gdGhpcy5jaGFyQ29kZUZvcktleXN0cm9rZShrZXlzdHJva2UpIDoga2V5c3Ryb2tlLmtleUNvZGU7XG4gICAgICAgICAgZXZlbnQuY2hhckNvZGUgPSB0eXBlID09PSAna2V5cHJlc3MnID8gZXZlbnQua2V5Q29kZSA6IDA7XG4gICAgICAgICAgZXZlbnQud2hpY2ggPSBldmVudC5rZXlDb2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdGhlIGNvcnJlY3Qgc2VxdWVuY2Ugb2YgZXZlbnRzIG9uIHRoZSBnaXZlbiB0YXJnZXQgYXMgaWYgdGhlIGdpdmVuXG4gICAgICogYWN0aW9uIHdhcyB1bmRlcnRha2VuIGJ5IGEgaHVtYW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIGUuZy4gXCJhbHQrc2hpZnQrbGVmdFwiIG9yIFwiYmFja3NwYWNlXCJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzcGF0Y2hFdmVudHNGb3JBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvckFjdGlvbihhY3Rpb24sIHRhcmdldCkge1xuICAgICAgdmFyIGtleXN0cm9rZSA9IHRoaXMua2V5c3Ryb2tlRm9yQWN0aW9uKGFjdGlvbik7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnRzRm9yS2V5c3Ryb2tlKGtleXN0cm9rZSwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgY29ycmVjdCBzZXF1ZW5jZSBvZiBldmVudHMgb24gdGhlIGdpdmVuIHRhcmdldCBhcyBpZiB0aGUgZ2l2ZW5cbiAgICAgKiBpbnB1dCBoYWQgYmVlbiB0eXBlZCBieSBhIGh1bWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3BhdGNoRXZlbnRzRm9ySW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvcklucHV0KGlucHV0LCB0YXJnZXQpIHtcbiAgICAgIHZhciBjdXJyZW50TW9kaWZpZXJTdGF0ZSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleXN0cm9rZSA9IHRoaXMua2V5c3Ryb2tlRm9yQ2hhckNvZGUoaW5wdXQuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb2RpZmllclN0YXRlVHJhbnNpdGlvbih0YXJnZXQsIGN1cnJlbnRNb2RpZmllclN0YXRlLCBrZXlzdHJva2UubW9kaWZpZXJzKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50c0ZvcktleXN0cm9rZShrZXlzdHJva2UsIHRhcmdldCwgZmFsc2UpO1xuICAgICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSA9IGtleXN0cm9rZS5tb2RpZmllcnM7XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BhdGNoTW9kaWZpZXJTdGF0ZVRyYW5zaXRpb24odGFyZ2V0LCBjdXJyZW50TW9kaWZpZXJTdGF0ZSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdGhlIGNvcnJlY3Qgc2VxdWVuY2Ugb2YgZXZlbnRzIG9uIHRoZSBnaXZlbiB0YXJnZXQgYXMgaWYgdGhlIGdpdmVuXG4gICAgICoga2V5c3Ryb2tlIHdhcyBwZXJmb3JtZWQgYnkgYSBodW1hbi4gV2hlbiBzaW11bGF0aW5nLCBmb3IgZXhhbXBsZSwgdHlwaW5nXG4gICAgICogdGhlIGxldHRlciBcIkFcIiAoYXNzdW1pbmcgYSBVLlMuIEVuZ2xpc2gga2V5Ym9hcmQpIHRoZW4gdGhlIHNlcXVlbmNlIHdpbGxcbiAgICAgKiBsb29rIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqICAga2V5ZG93biAgIGtleUNvZGU9MTYgKFNISUZUKSBjaGFyQ29kZT0wICAgICAgc2hpZnRLZXk9dHJ1ZVxuICAgICAqICAga2V5ZG93biAgIGtleUNvZGU9NjUgKEEpICAgICBjaGFyQ29kZT0wICAgICAgc2hpZnRLZXk9dHJ1ZVxuICAgICAqICAga2V5cHJlc3MgIGtleUNvZGU9NjUgKEEpICAgICBjaGFyQ29kZT02NSAoQSkgc2hpZnRLZXk9dHJ1ZVxuICAgICAqICAgdGV4dElucHV0IGRhdGE9QVxuICAgICAqICAgaW5wdXRcbiAgICAgKiAgIGtleXVwICAgICBrZXlDb2RlPTY1IChBKSAgICAgY2hhckNvZGU9MCAgICAgIHNoaWZ0S2V5PXRydWVcbiAgICAgKiAgIGtleXVwICAgICBrZXlDb2RlPTE2IChTSElGVCkgY2hhckNvZGU9MCAgICAgIHNoaWZ0S2V5PWZhbHNlXG4gICAgICpcbiAgICAgKiBJZiB0aGUga2V5c3Ryb2tlIHdvdWxkIG5vdCBjYXVzZSBhIGNoYXJhY3RlciB0byBiZSBpbnB1dCwgc3VjaCBhcyB3aGVuXG4gICAgICogcHJlc3NpbmcgYWx0K3NoaWZ0K2xlZnQsIHRoZSBzZXF1ZW5jZSBsb29rcyBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiAgIGtleWRvd24gICBrZXlDb2RlPTE2IChTSElGVCkgY2hhckNvZGU9MCBhbHRLZXk9ZmFsc2Ugc2hpZnRLZXk9dHJ1ZVxuICAgICAqICAga2V5ZG93biAgIGtleUNvZGU9MTggKEFMVCkgICBjaGFyQ29kZT0wIGFsdEtleT10cnVlICBzaGlmdEtleT10cnVlXG4gICAgICogICBrZXlkb3duICAga2V5Q29kZT0zNyAoTEVGVCkgIGNoYXJDb2RlPTAgYWx0S2V5PXRydWUgIHNoaWZ0S2V5PXRydWVcbiAgICAgKiAgIGtleXVwICAgICBrZXlDb2RlPTM3IChMRUZUKSAgY2hhckNvZGU9MCBhbHRLZXk9dHJ1ZSAgc2hpZnRLZXk9dHJ1ZVxuICAgICAqICAga2V5dXAgICAgIGtleUNvZGU9MTggKEFMVCkgICBjaGFyQ29kZT0wIGFsdEtleT1mYWxzZSBzaGlmdEtleT10cnVlXG4gICAgICogICBrZXl1cCAgICAga2V5Q29kZT0xNiAoU0hJRlQpIGNoYXJDb2RlPTAgYWx0S2V5PWZhbHNlIHNoaWZ0S2V5PWZhbHNlXG4gICAgICpcbiAgICAgKiBUbyBkaXNhYmxlIGhhbmRsaW5nIG9mIG1vZGlmaWVyIGtleXMsIGNhbGwgd2l0aCBgdHJhbnNpdGlvbk1vZGlmZXJzYCBzZXRcbiAgICAgKiB0byBmYWxzZS4gRG9pbmcgc28gd2lsbCBvbWl0IHRoZSBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICogc2hpZnQsIGN0cmwsIGFsdCwgYW5kIG1ldGEga2V5cyBzdXJyb3VuZGluZyB0aGUgYWN0dWFsIGtleXN0cm9rZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5c3Ryb2tlfSBrZXlzdHJva2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB0cmFuc2l0aW9uTW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwYXRjaEV2ZW50c0ZvcktleXN0cm9rZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRzRm9yS2V5c3Ryb2tlKGtleXN0cm9rZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbk1vZGlmaWVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIHZhciBldmVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IEtleUV2ZW50cy5BTEw7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uTW9kaWZpZXJzKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb2RpZmllclN0YXRlVHJhbnNpdGlvbih0YXJnZXQsIDAsIGtleXN0cm9rZS5tb2RpZmllcnMsIGV2ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlkb3duRXZlbnQgPSB2b2lkIDA7XG4gICAgICBpZiAoZXZlbnRzICYgS2V5RXZlbnRzLkRPV04pIHtcbiAgICAgICAga2V5ZG93bkV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleWRvd24nLCBrZXlzdHJva2UsIHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlkb3duRXZlbnQgJiYgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoa2V5ZG93bkV2ZW50KSAmJiB0aGlzLnRhcmdldENhblJlY2VpdmVUZXh0SW5wdXQodGFyZ2V0KSkge1xuICAgICAgICB2YXIga2V5cHJlc3NFdmVudCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGV2ZW50cyAmIEtleUV2ZW50cy5QUkVTUykge1xuICAgICAgICAgIGtleXByZXNzRXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5cHJlc3MnLCBrZXlzdHJva2UsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXByZXNzRXZlbnQgJiYga2V5cHJlc3NFdmVudC5jaGFyQ29kZSAmJiB0YXJnZXQuZGlzcGF0Y2hFdmVudChrZXlwcmVzc0V2ZW50KSkge1xuICAgICAgICAgIGlmIChldmVudHMgJiBLZXlFdmVudHMuSU5QVVQpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0aW5wdXRFdmVudCA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCd0ZXh0SW5wdXQnLCBrZXlzdHJva2UsIHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0ZXh0aW5wdXRFdmVudCk7XG5cbiAgICAgICAgICAgIHZhciBpbnB1dEV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2lucHV0Jywga2V5c3Ryb2tlLCB0YXJnZXQpO1xuICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoaW5wdXRFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudHMgJiBLZXlFdmVudHMuVVApIHtcbiAgICAgICAgdmFyIGtleXVwRXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5dXAnLCBrZXlzdHJva2UsIHRhcmdldCk7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGtleXVwRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNpdGlvbk1vZGlmaWVycykge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTW9kaWZpZXJTdGF0ZVRyYW5zaXRpb24odGFyZ2V0LCBrZXlzdHJva2UubW9kaWZpZXJzLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9ucyBmcm9tIG9uZSBtb2RpZmllciBzdGF0ZSB0byBhbm90aGVyIGJ5IGRpc3BhdGNoaW5nIGtleSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbU1vZGlmaWVyU3RhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9Nb2RpZmllclN0YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3BhdGNoTW9kaWZpZXJTdGF0ZVRyYW5zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaE1vZGlmaWVyU3RhdGVUcmFuc2l0aW9uKHRhcmdldCwgZnJvbU1vZGlmaWVyU3RhdGUsIHRvTW9kaWZpZXJTdGF0ZSkge1xuICAgICAgdmFyIGV2ZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogS2V5RXZlbnRzLkFMTDtcblxuICAgICAgdmFyIGN1cnJlbnRNb2RpZmllclN0YXRlID0gZnJvbU1vZGlmaWVyU3RhdGU7XG4gICAgICB2YXIgZGlkSGF2ZU1ldGEgPSAoZnJvbU1vZGlmaWVyU3RhdGUgJiBNRVRBKSA9PT0gTUVUQTtcbiAgICAgIHZhciB3aWxsSGF2ZU1ldGEgPSAodG9Nb2RpZmllclN0YXRlICYgTUVUQSkgPT09IE1FVEE7XG4gICAgICB2YXIgZGlkSGF2ZUN0cmwgPSAoZnJvbU1vZGlmaWVyU3RhdGUgJiBDVFJMKSA9PT0gQ1RSTDtcbiAgICAgIHZhciB3aWxsSGF2ZUN0cmwgPSAodG9Nb2RpZmllclN0YXRlICYgQ1RSTCkgPT09IENUUkw7XG4gICAgICB2YXIgZGlkSGF2ZVNoaWZ0ID0gKGZyb21Nb2RpZmllclN0YXRlICYgU0hJRlQpID09PSBTSElGVDtcbiAgICAgIHZhciB3aWxsSGF2ZVNoaWZ0ID0gKHRvTW9kaWZpZXJTdGF0ZSAmIFNISUZUKSA9PT0gU0hJRlQ7XG4gICAgICB2YXIgZGlkSGF2ZUFsdCA9IChmcm9tTW9kaWZpZXJTdGF0ZSAmIEFMVCkgPT09IEFMVDtcbiAgICAgIHZhciB3aWxsSGF2ZUFsdCA9ICh0b01vZGlmaWVyU3RhdGUgJiBBTFQpID09PSBBTFQ7XG5cbiAgICAgIHZhciBpbmNsdWRlS2V5VXAgPSBldmVudHMgJiBLZXlFdmVudHMuVVA7XG4gICAgICB2YXIgaW5jbHVkZUtleURvd24gPSBldmVudHMgJiBLZXlFdmVudHMuRE9XTjtcblxuICAgICAgaWYgKGluY2x1ZGVLZXlVcCAmJiBkaWRIYXZlTWV0YSA9PT0gdHJ1ZSAmJiB3aWxsSGF2ZU1ldGEgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIG1ldGEga2V5LlxuICAgICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSAmPSB+TUVUQTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleXVwJywgbmV3IEtleXN0cm9rZShjdXJyZW50TW9kaWZpZXJTdGF0ZSwgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcC5NRVRBKSwgdGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlS2V5VXAgJiYgZGlkSGF2ZUN0cmwgPT09IHRydWUgJiYgd2lsbEhhdmVDdHJsID09PSBmYWxzZSkge1xuICAgICAgICAvLyBSZWxlYXNlIHRoZSBjdHJsIGtleS5cbiAgICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgJj0gfkNUUkw7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXl1cCcsIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuQ1RSTCksIHRhcmdldCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZUtleVVwICYmIGRpZEhhdmVTaGlmdCA9PT0gdHJ1ZSAmJiB3aWxsSGF2ZVNoaWZ0ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBSZWxlYXNlIHRoZSBzaGlmdCBrZXkuXG4gICAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlICY9IH5TSElGVDtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleXVwJywgbmV3IEtleXN0cm9rZShjdXJyZW50TW9kaWZpZXJTdGF0ZSwgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcC5TSElGVCksIHRhcmdldCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZUtleVVwICYmIGRpZEhhdmVBbHQgPT09IHRydWUgJiYgd2lsbEhhdmVBbHQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIGFsdCBrZXkuXG4gICAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlICY9IH5BTFQ7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXl1cCcsIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuQUxUKSwgdGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlS2V5RG93biAmJiBkaWRIYXZlTWV0YSA9PT0gZmFsc2UgJiYgd2lsbEhhdmVNZXRhID09PSB0cnVlKSB7XG4gICAgICAgIC8vIFByZXNzIHRoZSBtZXRhIGtleS5cbiAgICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgfD0gTUVUQTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleWRvd24nLCBuZXcgS2V5c3Ryb2tlKGN1cnJlbnRNb2RpZmllclN0YXRlLCB0aGlzLl9hY3Rpb25LZXlDb2RlTWFwLk1FVEEpLCB0YXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVLZXlEb3duICYmIGRpZEhhdmVDdHJsID09PSBmYWxzZSAmJiB3aWxsSGF2ZUN0cmwgPT09IHRydWUpIHtcbiAgICAgICAgLy8gUHJlc3MgdGhlIGN0cmwga2V5LlxuICAgICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSB8PSBDVFJMO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5ZG93bicsIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuQ1RSTCksIHRhcmdldCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZUtleURvd24gJiYgZGlkSGF2ZVNoaWZ0ID09PSBmYWxzZSAmJiB3aWxsSGF2ZVNoaWZ0ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIFByZXNzIHRoZSBzaGlmdCBrZXkuXG4gICAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlIHw9IFNISUZUO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5ZG93bicsIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuU0hJRlQpLCB0YXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVLZXlEb3duICYmIGRpZEhhdmVBbHQgPT09IGZhbHNlICYmIHdpbGxIYXZlQWx0ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIFByZXNzIHRoZSBhbHQga2V5LlxuICAgICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSB8PSBBTFQ7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXlkb3duJywgbmV3IEtleXN0cm9rZShjdXJyZW50TW9kaWZpZXJTdGF0ZSwgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcC5BTFQpLCB0YXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRNb2RpZmllclN0YXRlICE9PSB0b01vZGlmaWVyU3RhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnRlcm5hbCBlcnJvciwgZXhwZWN0ZWQgbW9kaWZpZXIgc3RhdGU6ICcgKyB0b01vZGlmaWVyU3RhdGUgKyAoJywgZ290OiAnICsgY3VycmVudE1vZGlmaWVyU3RhdGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBrZXlzdHJva2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICogQHJldHVybiB7P0tleXN0cm9rZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAna2V5c3Ryb2tlRm9yQWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5c3Ryb2tlRm9yQWN0aW9uKGFjdGlvbikge1xuICAgICAgdmFyIGtleUNvZGUgPSBudWxsO1xuICAgICAgdmFyIG1vZGlmaWVycyA9IDA7XG5cbiAgICAgIHZhciBwYXJ0cyA9IGFjdGlvbi5zcGxpdCgnKycpO1xuICAgICAgdmFyIGxhc3RQYXJ0ID0gcGFydHMucG9wKCk7XG5cbiAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgc3dpdGNoIChwYXJ0LnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICdDVFJMJzpcbiAgICAgICAgICAgIG1vZGlmaWVycyB8PSBDVFJMO2JyZWFrO1xuICAgICAgICAgIGNhc2UgJ01FVEEnOlxuICAgICAgICAgICAgbW9kaWZpZXJzIHw9IE1FVEE7YnJlYWs7XG4gICAgICAgICAgY2FzZSAnQUxUJzpcbiAgICAgICAgICAgIG1vZGlmaWVycyB8PSBBTFQ7YnJlYWs7XG4gICAgICAgICAgY2FzZSAnU0hJRlQnOlxuICAgICAgICAgICAgbW9kaWZpZXJzIHw9IFNISUZUO2JyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luIFwiJyArIGFjdGlvbiArICdcIiwgaW52YWxpZCBtb2RpZmllcjogJyArIHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGxhc3RQYXJ0LnRvVXBwZXJDYXNlKCkgaW4gdGhpcy5fYWN0aW9uS2V5Q29kZU1hcCkge1xuICAgICAgICBrZXlDb2RlID0gdGhpcy5fYWN0aW9uS2V5Q29kZU1hcFtsYXN0UGFydC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFBhcnQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBsYXN0UGFydEtleXN0cm9rZSA9IHRoaXMua2V5c3Ryb2tlRm9yQ2hhckNvZGUobGFzdFBhcnQuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIG1vZGlmaWVycyB8PSBsYXN0UGFydEtleXN0cm9rZS5tb2RpZmllcnM7XG4gICAgICAgIGtleUNvZGUgPSBsYXN0UGFydEtleXN0cm9rZS5rZXlDb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbiBcIicgKyBhY3Rpb24gKyAnXCIsIGludmFsaWQgYWN0aW9uOiAnICsgbGFzdFBhcnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEtleXN0cm9rZShtb2RpZmllcnMsIGtleUNvZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGtleXN0cm9rZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiBjaGFyYWN0ZXIgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyQ29kZVxuICAgICAqIEByZXR1cm4gez9LZXlzdHJva2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2tleXN0cm9rZUZvckNoYXJDb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5c3Ryb2tlRm9yQ2hhckNvZGUoY2hhckNvZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFyQ29kZUtleUNvZGVNYXBbY2hhckNvZGVdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndGFyZ2V0Q2FuUmVjZWl2ZVRleHRJbnB1dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhcmdldENhblJlY2VpdmVUZXh0SW5wdXQodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0VkaXRhYmxlKHRhcmdldCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLZXlib2FyZDtcbn0oKTtcblxudmFyIFVTX0VOR0xJU0hfQ0hBUkNPREVfS0VZQ09ERV9NQVAgPSB7XG4gIDMyOiBuZXcgS2V5c3Ryb2tlKDAsIDMyKSwgLy8gPHNwYWNlPlxuICAzMzogbmV3IEtleXN0cm9rZShTSElGVCwgNDkpLCAvLyAhXG4gIDM0OiBuZXcgS2V5c3Ryb2tlKFNISUZULCAyMjIpLCAvLyBcIlxuICAzNTogbmV3IEtleXN0cm9rZShTSElGVCwgNTEpLCAvLyAjXG4gIDM2OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1MiksIC8vICRcbiAgMzc6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDUzKSwgLy8gJVxuICAzODogbmV3IEtleXN0cm9rZShTSElGVCwgNTUpLCAvLyAmXG4gIDM5OiBuZXcgS2V5c3Ryb2tlKDAsIDIyMiksIC8vICdcbiAgNDA6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDU3KSwgLy8gKFxuICA0MTogbmV3IEtleXN0cm9rZShTSElGVCwgNDgpLCAvLyApXG4gIDQyOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1NiksIC8vICpcbiAgNDM6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDE4NyksIC8vICtcbiAgNDQ6IG5ldyBLZXlzdHJva2UoMCwgMTg4KSwgLy8gLFxuICA0NTogbmV3IEtleXN0cm9rZSgwLCAxODkpLCAvLyAtXG4gIDQ2OiBuZXcgS2V5c3Ryb2tlKDAsIDE5MCksIC8vIC5cbiAgNDc6IG5ldyBLZXlzdHJva2UoMCwgMTkxKSwgLy8gL1xuICA0ODogbmV3IEtleXN0cm9rZSgwLCA0OCksIC8vIDBcbiAgNDk6IG5ldyBLZXlzdHJva2UoMCwgNDkpLCAvLyAxXG4gIDUwOiBuZXcgS2V5c3Ryb2tlKDAsIDUwKSwgLy8gMlxuICA1MTogbmV3IEtleXN0cm9rZSgwLCA1MSksIC8vIDNcbiAgNTI6IG5ldyBLZXlzdHJva2UoMCwgNTIpLCAvLyA0XG4gIDUzOiBuZXcgS2V5c3Ryb2tlKDAsIDUzKSwgLy8gNVxuICA1NDogbmV3IEtleXN0cm9rZSgwLCA1NCksIC8vIDZcbiAgNTU6IG5ldyBLZXlzdHJva2UoMCwgNTUpLCAvLyA3XG4gIDU2OiBuZXcgS2V5c3Ryb2tlKDAsIDU2KSwgLy8gOFxuICA1NzogbmV3IEtleXN0cm9rZSgwLCA1NyksIC8vIDlcbiAgNTg6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDE4NiksIC8vIDpcbiAgNTk6IG5ldyBLZXlzdHJva2UoMCwgMTg2KSwgLy8gO1xuICA2MDogbmV3IEtleXN0cm9rZShTSElGVCwgMTg4KSwgLy8gPFxuICA2MTogbmV3IEtleXN0cm9rZSgwLCAxODcpLCAvLyA9XG4gIDYyOiBuZXcgS2V5c3Ryb2tlKFNISUZULCAxOTApLCAvLyA+XG4gIDYzOiBuZXcgS2V5c3Ryb2tlKFNISUZULCAxOTEpLCAvLyA/XG4gIDY0OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1MCksIC8vIEBcbiAgNjU6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDY1KSwgLy8gQVxuICA2NjogbmV3IEtleXN0cm9rZShTSElGVCwgNjYpLCAvLyBCXG4gIDY3OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA2NyksIC8vIENcbiAgNjg6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDY4KSwgLy8gRFxuICA2OTogbmV3IEtleXN0cm9rZShTSElGVCwgNjkpLCAvLyBFXG4gIDcwOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3MCksIC8vIEZcbiAgNzE6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDcxKSwgLy8gR1xuICA3MjogbmV3IEtleXN0cm9rZShTSElGVCwgNzIpLCAvLyBIXG4gIDczOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3MyksIC8vIElcbiAgNzQ6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDc0KSwgLy8gSlxuICA3NTogbmV3IEtleXN0cm9rZShTSElGVCwgNzUpLCAvLyBLXG4gIDc2OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3NiksIC8vIExcbiAgNzc6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDc3KSwgLy8gTVxuICA3ODogbmV3IEtleXN0cm9rZShTSElGVCwgNzgpLCAvLyBOXG4gIDc5OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3OSksIC8vIE9cbiAgODA6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDgwKSwgLy8gUFxuICA4MTogbmV3IEtleXN0cm9rZShTSElGVCwgODEpLCAvLyBRXG4gIDgyOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4MiksIC8vIFJcbiAgODM6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDgzKSwgLy8gU1xuICA4NDogbmV3IEtleXN0cm9rZShTSElGVCwgODQpLCAvLyBUXG4gIDg1OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4NSksIC8vIFVcbiAgODY6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDg2KSwgLy8gVlxuICA4NzogbmV3IEtleXN0cm9rZShTSElGVCwgODcpLCAvLyBXXG4gIDg4OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4OCksIC8vIFhcbiAgODk6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDg5KSwgLy8gWVxuICA5MDogbmV3IEtleXN0cm9rZShTSElGVCwgOTApLCAvLyBaXG4gIDkxOiBuZXcgS2V5c3Ryb2tlKDAsIDIxOSksIC8vIFtcbiAgOTI6IG5ldyBLZXlzdHJva2UoMCwgMjIwKSwgLy8gXFxcbiAgOTM6IG5ldyBLZXlzdHJva2UoMCwgMjIxKSwgLy8gXVxuICA5NjogbmV3IEtleXN0cm9rZSgwLCAxOTIpLCAvLyBgXG4gIDk3OiBuZXcgS2V5c3Ryb2tlKDAsIDY1KSwgLy8gYVxuICA5ODogbmV3IEtleXN0cm9rZSgwLCA2NiksIC8vIGJcbiAgOTk6IG5ldyBLZXlzdHJva2UoMCwgNjcpLCAvLyBjXG4gIDEwMDogbmV3IEtleXN0cm9rZSgwLCA2OCksIC8vIGRcbiAgMTAxOiBuZXcgS2V5c3Ryb2tlKDAsIDY5KSwgLy8gZVxuICAxMDI6IG5ldyBLZXlzdHJva2UoMCwgNzApLCAvLyBmXG4gIDEwMzogbmV3IEtleXN0cm9rZSgwLCA3MSksIC8vIGdcbiAgMTA0OiBuZXcgS2V5c3Ryb2tlKDAsIDcyKSwgLy8gaFxuICAxMDU6IG5ldyBLZXlzdHJva2UoMCwgNzMpLCAvLyBpXG4gIDEwNjogbmV3IEtleXN0cm9rZSgwLCA3NCksIC8vIGpcbiAgMTA3OiBuZXcgS2V5c3Ryb2tlKDAsIDc1KSwgLy8ga1xuICAxMDg6IG5ldyBLZXlzdHJva2UoMCwgNzYpLCAvLyBsXG4gIDEwOTogbmV3IEtleXN0cm9rZSgwLCA3NyksIC8vIG1cbiAgMTEwOiBuZXcgS2V5c3Ryb2tlKDAsIDc4KSwgLy8gblxuICAxMTE6IG5ldyBLZXlzdHJva2UoMCwgNzkpLCAvLyBvXG4gIDExMjogbmV3IEtleXN0cm9rZSgwLCA4MCksIC8vIHBcbiAgMTEzOiBuZXcgS2V5c3Ryb2tlKDAsIDgxKSwgLy8gcVxuICAxMTQ6IG5ldyBLZXlzdHJva2UoMCwgODIpLCAvLyByXG4gIDExNTogbmV3IEtleXN0cm9rZSgwLCA4MyksIC8vIHNcbiAgMTE2OiBuZXcgS2V5c3Ryb2tlKDAsIDg0KSwgLy8gdFxuICAxMTc6IG5ldyBLZXlzdHJva2UoMCwgODUpLCAvLyB1XG4gIDExODogbmV3IEtleXN0cm9rZSgwLCA4NiksIC8vIHZcbiAgMTE5OiBuZXcgS2V5c3Ryb2tlKDAsIDg3KSwgLy8gd1xuICAxMjA6IG5ldyBLZXlzdHJva2UoMCwgODgpLCAvLyB4XG4gIDEyMTogbmV3IEtleXN0cm9rZSgwLCA4OSksIC8vIHlcbiAgMTIyOiBuZXcgS2V5c3Ryb2tlKDAsIDkwKSwgLy8gelxuICAxMjM6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDIxOSksIC8vIHtcbiAgMTI0OiBuZXcgS2V5c3Ryb2tlKFNISUZULCAyMjApLCAvLyB8XG4gIDEyNTogbmV3IEtleXN0cm9rZShTSElGVCwgMjIxKSwgLy8gfVxuICAxMjY6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDE5MikgLy8gflxufTtcblxudmFyIFVTX0VOR0xJU0hfQUNUSU9OX0tFWUNPREVfTUFQID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBTSElGVDogMTYsXG4gIENUUkw6IDE3LFxuICBBTFQ6IDE4LFxuICBQQVVTRTogMTksXG4gIENBUFNMT0NLOiAyMCxcbiAgRVNDQVBFOiAyNyxcbiAgUEFHRVVQOiAzMyxcbiAgUEFHRURPV046IDM0LFxuICBFTkQ6IDM1LFxuICBIT01FOiAzNixcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgUklHSFQ6IDM5LFxuICBET1dOOiA0MCxcbiAgSU5TRVJUOiA0NSxcbiAgREVMRVRFOiA0NixcbiAgTUVUQTogOTEsXG4gIEYxOiAxMTIsXG4gIEYyOiAxMTMsXG4gIEYzOiAxMTQsXG4gIEY0OiAxMTUsXG4gIEY1OiAxMTYsXG4gIEY2OiAxMTcsXG4gIEY3OiAxMTgsXG4gIEY4OiAxMTksXG4gIEY5OiAxMjAsXG4gIEYxMDogMTIxLFxuICBGMTE6IDEyMixcbiAgRjEyOiAxMjNcbn07XG5cbi8qKlxuICogR2V0cyBhIGtleWJvYXJkIGluc3RhbmNlIGNvbmZpZ3VyZWQgYXMgYSBVLlMuIEVuZ2xpc2gga2V5Ym9hcmQgd291bGQgYmUuXG4gKlxuICogQHJldHVybiB7S2V5Ym9hcmR9XG4gKi9cbktleWJvYXJkLlVTX0VOR0xJU0ggPSBuZXcgS2V5Ym9hcmQoVVNfRU5HTElTSF9DSEFSQ09ERV9LRVlDT0RFX01BUCwgVVNfRU5HTElTSF9BQ1RJT05fS0VZQ09ERV9NQVApO1xuXG5leHBvcnQgeyBLZXlFdmVudHMsIEtleXN0cm9rZSwgS2V5Ym9hcmQgfTtcbiIsImltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJ2tleXNpbSdcbmtleWJvYXJkID0gS2V5Ym9hcmQuVVNfRU5HTElTSFxuXG5cbmV4cG9ydCBkZWZhdWx0ICh0YXJnZXQsIGtleXMsIHZhbHVlKS0+XG5cdHRhcmdldC5mb2N1cygpIGlmIHRhcmdldC5mb2N1c1xuXHR0YXJnZXQudmFsdWUgKz0gaWYgdmFsdWU/IHRoZW4gKHZhbHVlIG9yICcnKSBlbHNlIGtleXNcblx0a2V5Ym9hcmQuZGlzcGF0Y2hFdmVudHNGb3JJbnB1dChrZXlzLCB0YXJnZXQpXG5cblxuXG5cbiIsImltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJ2tleXNpbSdcbmtleWJvYXJkID0gS2V5Ym9hcmQuVVNfRU5HTElTSFxuXG5cbmV4cG9ydCBkZWZhdWx0ICh0YXJnZXQsIGtleXMpLT5cblx0a2V5Ym9hcmQuZGlzcGF0Y2hFdmVudHNGb3JBY3Rpb24oa2V5cywgdGFyZ2V0KVxuXG5cblxuXG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59dmFyIFJFR0VYX0xFTl9WQUwgPSAvXlxcZCsoPzpbYS16XXxcXCUpKyQvaTtcbnZhciBSRUdFWF9ESUdJVFMgPSAvXFxkKyQvO1xudmFyIFJFR0VYX1NQQUNFID0gL1xccy87XG52YXIgUkVHRVhfS0VCQUIgPSAvKFtBLVpdKSsvZztcbnZhciBJTVBPUlRBTlQgPSAnaW1wb3J0YW50JztcbnZhciBQT1NTSUJMRV9QUkVGSVhFUyA9IFsnd2Via2l0JywgJ21veicsICdtcycsICdvJ107XG52YXIgUkVRVUlSRVNfVU5JVF9WQUxVRSA9IFsnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICdibG9jay1zaXplJywgJ2JvcmRlci13aWR0aCcsICdjb2x1bW5SdWxlLXdpZHRoJywgJ2N4JywgJ2N5JywgJ2ZvbnQtc2l6ZScsICdncmlkLWNvbHVtbi1nYXAnLCAnZ3JpZC1yb3ctZ2FwJywgJ2hlaWdodCcsICdpbmxpbmUtc2l6ZScsICdsaW5lLWhlaWdodCcsICdtaW5CbG9jay1zaXplJywgJ21pbi1oZWlnaHQnLCAnbWluLWlubGluZS1zaXplJywgJ21pbi13aWR0aCcsICdtYXgtaGVpZ2h0JywgJ21heC13aWR0aCcsICdvdXRsaW5lLW9mZnNldCcsICdvdXRsaW5lLXdpZHRoJywgJ3BlcnNwZWN0aXZlJywgJ3NoYXBlLW1hcmdpbicsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2Utd2lkdGgnLCAndGV4dC1pbmRlbnQnLCAnd2lkdGgnLCAnd29yZC1zcGFjaW5nJywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICd4JywgJ3knXTtcbnZhciBRVUFEX1NIT1JUSEFORFMgPSBbJ21hcmdpbicsICdwYWRkaW5nJywgJ2JvcmRlcicsICdib3JkZXItcmFkaXVzJ107XG52YXIgRElSRUNUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J107XG5RVUFEX1NIT1JUSEFORFMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgdmFyIGRpcmVjdGlvbiwgaSwgbGVuO1xuICBSRVFVSVJFU19VTklUX1ZBTFVFLnB1c2gocHJvcGVydHkpO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IERJUkVDVElPTlMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT05TW2ldO1xuICAgIFJFUVVJUkVTX1VOSVRfVkFMVUUucHVzaChwcm9wZXJ0eSArICctJyArIGRpcmVjdGlvbik7XG4gIH1cbn0pO3ZhciBTQU1QTEVfU1RZTEUsIHN0eWxlQ29uZmlnO1xuU0FNUExFX1NUWUxFID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyh0YXJnZXQsIGl0ZW0pIHtcbiAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xudmFyIGlzSXRlcmFibGUgPSBmdW5jdGlvbiBpc0l0ZXJhYmxlKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0ICYmIF90eXBlb2YodGFyZ2V0KSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5sZW5ndGggPT09ICdudW1iZXInICYmICF0YXJnZXQubm9kZVR5cGU7XG59O1xudmFyIHRvS2ViYWJDYXNlID0gZnVuY3Rpb24gdG9LZWJhYkNhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShSRUdFWF9LRUJBQiwgZnVuY3Rpb24gKGUsIGxldHRlcikge1xuICAgIHJldHVybiBcIi1cIi5jb25jYXQobGV0dGVyLnRvTG93ZXJDYXNlKCkpO1xuICB9KTtcbn07XG52YXIgaXNQcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNQcm9wU3VwcG9ydGVkKHByb3BlcnR5KSB7XG4gIHJldHVybiB0eXBlb2YgU0FNUExFX1NUWUxFW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xudmFyIGlzVmFsdWVTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1ZhbHVlU3VwcG9ydGVkKHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAod2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5DU1Muc3VwcG9ydHMocHJvcGVydHksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBTQU1QTEVfU1RZTEVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgcmV0dXJuIFNBTVBMRV9TVFlMRVtwcm9wZXJ0eV0gPT09ICcnICsgdmFsdWU7XG4gIH1cbn07XG52YXIgZ2V0UHJlZml4ID0gZnVuY3Rpb24gZ2V0UHJlZml4KHByb3BlcnR5LCBza2lwSW5pdGlhbENoZWNrKSB7XG4gIHZhciBqLCBsZW4xLCBwcmVmaXg7XG5cbiAgaWYgKHNraXBJbml0aWFsQ2hlY2sgfHwgIWlzUHJvcFN1cHBvcnRlZChwcm9wZXJ0eSkpIHtcbiAgICBmb3IgKGogPSAwLCBsZW4xID0gUE9TU0lCTEVfUFJFRklYRVMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICBwcmVmaXggPSBQT1NTSUJMRV9QUkVGSVhFU1tqXTtcblxuICAgICAgaWYgKGlzUHJvcFN1cHBvcnRlZChcIi1cIi5jb25jYXQocHJlZml4LCBcIi1cIikuY29uY2F0KHByb3BlcnR5KSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIFwiLVwiLmNvbmNhdChwcmVmaXgsIFwiLVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xudmFyIG5vcm1hbGl6ZVByb3BlcnR5ID0gZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHkocHJvcGVydHkpIHtcbiAgcHJvcGVydHkgPSB0b0tlYmFiQ2FzZShwcm9wZXJ0eSk7XG5cbiAgaWYgKGlzUHJvcFN1cHBvcnRlZChwcm9wZXJ0eSkpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGdldFByZWZpeChwcm9wZXJ0eSwgdHJ1ZSkpLmNvbmNhdChwcm9wZXJ0eSk7XG4gIH1cbn07XG52YXIgbm9ybWFsaXplVmFsdWUgPSBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgaWYgKGluY2x1ZGVzKFJFUVVJUkVTX1VOSVRfVkFMVUUsIHByb3BlcnR5KSAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIGlmIChSRUdFWF9ESUdJVFMudGVzdCh2YWx1ZSkgJiYgIVJFR0VYX0xFTl9WQUwudGVzdCh2YWx1ZSkgJiYgIVJFR0VYX1NQQUNFLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSArPSBwcm9wZXJ0eSA9PT0gJ2xpbmUtaGVpZ2h0JyA/ICdlbScgOiAncHgnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgc29ydCA9IGZ1bmN0aW9uIHNvcnQoYXJyYXkpIHtcbiAgdmFyIGdyZWF0LCBpLCBsZW4sIGxlc3MsIHBpdm90O1xuXG4gIGlmIChhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9IGVsc2Uge1xuICAgIHBpdm90ID0gYXJyYXlbMF07XG4gICAgbGVzcyA9IFtdO1xuICAgIGdyZWF0ID0gW107XG4gICAgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKCsraSAhPT0gbGVuKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPD0gcGl2b3QpIHtcbiAgICAgICAgbGVzcy5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyZWF0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3J0KGxlc3MpLmNvbmNhdChwaXZvdCwgc29ydChncmVhdCkpO1xuICB9XG59O1xudmFyIGhhc2ggPSBmdW5jdGlvbiBoYXNoKHN0cmluZykge1xuICB2YXIgaHNoLCBpLCBsZW5ndGg7XG4gIGhzaCA9IDUzODE7XG4gIGkgPSAtMTtcbiAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoKytpICE9PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgaHNoID0gKGhzaCA8PCA1KSAtIGhzaCArIHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIGhzaCB8PSAwO1xuICB9XG5cbiAgcmV0dXJuICdfJyArIChoc2ggPCAwID8gaHNoICogLTIgOiBoc2gpO1xufTtcbnZhciBydWxlVG9TdHJpbmcgPSBmdW5jdGlvbiBydWxlVG9TdHJpbmcocnVsZSwgaW1wb3J0YW50KSB7XG4gIHZhciBqLCBsZW4xLCBvdXRwdXQsIHByb3AsIHByb3BlcnR5LCBwcm9wcywgdmFsdWU7XG4gIG91dHB1dCA9ICcnO1xuICBwcm9wcyA9IHNvcnQoT2JqZWN0LmtleXMocnVsZSkpO1xuXG4gIGZvciAoaiA9IDAsIGxlbjEgPSBwcm9wcy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICBwcm9wID0gcHJvcHNbal07XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVbcHJvcF0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBydWxlW3Byb3BdID09PSAnbnVtYmVyJykge1xuICAgICAgcHJvcGVydHkgPSBub3JtYWxpemVQcm9wZXJ0eShwcm9wKTtcbiAgICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUocHJvcGVydHksIHJ1bGVbcHJvcF0pO1xuXG4gICAgICBpZiAoaW1wb3J0YW50KSB7XG4gICAgICAgIHZhbHVlICs9IFwiICFpbXBvcnRhbnRcIjtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0ICs9IFwiXCIuY29uY2F0KHByb3BlcnR5LCBcIjpcIikuY29uY2F0KHZhbHVlLCBcIjtcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG52YXIgaW5saW5lU3R5bGVDb25maWcgPSBzdHlsZUNvbmZpZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgaW5saW5lU3R5bGUgPSBmdW5jdGlvbiBpbmxpbmVTdHlsZShydWxlLCB2YWx1ZVRvU3RvcmUsIGxldmVsKSB7XG4gIHZhciBjb25maWcsIHN0eWxlRWw7XG5cbiAgaWYgKCEoY29uZmlnID0gc3R5bGVDb25maWdbbGV2ZWxdKSkge1xuICAgIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWwuaWQgPSBcInF1aWNrY3NzXCIuY29uY2F0KGxldmVsIHx8ICcnKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICAgIHN0eWxlQ29uZmlnW2xldmVsXSA9IGNvbmZpZyA9IHtcbiAgICAgIGVsOiBzdHlsZUVsLFxuICAgICAgY29udGVudDogJycsXG4gICAgICBjYWNoZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gIH1cblxuICBpZiAoIWNvbmZpZy5jYWNoZVtydWxlXSkge1xuICAgIGNvbmZpZy5jYWNoZVtydWxlXSA9IHZhbHVlVG9TdG9yZSB8fCB0cnVlO1xuICAgIGNvbmZpZy5lbC50ZXh0Q29udGVudCA9IGNvbmZpZy5jb250ZW50ICs9IHJ1bGU7XG4gIH1cbn07XG52YXIgY2xlYXJJbmxpbmVTdHlsZSA9IGZ1bmN0aW9uIGNsZWFySW5saW5lU3R5bGUobGV2ZWwpIHtcbiAgdmFyIGNvbmZpZywgaiwga2V5LCBrZXlzLCBsZW4xO1xuXG4gIGlmIChjb25maWcgPSBzdHlsZUNvbmZpZ1tsZXZlbF0pIHtcbiAgICBpZiAoIWNvbmZpZy5jb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnLmVsLnRleHRDb250ZW50ID0gY29uZmlnLmNvbnRlbnQgPSAnJztcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnLmNhY2hlKTtcblxuICAgIGZvciAoaiA9IDAsIGxlbjEgPSBrZXlzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAga2V5ID0ga2V5c1tqXTtcbiAgICAgIGNvbmZpZy5jYWNoZVtrZXldID0gbnVsbDtcbiAgICB9XG4gIH1cbn07dmFyIHZlcnNpb24gPSBcIjEuNC4zXCI7dmFyIF9xdWlja2NzcztcbnZhciBpbmRleCA9IF9xdWlja2NzcyA9IGZ1bmN0aW9uIHF1aWNrY3NzKHRhcmdldEVsLCBwcm9wZXJ0eSwgdmFsdWUsIGltcG9ydGFudCkge1xuICB2YXIgY29tcHV0ZWRTdHlsZSwgaSwgbGVuLCBzdWJFbCwgc3ViUHJvcGVydHksIHN1YlZhbHVlO1xuXG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICFpc0l0ZXJhYmxlKHRhcmdldEVsKTpcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRhcmdldEVsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN1YkVsID0gdGFyZ2V0RWxbaV07XG5cbiAgICAgICAgX3F1aWNrY3NzKHN1YkVsLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX3R5cGVvZihwcm9wZXJ0eSkgIT09ICdvYmplY3QnOlxuICAgICAgLy8gUGFzc2VkIGEgc3R5bGUgbWFwXG4gICAgICBmb3IgKHN1YlByb3BlcnR5IGluIHByb3BlcnR5KSB7XG4gICAgICAgIHN1YlZhbHVlID0gcHJvcGVydHlbc3ViUHJvcGVydHldO1xuXG4gICAgICAgIF9xdWlja2Nzcyh0YXJnZXRFbCwgc3ViUHJvcGVydHksIHN1YlZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcGVydHkgPSBub3JtYWxpemVQcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbXB1dGVkU3R5bGUgPSB0YXJnZXRFbC5fY29tcHV0ZWRTdHlsZSB8fCAodGFyZ2V0RWwuX2NvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsKSk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgdGFyZ2V0RWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIG5vcm1hbGl6ZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSksIGltcG9ydGFudCA/IElNUE9SVEFOVCA6IHZvaWQgMCk7XG4gICAgICB9XG5cbiAgfVxufTtcblxuX3F1aWNrY3NzLmFuaW1hdGlvbiA9IGZ1bmN0aW9uIChuYW1lJCQxLCBmcmFtZXMpIHtcbiAgdmFyIGZyYW1lLCBnZW5lcmF0ZWQsIHByZWZpeCwgcnVsZXM7XG5cbiAgaWYgKG5hbWUkJDEgJiYgdHlwZW9mIG5hbWUkJDEgPT09ICdzdHJpbmcnICYmIGZyYW1lcyAmJiBfdHlwZW9mKGZyYW1lcykgPT09ICdvYmplY3QnKSB7XG4gICAgcHJlZml4ID0gZ2V0UHJlZml4KCdhbmltYXRpb24nKTtcbiAgICBnZW5lcmF0ZWQgPSAnJztcblxuICAgIGZvciAoZnJhbWUgaW4gZnJhbWVzKSB7XG4gICAgICBydWxlcyA9IGZyYW1lc1tmcmFtZV07XG4gICAgICBnZW5lcmF0ZWQgKz0gXCJcIi5jb25jYXQoZnJhbWUsIFwiIHtcIikuY29uY2F0KHJ1bGVUb1N0cmluZyhydWxlcyksIFwifVwiKTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZWQgPSBcIkBcIi5jb25jYXQocHJlZml4LCBcImtleWZyYW1lcyBcIikuY29uY2F0KG5hbWUkJDEsIFwiIHtcIikuY29uY2F0KGdlbmVyYXRlZCwgXCJ9XCIpO1xuICAgIHJldHVybiBpbmxpbmVTdHlsZShnZW5lcmF0ZWQsIHRydWUsIDApO1xuICB9XG59O1xuXG5fcXVpY2tjc3MucmVnaXN0ZXIgPSBmdW5jdGlvbiAocnVsZSwgbGV2ZWwsIGltcG9ydGFudCkge1xuICB2YXIgY2xhc3NOYW1lLCByZWYsIHN0eWxlO1xuXG4gIGlmIChydWxlICYmIF90eXBlb2YocnVsZSkgPT09ICdvYmplY3QnKSB7XG4gICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgcnVsZSA9IHJ1bGVUb1N0cmluZyhydWxlLCBpbXBvcnRhbnQpO1xuXG4gICAgaWYgKCEoY2xhc3NOYW1lID0gKHJlZiA9IGlubGluZVN0eWxlQ29uZmlnW2xldmVsXSkgIT0gbnVsbCA/IHJlZltydWxlXSA6IHZvaWQgMCkpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGhhc2gocnVsZSk7XG4gICAgICBzdHlsZSA9IFwiLlwiLmNvbmNhdChjbGFzc05hbWUsIFwiIHtcIikuY29uY2F0KHJ1bGUsIFwifVwiKTtcbiAgICAgIGlubGluZVN0eWxlKHN0eWxlLCBjbGFzc05hbWUsIGxldmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59O1xuXG5fcXVpY2tjc3MuY2xlYXJSZWdpc3RlcmVkID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gIHJldHVybiBjbGVhcklubGluZVN0eWxlKGxldmVsIHx8IDApO1xufTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuX3F1aWNrY3NzLlVOU0VUID0gZnVuY3Rpb24gKCkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhaXNWYWx1ZVN1cHBvcnRlZCgnZGlzcGxheScsICd1bnNldCcpOlxuICAgICAgcmV0dXJuICd1bnNldCc7XG5cbiAgICBjYXNlICFpc1ZhbHVlU3VwcG9ydGVkKCdkaXNwbGF5JywgJ2luaXRpYWwnKTpcbiAgICAgIHJldHVybiAnaW5pdGlhbCc7XG5cbiAgICBjYXNlICFpc1ZhbHVlU3VwcG9ydGVkKCdkaXNwbGF5JywgJ2luaGVyaXQnKTpcbiAgICAgIHJldHVybiAnaW5oZXJpdCc7XG4gIH1cbn0oKTtcblxuX3F1aWNrY3NzLnN1cHBvcnRzID0gaXNWYWx1ZVN1cHBvcnRlZDtcbl9xdWlja2Nzcy5zdXBwb3J0c1Byb3BlcnR5ID0gaXNQcm9wU3VwcG9ydGVkO1xuX3F1aWNrY3NzLm5vcm1hbGl6ZVByb3BlcnR5ID0gbm9ybWFsaXplUHJvcGVydHk7XG5fcXVpY2tjc3Mubm9ybWFsaXplVmFsdWUgPSBub3JtYWxpemVWYWx1ZTtcbl9xdWlja2Nzcy52ZXJzaW9uID0gdmVyc2lvbjtleHBvcnQgZGVmYXVsdCBpbmRleDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59dmFyIF9leHRlbmQsIGlzQXJyYXksIGlzT2JqZWN0LCBfc2hvdWxkRGVlcEV4dGVuZDtcblxuaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkodGFyZ2V0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRhcmdldCk7XG59O1xuXG5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0ICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXQpID09PSAnW29iamVjdCBPYmplY3RdJyB8fCBpc0FycmF5KHRhcmdldCk7XG59O1xuXG5fc2hvdWxkRGVlcEV4dGVuZCA9IGZ1bmN0aW9uIHNob3VsZERlZXBFeHRlbmQob3B0aW9ucywgdGFyZ2V0LCBwYXJlbnRLZXkpIHtcbiAgaWYgKG9wdGlvbnMuZGVlcCkge1xuICAgIGlmIChvcHRpb25zLm5vdERlZXApIHtcbiAgICAgIHJldHVybiAhb3B0aW9ucy5ub3REZWVwW3RhcmdldF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmRlZXBPbmx5KSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGVlcE9ubHlbdGFyZ2V0XSB8fCBwYXJlbnRLZXkgJiYgX3Nob3VsZERlZXBFeHRlbmQob3B0aW9ucywgcGFyZW50S2V5KTtcbiAgfVxufTsgLy8gZWxzZSBmYWxzZVxuXG5cbnZhciBleHRlbmQgPSBfZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG9wdGlvbnMsIHRhcmdldCwgc291cmNlcywgcGFyZW50S2V5KSB7XG4gIHZhciBpLCBrZXksIGxlbiwgc291cmNlLCBzb3VyY2VWYWx1ZSwgc3ViVGFyZ2V0LCB0YXJnZXRWYWx1ZTtcblxuICBpZiAoIXRhcmdldCB8fCBfdHlwZW9mKHRhcmdldCkgIT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0YXJnZXQgPSB7fTtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgc291cmNlVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcblxuICAgICAgICBpZiAoc291cmNlVmFsdWUgPT09IHRhcmdldCB8fCBzb3VyY2VWYWx1ZSA9PT0gdm9pZCAwIHx8IHNvdXJjZVZhbHVlID09PSBudWxsICYmICFvcHRpb25zLmFsbG93TnVsbCAmJiAhb3B0aW9ucy5udWxsRGVsZXRlcyB8fCBvcHRpb25zLmtleXMgJiYgIW9wdGlvbnMua2V5c1trZXldIHx8IG9wdGlvbnMubm90S2V5cyAmJiBvcHRpb25zLm5vdEtleXNba2V5XSB8fCBvcHRpb25zLm93biAmJiAhc291cmNlLmhhc093blByb3BlcnR5KGtleSkgfHwgb3B0aW9ucy5nbG9iYWxGaWx0ZXIgJiYgIW9wdGlvbnMuZ2xvYmFsRmlsdGVyKHNvdXJjZVZhbHVlLCBrZXksIHNvdXJjZSkgfHwgb3B0aW9ucy5maWx0ZXJzICYmIG9wdGlvbnMuZmlsdGVyc1trZXldICYmICFvcHRpb25zLmZpbHRlcnNba2V5XShzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlVmFsdWUgPT09IG51bGwgJiYgb3B0aW9ucy5udWxsRGVsZXRlcykge1xuICAgICAgICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmdsb2JhbFRyYW5zZm9ybSkge1xuICAgICAgICAgIHNvdXJjZVZhbHVlID0gb3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0oc291cmNlVmFsdWUsIGtleSwgc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zZm9ybXMgJiYgb3B0aW9ucy50cmFuc2Zvcm1zW2tleV0pIHtcbiAgICAgICAgICBzb3VyY2VWYWx1ZSA9IG9wdGlvbnMudHJhbnNmb3Jtc1trZXldKHNvdXJjZVZhbHVlLCBrZXksIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhKG9wdGlvbnMuY29uY2F0ICYmIGlzQXJyYXkoc291cmNlVmFsdWUpICYmIGlzQXJyYXkodGFyZ2V0VmFsdWUpKTpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdGFyZ2V0VmFsdWUuY29uY2F0KHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAhKF9zaG91bGREZWVwRXh0ZW5kKG9wdGlvbnMsIGtleSwgcGFyZW50S2V5KSAmJiBpc09iamVjdChzb3VyY2VWYWx1ZSkpOlxuICAgICAgICAgICAgc3ViVGFyZ2V0ID0gaXNPYmplY3QodGFyZ2V0VmFsdWUpID8gdGFyZ2V0VmFsdWUgOiBpc0FycmF5KHNvdXJjZVZhbHVlKSA/IFtdIDoge307XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IF9leHRlbmQob3B0aW9ucywgc3ViVGFyZ2V0LCBbc291cmNlVmFsdWVdLCBrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O3ZhciB2ZXJzaW9uID0gXCIxLjcuNFwiO3ZhciBtb2RpZmllcnMsIG5ld0J1aWxkZXIsIG5vcm1hbGl6ZUtleXMsIHByaW1hcnlCdWlsZGVyO1xuXG5ub3JtYWxpemVLZXlzID0gZnVuY3Rpb24gbm9ybWFsaXplS2V5cyhrZXlzKSB7XG4gIHZhciBpLCBrZXksIGxlbiwgb3V0cHV0O1xuXG4gIGlmIChrZXlzKSB7XG4gICAgb3V0cHV0ID0ge307XG5cbiAgICBpZiAoX3R5cGVvZihrZXlzKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG91dHB1dFtrZXlzXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgb3V0cHV0W2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG5cbm5ld0J1aWxkZXIgPSBmdW5jdGlvbiBuZXdCdWlsZGVyKGlzQmFzZSkge1xuICB2YXIgX2J1aWxkZXI7XG5cbiAgX2J1aWxkZXIgPSBmdW5jdGlvbiBidWlsZGVyKHRhcmdldCkge1xuICAgIHZhciB0aGVUYXJnZXQ7XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgJF9pID0gLTEsIHNvdXJjZXMgPSBuZXcgQXJyYXkoJF9sZW4pOyB3aGlsZSAoKyskX2kgPCAkX2xlbikgc291cmNlc1skX2ldID0gYXJndW1lbnRzWyRfaV07XG5cbiAgICBpZiAoX2J1aWxkZXIub3B0aW9ucy50YXJnZXQpIHtcbiAgICAgIHRoZVRhcmdldCA9IF9idWlsZGVyLm9wdGlvbnMudGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGVUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZChfYnVpbGRlci5vcHRpb25zLCB0aGVUYXJnZXQsIHNvdXJjZXMpO1xuICB9O1xuXG4gIGlmIChpc0Jhc2UpIHtcbiAgICBfYnVpbGRlci5pc0Jhc2UgPSB0cnVlO1xuICB9XG5cbiAgX2J1aWxkZXIub3B0aW9ucyA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfYnVpbGRlciwgbW9kaWZpZXJzKTtcbiAgcmV0dXJuIF9idWlsZGVyO1xufTtcblxubW9kaWZpZXJzID0ge1xuICAnZGVlcCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmRlZXAgPSB0cnVlO1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnb3duJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICBfLm9wdGlvbnMub3duID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ2FsbG93TnVsbCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmFsbG93TnVsbCA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdudWxsRGVsZXRlcyc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLm51bGxEZWxldGVzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ2NvbmNhdCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmNvbmNhdCA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdjbG9uZSc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLnRhcmdldCA9IHt9O1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnbm90RGVlcCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIF8ub3B0aW9ucy5ub3REZWVwID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ2RlZXBPbmx5Jzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLmRlZXBPbmx5ID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ2tleXMnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBfLm9wdGlvbnMua2V5cyA9IG5vcm1hbGl6ZUtleXMoa2V5cyk7XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdub3RLZXlzJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLm5vdEtleXMgPSBub3JtYWxpemVLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gXztcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAndHJhbnNmb3JtJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF8ub3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtICYmIF90eXBlb2YodHJhbnNmb3JtKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBfLm9wdGlvbnMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdmaWx0ZXInOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgXy5vcHRpb25zLmdsb2JhbEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIgJiYgX3R5cGVvZihmaWx0ZXIpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIF8ub3B0aW9ucy5maWx0ZXJzID0gZmlsdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnByaW1hcnlCdWlsZGVyID0gbmV3QnVpbGRlcih0cnVlKTtcbnByaW1hcnlCdWlsZGVyLnZlcnNpb24gPSB2ZXJzaW9uO1xudmFyIHByaW1hcnlCdWlsZGVyJDEgPSBwcmltYXJ5QnVpbGRlcjtleHBvcnQgZGVmYXVsdCBwcmltYXJ5QnVpbGRlciQxOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufXZhciBkZWZpbmVkID0gZnVuY3Rpb24gZGVmaW5lZChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICE9PSB2b2lkIDA7XG59O1xudmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCBpbnN0YW5jZW9mIEFycmF5O1xufTtcbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gX3R5cGVvZihzdWJqZWN0KSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdDsgLy8gMm5kIGNoZWNrIGlzIHRvIHRlc3QgYWdhaW5zdCAnbnVsbCcgdmFsdWVzXG59O1xudmFyIG9iamVjdFBsYWluID0gZnVuY3Rpb24gb2JqZWN0UGxhaW4oc3ViamVjdCkge1xuICByZXR1cm4gb2JqZWN0KHN1YmplY3QpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgc3ViamVjdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnO1xufTtcbnZhciBudW1iZXIgPSBmdW5jdGlvbiBudW1iZXIoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInICYmICFpc05hTihzdWJqZWN0KTtcbn07XG52YXIgbnVtYmVyTG9vc2UgPSBmdW5jdGlvbiBudW1iZXJMb29zZShzdWJqZWN0KSB7XG4gIHJldHVybiBudW1iZXIoc3ViamVjdCkgfHwgc3RyaW5nKHN1YmplY3QpICYmIG51bWJlcihOdW1iZXIoc3ViamVjdCkpO1xufTtcbnZhciBpdGVyYWJsZSA9IGZ1bmN0aW9uIGl0ZXJhYmxlKHN1YmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdChzdWJqZWN0KSAmJiBudW1iZXIoc3ViamVjdC5sZW5ndGgpO1xufTtcbnZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbiBmdW5jdGlvbl8oc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdmdW5jdGlvbic7XG59O3ZhciBuYXRpdmVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RlZmluZWQ6IGRlZmluZWQsYXJyYXk6IGFycmF5LG9iamVjdDogb2JqZWN0LG9iamVjdFBsYWluOiBvYmplY3RQbGFpbixzdHJpbmc6IHN0cmluZyxudW1iZXI6IG51bWJlcixudW1iZXJMb29zZTogbnVtYmVyTG9vc2UsaXRlcmFibGU6IGl0ZXJhYmxlLGZ1bmN0aW9uXzogZnVuY3Rpb25ffSk7dmFyIGRvbURvYyA9IGZ1bmN0aW9uIGRvbURvYyhzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZVR5cGUgPT09IDk7XG59O1xudmFyIGRvbUVsID0gZnVuY3Rpb24gZG9tRWwoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVUeXBlID09PSAxO1xufTtcbnZhciBkb21UZXh0ID0gZnVuY3Rpb24gZG9tVGV4dChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZVR5cGUgPT09IDM7XG59O1xudmFyIGRvbU5vZGUgPSBmdW5jdGlvbiBkb21Ob2RlKHN1YmplY3QpIHtcbiAgcmV0dXJuIGRvbUVsKHN1YmplY3QpIHx8IGRvbVRleHQoc3ViamVjdCk7XG59O1xudmFyIGRvbVRleHRhcmVhID0gZnVuY3Rpb24gZG9tVGV4dGFyZWEoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVOYW1lID09PSAnVEVYVEFSRUEnO1xufTtcbnZhciBkb21JbnB1dCA9IGZ1bmN0aW9uIGRvbUlucHV0KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlTmFtZSA9PT0gJ0lOUFVUJztcbn07XG52YXIgZG9tU2VsZWN0ID0gZnVuY3Rpb24gZG9tU2VsZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCc7XG59O1xudmFyIGRvbUZpZWxkID0gZnVuY3Rpb24gZG9tRmllbGQoc3ViamVjdCkge1xuICByZXR1cm4gZG9tSW5wdXQoc3ViamVjdCkgfHwgZG9tVGV4dGFyZWEoc3ViamVjdCkgfHwgZG9tU2VsZWN0KHN1YmplY3QpO1xufTt2YXIgZG9tID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RvbURvYzogZG9tRG9jLGRvbUVsOiBkb21FbCxkb21UZXh0OiBkb21UZXh0LGRvbU5vZGU6IGRvbU5vZGUsZG9tVGV4dGFyZWE6IGRvbVRleHRhcmVhLGRvbUlucHV0OiBkb21JbnB1dCxkb21TZWxlY3Q6IGRvbVNlbGVjdCxkb21GaWVsZDogZG9tRmllbGR9KTt2YXIgQVZBSUxfU0VUUywgQ2hlY2tzO1xuQVZBSUxfU0VUUyA9IHtcbiAgbmF0aXZlczogbmF0aXZlcyxcbiAgZG9tOiBkb21cbn07XG5cbkNoZWNrcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhDaGVja3MsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgYXJncztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ2hlY2tzKGFyZ3MpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIENoZWNrcyhzZXRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrcyk7XG5cbiAgICB2YXIgaSwgbGVuLCBzZXQ7XG5cbiAgICBpZiAoc2V0cyA9PSBudWxsKSB7XG4gICAgICBzZXRzID0gWyduYXRpdmVzJ107XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0ID0gc2V0c1tpXTtcblxuICAgICAgaWYgKEFWQUlMX1NFVFNbc2V0XSkge1xuICAgICAgICB0aGlzLmxvYWQoQVZBSUxfU0VUU1tzZXRdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hlY2tzLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoc2V0KSB7XG4gICAgICB2YXIga2V5LCB2YWx1ZTtcblxuICAgICAgaWYgKEFWQUlMX1NFVFMubmF0aXZlcy5zdHJpbmcoc2V0KSkge1xuICAgICAgICBzZXQgPSBBVkFJTF9TRVRTW3NldF07XG4gICAgICB9XG5cbiAgICAgIGlmICghQVZBSUxfU0VUUy5uYXRpdmVzLm9iamVjdFBsYWluKHNldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGtleSBpbiBzZXQpIHtcbiAgICAgICAgdmFsdWUgPSBzZXRba2V5XTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnZnVuY3Rpb25fJykge1xuICAgICAgICAgIGtleSA9ICdmdW5jdGlvbic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2hlY2tzO1xufSgpO1xuXG52YXIgaW5kZXggPSBDaGVja3MucHJvdG90eXBlLmNyZWF0ZSgpO2V4cG9ydCBkZWZhdWx0IGluZGV4OyIsImltcG9ydCBDU1MgZnJvbSdxdWlja2Nzcyc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0IElTXyBmcm9tJ0BkYW5pZWxrYWxlbi9pcyc7ZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59dmFyIHRlbXBsYXRlID0gWydpZCcsICduYW1lJywgJ3R5cGUnLCAnaHJlZicsICdzZWxlY3RlZCcsICdjaGVja2VkJywgJ2NsYXNzTmFtZSddOyAvLyBUbyBjb3B5IGZyb20gRE9NIEVsZW1lbnRzXG5cbnZhciBlbGVtZW50ID0gWydpZCcsICdyZWYnLCAndHlwZScsICduYW1lJywgJ3RleHQnLCAnc3R5bGUnLCAnY2xhc3MnLCAnY2xhc3NOYW1lJywgJ3VybCcsICdocmVmJywgJ3NlbGVjdGVkJywgJ2NoZWNrZWQnLCAncHJvcHMnLCAnYXR0cnMnLCAncGFzc1N0YXRlVG9DaGlsZHJlbicsICdzdGF0ZVRyaWdnZXJzJywgJ3VucGFzc2FibGVTdGF0ZXMnXTsgLy8gVXNlZCBpbiBRdWlja0VsZW1lbnQ6OnRvSlNPTlxuLy8gJ3JlbGF0ZWRJbnN0YW5jZSdcbnZhciBJUztcbklTID0gSVNfLmNyZWF0ZSgnbmF0aXZlcycsICdkb20nKTtcbklTLmxvYWQoe1xuICBxdWlja0RvbUVsOiBmdW5jdGlvbiBxdWlja0RvbUVsKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdRdWlja0VsZW1lbnQnO1xuICB9LFxuICB0ZW1wbGF0ZTogZnVuY3Rpb24gdGVtcGxhdGUoc3ViamVjdCkge1xuICAgIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ1F1aWNrVGVtcGxhdGUnO1xuICB9XG59KTsgLy8gYmF0Y2g6IChzdWJqZWN0KS0+IHN1YmplY3QgYW5kIHN1YmplY3QuY29uc3RydWN0b3IubmFtZSBpcyAnUXVpY2tCYXRjaCdcblxudmFyIElTJDEgPSBJUzt2YXIgUXVpY2tFbGVtZW50LCBRdWlja1dpbmRvdywgX3F1aWNrZG9tO1xuUXVpY2tFbGVtZW50ID0gbnVsbDtcblF1aWNrV2luZG93ID0gbnVsbDtcblxuX3F1aWNrZG9tID0gZnVuY3Rpb24gcXVpY2tkb20oKSB7XG4gIHZhciBhcmcsIGFyZ3MsIGVsZW1lbnQsIGksIGosIGxlbiwgcHJldkNvdW50O1xuICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG4gIGZvciAoaSA9IGogPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgIGFyZ3NbaV0gPSBhcmc7XG4gIH1cblxuICBwcmV2Q291bnQgPSBRdWlja0VsZW1lbnQuY291bnQ7XG4gIGVsZW1lbnQgPSBfcXVpY2tkb20uY3JlYXRlKGFyZ3MpO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX3Bvc3RDcmVhdGlvbiAmJiBRdWlja0VsZW1lbnQuY291bnQgIT09IHByZXZDb3VudCkge1xuICAgIGVsZW1lbnQuX3Bvc3RDcmVhdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5fcXVpY2tkb20uY3JlYXRlID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgdmFyIGFyZ3NMZW5ndGgsIGNoaWxkLCBjaGlsZHJlbiwgZWxlbWVudCwgaSwgaiwgbGVuLCBvcHRpb25zLCB0eXBlO1xuXG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICFJUyQxLmFycmF5KGFyZ3NbMF0pOlxuICAgICAgcmV0dXJuIF9xdWlja2RvbS5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShhcmdzWzBdKSk7XG5cbiAgICBjYXNlICFJUyQxLnRlbXBsYXRlKGFyZ3NbMF0pOlxuICAgICAgcmV0dXJuIGFyZ3NbMF0uc3Bhd24oKTtcblxuICAgIGNhc2UgIUlTJDEucXVpY2tEb21FbChhcmdzWzBdKTpcbiAgICAgIGlmIChhcmdzWzFdKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdLnVwZGF0ZU9wdGlvbnMoYXJnc1sxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH1cblxuICAgIGNhc2UgIShJUyQxLmRvbU5vZGUoYXJnc1swXSkgfHwgSVMkMS5kb21Eb2MoYXJnc1swXSkpOlxuICAgICAgaWYgKGFyZ3NbMF0uX3F1aWNrRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYXJnc1swXS5fcXVpY2tFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gYXJnc1swXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgICBvcHRpb25zID0gYXJnc1sxXSB8fCB7fTtcbiAgICAgIG9wdGlvbnMuZXhpc3RpbmcgPSBhcmdzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBRdWlja0VsZW1lbnQodHlwZSwgb3B0aW9ucyk7XG5cbiAgICBjYXNlIGFyZ3NbMF0gIT09IHdpbmRvdzpcbiAgICAgIHJldHVybiBRdWlja1dpbmRvdztcblxuICAgIGNhc2UgIUlTJDEuc3RyaW5nKGFyZ3NbMF0pOlxuICAgICAgdHlwZSA9IGFyZ3NbMF0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBvcHRpb25zID0gSVMkMS5vYmplY3QoYXJnc1sxXSkgPyBhcmdzWzFdIDoge1xuICAgICAgICAgIHRleHQ6IGFyZ3NbMV0gfHwgJydcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBJUyQxLm9iamVjdChhcmdzWzFdKSA/IGFyZ3NbMV0gOiB7fTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IG5ldyBRdWlja0VsZW1lbnQodHlwZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBuZXcgQXJyYXkoYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBhcmdzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2pdO1xuXG4gICAgICAgICAgaWYgKElTJDEuc3RyaW5nKGNoaWxkKSkge1xuICAgICAgICAgICAgY2hpbGQgPSBfcXVpY2tkb20udGV4dChjaGlsZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKElTJDEuYXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICBjaGlsZCA9IF9xdWlja2RvbS5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShjaGlsZCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChJUyQxLnF1aWNrRG9tRWwoY2hpbGQpKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuXG4gICAgY2FzZSAhKGFyZ3NbMF0gJiYgKElTJDEuZG9tTm9kZShhcmdzWzBdWzBdKSB8fCBJUyQxLmRvbURvYyhhcmdzWzBdWzBdKSkpOlxuICAgICAgcmV0dXJuIF9xdWlja2RvbShhcmdzWzBdWzBdKTtcbiAgfVxufTtcblxuX3F1aWNrZG9tLmh0bWwgPSBmdW5jdGlvbiAoaW5uZXJIVE1MKSB7XG4gIHZhciBjaGlsZHJlbiwgY29udGFpbmVyO1xuICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udGFpbmVyLmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250YWluZXIuY2hpbGROb2Rlcyk7XG4gIHJldHVybiBfcXVpY2tkb20uYmF0Y2goY2hpbGRyZW4pO1xufTtcblxuX3F1aWNrZG9tLmlzUXVpY2tFbCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIElTJDEucXVpY2tEb21FbCh0YXJnZXQpO1xufTtcblxuX3F1aWNrZG9tLmlzRWwgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBJUyQxLmRvbUVsKHRhcmdldCk7XG59O1xudmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KFF1aWNrRWxlbWVudF8sIFF1aWNrV2luZG93Xykge1xuICBRdWlja0VsZW1lbnQgPSBRdWlja0VsZW1lbnRfO1xuICBRdWlja1dpbmRvdyA9IFF1aWNrV2luZG93XztcbiAgcmV0dXJuIF9xdWlja2RvbTtcbn07dmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModGFyZ2V0LCBpdGVtKSB7XG4gIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufTtcbnZhciByZW1vdmVJdGVtID0gZnVuY3Rpb24gcmVtb3ZlSXRlbSh0YXJnZXQsIGl0ZW0pIHtcbiAgdmFyIGl0ZW1JbmRleDtcbiAgaXRlbUluZGV4ID0gdGFyZ2V0LmluZGV4T2YoaXRlbSk7XG5cbiAgaWYgKGl0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBub3JtYWxpemVFbGVtZW50QXJnID0gZnVuY3Rpb24gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhSVMkMS5zdHJpbmcodGFyZ2V0RWwpOlxuICAgICAgcmV0dXJuIHF1aWNrZG9tLnRleHQodGFyZ2V0RWwpO1xuXG4gICAgY2FzZSAhSVMkMS5kb21Ob2RlKHRhcmdldEVsKTpcbiAgICAgIHJldHVybiBxdWlja2RvbSh0YXJnZXRFbCk7XG5cbiAgICBjYXNlICFJUyQxLnRlbXBsYXRlKHRhcmdldEVsKTpcbiAgICAgIHJldHVybiB0YXJnZXRFbC5zcGF3bigpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0YXJnZXRFbDtcbiAgfVxufTtcbnZhciBpc1N0YXRlU3R5bGUgPSBmdW5jdGlvbiBpc1N0YXRlU3R5bGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbMF0gPT09ICckJyB8fCBzdHJpbmdbMF0gPT09ICdAJztcbn07XG52YXIgcmVnaXN0ZXJTdHlsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGUocnVsZSwgbGV2ZWwsIGltcG9ydGFudCkge1xuICB2YXIgY2FjaGVkLCBpLCBsZW4sIG91dHB1dCwgcHJvcCwgcHJvcHM7XG4gIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICBjYWNoZWQgPSBzdHlsZUNhY2hlLmdldChydWxlLCBsZXZlbCk7XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cblxuICBvdXRwdXQgPSB7XG4gICAgY2xhc3NOYW1lOiBbQ1NTLnJlZ2lzdGVyKHJ1bGUsIGxldmVsLCBpbXBvcnRhbnQpXSxcbiAgICBmbnM6IFtdLFxuICAgIHJ1bGU6IHJ1bGVcbiAgfTtcbiAgcHJvcHMgPSBPYmplY3Qua2V5cyhydWxlKTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBwcm9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgIGlmICh0eXBlb2YgcnVsZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3V0cHV0LmZucy5wdXNoKFtwcm9wLCBydWxlW3Byb3BdXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlQ2FjaGUuc2V0KHJ1bGUsIG91dHB1dCwgbGV2ZWwpO1xufTtcbnZhciBzdHlsZUNhY2hlID0gbmV3IChcbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2NsYXNzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXG4gICAgdGhpcy5rZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2NsYXNzLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSwgbGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleDtcblxuICAgICAgaWYgKHRoaXMua2V5c1tsZXZlbF0pIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLmtleXNbbGV2ZWxdLmluZGV4T2Yoa2V5KTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2xldmVsXVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlLCBsZXZlbCkge1xuICAgICAgaWYgKCF0aGlzLmtleXNbbGV2ZWxdKSB7XG4gICAgICAgIHRoaXMua2V5c1tsZXZlbF0gPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZXNbbGV2ZWxdID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMua2V5c1tsZXZlbF0ucHVzaChrZXkpO1xuICAgICAgdGhpcy52YWx1ZXNbbGV2ZWxdLnB1c2godmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfY2xhc3M7XG59KCkpKCk7dmFyIFJFR0VYX1dISVRFU1BBQ0U7XG5SRUdFWF9XSElURVNQQUNFID0gL1xccysvO1xudmFyIG9uXyA9IGZ1bmN0aW9uIG9uXyhldmVudE5hbWVzLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSwgaXNQcml2YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIGNhbGxiYWNrUmVmLCBzcGxpdDtcblxuICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3MgPT0gbnVsbCkge1xuICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tzID0ge1xuICAgICAgX19yZWZzOiB7fVxuICAgIH07XG4gIH1cblxuICBpZiAoSVMkMS5zdHJpbmcoZXZlbnROYW1lcykgJiYgSVMkMS5mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBzcGxpdCA9IGV2ZW50TmFtZXMuc3BsaXQoJy4nKTtcbiAgICBjYWxsYmFja1JlZiA9IHNwbGl0WzFdO1xuICAgIGV2ZW50TmFtZXMgPSBzcGxpdFswXTtcblxuICAgIGlmIChldmVudE5hbWVzID09PSAnaW5zZXJ0ZWQnICYmIHRoaXMuX2luc2VydGVkKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3BhcmVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBldmVudE5hbWVzLnNwbGl0KFJFR0VYX1dISVRFU1BBQ0UpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGJhc2U7XG5cbiAgICAgIGlmICghX3RoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgX3RoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0gPSBbXTtcblxuICAgICAgICBpZiAoIWlzUHJpdmF0ZSkge1xuICAgICAgICAgIF90aGlzLl9saXN0ZW5UbyhldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9pbnZva2VIYW5kbGVycyhldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICB9LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2tSZWYpIHtcbiAgICAgICAgaWYgKChiYXNlID0gX3RoaXMuX2V2ZW50Q2FsbGJhY2tzLl9fcmVmcylbZXZlbnROYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZVtldmVudE5hbWVdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5fZXZlbnRDYWxsYmFja3MuX19yZWZzW2V2ZW50TmFtZV1bY2FsbGJhY2tSZWZdID0gY2FsbGJhY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBvbmNlID0gZnVuY3Rpb24gb25jZShldmVudE5hbWVzLCBjYWxsYmFjaykge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICB2YXIgX29uY2VDYWxsYmFjaztcblxuICBpZiAoSVMkMS5zdHJpbmcoZXZlbnROYW1lcykgJiYgSVMkMS5mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICB0aGlzLm9uKGV2ZW50TmFtZXMsIF9vbmNlQ2FsbGJhY2sgPSBmdW5jdGlvbiBvbmNlQ2FsbGJhY2soZXZlbnQpIHtcbiAgICAgIF90aGlzMi5vZmYoZXZlbnROYW1lcywgX29uY2VDYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzMiwgZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIG9mZl8gPSBmdW5jdGlvbiBvZmZfKGV2ZW50TmFtZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIHZhciBjYWxsYmFja1JlZiwgZXZlbnROYW1lLCBzcGxpdDtcblxuICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3MgPT0gbnVsbCkge1xuICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tzID0ge1xuICAgICAgX19yZWZzOiB7fVxuICAgIH07XG4gIH1cblxuICBpZiAoIUlTJDEuc3RyaW5nKGV2ZW50TmFtZXMpKSB7XG4gICAgZm9yIChldmVudE5hbWUgaW4gdGhpcy5fZXZlbnRDYWxsYmFja3MpIHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNwbGl0ID0gZXZlbnROYW1lcy5zcGxpdCgnLicpO1xuICAgIGNhbGxiYWNrUmVmID0gc3BsaXRbMV07XG4gICAgZXZlbnROYW1lcyA9IHNwbGl0WzBdO1xuICAgIGV2ZW50TmFtZXMuc3BsaXQoUkVHRVhfV0hJVEVTUEFDRSkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB2YXIgcmVmO1xuXG4gICAgICBpZiAoX3RoaXMzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSAocmVmID0gX3RoaXMzLl9ldmVudENhbGxiYWNrcy5fX3JlZnNbZXZlbnROYW1lXSkgIT0gbnVsbCA/IHJlZltjYWxsYmFja1JlZl0gOiB2b2lkIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSVMkMS5mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbShfdGhpczMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2FsbGJhY2tSZWYpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBlbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudE5hbWUpIHtcbiAgdmFyIGJ1YmJsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBjYW5jZWxhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICB2YXIgZXZlbnQ7XG5cbiAgaWYgKGV2ZW50TmFtZSAmJiBJUyQxLnN0cmluZyhldmVudE5hbWUpKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblxuICAgIGlmIChkYXRhICYmIF90eXBlb2YoZGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBleHRlbmQoZXZlbnQsIGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgZW1pdFByaXZhdGUgPSBmdW5jdGlvbiBlbWl0UHJpdmF0ZShldmVudE5hbWUsIGFyZykge1xuICB2YXIgcmVmO1xuXG4gIGlmIChldmVudE5hbWUgJiYgSVMkMS5zdHJpbmcoZXZlbnROYW1lKSAmJiAoKHJlZiA9IHRoaXMuX2V2ZW50Q2FsbGJhY2tzKSAhPSBudWxsID8gcmVmW2V2ZW50TmFtZV0gOiB2b2lkIDApKSB7XG4gICAgdGhpcy5faW52b2tlSGFuZGxlcnMoZXZlbnROYW1lLCBhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIF9pbnZva2VIYW5kbGVycyA9IGZ1bmN0aW9uIF9pbnZva2VIYW5kbGVycyhldmVudE5hbWUsIGFyZykge1xuICB2YXIgY2FsbGJhY2tzLCBjYiwgaSwgbGVuO1xuICBjYWxsYmFja3MgPSB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLnNsaWNlKCk7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgY2IuY2FsbCh0aGlzLCBhcmcpO1xuICB9XG59O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxudmFyIF9saXN0ZW5UbyA9IGZ1bmN0aW9uIF9saXN0ZW5UbyhldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gIHZhciBldmVudE5hbWVUb0xpc3RlbkZvciwgbGlzdGVuTWV0aG9kO1xuICBsaXN0ZW5NZXRob2QgPSB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnO1xuICBldmVudE5hbWVUb0xpc3RlbkZvciA9IHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lciA/IGV2ZW50TmFtZSA6IFwib25cIi5jb25jYXQoZXZlbnROYW1lKTtcbiAgdGhpcy5lbFtsaXN0ZW5NZXRob2RdKGV2ZW50TmFtZVRvTGlzdGVuRm9yLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSk7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIGV2ZW50cyAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUub24gPSBvbl87XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUub25jZSA9IG9uY2U7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUub2ZmID0gb2ZmXztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5lbWl0ID0gZW1pdDtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5lbWl0UHJpdmF0ZSA9IGVtaXRQcml2YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9pbnZva2VIYW5kbGVycyA9IF9pbnZva2VIYW5kbGVycztcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2xpc3RlblRvID0gX2xpc3RlblRvO1xufS8qKlxuICogU2V0cy9nZXRzIHRoZSB2YWx1ZSBvZiBhIHN0eWxlIHByb3BlcnR5LiBJbiBnZXR0ZXIgbW9kZSB0aGUgY29tcHV0ZWQgcHJvcGVydHkgb2ZcbiAqIHRoZSBzdHlsZSB3aWxsIGJlIHJldHVybmVkIHVubGVzcyB0aGUgZWxlbWVudCBpcyBub3QgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLiBJblxuICogd2Via2l0IGJyb3dzZXJzIGFsbCBjb21wdXRlZCBwcm9wZXJ0aWVzIG9mIGEgZGV0YWNoZWQgbm9kZSBhcmUgYWx3YXlzIGFuIGVtcHR5XG4gKiBzdHJpbmcgYnV0IGluIGdlY2tvIHRoZXkgcmVmbGVjdCBvbiB0aGUgYWN0dWFsIGNvbXB1dGVkIHZhbHVlLCBoZW5jZSB3ZSBuZWVkXG4gKiB0byBcIm5vcm1hbGl6ZVwiIHRoaXMgYmVoYXZpb3IgYW5kIG1ha2Ugc3VyZSB0aGF0IGV2ZW4gb24gZ2Vja28gYW4gZW1wdHkgc3RyaW5nXG4gKiBpcyByZXR1cm5lZFxuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cblxudmFyIHN0eWxlID0gZnVuY3Rpb24gc3R5bGUocHJvcGVydHkpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgYXJncywgaSwga2V5LCBrZXlzLCByZXN1bHQsIHZhbHVlO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgaWYgKElTJDEuc3RyaW5nKHByb3BlcnR5KSkge1xuICAgIHZhbHVlID0gdHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicgPyBhcmdzWzFdLmNhbGwodGhpcywgdGhpcy5yZWxhdGVkKSA6IGFyZ3NbMV07XG5cbiAgICBpZiAoYXJnc1sxXSA9PT0gbnVsbCAmJiBJUyQxLmRlZmluZWQodGhpcy5jdXJyZW50U3RhdGVTdHlsZShwcm9wZXJ0eSkpICYmICFJUyQxLmZ1bmN0aW9uKHRoaXMuY3VycmVudFN0YXRlU3R5bGUocHJvcGVydHkpKSkge1xuICAgICAgdmFsdWUgPSBDU1MuVU5TRVQ7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ1NTKF90aGlzLmVsLCBwcm9wZXJ0eSwgdmFsdWUsIF90aGlzLm9wdGlvbnMuZm9yY2VTdHlsZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gQ1NTKHRoaXMuZWwsIHByb3BlcnR5LCB2YWx1ZSwgdGhpcy5vcHRpb25zLmZvcmNlU3R5bGUpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICh0aGlzLl9pbnNlcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKElTJDEub2JqZWN0KHByb3BlcnR5KSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0eSk7XG4gICAgaSA9IC0xO1xuXG4gICAgd2hpbGUgKGtleSA9IGtleXNbKytpXSkge1xuICAgICAgdGhpcy5zdHlsZShrZXksIHByb3BlcnR5W2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuKiBBdHRlbXB0cyB0byByZXNvbHZlIHRoZSB2YWx1ZSBmb3IgYSBnaXZlbiBwcm9wZXJ0eSBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGlmIGVhY2ggb25lIGlzbid0IGEgdmFsaWQgdmFsdWU6XG4qIDEuIGZyb20gY29tcHV0ZWQgc3R5bGUgKGZvciBkb20taW5zZXJ0ZWQgZWxzKVxuKiAyLiBmcm9tIERPTUVsZW1lbnQuc3R5bGUgb2JqZWN0IChmb3Igbm9uLWluc2VydGVkIGVsczsgaWYgb3B0aW9ucy5zdHlsZUFmdGVySW5zZXJ0LCB3aWxsIG9ubHkgaGF2ZSBzdGF0ZSBzdHlsZXMpXG4qIDMuIGZyb20gcHJvdmlkZWQgc3R5bGUgb3B0aW9uc1xuKiAoZm9yIG5vbi1pbnNlcnRlZCBlbHM7IGNoZWNraW5nIG9ubHkgJGJhc2Ugc2luY2Ugc3RhdGUgc3R5bGVzIHdpbGwgYWx3YXlzIGJlIGFwcGxpZWQgdG8gdGhlIHN0eWxlIG9iamVjdCBldmVuIGZvciBub24taW5zZXJ0ZWQpXG4gKi9cblxudmFyIHN0eWxlU2FmZSA9IGZ1bmN0aW9uIHN0eWxlU2FmZShwcm9wZXJ0eSwgc2tpcENvbXB1dGVkKSB7XG4gIHZhciBjb21wdXRlZCwgcmVzdWx0LCBzYW1wbGU7XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2FtcGxlID0gdGhpcy5lbC5zdHlsZVtwcm9wZXJ0eV07XG5cbiAgaWYgKElTJDEuc3RyaW5nKHNhbXBsZSkgfHwgSVMkMS5udW1iZXIoc2FtcGxlKSkge1xuICAgIGNvbXB1dGVkID0gc2tpcENvbXB1dGVkID8gMCA6IHRoaXMuc3R5bGUocHJvcGVydHkpO1xuICAgIHJlc3VsdCA9IGNvbXB1dGVkIHx8IHRoaXMuZWwuc3R5bGVbcHJvcGVydHldIHx8IHRoaXMuY3VycmVudFN0YXRlU3R5bGUocHJvcGVydHkpIHx8ICcnO1xuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCB0aGlzLnJlbGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBzdHlsZVBhcnNlZCA9IGZ1bmN0aW9uIHN0eWxlUGFyc2VkKHByb3BlcnR5LCBza2lwQ29tcHV0ZWQpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5zdHlsZVNhZmUocHJvcGVydHksIHNraXBDb21wdXRlZCkpO1xufTtcbnZhciByZWNhbGNTdHlsZSA9IGZ1bmN0aW9uIHJlY2FsY1N0eWxlKHJlY2FsY0NoaWxkcmVuKSB7XG4gIHZhciBjaGlsZCwgaiwgbGVuLCByZWYsIHRhcmdldFN0eWxlcztcbiAgdGFyZ2V0U3R5bGVzID0gdGhpcy5fcmVzb2x2ZUZuU3R5bGVzKHRoaXMuX2dldEFjdGl2ZVN0YXRlcygpLCB0cnVlKTtcbiAgdGhpcy5zdHlsZSh0YXJnZXRTdHlsZXMpO1xuXG4gIGlmIChyZWNhbGNDaGlsZHJlbikge1xuICAgIHJlZiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBjaGlsZCA9IHJlZltqXTtcbiAgICAgIGNoaWxkLnJlY2FsY1N0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGN1cnJlbnRTdGF0ZVN0eWxlID0gZnVuY3Rpb24gY3VycmVudFN0YXRlU3R5bGUocHJvcGVydHkpIHtcbiAgdmFyIGksIHN0YXRlLCBzdGF0ZXM7XG5cbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlLmxlbmd0aCkge1xuICAgICAgc3RhdGVzID0gdGhpcy5fc3RhdGUuc2xpY2UoKTtcblxuICAgICAgaWYgKHRoaXMuX3N0YXRlU2hhcmVkICYmIHRoaXMuX3N0YXRlU2hhcmVkLmxlbmd0aCkge1xuICAgICAgICB2YXIgX3N0YXRlcztcblxuICAgICAgICAoX3N0YXRlcyA9IHN0YXRlcykucHVzaC5hcHBseShfc3RhdGVzLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fc3RhdGVTaGFyZWQpKTtcbiAgICAgIH1cblxuICAgICAgaSA9IHN0YXRlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChzdGF0ZSA9IHN0YXRlc1stLWldKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZXNbc3RhdGVdICYmIElTJDEuZGVmaW5lZCh0aGlzLl9zdHlsZXNbc3RhdGVdLnJ1bGVbcHJvcGVydHldKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdHlsZXNbc3RhdGVdLnJ1bGVbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0eWxlcy5iYXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVzLmJhc2UucnVsZVtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG59O1xudmFyIGhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICdub25lJyk7XG59O1xudmFyIHNob3cgPSBmdW5jdGlvbiBzaG93KGRpc3BsYXkpIHtcbiAgdmFyIHJlZjtcblxuICBpZiAoIWRpc3BsYXkpIHtcbiAgICBkaXNwbGF5ID0gdGhpcy5jdXJyZW50U3RhdGVTdHlsZSgnZGlzcGxheScpO1xuXG4gICAgaWYgKGRpc3BsYXkgPT09ICdub25lJyB8fCAhZGlzcGxheSkge1xuICAgICAgZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpc3BsYXkgPT0gbnVsbCkge1xuICAgIGRpc3BsYXkgPSAoKHJlZiA9IHRoaXMuX3N0eWxlcy5iYXNlKSAhPSBudWxsID8gcmVmLmRpc3BsYXkgOiB2b2lkIDApIHx8ICdibG9jayc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsIGRpc3BsYXkpO1xufTtcbnZhciBvcmllbnRhdGlvbkdldHRlciA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMud2lkdGggPiB0aGlzLmhlaWdodCkge1xuICAgICAgcmV0dXJuICdsYW5kc2NhcGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3BvcnRyYWl0JztcbiAgICB9XG4gIH1cbn07XG52YXIgYXNwZWN0UmF0aW9HZXR0ZXIgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBzdHlsZSQxIChRdWlja0VsZW1lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICdvcmllbnRhdGlvbic6IG9yaWVudGF0aW9uR2V0dGVyLFxuICAgICdhc3BlY3RSYXRpbyc6IGFzcGVjdFJhdGlvR2V0dGVyLFxuICAgICdyZWN0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3dpZHRoJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuc3R5bGUoJ3dpZHRoJykpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCd3aWR0aCcsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdoZWlnaHQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5zdHlsZSgnaGVpZ2h0JykpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdoZWlnaHQnLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zdHlsZSA9IHN0eWxlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnN0eWxlU2FmZSA9IHN0eWxlU2FmZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zdHlsZVBhcnNlZCA9IHN0eWxlUGFyc2VkO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnJlY2FsY1N0eWxlID0gcmVjYWxjU3R5bGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuY3VycmVudFN0YXRlU3R5bGUgPSBjdXJyZW50U3RhdGVTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gaGlkZTtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc2hvdyA9IHNob3c7XG59dmFyIFF1aWNrV2luZG93JDE7XG52YXIgUXVpY2tXaW5kb3ckMiA9IFF1aWNrV2luZG93JDEgPSB7XG4gIHR5cGU6ICd3aW5kb3cnLFxuICBlbDogd2luZG93LFxuICByYXc6IHdpbmRvdyxcbiAgX2V2ZW50Q2FsbGJhY2tzOiB7XG4gICAgX19yZWZzOiB7fVxuICB9XG59O1xuUXVpY2tXaW5kb3ckMS5vbiA9IG9uXztcblF1aWNrV2luZG93JDEub2ZmID0gb2ZmXztcblF1aWNrV2luZG93JDEuZW1pdCA9IGVtaXQ7XG5RdWlja1dpbmRvdyQxLmVtaXRQcml2YXRlID0gZW1pdFByaXZhdGU7XG5RdWlja1dpbmRvdyQxLl9saXN0ZW5UbyA9IF9saXN0ZW5UbztcblF1aWNrV2luZG93JDEuX2ludm9rZUhhbmRsZXJzID0gX2ludm9rZUhhbmRsZXJzO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tXaW5kb3ckMSwge1xuICAnd2lkdGgnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgfVxuICB9LFxuICAnaGVpZ2h0Jzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG4gIH0sXG4gICdvcmllbnRhdGlvbic6IG9yaWVudGF0aW9uR2V0dGVyLFxuICAnYXNwZWN0UmF0aW8nOiBhc3BlY3RSYXRpb0dldHRlclxufSk7dmFyIE1lZGlhUXVlcnksIFJVTEVfREVJTElNSVRFUjtcblJVTEVfREVJTElNSVRFUiA9IC8sXFxzKi87XG52YXIgTWVkaWFRdWVyeSQxID0gTWVkaWFRdWVyeSA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MsIHRlc3RSdWxlO1xuICBjYWxsYmFja3MgPSBbXTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FsbGJhY2ssIGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24gKHRhcmdldCwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcXVlcnlTcGxpdCwgcnVsZXMsIHNvdXJjZTtcbiAgICBxdWVyeVNwbGl0ID0gcXVlcnlTdHJpbmcuc3BsaXQoJygnKTtcbiAgICBzb3VyY2UgPSBxdWVyeVNwbGl0WzBdO1xuXG4gICAgc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgY2FzZSAnd2luZG93JzpcbiAgICAgICAgICByZXR1cm4gUXVpY2tXaW5kb3ckMjtcblxuICAgICAgICBjYXNlICdwYXJlbnQnOlxuICAgICAgICAgIHJldHVybiB0YXJnZXQucGFyZW50O1xuXG4gICAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LnBhcmVudE1hdGNoaW5nKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQucmVmID09PSBzb3VyY2Uuc2xpY2UoMSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSgpO1xuXG4gICAgcnVsZXMgPSBxdWVyeVNwbGl0WzFdLnNsaWNlKDAsIC0xKS5zcGxpdChSVUxFX0RFSUxJTUlURVIpLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgdmFyIGdldHRlciwga2V5LCBrZXlQcmVmaXgsIG1heCwgbWluLCBzcGxpdCwgdmFsdWU7XG4gICAgICBzcGxpdCA9IHJ1bGUuc3BsaXQoJzonKTtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdChzcGxpdFsxXSk7XG5cbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBzcGxpdFsxXTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gc3BsaXRbMF07XG4gICAgICBrZXlQcmVmaXggPSBrZXkuc2xpY2UoMCwgNCk7XG4gICAgICBtYXggPSBrZXlQcmVmaXggPT09ICdtYXgtJztcbiAgICAgIG1pbiA9ICFtYXggJiYga2V5UHJlZml4ID09PSAnbWluLSc7XG5cbiAgICAgIGlmIChtYXggfHwgbWluKSB7XG4gICAgICAgIGtleSA9IGtleS5zbGljZSg0KTtcbiAgICAgIH1cblxuICAgICAgZ2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ29yaWVudGF0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzb3VyY2Uub3JpZW50YXRpb247XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FzZSAnYXNwZWN0LXJhdGlvJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc291cmNlW2tleV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJzZWRWYWx1ZSwgc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc291cmNlLnN0eWxlKGtleSk7XG4gICAgICAgICAgICAgIHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdChzdHJpbmdWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4LFxuICAgICAgICBnZXR0ZXI6IGdldHRlclxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBydWxlczogcnVsZXNcbiAgICB9O1xuICB9O1xuXG4gIHRoaXMucmVnaXN0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBxdWVyeVN0cmluZykge1xuICAgIHZhciBjYWxsYmFjaywgcXVlcnk7XG4gICAgcXVlcnkgPSB0aGlzLnBhcnNlUXVlcnkodGFyZ2V0LCBxdWVyeVN0cmluZyk7XG5cbiAgICBpZiAocXVlcnkuc291cmNlKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGVzdFJ1bGUodGFyZ2V0LCBxdWVyeSwgcXVlcnlTdHJpbmcpO1xuICAgICAgfSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeTtcbiAgfTtcblxuICB0ZXN0UnVsZSA9IGZ1bmN0aW9uIHRlc3RSdWxlKHRhcmdldCwgcXVlcnksIHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSwgaSwgbGVuLCBwYXNzZWQsIHJlZiwgcnVsZTtcbiAgICBwYXNzZWQgPSB0cnVlO1xuICAgIHJlZiA9IHF1ZXJ5LnJ1bGVzO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBydWxlID0gcmVmW2ldO1xuICAgICAgY3VycmVudFZhbHVlID0gcnVsZS5nZXR0ZXIoKTtcblxuICAgICAgcGFzc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhcnVsZS5taW46XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlID49IHJ1bGUudmFsdWU7XG5cbiAgICAgICAgICBjYXNlICFydWxlLm1heDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPD0gcnVsZS52YWx1ZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSBydWxlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICghcGFzc2VkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc3RhdGUocXVlcnlTdHJpbmcsIHBhc3NlZCk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59KCk7dmFyIFN0YXRlQ2hhaW47XG52YXIgU3RhdGVDaGFpbiQxID0gU3RhdGVDaGFpbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXRlQ2hhaW4oc3RhdGVzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRlQ2hhaW4pO1xuXG4gICAgdGhpcy5zdHJpbmcgPSBzdGF0ZXMuam9pbignKycpO1xuICAgIHRoaXMuYXJyYXkgPSBzdGF0ZXMuc2xpY2UoKTtcbiAgICB0aGlzLmxlbmd0aCA9IHN0YXRlcy5sZW5ndGg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RhdGVDaGFpbiwgW3tcbiAgICBrZXk6IFwiaW5jbHVkZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jbHVkZXModGFyZ2V0KSB7XG4gICAgICB2YXIgaSwgbGVuLCByZWYsIHN0YXRlO1xuICAgICAgcmVmID0gdGhpcy5hcnJheTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gcmVmW2ldO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRob3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhvdXQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheS5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSAhPT0gdGFyZ2V0O1xuICAgICAgfSkuam9pbignKycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0FwcGxpY2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBcHBsaWNhYmxlKHRhcmdldCwgb3RoZXJBY3RpdmUpIHtcbiAgICAgIHZhciBhY3RpdmU7XG4gICAgICBhY3RpdmUgPSB0aGlzLmFycmF5LmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSB0YXJnZXQgfHwgb3RoZXJBY3RpdmUuaW5kZXhPZihzdGF0ZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWN0aXZlLmxlbmd0aCA9PT0gdGhpcy5hcnJheS5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YXRlQ2hhaW47XG59KCk7dmFyIEJBU0VfU1RBVEVfVFJJR0dFUlMsIENBQ0hFRF9GTl9JTlNFUlRFRDtcbkJBU0VfU1RBVEVfVFJJR0dFUlMgPSB7XG4gICdob3Zlcic6IHtcbiAgICBvbjogJ21vdXNlZW50ZXInLFxuICAgIG9mZjogJ21vdXNlbGVhdmUnLFxuICAgIGJ1YmJsZXM6IHRydWVcbiAgfSxcbiAgJ2ZvY3VzJzoge1xuICAgIG9uOiAnZm9jdXMnLFxuICAgIG9mZjogJ2JsdXInLFxuICAgIGJ1YmJsZXM6IHRydWVcbiAgfVxufTtcbnZhciBfbm9ybWFsaXplT3B0aW9ucyA9IGZ1bmN0aW9uIF9ub3JtYWxpemVPcHRpb25zKCkge1xuICB2YXIgYmFzZTEsIGJhc2UyLCBiYXNlMywgYmFzZTQsIGJhc2U1O1xuXG4gIGlmICh0aGlzLm9wdGlvbnMucmVsYXRlZEluc3RhbmNlKSB7XG4gICAgKGJhc2UxID0gdGhpcy5vcHRpb25zKS5yZWxhdGVkIHx8IChiYXNlMS5yZWxhdGVkID0gdGhpcy5vcHRpb25zLnJlbGF0ZWRJbnN0YW5jZSk7XG4gICAgdGhpcy5vcHRpb25zLnJlbGF0ZWRJbnN0YW5jZSA9IG51bGw7XG4gIH1cblxuICB0aGlzLnJlbGF0ZWQgPSAoYmFzZTIgPSB0aGlzLm9wdGlvbnMpLnJlbGF0ZWQgIT0gbnVsbCA/IGJhc2UyLnJlbGF0ZWQgOiBiYXNlMi5yZWxhdGVkID0gdGhpcztcblxuICBpZiAodGhpcy5vcHRpb25zLmNsYXNzKSB7XG4gICAgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5jbGFzcztcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMudXJsKSB7XG4gICAgdGhpcy5vcHRpb25zLmhyZWYgPSB0aGlzLm9wdGlvbnMudXJsO1xuICB9XG5cbiAgaWYgKChiYXNlMyA9IHRoaXMub3B0aW9ucykudW5wYXNzYWJsZVN0YXRlcyA9PSBudWxsKSB7XG4gICAgYmFzZTMudW5wYXNzYWJsZVN0YXRlcyA9IFtdO1xuICB9XG5cbiAgaWYgKChiYXNlNCA9IHRoaXMub3B0aW9ucykucGFzc1N0YXRlVG9DaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgYmFzZTQucGFzc1N0YXRlVG9DaGlsZHJlbiA9IHRydWU7XG4gIH1cblxuICBpZiAoKGJhc2U1ID0gdGhpcy5vcHRpb25zKS5wYXNzRGF0YVRvQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIGJhc2U1LnBhc3NEYXRhVG9DaGlsZHJlbiA9IHRydWU7XG4gIH1cblxuICB0aGlzLm9wdGlvbnMuc3RhdGVUcmlnZ2VycyA9IHRoaXMub3B0aW9ucy5zdGF0ZVRyaWdnZXJzID8gZXh0ZW5kLmNsb25lLmRlZXAoQkFTRV9TVEFURV9UUklHR0VSUywgdGhpcy5vcHRpb25zLnN0YXRlVHJpZ2dlcnMpIDogQkFTRV9TVEFURV9UUklHR0VSUztcblxuICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICBleHRlbmQodGhpcywgdGhpcy5fcGFyc2VUZXh0cyh0aGlzLm9wdGlvbnMudGV4dCwgdGhpcy5fdGV4dHMpKTtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQodGhpcywgdGhpcy5fcGFyc2VTdHlsZXModGhpcy5vcHRpb25zLnN0eWxlLCB0aGlzLl9zdHlsZXMpKTtcbiAgfVxufTtcbnZhciBfcGFyc2VTdHlsZXMgPSBmdW5jdGlvbiBfcGFyc2VTdHlsZXMoc3R5bGVzLCBzdG9yZSkge1xuICB2YXIgX21lZGlhU3RhdGVzLCBfcHJvdmlkZWRTdGF0ZXMsIF9wcm92aWRlZFN0YXRlc1NoYXJlZCwgX3N0YXRlU2hhcmVkLCBfc3R5bGVzLCBiYXNlLCBfZmxhdHRlbk5lc3RlZFN0YXRlcywgZm9yY2VTdHlsZSwgaSwga2V5cywgbGVuLCBzcGVjaWFsU3RhdGVzLCBzdGF0ZSwgc3RhdGVTdHlsZXMsIHN0YXRlXywgc3RhdGVzO1xuXG4gIGlmICghSVMkMS5vYmplY3RQbGFpbihzdHlsZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyk7XG4gIHN0YXRlcyA9IGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaXNTdGF0ZVN0eWxlKGtleSk7XG4gIH0pO1xuICBzcGVjaWFsU3RhdGVzID0gcmVtb3ZlSXRlbShzdGF0ZXMuc2xpY2UoKSwgJyRiYXNlJyk7XG4gIF9tZWRpYVN0YXRlcyA9IHN0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXlbMF0gPT09ICdAJztcbiAgfSkubWFwKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5zbGljZSgxKTtcbiAgfSk7XG4gIF9wcm92aWRlZFN0YXRlcyA9IHN0YXRlcy5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnNsaWNlKDEpOyAvLyBSZW1vdmUgJyQnIHByZWZpeFxuICB9KTtcbiAgX3N0eWxlcyA9IHN0b3JlIHx8IHt9O1xuICBfc3RhdGVTaGFyZWQgPSBfcHJvdmlkZWRTdGF0ZXNTaGFyZWQgPSB2b2lkIDA7XG4gIGJhc2UgPSAhaW5jbHVkZXMoc3RhdGVzLCAnJGJhc2UnKSA/IHN0eWxlcyA6IHN0eWxlcy4kYmFzZTtcbiAgX3N0eWxlcy5iYXNlID0gcmVnaXN0ZXJTdHlsZShiYXNlLCAwLCBmb3JjZVN0eWxlID0gdGhpcy5vcHRpb25zLmZvcmNlU3R5bGUpO1xuXG4gIGlmIChzcGVjaWFsU3RhdGVzLmxlbmd0aCkge1xuICAgIF9mbGF0dGVuTmVzdGVkU3RhdGVzID0gZnVuY3Rpb24gZmxhdHRlbk5lc3RlZFN0YXRlcyhzdHlsZU9iamVjdCwgY2hhaW4sIGxldmVsKSB7XG4gICAgICB2YXIgaGFzTm9uU3RhdGVQcm9wcywgaSwgbGVuLCBvdXRwdXQsIHN0YXRlLCBzdGF0ZUNoYWluLCBzdGF0ZV8sIHN0eWxlS2V5cztcbiAgICAgIHN0eWxlS2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlT2JqZWN0KTtcbiAgICAgIG91dHB1dCA9IHt9O1xuICAgICAgaGFzTm9uU3RhdGVQcm9wcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHlsZUtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhdGUgPSBzdHlsZUtleXNbaV07XG5cbiAgICAgICAgaWYgKCFpc1N0YXRlU3R5bGUoc3RhdGUpKSB7XG4gICAgICAgICAgaGFzTm9uU3RhdGVQcm9wcyA9IHRydWU7XG4gICAgICAgICAgb3V0cHV0W3N0YXRlXSA9IHN0eWxlT2JqZWN0W3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFpbi5wdXNoKHN0YXRlXyA9IHN0YXRlLnNsaWNlKDEpKTtcbiAgICAgICAgICBzdGF0ZUNoYWluID0gbmV3IFN0YXRlQ2hhaW4kMShjaGFpbik7XG5cbiAgICAgICAgICBpZiAoX3N0YXRlU2hhcmVkID09IG51bGwpIHtcbiAgICAgICAgICAgIF9zdGF0ZVNoYXJlZCA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfcHJvdmlkZWRTdGF0ZXNTaGFyZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgX3Byb3ZpZGVkU3RhdGVzU2hhcmVkID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3Byb3ZpZGVkU3RhdGVzU2hhcmVkLnB1c2goc3RhdGVDaGFpbik7XG5cbiAgICAgICAgICBpZiAoc3RhdGVbMF0gPT09ICdAJykge1xuICAgICAgICAgICAgX21lZGlhU3RhdGVzLnB1c2goc3RhdGVfKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc3R5bGVzW3N0YXRlQ2hhaW4uc3RyaW5nXSA9IHJlZ2lzdGVyU3R5bGUoX2ZsYXR0ZW5OZXN0ZWRTdGF0ZXMoc3R5bGVPYmplY3Rbc3RhdGVdLCBjaGFpbiwgbGV2ZWwgKyAxKSwgbGV2ZWwgKyAxLCBmb3JjZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTm9uU3RhdGVQcm9wcykge1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzcGVjaWFsU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdGF0ZSA9IHNwZWNpYWxTdGF0ZXNbaV07XG4gICAgICBzdGF0ZV8gPSBzdGF0ZS5zbGljZSgxKTtcbiAgICAgIHN0YXRlU3R5bGVzID0gX2ZsYXR0ZW5OZXN0ZWRTdGF0ZXMoc3R5bGVzW3N0YXRlXSwgW3N0YXRlX10sIDEpO1xuXG4gICAgICBpZiAoc3RhdGVTdHlsZXMpIHtcbiAgICAgICAgX3N0eWxlc1tzdGF0ZV9dID0gcmVnaXN0ZXJTdHlsZShzdGF0ZVN0eWxlcywgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfc3R5bGVzOiBfc3R5bGVzLFxuICAgIF9tZWRpYVN0YXRlczogX21lZGlhU3RhdGVzLFxuICAgIF9zdGF0ZVNoYXJlZDogX3N0YXRlU2hhcmVkLFxuICAgIF9wcm92aWRlZFN0YXRlczogX3Byb3ZpZGVkU3RhdGVzLFxuICAgIF9wcm92aWRlZFN0YXRlc1NoYXJlZDogX3Byb3ZpZGVkU3RhdGVzU2hhcmVkXG4gIH07XG59O1xudmFyIF9wYXJzZVRleHRzID0gZnVuY3Rpb24gX3BhcnNlVGV4dHModGV4dHMsIHN0b3JlKSB7XG4gIHZhciBfcHJvdmlkZWRTdGF0ZXMsIF90ZXh0cywgaSwgbGVuLCBzdGF0ZSwgc3RhdGVzO1xuXG4gIGlmICghSVMkMS5vYmplY3RQbGFpbih0ZXh0cykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZXMgPSBPYmplY3Qua2V5cyh0ZXh0cykubWFwKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5zbGljZSgxKTtcbiAgfSk7XG4gIF9wcm92aWRlZFN0YXRlcyA9IHN0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlICE9PSAnYmFzZSc7XG4gIH0pO1xuICBfdGV4dHMgPSBzdG9yZSB8fCB7fTtcbiAgX3RleHRzID0ge1xuICAgIGJhc2U6ICcnXG4gIH07XG5cbiAgZm9yIChpID0gMCwgbGVuID0gc3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgX3RleHRzW3N0YXRlXSA9IHRleHRzWyckJyArIHN0YXRlXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX3RleHRzOiBfdGV4dHMsXG4gICAgX3Byb3ZpZGVkU3RhdGVzOiBfcHJvdmlkZWRTdGF0ZXNcbiAgfTtcbn07XG52YXIgX2FwcGx5T3B0aW9ucyA9IGZ1bmN0aW9uIF9hcHBseU9wdGlvbnMoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIGV2ZW50LCBoYW5kbGVyLCBtZXRob2QsIHJlZiwgcmVmMSwgcmVmMiwgdmFsdWU7XG5cbiAgaWYgKHJlZiA9IHRoaXMub3B0aW9ucy5pZCB8fCB0aGlzLm9wdGlvbnMucmVmKSB7XG4gICAgdGhpcy5hdHRyKCdkYXRhLXJlZicsIHRoaXMucmVmID0gcmVmKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuaWQpIHtcbiAgICB0aGlzLmVsLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5jbGFzc05hbWU7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnNyYykge1xuICAgIHRoaXMuZWwuc3JjID0gdGhpcy5vcHRpb25zLnNyYztcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuaHJlZikge1xuICAgIHRoaXMuZWwuaHJlZiA9IHRoaXMub3B0aW9ucy5ocmVmO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgdGhpcy5lbC50eXBlID0gdGhpcy5vcHRpb25zLnR5cGU7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLm5hbWUpIHtcbiAgICB0aGlzLmVsLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMudmFsdWUpIHtcbiAgICB0aGlzLmVsLnZhbHVlID0gdGhpcy5vcHRpb25zLnZhbHVlO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RlZCkge1xuICAgIHRoaXMuZWwuc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWQ7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmNoZWNrZWQpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSB0aGlzLm9wdGlvbnMuY2hlY2tlZDtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucHJvcHMpIHtcbiAgICB0aGlzLnByb3AodGhpcy5vcHRpb25zLnByb3BzKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuYXR0cnMpIHtcbiAgICB0aGlzLmF0dHIodGhpcy5vcHRpb25zLmF0dHJzKTtcbiAgfVxuXG4gIHRoaXMuX2FwcGx5UmVnaXN0ZXJlZFN0eWxlKHRoaXMuX3N0eWxlcy5iYXNlLCBudWxsLCBudWxsLCB0aGlzLm9wdGlvbnMuc3R5bGVBZnRlckluc2VydCk7XG5cbiAgaWYgKHRoaXMuX3RleHRzKSB7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dHMuYmFzZTtcbiAgfVxuXG4gIHRoaXMub24oJ2luc2VydGVkJywgQ0FDSEVEX0ZOX0lOU0VSVEVELCBmYWxzZSwgdHJ1ZSk7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5pbnZva2VDb21wdXRlcnNPbmNlKSB7XG4gICAgdGhpcy5faW52b2tlZENvbXB1dGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5yZWNhbGNPblJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVjYWxjU3R5bGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRzKSB7XG4gICAgcmVmMSA9IHRoaXMub3B0aW9ucy5ldmVudHM7XG5cbiAgICBmb3IgKGV2ZW50IGluIHJlZjEpIHtcbiAgICAgIGhhbmRsZXIgPSByZWYxW2V2ZW50XTtcbiAgICAgIHRoaXMub24oZXZlbnQsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMubWV0aG9kcykge1xuICAgIHJlZjIgPSB0aGlzLm9wdGlvbnMubWV0aG9kcztcblxuICAgIGZvciAobWV0aG9kIGluIHJlZjIpIHtcbiAgICAgIHZhbHVlID0gcmVmMlttZXRob2RdO1xuXG4gICAgICBpZiAoIXRoaXNbbWV0aG9kXSkge1xuICAgICAgICBpZiAoSVMkMS5mdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzW21ldGhvZF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChJUyQxLm9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbWV0aG9kLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IHZhbHVlLmdldCxcbiAgICAgICAgICAgIHNldDogdmFsdWUuc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcgJiYgSVMkMS5vYmplY3QodGhpcy5vcHRpb25zLnRleHQpKSB7XG4gICAgdGhpcy5hcHBlbmQoX3F1aWNrZG9tKCd0ZXh0Jywge1xuICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnRleHRcbiAgICB9KSk7XG4gIH1cbn07XG52YXIgX3Bvc3RDcmVhdGlvbiA9IGZ1bmN0aW9uIF9wb3N0Q3JlYXRpb24oZGF0YSkge1xuICBpZiAodGhpcy5vcHRpb25zLmNvbXB1dGVycykge1xuICAgIGlmIChkYXRhICYmIHRoaXMub3B0aW9ucy5kYXRhKSB7XG4gICAgICBkYXRhID0gZXh0ZW5kLmNsb25lKHRoaXMub3B0aW9ucy5kYXRhLCBkYXRhKTtcbiAgICB9XG5cbiAgICBkYXRhIHx8IChkYXRhID0gdGhpcy5vcHRpb25zLmRhdGEpO1xuICAgIHRoaXMuYXBwbHlEYXRhKGRhdGEsIGZhbHNlKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcHV0ZXJzLl9pbml0KSB7XG4gICAgICB0aGlzLl9ydW5Db21wdXRlcignX2luaXQnLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSh0aGlzLm9wdGlvbnMuc3RhdGUpO1xuICB9XG59O1xudmFyIF9hdHRhY2hTdGF0ZUV2ZW50cyA9IGZ1bmN0aW9uIF9hdHRhY2hTdGF0ZUV2ZW50cyhmb3JjZSkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICB2YXIgc3RhdGVzO1xuICBzdGF0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuc3RhdGVUcmlnZ2Vycyk7XG4gIHN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBkaXNhYmxlciwgZW5hYmxlciwgdHJpZ2dlcjtcbiAgICB0cmlnZ2VyID0gX3RoaXMyLm9wdGlvbnMuc3RhdGVUcmlnZ2Vyc1tzdGF0ZV07XG5cbiAgICBpZiAoIWluY2x1ZGVzKF90aGlzMi5fcHJvdmlkZWRTdGF0ZXMsIHN0YXRlKSAmJiAhZm9yY2UgJiYgIXRyaWdnZXIuZm9yY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbmFibGVyID0gSVMkMS5zdHJpbmcodHJpZ2dlcikgPyB0cmlnZ2VyIDogdHJpZ2dlci5vbjtcblxuICAgIGlmIChJUyQxLm9iamVjdCh0cmlnZ2VyKSkge1xuICAgICAgZGlzYWJsZXIgPSB0cmlnZ2VyLm9mZjtcbiAgICB9XG5cbiAgICBfdGhpczIuX2xpc3RlblRvKGVuYWJsZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczIuc3RhdGUoc3RhdGUsIHRydWUsIHRyaWdnZXIuYnViYmxlcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGlzYWJsZXIpIHtcbiAgICAgIHJldHVybiBfdGhpczIuX2xpc3RlblRvKGRpc2FibGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuc3RhdGUoc3RhdGUsIGZhbHNlLCB0cmlnZ2VyLmJ1YmJsZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgX3Byb3h5UGFyZW50ID0gZnVuY3Rpb24gX3Byb3h5UGFyZW50KCkge1xuICB2YXIgcGFyZW50O1xuICBwYXJlbnQgPSB2b2lkIDA7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19wYXJlbnQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3UGFyZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGxhc3RQYXJlbnQ7XG5cbiAgICAgIGlmIChwYXJlbnQgPSBuZXdQYXJlbnQpIHtcbiAgICAgICAgbGFzdFBhcmVudCA9IHRoaXMucGFyZW50cy5zbGljZSgtMSlbMF07XG5cbiAgICAgICAgaWYgKGxhc3RQYXJlbnQucmF3ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl91bnByb3h5UGFyZW50KG5ld1BhcmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50Lm9uKCdpbnNlcnRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG5ld1BhcmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl91bnByb3h5UGFyZW50KG5ld1BhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbnZhciBfdW5wcm94eVBhcmVudCA9IGZ1bmN0aW9uIF91bnByb3h5UGFyZW50KG5ld1BhcmVudCkge1xuICBkZWxldGUgdGhpcy5fcGFyZW50O1xuICB0aGlzLl9wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gIHRoaXMuZW1pdFByaXZhdGUoJ2luc2VydGVkJywgbmV3UGFyZW50KTtcbn07XG5cbkNBQ0hFRF9GTl9JTlNFUlRFRCA9IGZ1bmN0aW9uIENBQ0hFRF9GTl9JTlNFUlRFRCgpIHtcbiAgdmFyIGksIGxlbiwgbWVkaWFTdGF0ZXMsIHF1ZXJ5U3RyaW5nLCByZXN1bHRzO1xuICB0aGlzLl9pbnNlcnRlZCA9IHRoaXM7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZUFmdGVySW5zZXJ0KSB7XG4gICAgdGhpcy5yZWNhbGNTdHlsZSgpO1xuICB9XG5cbiAgaWYgKChtZWRpYVN0YXRlcyA9IHRoaXMuX21lZGlhU3RhdGVzKSAmJiB0aGlzLl9tZWRpYVN0YXRlcy5sZW5ndGgpIHtcbiAgICB0aGlzLl9tZWRpYVN0YXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gbWVkaWFTdGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHF1ZXJ5U3RyaW5nID0gbWVkaWFTdGF0ZXNbaV07XG4gICAgICByZXN1bHRzLnB1c2godGhpcy5fbWVkaWFTdGF0ZXNbcXVlcnlTdHJpbmddID0gTWVkaWFRdWVyeSQxLnJlZ2lzdGVyKHRoaXMsIHF1ZXJ5U3RyaW5nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluaXQkMSAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX25vcm1hbGl6ZU9wdGlvbnMgPSBfbm9ybWFsaXplT3B0aW9ucztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcGFyc2VTdHlsZXMgPSBfcGFyc2VTdHlsZXM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3BhcnNlVGV4dHMgPSBfcGFyc2VUZXh0cztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fYXBwbHlPcHRpb25zID0gX2FwcGx5T3B0aW9ucztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcG9zdENyZWF0aW9uID0gX3Bvc3RDcmVhdGlvbjtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fYXR0YWNoU3RhdGVFdmVudHMgPSBfYXR0YWNoU3RhdGVFdmVudHM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3Byb3h5UGFyZW50ID0gX3Byb3h5UGFyZW50O1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fdW5wcm94eVBhcmVudCA9IF91bnByb3h5UGFyZW50O1xufWZ1bmN0aW9uIGFsaWFzZXMgKFF1aWNrRWxlbWVudCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICdyYXcnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICAnMCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICdjc3MnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGU7XG4gICAgICB9XG4gICAgfSxcbiAgICAncmVwbGFjZVdpdGgnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdyZW1vdmVMaXN0ZW5lcic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmY7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn12YXIgcGFyZW50c1VudGlsID0gZnVuY3Rpb24gcGFyZW50c1VudGlsKGZpbHRlcikge1xuICByZXR1cm4gX2dldFBhcmVudHModGhpcywgZmlsdGVyKTtcbn07XG52YXIgcGFyZW50TWF0Y2hpbmcgPSBmdW5jdGlvbiBwYXJlbnRNYXRjaGluZyhmaWx0ZXIpIHtcbiAgdmFyIGlzUmVmLCBuZXh0UGFyZW50O1xuXG4gIGlmIChJUyQxLmZ1bmN0aW9uKGZpbHRlcikgfHwgKGlzUmVmID0gSVMkMS5zdHJpbmcoZmlsdGVyKSkpIHtcbiAgICBuZXh0UGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICB3aGlsZSAobmV4dFBhcmVudCkge1xuICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgIGlmIChuZXh0UGFyZW50LnJlZiA9PT0gZmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmaWx0ZXIobmV4dFBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0UGFyZW50ID0gbmV4dFBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG59O1xudmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIF9xdWlja2RvbSh0aGlzLnJhdy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSk7XG59O1xudmFyIHF1ZXJ5QWxsID0gZnVuY3Rpb24gcXVlcnlBbGwoc2VsZWN0b3IpIHtcbiAgdmFyIGksIGl0ZW0sIGxlbiwgb3V0cHV0LCByZXN1bHQ7XG4gIHJlc3VsdCA9IHRoaXMucmF3LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBvdXRwdXQgPSBbXTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpdGVtID0gcmVzdWx0W2ldO1xuICAgIG91dHB1dC5wdXNoKGl0ZW0pO1xuICB9XG5cbiAgcmV0dXJuIF9xdWlja2RvbS5iYXRjaChvdXRwdXQpO1xufTtcbnZhciBfZ2V0UGFyZW50cyA9IGZ1bmN0aW9uIF9nZXRQYXJlbnRzKHRhcmdldEVsLCBmaWx0ZXIpIHtcbiAgdmFyIGlzUmVmLCBuZXh0UGFyZW50LCBwYXJlbnRzO1xuXG4gIGlmICghSVMkMS5mdW5jdGlvbihmaWx0ZXIpICYmICEoaXNSZWYgPSBJUyQxLnN0cmluZyhmaWx0ZXIpKSkge1xuICAgIGZpbHRlciA9IHZvaWQgMDtcbiAgfVxuXG4gIHBhcmVudHMgPSBbXTtcbiAgbmV4dFBhcmVudCA9IHRhcmdldEVsLnBhcmVudDtcblxuICB3aGlsZSAobmV4dFBhcmVudCkge1xuICAgIHBhcmVudHMucHVzaChuZXh0UGFyZW50KTtcbiAgICBuZXh0UGFyZW50ID0gbmV4dFBhcmVudC5wYXJlbnQ7XG5cbiAgICBpZiAoaXNSZWYpIHtcbiAgICAgIGlmIChuZXh0UGFyZW50ICYmIG5leHRQYXJlbnQucmVmID09PSBmaWx0ZXIpIHtcbiAgICAgICAgbmV4dFBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIGlmIChmaWx0ZXIobmV4dFBhcmVudCkpIHtcbiAgICAgICAgbmV4dFBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudHM7XG59O1xudmFyIF9nZXRDaGlsZFJlZnMgPSBmdW5jdGlvbiBfZ2V0Q2hpbGRSZWZzKHRhcmdldCwgZnJlc2hDb3B5KSB7XG4gIHZhciBjaGlsZCwgY2hpbGRSZWZzLCBjaGlsZHJlbiwgZWwsIGksIGxlbiwgcmVmLCByZWZzO1xuXG4gIGlmIChmcmVzaENvcHkgfHwgIXRhcmdldC5fY2hpbGRSZWZzKSB7XG4gICAgdGFyZ2V0Ll9jaGlsZFJlZnMgPSB7fTtcbiAgfVxuXG4gIHJlZnMgPSB0YXJnZXQuX2NoaWxkUmVmcztcblxuICBpZiAodGFyZ2V0LnJlZikge1xuICAgIHJlZnNbdGFyZ2V0LnJlZl0gPSB0YXJnZXQ7XG4gIH1cblxuICBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZHJlbjtcblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjaGlsZFJlZnMgPSBfZ2V0Q2hpbGRSZWZzKGNoaWxkLCBmcmVzaENvcHkpO1xuXG4gICAgICBmb3IgKHJlZiBpbiBjaGlsZFJlZnMpIHtcbiAgICAgICAgZWwgPSBjaGlsZFJlZnNbcmVmXTtcbiAgICAgICAgcmVmc1tyZWZdIHx8IChyZWZzW3JlZl0gPSBlbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlZnM7XG59O1xudmFyIF9nZXRJbmRleEJ5UHJvcCA9IGZ1bmN0aW9uIF9nZXRJbmRleEJ5UHJvcChtYWluLCBwcm9wKSB7XG4gIHZhciBwYXJlbnQ7XG5cbiAgaWYgKCEocGFyZW50ID0gbWFpbi5wYXJlbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGRbcHJvcF0gPT09IG1haW5bcHJvcF07XG4gICAgfSkuaW5kZXhPZihtYWluKTtcbiAgfVxufTtcbnZhciBfZmlsdGVyRWxlbWVudHMgPSBmdW5jdGlvbiBfZmlsdGVyRWxlbWVudHMoYXJyYXkpIHtcbiAgdmFyIGksIGl0ZW0sIGxlbiwgb3V0cHV0O1xuXG4gIGlmICghYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBhcnJheVtpXTtcblxuICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG5mdW5jdGlvbiB0cmF2ZXJzaW5nIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5wYXJlbnRzVW50aWwgPSBwYXJlbnRzVW50aWw7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucGFyZW50TWF0Y2hpbmcgPSBwYXJlbnRNYXRjaGluZztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5xdWVyeSA9IHF1ZXJ5O1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsID0gcXVlcnlBbGw7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhRdWlja0VsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgJ2NoaWxkcmVuJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByZWYxO1xuXG4gICAgICAgIGlmICh0aGlzLmVsLmNoaWxkTm9kZXMubGVuZ3RoICE9PSB0aGlzLl9jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBSZS1jb2xsZWN0IGNoaWxkcmVuXHRcbiAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPSAwOyAvLyBFbXB0eSBvdXQgY2hpbGRyZW4gYXJyYXlcblxuICAgICAgICAgIHJlZjEgPSB0aGlzLmVsLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZjFbaV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA8IDQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChfcXVpY2tkb20oY2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgICB9XG4gICAgfSxcbiAgICAnZWxlbWVudENoaWxkcmVuJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcbiAgICAncGFyZW50Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICgoIXRoaXMuX3BhcmVudCB8fCB0aGlzLl9wYXJlbnQuZWwgIT09IHRoaXMuZWwucGFyZW50Tm9kZSkgJiYgIUlTJDEuZG9tRG9jKHRoaXMuZWwucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcXVpY2tkb20odGhpcy5lbC5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAncGFyZW50cyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2dldFBhcmVudHModGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnbmV4dCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3F1aWNrZG9tKHRoaXMuZWwubmV4dFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ25leHRFbCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3F1aWNrZG9tKHRoaXMuZWwubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICduZXh0RWxBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJFbGVtZW50cyh0aGlzLm5leHRBbGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ25leHRBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nLCBzaWJsaW5ncztcbiAgICAgICAgc2libGluZ3MgPSBbXTtcbiAgICAgICAgbmV4dFNpYmxpbmcgPSBfcXVpY2tkb20odGhpcy5lbC5uZXh0U2libGluZyk7XG5cbiAgICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgc2libGluZ3MucHVzaChuZXh0U2libGluZyk7XG4gICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXYnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9xdWlja2RvbSh0aGlzLmVsLnByZXZpb3VzU2libGluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAncHJldkVsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcXVpY2tkb20odGhpcy5lbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdwcmV2RWxBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJFbGVtZW50cyh0aGlzLnByZXZBbGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXZBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHByZXZTaWJsaW5nLCBzaWJsaW5ncztcbiAgICAgICAgc2libGluZ3MgPSBbXTtcbiAgICAgICAgcHJldlNpYmxpbmcgPSBfcXVpY2tkb20odGhpcy5lbC5wcmV2aW91c1NpYmxpbmcpO1xuXG4gICAgICAgIHdoaWxlIChwcmV2U2libGluZykge1xuICAgICAgICAgIHNpYmxpbmdzLnB1c2gocHJldlNpYmxpbmcpO1xuICAgICAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcucHJldjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICAgIH1cbiAgICB9LFxuICAgICdzaWJsaW5ncyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2QWxsLnJldmVyc2UoKS5jb25jYXQodGhpcy5uZXh0QWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdlbGVtZW50U2libGluZ3MnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJFbGVtZW50cyh0aGlzLnNpYmxpbmdzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdjaGlsZCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRSZWZzIHx8IF9nZXRDaGlsZFJlZnModGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2hpbGRmJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0Q2hpbGRSZWZzKHRoaXMsIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2ZpcnN0Q2hpbGQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gICAgICB9XG4gICAgfSxcbiAgICAnbGFzdENoaWxkJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfSxcbiAgICAnaW5kZXgnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHBhcmVudDtcblxuICAgICAgICBpZiAoIShwYXJlbnQgPSB0aGlzLnBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdpbmRleFR5cGUnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbmRleEJ5UHJvcCh0aGlzLCAndHlwZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2luZGV4UmVmJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5kZXhCeVByb3AodGhpcywgJ3JlZicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbl9xdWlja2RvbS5xdWVyeSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIF9xdWlja2RvbShkb2N1bWVudCkucXVlcnkodGFyZ2V0KTtcbn07XG5cbl9xdWlja2RvbS5xdWVyeUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIF9xdWlja2RvbShkb2N1bWVudCkucXVlcnlBbGwodGFyZ2V0KTtcbn07dmFyIERVTU1ZX0FSUkFZO1xuRFVNTVlfQVJSQVkgPSBbXTtcbnZhciBzdGF0ZSA9IGZ1bmN0aW9uIHN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgYnViYmxlcywgc291cmNlKSB7XG4gIHZhciBhY3RpdmVTdGF0ZXMsIGNoaWxkLCBkZXNpcmVkVmFsdWUsIGksIGosIGtleSwga2V5cywgbGVuLCBwcm9wLCByZWYsIHRvZ2dsZTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5zbGljZSgpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoSVMkMS5zdHJpbmcodGFyZ2V0U3RhdGUpKSB7XG4gICAgICByZXR1cm4gaW5jbHVkZXModGhpcy5fc3RhdGUsIHRhcmdldFN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKElTJDEub2JqZWN0KHRhcmdldFN0YXRlKSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldFN0YXRlKTtcbiAgICAgIGkgPSAtMTtcblxuICAgICAgd2hpbGUgKGtleSA9IGtleXNbKytpXSkge1xuICAgICAgICB0aGlzLnN0YXRlKGtleSwgdGFyZ2V0U3RhdGVba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZVBpcGVUYXJnZXQgJiYgc291cmNlICE9PSB0aGlzKSB7XG4gICAgdGhpcy5fc3RhdGVQaXBlVGFyZ2V0LnN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgYnViYmxlcywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChJUyQxLnN0cmluZyh0YXJnZXRTdGF0ZSkpIHtcbiAgICBpZiAodGFyZ2V0U3RhdGVbMF0gPT09ICckJykge1xuICAgICAgdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZS5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0U3RhdGUgPT09ICdiYXNlJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGVzaXJlZFZhbHVlID0gISF2YWx1ZTsgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBib29sZWFuXG5cbiAgICBhY3RpdmVTdGF0ZXMgPSB0aGlzLl9nZXRBY3RpdmVTdGF0ZXModGFyZ2V0U3RhdGUsIGZhbHNlKTsgLy8gPT09PSBUb2dnbGUgc3R5bGVzIGZvciB0aGlzIHN0YXRlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgaWYgKHRoaXMuc3RhdGUodGFyZ2V0U3RhdGUpICE9PSBkZXNpcmVkVmFsdWUpIHtcbiAgICAgIHByb3AgPSB0aGlzLnR5cGUgPT09ICd0ZXh0JyA/ICdUZXh0JyA6ICdTdHlsZSc7XG5cbiAgICAgIGlmIChkZXNpcmVkVmFsdWUpIHtcbiAgICAgICAgLy9pcyBvblxuICAgICAgICB0aGlzLl9zdGF0ZS5wdXNoKHRhcmdldFN0YXRlKTtcblxuICAgICAgICB0b2dnbGUgPSAnT04nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlSXRlbSh0aGlzLl9zdGF0ZSwgdGFyZ2V0U3RhdGUpO1xuICAgICAgICB0b2dnbGUgPSAnT0ZGJztcbiAgICAgIH1cblxuICAgICAgdGhpc1snX3R1cm4nICsgcHJvcCArIHRvZ2dsZV0odGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcyk7XG4gICAgICB0aGlzLmVtaXRQcml2YXRlKFwic3RhdGVDaGFuZ2U6XCIuY29uY2F0KHRhcmdldFN0YXRlKSwgZGVzaXJlZFZhbHVlKTtcbiAgICB9IC8vID09PT0gUGFzcyBzdGF0ZSB0byBwYXJlbnQvY2hpbGRyZW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIGlmICghaW5jbHVkZXModGhpcy5vcHRpb25zLnVucGFzc2FibGVTdGF0ZXMsIHRhcmdldFN0YXRlKSkge1xuICAgICAgaWYgKGJ1YmJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5fcGFyZW50LnN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgdHJ1ZSwgc291cmNlIHx8IHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wYXNzU3RhdGVUb0NoaWxkcmVuKSB7XG4gICAgICAgIHJlZiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgICAgIGNoaWxkLnN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgZmFsc2UsIHNvdXJjZSB8fCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIHRvZ2dsZVN0YXRlID0gZnVuY3Rpb24gdG9nZ2xlU3RhdGUodGFyZ2V0U3RhdGUpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGUodGFyZ2V0U3RhdGUsICF0aGlzLnN0YXRlKHRhcmdldFN0YXRlKSk7XG59O1xudmFyIHJlc2V0U3RhdGUgPSBmdW5jdGlvbiByZXNldFN0YXRlKCkge1xuICB2YXIgYWN0aXZlU3RhdGUsIGosIGxlbiwgcmVmO1xuICByZWYgPSB0aGlzLl9zdGF0ZS5zbGljZSgpO1xuXG4gIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgIGFjdGl2ZVN0YXRlID0gcmVmW2pdO1xuICAgIHRoaXMuc3RhdGUoYWN0aXZlU3RhdGUsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBwaXBlU3RhdGUgPSBmdW5jdGlvbiBwaXBlU3RhdGUodGFyZ2V0RWwpIHtcbiAgdmFyIGFjdGl2ZVN0YXRlLCBqLCBsZW4sIHJlZjtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3N0YXRlUGlwZVRhcmdldCA9IHRhcmdldEVsO1xuICAgICAgcmVmID0gdGhpcy5fc3RhdGU7XG5cbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBhY3RpdmVTdGF0ZSA9IHJlZltqXTtcbiAgICAgICAgdGFyZ2V0RWwuc3RhdGUoYWN0aXZlU3RhdGUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0YXJnZXRFbCA9PT0gZmFsc2UpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVQaXBlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIF9hcHBseVJlZ2lzdGVyZWRTdHlsZSA9IGZ1bmN0aW9uIF9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0YXJnZXRTdHlsZSwgc3VwZXJpb3JTdGF0ZXMsIGluY2x1ZGVCYXNlLCBza2lwRm5zKSB7XG4gIHZhciBjbGFzc05hbWUsIGVudHJ5LCBqLCBrLCBsZW4sIGxlbjEsIHJlZiwgcmVmMSwgc3VwZXJpb3JTdHlsZXM7XG5cbiAgaWYgKHRhcmdldFN0eWxlKSB7XG4gICAgcmVmID0gdGFyZ2V0U3R5bGUuY2xhc3NOYW1lO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBjbGFzc05hbWUgPSByZWZbal07XG4gICAgICB0aGlzLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldFN0eWxlLmZucy5sZW5ndGggJiYgIXNraXBGbnMpIHtcbiAgICAgIGlmIChzdXBlcmlvclN0YXRlcykge1xuICAgICAgICBzdXBlcmlvclN0eWxlcyA9IHRoaXMuX3Jlc29sdmVGblN0eWxlcyhzdXBlcmlvclN0YXRlcywgaW5jbHVkZUJhc2UpO1xuICAgICAgfVxuXG4gICAgICByZWYxID0gdGFyZ2V0U3R5bGUuZm5zO1xuXG4gICAgICBmb3IgKGsgPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgZW50cnkgPSByZWYxW2tdO1xuXG4gICAgICAgIGlmICghKHN1cGVyaW9yU3R5bGVzICYmIHN1cGVyaW9yU3R5bGVzW2VudHJ5WzBdXSkpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZSA9IGZ1bmN0aW9uIF9yZW1vdmVSZWdpc3RlcmVkU3R5bGUodGFyZ2V0U3R5bGUsIHN1cGVyaW9yU3RhdGVzLCBpbmNsdWRlQmFzZSkge1xuICB2YXIgY2xhc3NOYW1lLCBlbnRyeSwgaiwgaywgbGVuLCBsZW4xLCByZWYsIHJlZjEsIHJlc2V0VmFsdWUsIHN1cGVyaW9yU3R5bGVzO1xuICByZWYgPSB0YXJnZXRTdHlsZS5jbGFzc05hbWU7XG5cbiAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgY2xhc3NOYW1lID0gcmVmW2pdO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIGlmICh0YXJnZXRTdHlsZS5mbnMubGVuZ3RoKSB7XG4gICAgaWYgKHN1cGVyaW9yU3RhdGVzKSB7XG4gICAgICBzdXBlcmlvclN0eWxlcyA9IHRoaXMuX3Jlc29sdmVGblN0eWxlcyhzdXBlcmlvclN0YXRlcywgaW5jbHVkZUJhc2UpO1xuICAgIH1cblxuICAgIHJlZjEgPSB0YXJnZXRTdHlsZS5mbnM7XG5cbiAgICBmb3IgKGsgPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgIGVudHJ5ID0gcmVmMVtrXTtcbiAgICAgIHJlc2V0VmFsdWUgPSBzdXBlcmlvclN0eWxlcyAmJiBzdXBlcmlvclN0eWxlc1tlbnRyeVswXV0gfHwgbnVsbDtcbiAgICAgIHRoaXMuc3R5bGUoZW50cnlbMF0sIHJlc2V0VmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfdHVyblN0eWxlT04gPSBmdW5jdGlvbiBfdHVyblN0eWxlT04odGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcykge1xuICB2YXIgaiwgbGVuLCBzaGFyZWRTdGF0ZXMsIHNraXBGbnMsIHN0YXRlQ2hhaW47XG4gIHNraXBGbnMgPSB0aGlzLm9wdGlvbnMuc3R5bGVBZnRlckluc2VydCAmJiAhdGhpcy5faW5zZXJ0ZWQ7XG5cbiAgaWYgKHRoaXMuX3N0eWxlc1t0YXJnZXRTdGF0ZV0pIHtcbiAgICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXNbdGFyZ2V0U3RhdGVdLCB0aGlzLl9nZXRTdXBlcmlvclN0YXRlcyh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSwgZmFsc2UsIHNraXBGbnMpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Byb3ZpZGVkU3RhdGVzU2hhcmVkKSB7XG4gICAgc2hhcmVkU3RhdGVzID0gdGhpcy5fZ2V0U2hhcmVkU3RhdGVzKHRhcmdldFN0YXRlKTtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHNoYXJlZFN0YXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgc3RhdGVDaGFpbiA9IHNoYXJlZFN0YXRlc1tqXTtcblxuICAgICAgaWYgKCFpbmNsdWRlcyh0aGlzLl9zdGF0ZVNoYXJlZCwgc3RhdGVDaGFpbi5zdHJpbmcpKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlU2hhcmVkLnB1c2goc3RhdGVDaGFpbi5zdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXNbc3RhdGVDaGFpbi5zdHJpbmddLCBudWxsLCBudWxsLCBza2lwRm5zKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX3R1cm5TdHlsZU9GRiA9IGZ1bmN0aW9uIF90dXJuU3R5bGVPRkYodGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcykge1xuICB2YXIgYWN0aXZlU2hhcmVkU3RhdGVzLCBqLCBsZW4sIHNoYXJlZFN0YXRlcywgc3RhdGVDaGFpbiwgdGFyZ2V0U3R5bGU7XG5cbiAgaWYgKHRoaXMuX3N0eWxlc1t0YXJnZXRTdGF0ZV0pIHtcbiAgICB0aGlzLl9yZW1vdmVSZWdpc3RlcmVkU3R5bGUodGhpcy5fc3R5bGVzW3RhcmdldFN0YXRlXSwgYWN0aXZlU3RhdGVzLCB0cnVlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9wcm92aWRlZFN0YXRlc1NoYXJlZCkge1xuICAgIHNoYXJlZFN0YXRlcyA9IHRoaXMuX2dldFNoYXJlZFN0YXRlcyh0YXJnZXRTdGF0ZSk7XG5cbiAgICBpZiAoc2hhcmVkU3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHNoYXJlZFN0YXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgc3RhdGVDaGFpbiA9IHNoYXJlZFN0YXRlc1tqXTtcbiAgICAgIHJlbW92ZUl0ZW0odGhpcy5fc3RhdGVTaGFyZWQsIHN0YXRlQ2hhaW4uc3RyaW5nKTtcbiAgICAgIHRhcmdldFN0eWxlID0gdGhpcy5fc3R5bGVzW3N0YXRlQ2hhaW4uc3RyaW5nXTtcblxuICAgICAgaWYgKHRhcmdldFN0eWxlLmZucy5sZW5ndGggJiYgdGhpcy5fc3RhdGVTaGFyZWQubGVuZ3RoICYmICFhY3RpdmVTaGFyZWRTdGF0ZXMpIHtcbiAgICAgICAgYWN0aXZlU2hhcmVkU3RhdGVzID0gdGhpcy5fc3RhdGVTaGFyZWQuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiAhaW5jbHVkZXMoc3RhdGUsIHRhcmdldFN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZVN0YXRlcyA9IGFjdGl2ZVN0YXRlcy5jb25jYXQoYWN0aXZlU2hhcmVkU3RhdGVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlKHRhcmdldFN0eWxlLCBhY3RpdmVTdGF0ZXMsIHRydWUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfdHVyblRleHRPTiA9IGZ1bmN0aW9uIF90dXJuVGV4dE9OKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIHN1cGVyaW9yU3RhdGVzLCB0YXJnZXRUZXh0O1xuXG4gIGlmICh0aGlzLl90ZXh0cyAmJiBJUyQxLnN0cmluZyh0YXJnZXRUZXh0ID0gdGhpcy5fdGV4dHNbdGFyZ2V0U3RhdGVdKSkge1xuICAgIHN1cGVyaW9yU3RhdGVzID0gdGhpcy5fZ2V0U3VwZXJpb3JTdGF0ZXModGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcyk7XG5cbiAgICBpZiAoIXN1cGVyaW9yU3RhdGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy50ZXh0ID0gdGFyZ2V0VGV4dDtcbiAgICB9XG4gIH1cbn07XG52YXIgX3R1cm5UZXh0T0ZGID0gZnVuY3Rpb24gX3R1cm5UZXh0T0ZGKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIHRhcmdldFRleHQ7XG5cbiAgaWYgKHRoaXMuX3RleHRzICYmIElTJDEuc3RyaW5nKHRhcmdldFRleHQgPSB0aGlzLl90ZXh0c1t0YXJnZXRTdGF0ZV0pKSB7XG4gICAgYWN0aXZlU3RhdGVzID0gYWN0aXZlU3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZSAhPT0gdGFyZ2V0U3RhdGU7XG4gICAgfSk7XG4gICAgdGFyZ2V0VGV4dCA9IHRoaXMuX3RleHRzW2FjdGl2ZVN0YXRlc1thY3RpdmVTdGF0ZXMubGVuZ3RoIC0gMV1dO1xuXG4gICAgaWYgKHRhcmdldFRleHQgPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0VGV4dCA9IHRoaXMuX3RleHRzLmJhc2U7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gdGFyZ2V0VGV4dDtcbiAgfVxufTtcbnZhciBfZ2V0QWN0aXZlU3RhdGVzID0gZnVuY3Rpb24gX2dldEFjdGl2ZVN0YXRlcyhzdGF0ZVRvRXhjbHVkZSkge1xuICB2YXIgaW5jbHVkZVNoYXJlZFN0YXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIGFjdGl2ZVN0YXRlcywgaiwgbGVuLCBwbGFpblN0YXRlcztcblxuICBpZiAoIXRoaXMuX3Byb3ZpZGVkU3RhdGVzKSB7XG4gICAgcmV0dXJuIERVTU1ZX0FSUkFZO1xuICB9XG5cbiAgYWN0aXZlU3RhdGVzID0gcGxhaW5TdGF0ZXMgPSB0aGlzLl9zdGF0ZTtcblxuICBpZiAoc3RhdGVUb0V4Y2x1ZGUpIHtcbiAgICBwbGFpblN0YXRlcyA9IFtdO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gYWN0aXZlU3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBzdGF0ZSA9IGFjdGl2ZVN0YXRlc1tqXTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBzdGF0ZVRvRXhjbHVkZSkge1xuICAgICAgICBwbGFpblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWluY2x1ZGVTaGFyZWRTdGF0ZXMgfHwgIXRoaXMuX3Byb3ZpZGVkU3RhdGVzU2hhcmVkKSB7XG4gICAgcmV0dXJuIHBsYWluU3RhdGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwbGFpblN0YXRlcy5jb25jYXQodGhpcy5fc3RhdGVTaGFyZWQpO1xuICB9XG59O1xudmFyIF9nZXRTdXBlcmlvclN0YXRlcyA9IGZ1bmN0aW9uIF9nZXRTdXBlcmlvclN0YXRlcyh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSB7XG4gIHZhciBjYW5kaWRhdGUsIGosIGxlbiwgc3VwZXJpb3IsIHRhcmdldFN0YXRlSW5kZXg7XG4gIHRhcmdldFN0YXRlSW5kZXggPSB0aGlzLl9wcm92aWRlZFN0YXRlcy5pbmRleE9mKHRhcmdldFN0YXRlKTtcblxuICBpZiAodGFyZ2V0U3RhdGVJbmRleCA9PT0gdGhpcy5fcHJvdmlkZWRTdGF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBEVU1NWV9BUlJBWTtcbiAgfVxuXG4gIHN1cGVyaW9yID0gW107XG5cbiAgZm9yIChqID0gMCwgbGVuID0gYWN0aXZlU3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgY2FuZGlkYXRlID0gYWN0aXZlU3RhdGVzW2pdO1xuXG4gICAgaWYgKHRoaXMuX3Byb3ZpZGVkU3RhdGVzLmluZGV4T2YoY2FuZGlkYXRlKSA+IHRhcmdldFN0YXRlSW5kZXgpIHtcbiAgICAgIHN1cGVyaW9yLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VwZXJpb3I7XG59O1xudmFyIF9nZXRTaGFyZWRTdGF0ZXMgPSBmdW5jdGlvbiBfZ2V0U2hhcmVkU3RhdGVzKHRhcmdldFN0YXRlKSB7XG4gIHZhciBhY3RpdmVTdGF0ZXMsIGosIGxlbiwgcmVmLCBzaGFyZWRTdGF0ZXMsIHN0YXRlQ2hhaW47XG4gIGFjdGl2ZVN0YXRlcyA9IHRoaXMuX3N0YXRlO1xuICBzaGFyZWRTdGF0ZXMgPSBbXTtcbiAgcmVmID0gdGhpcy5fcHJvdmlkZWRTdGF0ZXNTaGFyZWQ7XG5cbiAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgc3RhdGVDaGFpbiA9IHJlZltqXTtcblxuICAgIGlmIChzdGF0ZUNoYWluLmluY2x1ZGVzKHRhcmdldFN0YXRlKSAmJiBzdGF0ZUNoYWluLmlzQXBwbGljYWJsZSh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSkge1xuICAgICAgc2hhcmVkU3RhdGVzLnB1c2goc3RhdGVDaGFpbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNoYXJlZFN0YXRlcztcbn07XG52YXIgX3Jlc29sdmVGblN0eWxlcyA9IGZ1bmN0aW9uIF9yZXNvbHZlRm5TdHlsZXMoc3RhdGVzLCBpbmNsdWRlQmFzZSkge1xuICB2YXIgZW50cnksIGosIGssIGxlbiwgbGVuMSwgb3V0cHV0LCByZWY7XG5cbiAgaWYgKGluY2x1ZGVCYXNlKSB7XG4gICAgc3RhdGVzID0gWydiYXNlJ10uY29uY2F0KHN0YXRlcyk7XG4gIH1cblxuICBvdXRwdXQgPSB7fTtcblxuICBmb3IgKGogPSAwLCBsZW4gPSBzdGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICBzdGF0ZSA9IHN0YXRlc1tqXTtcblxuICAgIGlmICh0aGlzLl9zdHlsZXNbc3RhdGVdICYmIHRoaXMuX3N0eWxlc1tzdGF0ZV0uZm5zLmxlbmd0aCkge1xuICAgICAgcmVmID0gdGhpcy5fc3R5bGVzW3N0YXRlXS5mbnM7XG5cbiAgICAgIGZvciAoayA9IDAsIGxlbjEgPSByZWYubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgIGVudHJ5ID0gcmVmW2tdO1xuICAgICAgICBvdXRwdXRbZW50cnlbMF1dID0gZW50cnlbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5mdW5jdGlvbiBzdGF0ZSQxIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zdGF0ZSA9IHN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnRvZ2dsZVN0YXRlID0gdG9nZ2xlU3RhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVzZXRTdGF0ZSA9IHJlc2V0U3RhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucGlwZVN0YXRlID0gcGlwZVN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSA9IF9hcHBseVJlZ2lzdGVyZWRTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlID0gX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fdHVyblN0eWxlT04gPSBfdHVyblN0eWxlT047XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5TdHlsZU9GRiA9IF90dXJuU3R5bGVPRkY7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5UZXh0T04gPSBfdHVyblRleHRPTjtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fdHVyblRleHRPRkYgPSBfdHVyblRleHRPRkY7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2dldEFjdGl2ZVN0YXRlcyA9IF9nZXRBY3RpdmVTdGF0ZXM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2dldFN1cGVyaW9yU3RhdGVzID0gX2dldFN1cGVyaW9yU3RhdGVzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9nZXRTaGFyZWRTdGF0ZXMgPSBfZ2V0U2hhcmVkU3RhdGVzO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVzb2x2ZUZuU3R5bGVzID0gX3Jlc29sdmVGblN0eWxlcztcbn12YXIgdG9UZW1wbGF0ZSA9IGZ1bmN0aW9uIHRvVGVtcGxhdGUoKSB7XG4gIHJldHVybiBfcXVpY2tkb20udGVtcGxhdGUodGhpcyk7XG59O1xudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciBhY3RpdmVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxiYWNrcywgY2hpbGQsIGVsQ2xvbmUsIGV2ZW50TmFtZSwgaSwgaiwgaywgbGVuLCBsZW4xLCBsZW4yLCBuZXdFbCwgb3B0aW9ucywgcmVmLCByZWYxLCByZWYyO1xuICBlbENsb25lID0gdGhpcy5lbC5jbG9uZU5vZGUoZmFsc2UpO1xuICBvcHRpb25zID0gZXh0ZW5kLmNsb25lKHRoaXMub3B0aW9ucywge1xuICAgIGV4aXN0aW5nOiBlbENsb25lXG4gIH0pO1xuICBuZXdFbCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudHlwZSwgb3B0aW9ucyk7XG4gIHJlZiA9IHRoaXMuX3N0YXRlO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFjdGl2ZVN0YXRlID0gcmVmW2ldO1xuICAgIG5ld0VsLnN0YXRlKGFjdGl2ZVN0YXRlLCB0cnVlKTtcbiAgfVxuXG4gIHJlZjEgPSB0aGlzLmNoaWxkcmVuO1xuXG4gIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgIGNoaWxkID0gcmVmMVtqXTtcbiAgICBuZXdFbC5hcHBlbmQoY2hpbGQuY2xvbmUoKSk7XG4gIH1cblxuICByZWYyID0gdGhpcy5fZXZlbnRDYWxsYmFja3M7XG5cbiAgZm9yIChldmVudE5hbWUgaW4gcmVmMikge1xuICAgIGNhbGxiYWNrcyA9IHJlZjJbZXZlbnROYW1lXTtcblxuICAgIGZvciAoayA9IDAsIGxlbjIgPSBjYWxsYmFja3MubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1trXTtcbiAgICAgIG5ld0VsLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdFbDtcbn07XG52YXIgYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKHRhcmdldEVsKSB7XG4gIHZhciBwcmV2UGFyZW50O1xuXG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgcHJldlBhcmVudCA9IHRhcmdldEVsLnBhcmVudDtcblxuICAgICAgaWYgKHByZXZQYXJlbnQpIHtcbiAgICAgICAgcHJldlBhcmVudC5fcmVtb3ZlQ2hpbGQodGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0YXJnZXRFbC5lbCk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGFwcGVuZFRvID0gZnVuY3Rpb24gYXBwZW5kVG8odGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5hcHBlbmQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKHRhcmdldEVsKSB7XG4gIHZhciBwcmV2UGFyZW50O1xuXG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgcHJldlBhcmVudCA9IHRhcmdldEVsLnBhcmVudDtcblxuICAgICAgaWYgKHByZXZQYXJlbnQpIHtcbiAgICAgICAgcHJldlBhcmVudC5fcmVtb3ZlQ2hpbGQodGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGlsZHJlbi51bnNoaWZ0KHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5pbnNlcnRCZWZvcmUodGFyZ2V0RWwuZWwsIHRoaXMuZWwuZmlyc3RDaGlsZCk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHByZXBlbmRUbyA9IGZ1bmN0aW9uIHByZXBlbmRUbyh0YXJnZXRFbCkge1xuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHRhcmdldEVsLnByZXBlbmQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIodGFyZ2V0RWwpIHtcbiAgdmFyIG15SW5kZXg7XG5cbiAgaWYgKHRhcmdldEVsICYmIHRoaXMucGFyZW50KSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICBteUluZGV4ID0gdGhpcy5wYXJlbnQuX2NoaWxkcmVuLmluZGV4T2YodGhpcyk7XG5cbiAgICAgIHRoaXMucGFyZW50Ll9jaGlsZHJlbi5zcGxpY2UobXlJbmRleCArIDEsIDAsIHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRFbC5lbCwgdGhpcy5lbC5uZXh0U2libGluZyk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIodGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5hZnRlcih0aGlzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKHRhcmdldEVsKSB7XG4gIHZhciBteUluZGV4O1xuXG4gIGlmICh0YXJnZXRFbCAmJiB0aGlzLnBhcmVudCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgbXlJbmRleCA9IHRoaXMucGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuXG4gICAgICB0aGlzLnBhcmVudC5fY2hpbGRyZW4uc3BsaWNlKG15SW5kZXgsIDAsIHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRFbC5lbCwgdGhpcy5lbCk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZSh0YXJnZXRFbCkge1xuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHRhcmdldEVsLmJlZm9yZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICB2YXIgcmVmO1xuXG4gIGlmICgocmVmID0gdGhpcy5wYXJlbnQpICE9IG51bGwpIHtcbiAgICByZWYuX3JlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIGV2ZW50TmFtZTtcbiAgdGhpcy5kZXRhY2goKTtcbiAgdGhpcy5yZXNldFN0YXRlKCk7XG5cbiAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzKSB7XG4gICAgZm9yIChldmVudE5hbWUgaW4gdGhpcy5fZXZlbnRDYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0ubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgdmFyIGNoaWxkLCBpLCBsZW4sIHJlZjtcbiAgcmVmID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNoaWxkID0gcmVmW2ldO1xuXG4gICAgdGhpcy5fcmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHdyYXAgPSBmdW5jdGlvbiB3cmFwKHRhcmdldEVsKSB7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuXG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG4gICAgY3VycmVudFBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMgJiYgdGFyZ2V0RWwgIT09IHRoaXMucGFyZW50KSB7XG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBjdXJyZW50UGFyZW50Ll9yZW1vdmVDaGlsZCh0aGlzLCAhdGFyZ2V0RWwucGFyZW50ID8gdGFyZ2V0RWwgOiB2b2lkIDApO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRFbC5hcHBlbmQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHVud3JhcCA9IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgdmFyIGdyYW5kUGFyZW50LCBwYXJlbnQsIHBhcmVudENoaWxkcmVuLCBwYXJlbnRTaWJsaW5nO1xuICBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50Q2hpbGRyZW4gPSBfcXVpY2tkb20uYmF0Y2gocGFyZW50LmNoaWxkcmVuKTtcbiAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHQ7XG4gICAgZ3JhbmRQYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXG4gICAgaWYgKGdyYW5kUGFyZW50KSB7XG4gICAgICBwYXJlbnQuZGV0YWNoKCk7XG5cbiAgICAgIGlmIChwYXJlbnRTaWJsaW5nKSB7XG4gICAgICAgIHBhcmVudENoaWxkcmVuLmluc2VydEJlZm9yZShwYXJlbnRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudENoaWxkcmVuLmFwcGVuZFRvKGdyYW5kUGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0RWwpIHtcbiAgdmFyIHJlZjtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMpIHtcbiAgICAgIHRhcmdldEVsLmRldGFjaCgpO1xuXG4gICAgICBpZiAoKHJlZiA9IHRoaXMucGFyZW50KSAhPSBudWxsKSB7XG4gICAgICAgIHJlZi5fcmVtb3ZlQ2hpbGQodGhpcywgdGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKHRhcmdldCkge1xuICByZXR1cm4gaW5jbHVkZXModGhpcy5jbGFzc0xpc3QsIHRhcmdldCk7XG59O1xudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3ModGFyZ2V0KSB7XG4gIHZhciBjbGFzc0xpc3QsIHRhcmdldEluZGV4O1xuICBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzTGlzdDtcbiAgdGFyZ2V0SW5kZXggPSBjbGFzc0xpc3QuaW5kZXhPZih0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbmRleCA9PT0gLTEpIHtcbiAgICBjbGFzc0xpc3QucHVzaCh0YXJnZXQpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NMaXN0Lmxlbmd0aCA+IDEgPyBjbGFzc0xpc3Quam9pbignICcpIDogY2xhc3NMaXN0WzBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3ModGFyZ2V0KSB7XG4gIHZhciBjbGFzc0xpc3QsIHRhcmdldEluZGV4O1xuICBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzTGlzdDtcbiAgdGFyZ2V0SW5kZXggPSBjbGFzc0xpc3QuaW5kZXhPZih0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbmRleCAhPT0gLTEpIHtcbiAgICBjbGFzc0xpc3Quc3BsaWNlKHRhcmdldEluZGV4LCAxKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5sZW5ndGggPyBjbGFzc0xpc3Quam9pbignICcpIDogJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyh0YXJnZXQpIHtcbiAgaWYgKHRoaXMuaGFzQ2xhc3ModGFyZ2V0KSkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3ModGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZENsYXNzKHRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgc2V0UmVmID0gZnVuY3Rpb24gc2V0UmVmKHRhcmdldCkge1xuICB0aGlzLnJlZiA9IHRoaXMub3B0aW9ucy5yZWYgPSB0YXJnZXQ7XG4gIHRoaXMuYXR0cignZGF0YS1yZWYnLCB0YXJnZXQpO1xuICByZXR1cm4gdGhpcztcbn07XG52YXIgX3JlZnJlc2hQYXJlbnQgPSBmdW5jdGlvbiBfcmVmcmVzaFBhcmVudCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcbnZhciBfcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiBfcmVtb3ZlQ2hpbGQodGFyZ2V0Q2hpbGQsIHJlcGxhY2VtZW50Q2hpbGQpIHtcbiAgdmFyIGluZGV4T2ZDaGlsZDtcbiAgaW5kZXhPZkNoaWxkID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKHRhcmdldENoaWxkKTtcblxuICBpZiAoaW5kZXhPZkNoaWxkICE9PSAtMSkge1xuICAgIGlmIChyZXBsYWNlbWVudENoaWxkKSB7XG4gICAgICB0aGlzLmVsLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudENoaWxkLmVsLCB0YXJnZXRDaGlsZC5lbCk7XG5cbiAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleE9mQ2hpbGQsIDEsIHJlcGxhY2VtZW50Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKHRhcmdldENoaWxkLmVsKTtcblxuICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4T2ZDaGlsZCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uIChRdWlja0VsZW1lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICdodG1sJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmlubmVySFRNTDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5pbm5lckhUTUwgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICd0ZXh0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnRleHRDb250ZW50O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnRleHRDb250ZW50ID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2xhc3NOYW1lJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmF3LmNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsYXNzJywgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhdy5jbGFzc05hbWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NsYXNzTGlzdCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgbGlzdCA9IHRoaXMuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgaWYgKGxpc3RbbGlzdC5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgICBsaXN0LnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS50b1RlbXBsYXRlID0gdG9UZW1wbGF0ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGNsb25lO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmFwcGVuZCA9IGFwcGVuZDtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hcHBlbmRUbyA9IGFwcGVuZFRvO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnByZXBlbmQgPSBwcmVwZW5kO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnByZXBlbmRUbyA9IHByZXBlbmRUbztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hZnRlciA9IGFmdGVyO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmluc2VydEFmdGVyID0gaW5zZXJ0QWZ0ZXI7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlID0gYmVmb3JlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5kZXRhY2ggPSBkZXRhY2g7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gcmVtb3ZlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmVtcHR5ID0gZW1wdHk7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUud3JhcCA9IHdyYXA7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudW53cmFwID0gdW53cmFwO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmhhc0NsYXNzID0gaGFzQ2xhc3M7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gdG9nZ2xlQ2xhc3M7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc2V0UmVmID0gc2V0UmVmO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9yZWZyZXNoUGFyZW50ID0gX3JlZnJlc2hQYXJlbnQ7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9yZW1vdmVDaGlsZCA9IF9yZW1vdmVDaGlsZDtcbn12YXIgdXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoSVMkMS5vYmplY3Qob3B0aW9ucykpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplT3B0aW9ucygpO1xuXG4gICAgdGhpcy5fYXBwbHlPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdXBkYXRlU3RhdGVTdHlsZXMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZVN0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIGksIGxlbiwgcGFyc2VkLCBzdGF0ZSwgdXBkYXRlZFN0YXRlcztcblxuICBpZiAoSVMkMS5vYmplY3RQbGFpbihzdHlsZXMpKSB7XG4gICAgZXh0ZW5kLmRlZXAuY29uY2F0KHRoaXMsIHBhcnNlZCA9IHRoaXMuX3BhcnNlU3R5bGVzKHN0eWxlcykpO1xuXG4gICAgaWYgKHBhcnNlZC5fc3R5bGVzKSB7XG4gICAgICB1cGRhdGVkU3RhdGVzID0gT2JqZWN0LmtleXMocGFyc2VkLl9zdHlsZXMpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB1cGRhdGVkU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gdXBkYXRlZFN0YXRlc1tpXTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZShzdGF0ZSkgfHwgc3RhdGUgPT09ICdiYXNlJykge1xuICAgICAgICAgIHRoaXMuX2FwcGx5UmVnaXN0ZXJlZFN0eWxlKHRoaXMuX3N0eWxlc1tzdGF0ZV0sIHRoaXMuX2dldEFjdGl2ZVN0YXRlcyhzdGF0ZSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciB1cGRhdGVTdGF0ZVRleHRzID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVUZXh0cyh0ZXh0cykge1xuICB2YXIgcGFyc2VkO1xuXG4gIGlmIChJUyQxLm9iamVjdFBsYWluKHRleHRzKSkge1xuICAgIGV4dGVuZC5kZWVwLmNvbmNhdCh0aGlzLCBwYXJzZWQgPSB0aGlzLl9wYXJzZVRleHRzKHRleHRzKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgYXBwbHlEYXRhID0gZnVuY3Rpb24gYXBwbHlEYXRhKGRhdGEsIHBhc3NUaHJvdWdoKSB7XG4gIHZhciBjaGlsZCwgY29tcHV0ZXJzLCBkZWZhdWx0cywgaSwgaiwga2V5LCBrZXlzLCBsZW4sIGxlbjEsIHJlZjtcblxuICBpZiAodGhpcy5vcHRpb25zLnBhc3NEYXRhVG9DaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggJiYgKHBhc3NUaHJvdWdoICE9IG51bGwgPyBwYXNzVGhyb3VnaCA6IHBhc3NUaHJvdWdoID0gdHJ1ZSkpIHtcbiAgICByZWYgPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICBjaGlsZC5hcHBseURhdGEoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXB1dGVycyA9IHRoaXMub3B0aW9ucy5jb21wdXRlcnMpIHtcbiAgICBkZWZhdWx0cyA9IHRoaXMub3B0aW9ucy5kZWZhdWx0cztcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoY29tcHV0ZXJzKTtcblxuICAgIGZvciAoaiA9IDAsIGxlbjEgPSBrZXlzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAga2V5ID0ga2V5c1tqXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnZva2VDb21wdXRlcnNPbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnZva2VkQ29tcHV0ZXJzW2tleV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ludm9rZWRDb21wdXRlcnNba2V5XSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICYmIGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0aGlzLl9ydW5Db21wdXRlcihrZXksIGRhdGFba2V5XSwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdGhpcy5fcnVuQ29tcHV0ZXIoa2V5LCBkZWZhdWx0c1trZXldLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgX3J1bkNvbXB1dGVyID0gZnVuY3Rpb24gX3J1bkNvbXB1dGVyKGNvbXB1dGVyLCBhcmcsIGRhdGEpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wdXRlcnNbY29tcHV0ZXJdLmNhbGwodGhpcywgYXJnLCBkYXRhKTtcbn07XG5mdW5jdGlvbiBhcHBsaWNhdGlvbiAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudXBkYXRlT3B0aW9ucyA9IHVwZGF0ZU9wdGlvbnM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudXBkYXRlU3RhdGVTdHlsZXMgPSB1cGRhdGVTdGF0ZVN0eWxlcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS51cGRhdGVTdGF0ZVRleHRzID0gdXBkYXRlU3RhdGVUZXh0cztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hcHBseURhdGEgPSBhcHBseURhdGE7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9ydW5Db21wdXRlciA9IF9ydW5Db21wdXRlcjtcbn12YXIgYXR0ciA9IGZ1bmN0aW9uIGF0dHIodGFyZ2V0LCBuZXdWYWx1ZSkge1xuICB2YXIgaSwga2V5LCBrZXlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAoSVMkMS5vYmplY3QodGFyZ2V0KSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICBpID0gLTE7XG5cbiAgICAgIHdoaWxlIChrZXkgPSBrZXlzWysraV0pIHtcbiAgICAgICAgdGhpcy5hdHRyKGtleSwgdGFyZ2V0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKHRhcmdldCwgbmV3VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHByb3AgPSBmdW5jdGlvbiBwcm9wKHRhcmdldCwgbmV3VmFsdWUpIHtcbiAgdmFyIGksIGtleSwga2V5cztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuZWxbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBpZiAoSVMkMS5vYmplY3QodGFyZ2V0KSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICBpID0gLTE7XG5cbiAgICAgIHdoaWxlIChrZXkgPSBrZXlzWysraV0pIHtcbiAgICAgICAgdGhpcy5wcm9wKGtleSwgdGFyZ2V0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsW3RhcmdldF0gPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIGF0dHJpYnV0ZXNBbmRQcm9wZXJ0aWVzIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hdHRyID0gYXR0cjtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucHJvcCA9IHByb3A7XG59dmFyIFF1aWNrRWxlbWVudCQxLCBzdmdOYW1lc3BhY2U7XG5zdmdOYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIFF1aWNrRWxlbWVudCQyID0gUXVpY2tFbGVtZW50JDEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBRdWlja0VsZW1lbnQgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWlja0VsZW1lbnQodHlwZSwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrRWxlbWVudCk7XG5cbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgUXVpY2tFbGVtZW50LmNvdW50Kys7XG5cbiAgICAgIGlmICh0aGlzLnR5cGVbMF0gPT09ICcqJykge1xuICAgICAgICB0aGlzLnN2ZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwgPSB0aGlzLm9wdGlvbnMuZXhpc3RpbmcgfHwgKHRoaXMudHlwZSA9PT0gJ3RleHQnID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodHlwZW9mIHRoaXMub3B0aW9ucy50ZXh0ID09PSAnc3RyaW5nJyA/IHRoaXMub3B0aW9ucy50ZXh0IDogJycpIDogdGhpcy5zdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTmFtZXNwYWNlLCB0aGlzLnR5cGUuc2xpY2UoMSkpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnR5cGUpKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kID0gdGhpcy5wcmVwZW5kID0gdGhpcy5hdHRyID0gZnVuY3Rpb24gKCkge307XG4gICAgICB9IC8vIEBfdGV4dHMgPSB7fSAjIGRlZmluZWQgY29uZGl0aW9uYWxseVxuXG5cbiAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9zdHlsZXMgPSB7fTtcbiAgICAgIHRoaXMuX3N0YXRlID0gW107XG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdOyAvLyBAX3Byb3ZpZGVkU3RhdGVzID0gW11cdFx0XHRcdCMgZGVmaW5lZCBjb25kaXRpb25hbGx5XG4gICAgICAvLyBAX3Byb3ZpZGVkU3RhdGVzU2hhcmVkID0gW11cdFx0IyBkZWZpbmVkIGNvbmRpdGlvbmFsbHlcbiAgICAgIC8vIEBfZXZlbnRDYWxsYmFja3MgPSB7X19yZWZzOnt9fVx0IyBkZWZpbmVkIGNvbmRpdGlvbmFsbHlcblxuICAgICAgdGhpcy5fbm9ybWFsaXplT3B0aW9ucygpO1xuXG4gICAgICB0aGlzLl9hcHBseU9wdGlvbnMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoU3RhdGVFdmVudHMoKTtcblxuICAgICAgdGhpcy5fcHJveHlQYXJlbnQoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leGlzdGluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoUGFyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuX3F1aWNrRWxlbWVudCA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFF1aWNrRWxlbWVudCwgW3tcbiAgICAgIGtleTogXCJ0b0pTT05cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY2hpbGRyZW4sIGksIGxlbiwgb3V0cHV0O1xuICAgICAgICBvdXRwdXQgPSBbdGhpcy50eXBlLCBleHRlbmQuY2xvbmUua2V5cyhlbGVtZW50KSh0aGlzLm9wdGlvbnMpXTtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZC50b0pTT04oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBRdWlja0VsZW1lbnQ7XG4gIH0oKTtcbiAgUXVpY2tFbGVtZW50LmNvdW50ID0gMDtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaWYgKFF1aWNrRWxlbWVudCQxLm5hbWUgPT0gbnVsbCkge1xuICBRdWlja0VsZW1lbnQkMS5uYW1lID0gJ1F1aWNrRWxlbWVudCc7XG59XG5pbml0JDEoUXVpY2tFbGVtZW50JDEpO1xuYWxpYXNlcyhRdWlja0VsZW1lbnQkMSk7XG50cmF2ZXJzaW5nKFF1aWNrRWxlbWVudCQxKTtcbmV2ZW50cyhRdWlja0VsZW1lbnQkMSk7XG5zdGF0ZSQxKFF1aWNrRWxlbWVudCQxKTtcbnN0eWxlJDEoUXVpY2tFbGVtZW50JDEpO1xubWFuaXB1bGF0aW9uKFF1aWNrRWxlbWVudCQxKTtcbmFwcGxpY2F0aW9uKFF1aWNrRWxlbWVudCQxKTtcbmF0dHJpYnV0ZXNBbmRQcm9wZXJ0aWVzKFF1aWNrRWxlbWVudCQxKTt2YXIgc2NoZW1hID0ge1xuICB0eXBlOiAnZGl2JyxcbiAgcmVmOiB2b2lkIDAsXG4gIG9wdGlvbnM6IHt9LFxuICBjaGlsZHJlbjogW11cbn07XG52YXIgbWF0Y2hlc1NjaGVtYSA9IGZ1bmN0aW9uIG1hdGNoZXNTY2hlbWEob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0LnR5cGUgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBvYmplY3QucmVmICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygb2JqZWN0Lm9wdGlvbnMgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBvYmplY3QuY2hpbGRyZW4gIT09ICd1bmRlZmluZWQnO1xufTt2YXIgUEFSU0VfRVJST1JfUFJFRklYLCBwYXJzZVRyZWU7XG5QQVJTRV9FUlJPUl9QUkVGSVggPSAnVGVtcGxhdGUgUGFyc2UgRXJyb3I6IGV4cGVjdGVkJztcbnZhciBwYXJzZVRyZWUkMSA9IHBhcnNlVHJlZSA9IGZ1bmN0aW9uIHBhcnNlVHJlZSh0cmVlLCBwYXJzZUNoaWxkcmVuKSB7XG4gIHZhciBvdXRwdXQ7XG5cbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIUlTJDEuYXJyYXkodHJlZSk6XG4gICAgICBvdXRwdXQgPSB7fTtcblxuICAgICAgaWYgKCFJUyQxLnN0cmluZyh0cmVlWzBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoUEFSU0VfRVJST1JfUFJFRklYLCBcIiBzdHJpbmcgZm9yICd0eXBlJywgZ290ICdcIikuY29uY2F0KFN0cmluZyh0cmVlWzBdKSwgXCInXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC50eXBlID0gdHJlZVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMSAmJiAhSVMkMS5vYmplY3QodHJlZVsxXSkgJiYgdHJlZVsxXSAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoUEFSU0VfRVJST1JfUFJFRklYLCBcIiBvYmplY3QgZm9yICdvcHRpb25zJywgZ290ICdcIikuY29uY2F0KFN0cmluZyh0cmVlWzFdKSwgXCInXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5vcHRpb25zID0gdHJlZVsxXSA/IGV4dGVuZC5kZWVwLmNsb25lKHRyZWVbMV0pIDogc2NoZW1hLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHRyZWVbMV0pIHtcbiAgICAgICAgICBvdXRwdXQucmVmID0gdHJlZVsxXS5pZCB8fCB0cmVlWzFdLnJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvdXRwdXQuY2hpbGRyZW4gPSB0cmVlLnNsaWNlKDIpO1xuXG4gICAgICBpZiAocGFyc2VDaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID09PSAzICYmIElTJDEub2JqZWN0UGxhaW4odHJlZVsyXSkgJiYgIUlTJDEudGVtcGxhdGUodHJlZVsyXSkpIHtcbiAgICAgICAgICBvdXRwdXQuY2hpbGRyZW4gPSB0cmVlWzJdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuY2hpbGRyZW4gPSBvdXRwdXQuY2hpbGRyZW4ubWFwKHF1aWNrZG9tLnRlbXBsYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgIGNhc2UgIShJUyQxLnN0cmluZyh0cmVlKSB8fCBJUyQxLmRvbVRleHQodHJlZSkpOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgdGV4dDogdHJlZS50ZXh0Q29udGVudCB8fCB0cmVlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBzY2hlbWEuY2hpbGRyZW5cbiAgICAgIH07XG5cbiAgICBjYXNlICFJUyQxLmRvbUVsKHRyZWUpOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdHJlZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICByZWY6IHRyZWUuaWQsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuZC5jbG9uZS5rZXlzKHRlbXBsYXRlKSh0cmVlKSxcbiAgICAgICAgY2hpbGRyZW46IHNjaGVtYS5jaGlsZHJlbi5tYXAuY2FsbCh0cmVlLmNoaWxkTm9kZXMsIHF1aWNrZG9tLnRlbXBsYXRlKVxuICAgICAgfTtcblxuICAgIGNhc2UgIUlTJDEucXVpY2tEb21FbCh0cmVlKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRyZWUudHlwZSxcbiAgICAgICAgcmVmOiB0cmVlLnJlZixcbiAgICAgICAgb3B0aW9uczogZXh0ZW5kLmNsb25lLmRlZXAubm90S2V5cyhbJ3JlbGF0ZWRJbnN0YW5jZScsICdyZWxhdGVkJ10pKHRyZWUub3B0aW9ucyksXG4gICAgICAgIGNoaWxkcmVuOiB0cmVlLmNoaWxkcmVuLm1hcChxdWlja2RvbS50ZW1wbGF0ZSlcbiAgICAgIH07XG5cbiAgICBjYXNlICFJUyQxLnRlbXBsYXRlKHRyZWUpOlxuICAgICAgcmV0dXJuIHRyZWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KFBBUlNFX0VSUk9SX1BSRUZJWCwgXCIgKGFycmF5IHx8IHN0cmluZyB8fCBkb21FbCB8fCBxdWlja0RvbUVsIHx8IHRlbXBsYXRlKSwgZ290IFwiKS5jb25jYXQoU3RyaW5nKHRyZWUpKSk7XG4gIH1cbn07dmFyIE5PVF9ERUVQX0tFWVMsIE5PVF9LRVlTLCBfZXh0ZW5kQnlSZWYsIGV4dGVuZFRlbXBsYXRlO1xuTk9UX0RFRVBfS0VZUyA9IFsncmVsYXRlZEluc3RhbmNlJywgJ3JlbGF0ZWQnLCAnZGF0YSddO1xuTk9UX0tFWVMgPSBbJ2NoaWxkcmVuJywgJ19jaGlsZFJlZnMnXTtcbnZhciBleHRlbmRUZW1wbGF0ZSQxID0gZXh0ZW5kVGVtcGxhdGUgPSBmdW5jdGlvbiBleHRlbmRUZW1wbGF0ZShjdXJyZW50T3B0cywgbmV3T3B0cywgZ2xvYmFsT3B0cykge1xuICB2YXIgY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGRyZW4sIGdsb2JhbE9wdHNUcmFuc2Zvcm0sIGluZGV4LCBtYXhMZW5ndGgsIG5lZWRzVGVtcGxhdGVXcmFwLCBuZXdDaGlsZCwgbmV3Q2hpbGRQcm9jZXNzZWQsIG5ld0NoaWxkcmVuLCBub0NoYW5nZXMsIG91dHB1dCwgcmVmLCByZW1haW5pbmdOZXdDaGlsZHJlbjtcblxuICBpZiAoZ2xvYmFsT3B0cykge1xuICAgIGdsb2JhbE9wdHNUcmFuc2Zvcm0gPSB7XG4gICAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChvcHRzLCBnbG9iYWxPcHRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKElTJDEuYXJyYXkobmV3T3B0cykpIHtcbiAgICBuZXdPcHRzID0gcGFyc2VUcmVlJDEobmV3T3B0cywgZmFsc2UpO1xuICB9IGVsc2UgaWYgKG5ld09wdHMgJiYgIW1hdGNoZXNTY2hlbWEobmV3T3B0cykpIHtcbiAgICBuZXdPcHRzID0ge1xuICAgICAgb3B0aW9uczogbmV3T3B0c1xuICAgIH07XG4gIH1cblxuICBvdXRwdXQgPSBleHRlbmQuZGVlcC5udWxsRGVsZXRlcy5ub3RLZXlzKE5PVF9LRVlTKS5ub3REZWVwKE5PVF9ERUVQX0tFWVMpLnRyYW5zZm9ybShnbG9iYWxPcHRzVHJhbnNmb3JtKS5jbG9uZShjdXJyZW50T3B0cywgbmV3T3B0cyk7XG4gIGN1cnJlbnRDaGlsZHJlbiA9IGN1cnJlbnRPcHRzLmNoaWxkcmVuO1xuICBuZXdDaGlsZHJlbiA9IChuZXdPcHRzICE9IG51bGwgPyBuZXdPcHRzLmNoaWxkcmVuIDogdm9pZCAwKSB8fCBbXTtcbiAgb3V0cHV0LmNoaWxkcmVuID0gW107XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgaWYgKElTJDEuYXJyYXkobmV3Q2hpbGRyZW4pKSB7XG4gICAgbWF4TGVuZ3RoID0gTWF0aC5tYXgoY3VycmVudENoaWxkcmVuLmxlbmd0aCwgbmV3Q2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKCsraW5kZXggIT09IG1heExlbmd0aCkge1xuICAgICAgbmVlZHNUZW1wbGF0ZVdyYXAgPSBub0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZHJlbltpbmRleF07XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkcmVuW2luZGV4XTtcblxuICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICBjYXNlICFJUyQxLnRlbXBsYXRlKG5ld0NoaWxkKTpcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZDtcblxuICAgICAgICAgIGNhc2UgIUlTJDEuYXJyYXkobmV3Q2hpbGQpOlxuICAgICAgICAgICAgcmV0dXJuIG5lZWRzVGVtcGxhdGVXcmFwID0gcGFyc2VUcmVlJDEobmV3Q2hpbGQpO1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS5zdHJpbmcobmV3Q2hpbGQpOlxuICAgICAgICAgICAgcmV0dXJuIG5lZWRzVGVtcGxhdGVXcmFwID0ge1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBuZXdDaGlsZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FzZSAhKCFuZXdDaGlsZCAmJiAhZ2xvYmFsT3B0cyk6XG4gICAgICAgICAgICByZXR1cm4gbm9DaGFuZ2VzID0gdHJ1ZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmVlZHNUZW1wbGF0ZVdyYXAgPSBuZXdDaGlsZCB8fCB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIGlmIChub0NoYW5nZXMpIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBjdXJyZW50Q2hpbGQ7XG4gICAgICB9IGVsc2UgaWYgKG5lZWRzVGVtcGxhdGVXcmFwKSB7XG4gICAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkID0gY3VycmVudENoaWxkID8gY3VycmVudENoaWxkLmV4dGVuZChuZXdDaGlsZFByb2Nlc3NlZCwgZ2xvYmFsT3B0cykgOiBuZXcgUXVpY2tUZW1wbGF0ZSQxKGV4dGVuZC5jbG9uZShzY2hlbWEsIG5ld0NoaWxkUHJvY2Vzc2VkKSk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5jaGlsZHJlbi5wdXNoKG5ld0NoaWxkUHJvY2Vzc2VkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoSVMkMS5vYmplY3QobmV3Q2hpbGRyZW4pKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBleHRlbmQuYWxsb3dOdWxsLmNsb25lKG5ld0NoaWxkcmVuKTtcbiAgICBvdXRwdXQuY2hpbGRyZW4gPSBfZXh0ZW5kQnlSZWYobmV3Q2hpbGRyZW4sIGN1cnJlbnRDaGlsZHJlbiwgZ2xvYmFsT3B0cyk7XG4gICAgcmVtYWluaW5nTmV3Q2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcblxuICAgIGZvciAocmVmIGluIHJlbWFpbmluZ05ld0NoaWxkcmVuKSB7XG4gICAgICBuZXdDaGlsZCA9IHJlbWFpbmluZ05ld0NoaWxkcmVuW3JlZl07XG4gICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IElTJDEub2JqZWN0UGxhaW4obmV3Q2hpbGQpICYmICFJUyQxLnRlbXBsYXRlKG5ld0NoaWxkKSA/IG5ld0NoaWxkIDogcGFyc2VUcmVlJDEobmV3Q2hpbGQpO1xuICAgICAgb3V0cHV0LmNoaWxkcmVuLnB1c2gobmV3IFF1aWNrVGVtcGxhdGUkMShuZXdDaGlsZFByb2Nlc3NlZCkpO1xuICAgICAgZGVsZXRlIHJlbWFpbmluZ05ld0NoaWxkcmVuW3JlZl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbl9leHRlbmRCeVJlZiA9IGZ1bmN0aW9uIGV4dGVuZEJ5UmVmKG5ld0NoaWxkcmVuUmVmcywgY3VycmVudENoaWxkcmVuLCBnbG9iYWxPcHRzKSB7XG4gIHZhciBjdXJyZW50Q2hpbGQsIGksIGxlbiwgbmV3Q2hpbGQsIG5ld0NoaWxkUHJvY2Vzc2VkLCBvdXRwdXQ7XG5cbiAgaWYgKCFjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRDaGlsZHJlbjtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGN1cnJlbnRDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkcmVuW2ldO1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZHJlblJlZnNbY3VycmVudENoaWxkLnJlZl07XG5cbiAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IGN1cnJlbnRDaGlsZC5leHRlbmQobmV3Q2hpbGQsIGdsb2JhbE9wdHMpO1xuICAgICAgICBkZWxldGUgbmV3Q2hpbGRyZW5SZWZzW2N1cnJlbnRDaGlsZC5yZWZdO1xuICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgbmV3Q2hpbGRyZW5SZWZzW2N1cnJlbnRDaGlsZC5yZWZdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNhc2UgIWdsb2JhbE9wdHM6XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2hpbGQuZXh0ZW5kKG51bGwsIGdsb2JhbE9wdHMpO1xuXG4gICAgICAgICAgICBjYXNlICFPYmplY3Qua2V5cyhuZXdDaGlsZHJlblJlZnMpLmxlbmd0aDpcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGlsZC5leHRlbmQoKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgIH1cblxuICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQuY2hpbGRyZW4gPSBfZXh0ZW5kQnlSZWYobmV3Q2hpbGRyZW5SZWZzLCBuZXdDaGlsZFByb2Nlc3NlZC5jaGlsZHJlbik7XG4gICAgICBvdXRwdXQucHVzaChuZXdDaGlsZFByb2Nlc3NlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTt2YXIgUXVpY2tUZW1wbGF0ZTtcbnZhciBRdWlja1RlbXBsYXRlJDEgPSBRdWlja1RlbXBsYXRlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUXVpY2tUZW1wbGF0ZShjb25maWcsIGlzVHJlZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlja1RlbXBsYXRlKTtcblxuICAgIGlmIChJUyQxLnRlbXBsYXRlKGNvbmZpZykpIHtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgY29uZmlnID0gaXNUcmVlID8gcGFyc2VUcmVlJDEoY29uZmlnKSA6IGNvbmZpZztcbiAgICBleHRlbmQodGhpcywgY29uZmlnKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdWlja1RlbXBsYXRlLCBbe1xuICAgIGtleTogXCJleHRlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kJCQxKG5ld1ZhbHVlcywgZ2xvYmFsT3B0cykge1xuICAgICAgcmV0dXJuIG5ldyBRdWlja1RlbXBsYXRlKGV4dGVuZFRlbXBsYXRlJDEodGhpcywgbmV3VmFsdWVzLCBnbG9iYWxPcHRzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwYXduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwYXduKG5ld1ZhbHVlcywgZ2xvYmFsT3B0cywgZGF0YSkge1xuICAgICAgdmFyIGNoaWxkLCBjaGlsZERhdGEsIGNoaWxkcmVuLCBlbGVtZW50LCBpLCBsZW4sIG9wdGlvbnMsIHR5cGU7XG5cbiAgICAgIGlmIChuZXdWYWx1ZXMgJiYgbmV3VmFsdWVzLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ld1ZhbHVlcy5kYXRhO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdWYWx1ZXMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5ld1ZhbHVlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1ZhbHVlcyB8fCBnbG9iYWxPcHRzKSB7XG4gICAgICAgIHZhciBfZXh0ZW5kVGVtcGxhdGUgPSBleHRlbmRUZW1wbGF0ZSQxKHRoaXMsIG5ld1ZhbHVlcywgZ2xvYmFsT3B0cyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IF9leHRlbmRUZW1wbGF0ZS5vcHRpb25zO1xuICAgICAgICBjaGlsZHJlbiA9IF9leHRlbmRUZW1wbGF0ZS5jaGlsZHJlbjtcbiAgICAgICAgdHlwZSA9IF9leHRlbmRUZW1wbGF0ZS50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kLmNsb25lKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gX3F1aWNrZG9tLmNyZWF0ZShbdHlwZSwgb3B0aW9uc10pO1xuXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGREYXRhID0gb3B0aW9ucy5wYXNzRGF0YVRvQ2hpbGRyZW4gPyBkYXRhIHx8IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgZWxlbWVudC5hcHBlbmQoY2hpbGQuc3Bhd24obnVsbCwgbnVsbCwgY2hpbGREYXRhKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5fcG9zdENyZWF0aW9uKGRhdGEpO1xuXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVpY2tUZW1wbGF0ZTtcbn0oKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbmlmIChRdWlja1RlbXBsYXRlLm5hbWUgPT0gbnVsbCkge1xuICBRdWlja1RlbXBsYXRlLm5hbWUgPSAnUXVpY2tUZW1wbGF0ZSc7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWlja1RlbXBsYXRlLnByb3RvdHlwZSwgJ2NoaWxkJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRSZWZzIHx8IF9nZXRDaGlsZFJlZnModGhpcyk7XG4gIH1cbn0pO1xuXG5fcXVpY2tkb20udGVtcGxhdGUgPSBmdW5jdGlvbiAodHJlZSkge1xuICByZXR1cm4gbmV3IFF1aWNrVGVtcGxhdGUodHJlZSwgdHJ1ZSk7XG59O1xuXG5fcXVpY2tkb20uaXNUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIElTJDEudGVtcGxhdGUodGFyZ2V0KTtcbn07dmFyIFF1aWNrQmF0Y2g7XG52YXIgUXVpY2tCYXRjaCQxID0gUXVpY2tCYXRjaCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1aWNrQmF0Y2goZWxlbWVudHMsIHJldHVyblJlc3VsdHMxKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrQmF0Y2gpO1xuXG4gICAgdGhpcy5yZXR1cm5SZXN1bHRzID0gcmV0dXJuUmVzdWx0czE7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBfcXVpY2tkb20oZWwpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFF1aWNrQmF0Y2gsIFt7XG4gICAga2V5OiBcInJldmVyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXR1cm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldHVybihyZXR1cm5OZXh0KSB7XG4gICAgICBpZiAocmV0dXJuTmV4dCkge1xuICAgICAgICB0aGlzLnJldHVyblJlc3VsdHMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHRzO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWlja0JhdGNoO1xufSgpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaWYgKFF1aWNrQmF0Y2gubmFtZSA9PSBudWxsKSB7XG4gIFF1aWNrQmF0Y2gubmFtZSA9ICdRdWlja0JhdGNoJztcbn1cblxuT2JqZWN0LmtleXMoUXVpY2tFbGVtZW50JDIucHJvdG90eXBlKS5jb25jYXQoJ2NzcycsICdyZXBsYWNlV2l0aCcsICdodG1sJywgJ3RleHQnKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgcmV0dXJuIFF1aWNrQmF0Y2gucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICB2YXIgZWxlbWVudCwgcmVzdWx0cztcblxuICAgIHJlc3VsdHMgPSB0aGlzLmxhc3RSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzMTtcbiAgICAgIHJlZiA9IHRoaXMuZWxlbWVudHM7XG4gICAgICByZXN1bHRzMSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHJlZltpXTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSAnaHRtbCcgfHwgbWV0aG9kID09PSAndGV4dCcpIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMxLnB1c2goZWxlbWVudFttZXRob2RdID0gbmV3VmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzMS5wdXNoKGVsZW1lbnRbbWV0aG9kXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZWxlbWVudDtcblxuICAgICAgICAgIHJlc3VsdHMxLnB1c2goKF9lbGVtZW50ID0gZWxlbWVudClbbWV0aG9kXS5hcHBseShfZWxlbWVudCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLnJldHVyblJlc3VsdHMpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcblxuX3F1aWNrZG9tLmJhdGNoID0gZnVuY3Rpb24gKGVsZW1lbnRzLCByZXR1cm5SZXN1bHRzKSB7XG4gIGlmICghSVMkMS5pdGVyYWJsZShlbGVtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaDogZXhwZWN0ZWQgYW4gaXRlcmFibGUsIGdvdCBcIi5jb25jYXQoU3RyaW5nKGVsZW1lbnRzKSkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBRdWlja0JhdGNoKGVsZW1lbnRzLCByZXR1cm5SZXN1bHRzKTtcbn07dmFyIHZlcnNpb24gPSBcIjEuMC45M1wiO3ZhciBTSE9SVENVVFMsIGksIGxlbiwgc2hvcnRjdXQ7XG5TSE9SVENVVFMgPSBbJ2xpbms6YScsICdhbmNob3I6YScsICdhJywgJ3RleHQnLCAnZGl2JywgJ3NwYW4nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ2Zvb3RlcicsICdzZWN0aW9uJywgJ2J1dHRvbicsICdicicsICd1bCcsICdvbCcsICdsaScsICdmaWVsZHNldCcsICdpbnB1dCcsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnb3B0aW9uJywgJ2Zvcm0nLCAnZnJhbWUnLCAnaHInLCAnaWZyYW1lJywgJ2ltZycsICdwaWN0dXJlJywgJ21haW4nLCAnbmF2JywgJ21ldGEnLCAnb2JqZWN0JywgJ3ByZScsICdzdHlsZScsICd0YWJsZScsICd0Ym9keScsICd0aCcsICd0cicsICd0ZCcsICd0Zm9vdCcsIC8vICd0ZW1wbGF0ZSdcbid2aWRlbyddO1xuXG5mb3IgKGkgPSAwLCBsZW4gPSBTSE9SVENVVFMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgc2hvcnRjdXQgPSBTSE9SVENVVFNbaV07XG5cbiAgKGZ1bmN0aW9uIChzaG9ydGN1dCkge1xuICAgIHZhciBwcm9wLCBzcGxpdCwgdHlwZTtcbiAgICBwcm9wID0gdHlwZSA9IHNob3J0Y3V0O1xuXG4gICAgaWYgKGluY2x1ZGVzKHNob3J0Y3V0LCAnOicpKSB7XG4gICAgICBzcGxpdCA9IHNob3J0Y3V0LnNwbGl0KCc6Jyk7XG4gICAgICBwcm9wID0gc3BsaXRbMF07XG4gICAgICB0eXBlID0gc3BsaXRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWlja2RvbVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBbdHlwZV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICB9KShzaG9ydGN1dCk7XG59aW5pdChRdWlja0VsZW1lbnQkMiwgUXVpY2tXaW5kb3ckMik7XG5fcXVpY2tkb20uUXVpY2tFbGVtZW50ID0gUXVpY2tFbGVtZW50JDI7XG5fcXVpY2tkb20uUXVpY2tUZW1wbGF0ZSA9IFF1aWNrVGVtcGxhdGUkMTtcbl9xdWlja2RvbS5RdWlja1dpbmRvdyA9IFF1aWNrV2luZG93JDI7XG5fcXVpY2tkb20uUXVpY2tCYXRjaCA9IFF1aWNrQmF0Y2gkMTtcbl9xdWlja2RvbS52ZXJzaW9uID0gdmVyc2lvbjtcbl9xdWlja2RvbS5DU1MgPSBDU1M7XG52YXIgcXVpY2tkb20gPSBfcXVpY2tkb207IC8vIGV4cG9ydCB7cXVpY2tkb20gYXMgZGVmYXVsdCwgUXVpY2tFbGVtZW50LCBRdWlja1RlbXBsYXRlLCBRdWlja1dpbmRvdywgUXVpY2tCYXRjaH1cbmV4cG9ydCBkZWZhdWx0IHF1aWNrZG9tOyIsImltcG9ydCBET00gZnJvbSAncXVpY2tkb20nXG5cbmV4cG9ydCBkZWZhdWx0IHJlc3RhcnRTYW5kYm94ID0gKCktPlxuXHRpZiB3aW5kb3cuc2FuZGJveFxuXHRcdGRlbGV0ZSBxdWlja2ZpZWxkLmluc3RhbmNlc1tpZF0gZm9yIGlkLGZpZWxkIG9mIHF1aWNrZmllbGQuaW5zdGFuY2VzXG5cdFx0d2luZG93LnNhbmRib3gucmVtb3ZlKClcblx0XG5cdHdpbmRvdy5zYW5kYm94ID0gRE9NLmRpdihpZDonc2FuZGJveCcsIHN0eWxlOntib3JkZXI6JzFweCBzb2xpZCcsIHBhZGRpbmc6JzIwcHgnLCBib3hTaXppbmc6J2JvcmRlci1ib3gnfSkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSlcbiIsImltcG9ydCBET00gZnJvbSAncXVpY2tkb20nXG5cbmV4cG9ydCBkZWZhdWx0ICh0aXRsZSwgbWFyZ2luPTIwKS0+XG5cdERPTS5kaXYoXG5cdFx0cmVmOiAndGVzdFRpdGxlJ1xuXHRcdHN0eWxlOnttYXJnaW5Ub3A6bWFyZ2luLCBtYXJnaW5Cb3R0b206bWFyZ2luLCBmb250U2l6ZToxNiwgZm9udFdlaWdodDo2MDAsIGZvbnRGYW1pbHk6J3N5c3RlbS11aSwgc2Fucy1zZXJpZid9XG5cdCx0aXRsZSkuYXBwZW5kVG8oc2FuZGJveClcbiIsImltcG9ydCBET00gZnJvbSAncXVpY2tkb20nXG5cbmV4cG9ydCBkZWZhdWx0ICgpLT5cblx0bWFyZ2luID0gYXJndW1lbnRzWzBdXG5cdG1hcmdpbiA9IDIwIGlmIGlzTmFOKG1hcmdpbilcblx0RE9NLmRpdihcblx0XHRyZWY6ICd0ZXN0VGl0bGUnXG5cdFx0c3R5bGU6IHttYXJnaW5Ub3A6bWFyZ2luLCBtYXJnaW5Cb3R0b206bWFyZ2lufVxuXHQpLmFwcGVuZFRvKHNhbmRib3gpXG4iLCJleHBvcnQgZGVmYXVsdCAoZWwpLT5cblx0dG9wOiBlbC5zdHlsZSgnYm9yZGVyVG9wV2lkdGgnKVxuXHRib3R0b206IGVsLnN0eWxlKCdib3JkZXJCb3R0b21XaWR0aCcpXG5cdGxlZnQ6IGVsLnN0eWxlKCdib3JkZXJMZWZ0V2lkdGgnKVxuXHRyaWdodDogZWwuc3R5bGUoJ2JvcmRlclJpZ2h0V2lkdGgnKSIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gKHByb21pc2UsIG9uRmluYWxseSkgPT4ge1xuXHRvbkZpbmFsbHkgPSBvbkZpbmFsbHkgfHwgKCgpID0+IHt9KTtcblxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKFxuXHRcdHZhbCA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRcdHJlc29sdmUob25GaW5hbGx5KCkpO1xuXHRcdH0pLnRoZW4oKCkgPT4gdmFsKSxcblx0XHRlcnIgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0XHRyZXNvbHZlKG9uRmluYWxseSgpKTtcblx0XHR9KS50aGVuKCgpID0+IHtcblx0XHRcdHRocm93IGVycjtcblx0XHR9KVxuXHQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBGaW5hbGx5ID0gcmVxdWlyZSgncC1maW5hbGx5Jyk7XG5cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb21pc2UsIG1zLCBmYWxsYmFjaykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZiAodHlwZW9mIG1zICE9PSAnbnVtYmVyJyAmJiBtcyA+PSAwKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYG1zYCB0byBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuXHR9XG5cblx0Y29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXNvbHZlKGZhbGxiYWNrKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdzdHJpbmcnID8gZmFsbGJhY2sgOiBgUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgJHttc30gbWlsbGlzZWNvbmRzYDtcblx0XHRjb25zdCBlcnIgPSBmYWxsYmFjayBpbnN0YW5jZW9mIEVycm9yID8gZmFsbGJhY2sgOiBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuXG5cdFx0cmVqZWN0KGVycik7XG5cdH0sIG1zKTtcblxuXHRwRmluYWxseShcblx0XHRwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSxcblx0XHQoKSA9PiB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdH1cblx0KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwVGltZW91dCA9IHJlcXVpcmUoJ3AtdGltZW91dCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChlbWl0dGVyLCBldmVudCwgb3B0cykgPT4ge1xuXHRsZXQgY2FuY2VsO1xuXG5cdGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9wdHMgPSB7ZmlsdGVyOiBvcHRzfTtcblx0XHR9XG5cblx0XHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRyZWplY3Rpb25FdmVudHM6IFsnZXJyb3InXSxcblx0XHRcdG11bHRpQXJnczogZmFsc2Vcblx0XHR9LCBvcHRzKTtcblxuXHRcdGxldCBhZGRMaXN0ZW5lciA9IGVtaXR0ZXIub24gfHwgZW1pdHRlci5hZGRMaXN0ZW5lciB8fCBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0bGV0IHJlbW92ZUxpc3RlbmVyID0gZW1pdHRlci5vZmYgfHwgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciB8fCBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cblx0XHRpZiAoIWFkZExpc3RlbmVyIHx8ICFyZW1vdmVMaXN0ZW5lcikge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRW1pdHRlciBpcyBub3QgY29tcGF0aWJsZScpO1xuXHRcdH1cblxuXHRcdGFkZExpc3RlbmVyID0gYWRkTGlzdGVuZXIuYmluZChlbWl0dGVyKTtcblx0XHRyZW1vdmVMaXN0ZW5lciA9IHJlbW92ZUxpc3RlbmVyLmJpbmQoZW1pdHRlcik7XG5cblx0XHRjb25zdCByZXNvbHZlSGFuZGxlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdHZhbHVlID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYW5jZWwoKTtcblx0XHRcdHJlc29sdmUodmFsdWUpO1xuXHRcdH07XG5cblx0XHRjb25zdCByZWplY3RIYW5kbGVyID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0Y2FuY2VsKCk7XG5cblx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRyZWplY3QoW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWplY3QocmVhc29uKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y2FuY2VsID0gKCkgPT4ge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoZXZlbnQsIHJlc29sdmVIYW5kbGVyKTtcblxuXHRcdFx0Zm9yIChjb25zdCByZWplY3Rpb25FdmVudCBvZiBvcHRzLnJlamVjdGlvbkV2ZW50cykge1xuXHRcdFx0XHRyZW1vdmVMaXN0ZW5lcihyZWplY3Rpb25FdmVudCwgcmVqZWN0SGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGFkZExpc3RlbmVyKGV2ZW50LCByZXNvbHZlSGFuZGxlcik7XG5cblx0XHRmb3IgKGNvbnN0IHJlamVjdGlvbkV2ZW50IG9mIG9wdHMucmVqZWN0aW9uRXZlbnRzKSB7XG5cdFx0XHRhZGRMaXN0ZW5lcihyZWplY3Rpb25FdmVudCwgcmVqZWN0SGFuZGxlcik7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXQuY2FuY2VsID0gY2FuY2VsO1xuXG5cdGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiBwVGltZW91dChyZXQsIG9wdHMudGltZW91dCk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsImV4cG9ydCBkZWZhdWx0XG5cdHJlZDogJyNjYzQ4MjAnXG5cdGdyZWVuOiAnIzcyYzMyMidcblx0b3JhbmdlOiAnI2ZmOWMwMCdcblx0YmxhY2s6ICcjMTgxODE4J1xuXHRncmV5X2Rhcms6ICcjNWU1ZTVlJ1xuXHRncmV5OiAnIzkwOTA5MCdcblx0Z3JleV9zZW1pX2xpZ2h0OiAnI2JlYmViZSdcblx0Z3JleV9saWdodDogJyNkM2QzZDMnXG5cdGdyZXlfbGlnaHQyOiAnI2RkZGRkZCdcblx0Z3JleV9saWdodDM6ICcjZjJmNWY3J1xuXHRncmV5X2xpZ2h0NDogJyNlNWU1ZTUnXG4iLCIvKiFcbiAqIGFzc2VydGlvbi1lcnJvclxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQHF1YWxpYW5jeS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9iamVjdCB0byBhbm90aGVyIGV4Y2x1ZGluZyBhbnkgb3JpZ2luYWxseVxuICogbGlzdGVkLiBSZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyBge31gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleGNsdWRlZCBwcm9wZXJ0aWVzIC4uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gZXhjbHVkZSAoKSB7XG4gIHZhciBleGNsdWRlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmdW5jdGlvbiBleGNsdWRlUHJvcHMgKHJlcywgb2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghfmV4Y2x1ZGVzLmluZGV4T2Yoa2V5KSkgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBleHRlbmRFeGNsdWRlICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgLCBpID0gMFxuICAgICAgLCByZXMgPSB7fTtcblxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhjbHVkZVByb3BzKHJlcywgYXJnc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiAjIyMgQXNzZXJ0aW9uRXJyb3JcbiAqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIEphdmFTY3JpcHQgYEVycm9yYCBjb25zdHJ1Y3RvciBmb3JcbiAqIGFzc2VydGlvbiBhbmQgdmFsaWRhdGlvbiBzY2VuYXJpb3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtjYWxsZWV9IHN0YXJ0IHN0YWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAqL1xuXG5mdW5jdGlvbiBBc3NlcnRpb25FcnJvciAobWVzc2FnZSwgX3Byb3BzLCBzc2YpIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ25hbWUnLCAnbWVzc2FnZScsICdzdGFjaycsICdjb25zdHJ1Y3RvcicsICd0b0pTT04nKVxuICAgICwgcHJvcHMgPSBleHRlbmQoX3Byb3BzIHx8IHt9KTtcblxuICAvLyBkZWZhdWx0IHZhbHVlc1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbnNwZWNpZmllZCBBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuc2hvd0RpZmYgPSBmYWxzZTtcblxuICAvLyBjb3B5IGZyb20gcHJvcGVydGllc1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICB9XG5cbiAgLy8gY2FwdHVyZSBzdGFjayB0cmFjZVxuICBzc2YgPSBzc2YgfHwgYXJndW1lbnRzLmNhbGxlZTtcbiAgaWYgKHNzZiAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHNzZik7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEVycm9yLnByb3RvdHlwZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuLyohXG4gKiBTdGF0aWNhbGx5IHNldCBuYW1lXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4vKiFcbiAqIEVuc3VyZSBjb3JyZWN0IGNvbnN0cnVjdG9yXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogQWxsb3cgZXJyb3JzIHRvIGJlIGNvbnZlcnRlZCB0byBKU09OIGZvciBzdGF0aWMgdHJhbnNmZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlIHN0YWNrIChkZWZhdWx0OiBgdHJ1ZWApXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB0aGF0IGNhbiBiZSBgSlNPTi5zdHJpbmdpZnlgXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzdGFjaykge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnY29uc3RydWN0b3InLCAndG9KU09OJywgJ3N0YWNrJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKHsgbmFtZTogdGhpcy5uYW1lIH0sIHRoaXMpO1xuXG4gIC8vIGluY2x1ZGUgc3RhY2sgaWYgZXhpc3RzIGFuZCBub3QgdHVybmVkIG9mZlxuICBpZiAoZmFsc2UgIT09IHN0YWNrICYmIHRoaXMuc3RhY2spIHtcbiAgICBwcm9wcy5zdGFjayA9IHRoaXMuc3RhY2s7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiAhXG4gKiBDaGFpIC0gcGF0aHZhbCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbG9naWNhbHBhcmFkb3gvZmlsdHJcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5oYXNQcm9wZXJ0eShvYmplY3QsIG5hbWUpXG4gKlxuICogVGhpcyBhbGxvd3MgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIG93blxuICogb3IgaW5oZXJpdGVkIGZyb20gcHJvdG90eXBlIGNoYWluIG5hbWVkIHByb3BlcnR5LlxuICpcbiAqIEJhc2ljYWxseSBkb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSBgaW5gXG4gKiBvcGVyYXRvciBidXQgd29ya3MgcHJvcGVybHkgd2l0aCBudWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAqIGFuZCBvdGhlciBwcmltaXRpdmVzLlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICB9XG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSB0aGUgcmVzdWx0cy5cbiAqXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLCAnc3RyJyk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLCAnY29uc3RydWN0b3InKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmosICdiYXInKTsgIC8vIGZhbHNlXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KG9iai5zdHIsICdsZW5ndGgnKTsgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5zdHIsIDEpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5zdHIsIDUpOyAgLy8gZmFsc2VcbiAqXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLmFyciwgJ2xlbmd0aCcpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5hcnIsIDIpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5hcnIsIDMpOyAgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIGl0IGV4aXN0c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgaGFzUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUaGUgYGluYCBvcGVyYXRvciBkb2VzIG5vdCB3b3JrIHdpdGggcHJpbWl0aXZlcy5cbiAgcmV0dXJuIG5hbWUgaW4gT2JqZWN0KG9iaik7XG59XG5cbi8qICFcbiAqICMjIHBhcnNlUGF0aChwYXRoKVxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIHBhcnNlIHN0cmluZyBvYmplY3RcbiAqIHBhdGhzLiBVc2UgaW4gY29uanVuY3Rpb24gd2l0aCBgaW50ZXJuYWxHZXRQYXRoVmFsdWVgLlxuICpcbiAqICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aCgnbXlvYmplY3QucHJvcGVydHkuc3VicHJvcCcpO1xuICpcbiAqICMjIyBQYXRoczpcbiAqXG4gKiAqIENhbiBiZSBpbmZpbml0ZWx5IGRlZXAgYW5kIG5lc3RlZC5cbiAqICogQXJyYXlzIGFyZSBhbHNvIHZhbGlkIHVzaW5nIHRoZSBmb3JtYWwgYG15b2JqZWN0LmRvY3VtZW50WzNdLnByb3BlcnR5YC5cbiAqICogTGl0ZXJhbCBkb3RzIGFuZCBicmFja2V0cyAobm90IGRlbGltaXRlcikgbXVzdCBiZSBiYWNrc2xhc2gtZXNjYXBlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gcGFyc2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgc3RyID0gcGF0aC5yZXBsYWNlKC8oW15cXFxcXSlcXFsvZywgJyQxLlsnKTtcbiAgdmFyIHBhcnRzID0gc3RyLm1hdGNoKC8oXFxcXFxcLnxbXi5dKz8pKy9nKTtcbiAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbiBtYXBNYXRjaGVzKHZhbHVlKSB7XG4gICAgdmFyIHJlZ2V4cCA9IC9eXFxbKFxcZCspXFxdJC87XG4gICAgdmFyIG1BcnIgPSByZWdleHAuZXhlYyh2YWx1ZSk7XG4gICAgdmFyIHBhcnNlZCA9IG51bGw7XG4gICAgaWYgKG1BcnIpIHtcbiAgICAgIHBhcnNlZCA9IHsgaTogcGFyc2VGbG9hdChtQXJyWzFdKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQgPSB7IHA6IHZhbHVlLnJlcGxhY2UoL1xcXFwoWy5cXFtcXF1dKS9nLCAnJDEnKSB9O1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0pO1xufVxuXG4vKiAhXG4gKiAjIyBpbnRlcm5hbEdldFBhdGhWYWx1ZShvYmosIHBhcnNlZFssIHBhdGhEZXB0aF0pXG4gKlxuICogSGVscGVyIGNvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYC5wYXJzZVBhdGhgIHRoYXQgcmV0dXJuc1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgdGhlIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICAgICAgdmFyIHZhbHVlID0gZ2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNlYXJjaCBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCAobmVzdGluZyBsZXZlbCkgb2YgdGhlIHByb3BlcnR5IHdlIHdhbnQgdG8gcmV0cmlldmVcbiAqIEByZXR1cm5zIHtPYmplY3R8VW5kZWZpbmVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWQsIHBhdGhEZXB0aCkge1xuICB2YXIgdGVtcG9yYXJ5VmFsdWUgPSBvYmo7XG4gIHZhciByZXMgPSBudWxsO1xuICBwYXRoRGVwdGggPSAodHlwZW9mIHBhdGhEZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyBwYXJzZWQubGVuZ3RoIDogcGF0aERlcHRoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhEZXB0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKHRlbXBvcmFyeVZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQucCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUgPSB0ZW1wb3JhcnlWYWx1ZVtwYXJ0LmldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUgPSB0ZW1wb3JhcnlWYWx1ZVtwYXJ0LnBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gKHBhdGhEZXB0aCAtIDEpKSB7XG4gICAgICAgIHJlcyA9IHRlbXBvcmFyeVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbi8qICFcbiAqICMjIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgdmFsdWUsIHBhcnNlZClcbiAqXG4gKiBDb21wYW5pb24gZnVuY3Rpb24gZm9yIGBwYXJzZVBhdGhgIHRoYXQgc2V0c1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgYSBwYXJzZWQgYWRkcmVzcy5cbiAqXG4gKiAgaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCAndmFsdWUnLCBwYXJzZWQpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFuZCBkZWZpbmUgb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdG8gdXNlIHVwb24gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCB2YWwsIHBhcnNlZCkge1xuICB2YXIgdGVtcE9iaiA9IG9iajtcbiAgdmFyIHBhdGhEZXB0aCA9IHBhcnNlZC5sZW5ndGg7XG4gIHZhciBwYXJ0ID0gbnVsbDtcbiAgLy8gSGVyZSB3ZSBpdGVyYXRlIHRocm91Z2ggZXZlcnkgcGFydCBvZiB0aGUgcGF0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhEZXB0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gbnVsbDtcbiAgICB2YXIgcHJvcFZhbCA9IG51bGw7XG4gICAgcGFydCA9IHBhcnNlZFtpXTtcblxuICAgIC8vIElmIGl0J3MgdGhlIGxhc3QgcGFydCBvZiB0aGUgcGF0aCwgd2Ugc2V0IHRoZSAncHJvcE5hbWUnIHZhbHVlIHdpdGggdGhlIHByb3BlcnR5IG5hbWVcbiAgICBpZiAoaSA9PT0gKHBhdGhEZXB0aCAtIDEpKSB7XG4gICAgICBwcm9wTmFtZSA9IHR5cGVvZiBwYXJ0LnAgPT09ICd1bmRlZmluZWQnID8gcGFydC5pIDogcGFydC5wO1xuICAgICAgLy8gTm93IHdlIHNldCB0aGUgcHJvcGVydHkgd2l0aCB0aGUgbmFtZSBoZWxkIGJ5ICdwcm9wTmFtZScgb24gb2JqZWN0IHdpdGggdGhlIGRlc2lyZWQgdmFsXG4gICAgICB0ZW1wT2JqW3Byb3BOYW1lXSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJ0LnAgIT09ICd1bmRlZmluZWQnICYmIHRlbXBPYmpbcGFydC5wXSkge1xuICAgICAgdGVtcE9iaiA9IHRlbXBPYmpbcGFydC5wXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJ0LmkgIT09ICd1bmRlZmluZWQnICYmIHRlbXBPYmpbcGFydC5pXSkge1xuICAgICAgdGVtcE9iaiA9IHRlbXBPYmpbcGFydC5pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIG9iaiBkb2Vzbid0IGhhdmUgdGhlIHByb3BlcnR5IHdlIGNyZWF0ZSBvbmUgd2l0aCB0aGF0IG5hbWUgdG8gZGVmaW5lIGl0XG4gICAgICB2YXIgbmV4dCA9IHBhcnNlZFtpICsgMV07XG4gICAgICAvLyBIZXJlIHdlIHNldCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hpY2ggd2lsbCBiZSBkZWZpbmVkXG4gICAgICBwcm9wTmFtZSA9IHR5cGVvZiBwYXJ0LnAgPT09ICd1bmRlZmluZWQnID8gcGFydC5pIDogcGFydC5wO1xuICAgICAgLy8gSGVyZSB3ZSBkZWNpZGUgaWYgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGFuIGFycmF5IG9yIGEgbmV3IG9iamVjdFxuICAgICAgcHJvcFZhbCA9IHR5cGVvZiBuZXh0LnAgPT09ICd1bmRlZmluZWQnID8gW10gOiB7fTtcbiAgICAgIHRlbXBPYmpbcHJvcE5hbWVdID0gcHJvcFZhbDtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3Byb3BOYW1lXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAjIyMgLmdldFBhdGhJbmZvKG9iamVjdCwgcGF0aClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IGluZm8gaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqIFRoZSBwYXRoIGluZm8gY29uc2lzdHMgb2YgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAqIHBhcmVudCAtIFRoZSBwYXJlbnQgb2JqZWN0IG9mIHRoZSBwcm9wZXJ0eSByZWZlcmVuY2VkIGJ5IGBwYXRoYFxuICogKiBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbmFsIHByb3BlcnR5LCBhIG51bWJlciBpZiBpdCB3YXMgYW4gYXJyYXkgaW5kZXhlclxuICogKiB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiAqIGV4aXN0cyAtIFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cyBvciBub3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gaW5mb1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UGF0aEluZm9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aEluZm8ob2JqLCBwYXRoKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgocGF0aCk7XG4gIHZhciBsYXN0ID0gcGFyc2VkW3BhcnNlZC5sZW5ndGggLSAxXTtcbiAgdmFyIGluZm8gPSB7XG4gICAgcGFyZW50OiBwYXJzZWQubGVuZ3RoID4gMSA/IGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkLCBwYXJzZWQubGVuZ3RoIC0gMSkgOiBvYmosXG4gICAgbmFtZTogbGFzdC5wIHx8IGxhc3QuaSxcbiAgICB2YWx1ZTogaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWQpLFxuICB9O1xuICBpbmZvLmV4aXN0cyA9IGhhc1Byb3BlcnR5KGluZm8ucGFyZW50LCBpbmZvLm5hbWUpO1xuXG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0UGF0aFZhbHVlKG9iamVjdCwgcGF0aClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHZhbHVlcyBpbiBhblxuICogb2JqZWN0IGdpdmVuIGEgc3RyaW5nIHBhdGguXG4gKlxuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIHByb3AxOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgICAgIH1cbiAqICAgICAgICwgcHJvcDI6IHtcbiAqICAgICAgICAgICAgIGFycjogWyB7IG5lc3RlZDogJ1VuaXZlcnNlJyB9IF1cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvIGFnYWluISdcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIHRoZSByZXN1bHRzLlxuICpcbiAqICAgICBnZXRQYXRoVmFsdWUob2JqLCAncHJvcDEuc3RyJyk7IC8vIEhlbGxvXG4gKiAgICAgZ2V0UGF0aFZhbHVlKG9iaiwgJ3Byb3AxLmF0dFsyXScpOyAvLyBiXG4gKiAgICAgZ2V0UGF0aFZhbHVlKG9iaiwgJ3Byb3AyLmFyclswXS5uZXN0ZWQnKTsgLy8gVW5pdmVyc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gdmFsdWUgb3IgYHVuZGVmaW5lZGBcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFBhdGhWYWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoVmFsdWUob2JqLCBwYXRoKSB7XG4gIHZhciBpbmZvID0gZ2V0UGF0aEluZm8ob2JqLCBwYXRoKTtcbiAgcmV0dXJuIGluZm8udmFsdWU7XG59XG5cbi8qKlxuICogIyMjIC5zZXRQYXRoVmFsdWUob2JqZWN0LCBwYXRoLCB2YWx1ZSlcbiAqXG4gKiBEZWZpbmUgdGhlIHZhbHVlIGluIGFuIG9iamVjdCBhdCBhIGdpdmVuIHN0cmluZyBwYXRoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgb2JqID0ge1xuICogICAgIHByb3AxOiB7XG4gKiAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgIH1cbiAqICAgLCBwcm9wMjoge1xuICogICAgICAgICBhcnI6IFsgeyBuZXN0ZWQ6ICdVbml2ZXJzZScgfSBdXG4gKiAgICAgICAsIHN0cjogJ0hlbGxvIGFnYWluISdcbiAqICAgICB9XG4gKiB9O1xuICogYGBgXG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSBhY2NlcHRhYmxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcHJvcGVydGllcyA9IHJlcXVpcmUoJ3RlYS1wcm9wZXJ0aWVzJyk7XG4gKiBwcm9wZXJ0aWVzLnNldChvYmosICdwcm9wMS5zdHInLCAnSGVsbG8gVW5pdmVyc2UhJyk7XG4gKiBwcm9wZXJ0aWVzLnNldChvYmosICdwcm9wMS5hcnJbMl0nLCAnQicpO1xuICogcHJvcGVydGllcy5zZXQob2JqLCAncHJvcDIuYXJyWzBdLm5lc3RlZC52YWx1ZScsIHsgaGVsbG86ICd1bml2ZXJzZScgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNldFBhdGhWYWx1ZShvYmosIHBhdGgsIHZhbCkge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpO1xuICBpbnRlcm5hbFNldFBhdGhWYWx1ZShvYmosIHZhbCwgcGFyc2VkKTtcbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhc1Byb3BlcnR5OiBoYXNQcm9wZXJ0eSxcbiAgZ2V0UGF0aEluZm86IGdldFBhdGhJbmZvLFxuICBnZXRQYXRoVmFsdWU6IGdldFBhdGhWYWx1ZSxcbiAgc2V0UGF0aFZhbHVlOiBzZXRQYXRoVmFsdWUsXG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmZsYWcob2JqZWN0LCBrZXksIFt2YWx1ZV0pXG4gKlxuICogR2V0IG9yIHNldCBhIGZsYWcgdmFsdWUgb24gYW4gb2JqZWN0LiBJZiBhXG4gKiB2YWx1ZSBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCwgZWxzZSBpdCB3aWxsXG4gKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZXQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWZcbiAqIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICpcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nLCAnYmFyJyk7IC8vIHNldHRlclxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycpOyAvLyBnZXR0ZXIsIHJldHVybnMgYGJhcmBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgKG9wdGlvbmFsKVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZmxhZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmbGFnKG9iaiwga2V5LCB2YWx1ZSkge1xuICB2YXIgZmxhZ3MgPSBvYmouX19mbGFncyB8fCAob2JqLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBmbGFnc1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZsYWdzW2tleV07XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0ZXN0IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKipcbiAqICMjIyAudGVzdChvYmplY3QsIGV4cHJlc3Npb24pXG4gKlxuICogVGVzdCBhbmQgb2JqZWN0IGZvciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgdGVzdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVzdChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIGV4cHIgPSBhcmdzWzBdO1xuICByZXR1cm4gbmVnYXRlID8gIWV4cHIgOiBleHByO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cbnZhciBwcm9taXNlRXhpc3RzID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbic7XG52YXIgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHNlbGY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbnZhciBpc0RvbSA9ICdsb2NhdGlvbicgaW4gZ2xvYmFsT2JqZWN0ICYmICdkb2N1bWVudCcgaW4gZ2xvYmFsT2JqZWN0O1xudmFyIHN5bWJvbEV4aXN0cyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xudmFyIG1hcEV4aXN0cyA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEV4aXN0cyA9IHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtNYXBFeGlzdHMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgd2Vha1NldEV4aXN0cyA9IHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciBkYXRhVmlld0V4aXN0cyA9IHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc2V0RW50cmllc0V4aXN0cyA9IHNldEV4aXN0cyAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nO1xudmFyIG1hcEVudHJpZXNFeGlzdHMgPSBtYXBFeGlzdHMgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzZXRJdGVyYXRvclByb3RvdHlwZSA9IHNldEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBTZXQoKS5lbnRyaWVzKCkpO1xudmFyIG1hcEl0ZXJhdG9yUHJvdG90eXBlID0gbWFwRW50cmllc0V4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IE1hcCgpLmVudHJpZXMoKSk7XG52YXIgYXJyYXlJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBhcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciBzdHJpbmdJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBTdHJpbmcucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJydbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciB0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCA9IDg7XG52YXIgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoID0gLTE7XG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2VzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LFxuICogbm9ybWFsaXNpbmcgYmVoYXZpb3VyIGFjcm9zcyBlbmdpbmUgdmVyc2lvbnMgJiB3ZWxsIG9wdGltaXNlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZURldGVjdChvYmopIHtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDMsMDM5LDAzNSBvcHMvc2VjIMKxMS42MiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAxLDQyNCwxMzggb3BzL3NlYyDCsTQuNTQlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMSw2NTMsMTUzIG9wcy9zZWMgwrExLjkxJSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDksOTc4LDY2MCBvcHMvc2VjIMKxMS45MiUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAyLDU1Niw3Njkgb3BzL3NlYyDCsTEuNzMlICg3NyBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMzgsNTY0LDc5NiBvcHMvc2VjIMKxMS4xNSUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAzMSwxNDgsOTQwIG9wcy9zZWMgwrExLjEwJSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDMyLDY3OSwzMzAgb3BzL3NlYyDCsTEuOTAlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggMzIsMzYzLDM2OCBvcHMvc2VjIMKxMS4wNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAzMSwyOTYsODcwIG9wcy9zZWMgwrEwLjk2JSAoODMgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgdmFyIHR5cGVvZk9iaiA9IHR5cGVvZiBvYmo7XG4gIGlmICh0eXBlb2ZPYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGVvZk9iajtcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAyOCw2NDUsNzY1IG9wcy9zZWMgwrExLjE3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDM2LDQyOCw5NjIgb3BzL3NlYyDCsTEuMzclICg4NCBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdylgYFxuICAgKiAgLSBOb2RlID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFBoYW50b21KUyA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgRWRnZSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpYGBcbiAgICogIC0gQ2hyb21lIFdvcmtlciA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94IFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIFNhZmFyaSBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSAxMSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSBFZGdlIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqL1xuICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QpIHtcbiAgICByZXR1cm4gJ2dsb2JhbCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMiw4ODgsMzUyIG9wcy9zZWMgwrEwLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIyLDQ3OSw2NTAgb3BzL3NlYyDCsTAuOTYlICg4MSBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAoXG4gICAgQXJyYXkuaXNBcnJheShvYmopICYmXG4gICAgKHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID09PSBmYWxzZSB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBvYmopKVxuICApIHtcbiAgICByZXR1cm4gJ0FycmF5JztcbiAgfVxuXG4gIGlmIChpc0RvbSkge1xuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2xvY2F0aW9uKVxuICAgICAqIFdoYXRXRyBIVE1MJDcuNy4zIC0gVGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cubG9jYXRpb24pYGBcbiAgICAgKiAgLSBJRSA8PTExID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0LmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG9jdW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkMy4xLjEgLSBUaGUgYERvY3VtZW50YCBvYmplY3RcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTI2ODA5MjY4KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiAgICAgICBXaGF0V0cgSFRNTCBzdGF0ZXM6XG4gICAgICogICAgICAgICA+IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIFdpbmRvdyBvYmplY3RzIG11c3QgYWxzbyBoYXZlIGFcbiAgICAgKiAgICAgICAgID4gd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSwgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgbmFtZWRcbiAgICAgKiAgICAgICAgID4gSFRNTERvY3VtZW50IHdob3NlIHZhbHVlIGlzIHRoZSBEb2N1bWVudCBpbnRlcmZhY2Ugb2JqZWN0LlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpYGBcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiAnRG9jdW1lbnQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjbWltZXR5cGVhcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBNaW1lVHlwZUFycmF5XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IubWltZVR5cGVzKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TTWltZVR5cGVzQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5taW1lVHlwZXMpIHtcbiAgICAgIHJldHVybiAnTWltZVR5cGVBcnJheSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBQbHVnaW5BcnJheVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLnBsdWdpbnMpYGBcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNQbHVnaW5zQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5wbHVnaW5zKSB7XG4gICAgICByZXR1cm4gJ1BsdWdpbkFycmF5JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuNC40IC0gVGhlIGBibG9ja3F1b3RlYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MUXVvdGVFbGVtZW50YFxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IEhUTUxCbG9ja0VsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdCTE9DS1FVT1RFJykge1xuICAgICAgcmV0dXJuICdIVE1MUXVvdGVFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlZGF0YWNlbGxlbGVtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50YFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpKVxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgIHJldHVybiAnSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlaGVhZGVyY2VsbGVsZW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudGBcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSlcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnVEgnKSB7XG4gICAgICByZXR1cm4gJ0hUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50JztcbiAgICB9XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDYyNSw2NDQgb3BzL3NlYyDCsTEuNTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCAxLDI3OSw4NTIgb3BzL3NlYyDCsTIuOTElICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCAxLDE3OCwxODUgb3BzL3NlYyDCsTEuOTUlICg4MyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCAxLDAwOCwzODAgb3BzL3NlYyDCsTIuMjUlICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCAxLDEyOCwwNDAgb3BzL3NlYyDCsTIuMTElICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCAxLDE3MCwxMTkgb3BzL3NlYyDCsTIuODglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCAxLDE3NiwzNDggb3BzL3NlYyDCsTUuNzklICg4NiBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCAxLDA1OCw3MDcgb3BzL3NlYyDCsTQuOTQlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCAxLDExMCw2MzMgb3BzL3NlYyDCsTQuMjAlICg4MCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDcsMTA1LDY3MSBvcHMvc2VjIMKxMTMuNDclICg2NCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCA1LDg4Nyw5MTIgb3BzL3NlYyDCsTEuNDYlICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCA2LDQ5MSw2NjEgb3BzL3NlYyDCsTEuNzYlICg3OSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCA2LDU1OSw3OTUgb3BzL3NlYyDCsTEuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCA2LDQ2Myw5NjYgb3BzL3NlYyDCsTEuNDMlICg4NSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCA1LDY0MSw4NDEgb3BzL3NlYyDCsTMuNDklICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCA2LDU4Myw1MTEgb3BzL3NlYyDCsTEuOTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCA2LDYwNiwwNzggb3BzL3NlYyDCsTEuNzQlICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCA2LDYwMiwyMjQgb3BzL3NlYyDCsTEuNzclICg4MyBydW5zIHNhbXBsZWQpXG4gICovXG4gIHZhciBzdHJpbmdUYWcgPSAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICBpZiAodHlwZW9mIHN0cmluZ1RhZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyaW5nVGFnO1xuICB9XG5cbiAgdmFyIG9ialByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDEsNzcyLDM4NSBvcHMvc2VjIMKxMS44NSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDIsMTQzLDYzNCBvcHMvc2VjIMKxMi40NiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMyw5MjgsMDA5IG9wcy9zZWMgwrEwLjY1JSAoNzggcnVucyBzYW1wbGVkKVxuICAqICAgcmVnZXggY29uc3RydWN0b3IgIHggMyw5MzEsMTA4IG9wcy9zZWMgwrEwLjU4JSAoODQgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAob2JqUHJvdG90eXBlID09PSBSZWdFeHAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdSZWdFeHAnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBkYXRlICAgICAgICAgICAgICAgeCAyLDEzMCwwNzQgb3BzL3NlYyDCsTQuNDIlICg2OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIGRhdGUgICAgICAgICAgICAgICB4IDMsOTUzLDc3OSBvcHMvc2VjIMKxMS4zNSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gRGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ0RhdGUnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLXByb21pc2UucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyNS40LjUuNCAtIFByb21pc2UucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlByb21pc2VcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQcm9taXNlLnJlc29sdmUoKSlgYFxuICAgKiAgLSBDaHJvbWUgPD00NyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKiAgLSBFZGdlIDw9MjAgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICogIC0gRmlyZWZveCAyOS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAqICAtIFNhZmFyaSA3LjEtTGF0ZXN0ID09PSBcIltvYmplY3QgUHJvbWlzZV1cIlxuICAgKi9cbiAgaWYgKHByb21pc2VFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBQcm9taXNlLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnUHJvbWlzZSc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIHNldCAgICAgICAgICAgICAgICB4IDIsMjIyLDE4NiBvcHMvc2VjIMKxMS4zMSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgc2V0ICAgICAgICAgICAgICAgIHggNCw1NDUsODc5IG9wcy9zZWMgwrExLjEzJSAoODMgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gU2V0LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU2V0JztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgbWFwICAgICAgICAgICAgICAgIHggMiwzOTYsODQyIG9wcy9zZWMgwrExLjU5JSAoODEgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBtYXAgICAgICAgICAgICAgICAgeCA0LDE4Myw5NDUgb3BzL3NlYyDCsTYuNTklICg4MiBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBNYXAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdNYXAnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICB3ZWFrc2V0ICAgICAgICAgICAgeCAxLDMyMywyMjAgb3BzL3NlYyDCsTIuMTclICg3NiBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHdlYWtzZXQgICAgICAgICAgICB4IDQsMjM3LDUxMCBvcHMvc2VjIMKxMi4wMSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHdlYWtTZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrU2V0LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnV2Vha1NldCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIHdlYWttYXAgICAgICAgICAgICB4IDEsNTAwLDI2MCBvcHMvc2VjIMKxMi4wMiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgd2Vha21hcCAgICAgICAgICAgIHggMyw4ODEsMzg0IG9wcy9zZWMgwrExLjQ1JSAoODIgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAod2Vha01hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtNYXAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdXZWFrTWFwJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1kYXRhdmlldy5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDI0LjIuNC4yMSAtIERhdGFWaWV3LnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJEYXRhVmlld1wiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKWBgXG4gICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKi9cbiAgaWYgKGRhdGFWaWV3RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdEYXRhVmlldyc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJW1hcGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjMuMS41LjIuMiAtICVNYXBJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiTWFwIEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpLmVudHJpZXMoKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBtYXBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnTWFwIEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc2V0aXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMy4yLjUuMi4yIC0gJVNldEl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTZXQgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgU2V0KCkuZW50cmllcygpKWBgXG4gICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKi9cbiAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHNldEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdTZXQgSXRlcmF0b3InO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjIuMS41LjIuMiAtICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJBcnJheSBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChhcnJheUl0ZXJhdG9yRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gYXJyYXlJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnQXJyYXkgSXRlcmF0b3InO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIxLjEuNS4yLjIgLSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlN0cmluZyBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdTdHJpbmcgSXRlcmF0b3InO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBvYmplY3QgZnJvbSBudWxsICAgeCAyLDQyNCwzMjAgb3BzL3NlYyDCsTEuNjclICg3NiBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIG9iamVjdCBmcm9tIG51bGwgICB4IDUsODM4LDAwMCBvcHMvc2VjIMKxMC45OSUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxuXG4gIHJldHVybiBPYmplY3RcbiAgICAucHJvdG90eXBlXG4gICAgLnRvU3RyaW5nXG4gICAgLmNhbGwob2JqKVxuICAgIC5zbGljZSh0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCwgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnR5cGVEZXRlY3QgPSBtb2R1bGUuZXhwb3J0cztcbiIsIi8qIVxuICogQ2hhaSAtIGV4cGVjdFR5cGVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZXhwZWN0VHlwZXMob2JqLCB0eXBlcylcbiAqXG4gKiBFbnN1cmVzIHRoYXQgdGhlIG9iamVjdCBiZWluZyB0ZXN0ZWQgYWdhaW5zdCBpcyBvZiBhIHZhbGlkIHR5cGUuXG4gKlxuICogICAgIHV0aWxzLmV4cGVjdFR5cGVzKHRoaXMsIFsnYXJyYXknLCAnb2JqZWN0JywgJ3N0cmluZyddKTtcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmogY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlIEEgbGlzdCBvZiBhbGxvd2VkIHR5cGVzIGZvciB0aGlzIGFzc2VydGlvblxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZXhwZWN0VHlwZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cGVjdFR5cGVzKG9iaiwgdHlwZXMpIHtcbiAgdmFyIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcbiAgdmFyIHNzZmkgPSBmbGFnKG9iaiwgJ3NzZmknKTtcblxuICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgb2JqID0gZmxhZyhvYmosICdvYmplY3QnKTtcbiAgdHlwZXMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTsgfSk7XG4gIHR5cGVzLnNvcnQoKTtcblxuICAvLyBUcmFuc2Zvcm1zIFsnbG9yZW0nLCAnaXBzdW0nXSBpbnRvICdhIGxvcmVtLCBvciBhbiBpcHN1bSdcbiAgdmFyIHN0ciA9IHR5cGVzLm1hcChmdW5jdGlvbiAodCwgaW5kZXgpIHtcbiAgICB2YXIgYXJ0ID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHQuY2hhckF0KDApKSA/ICdhbicgOiAnYSc7XG4gICAgdmFyIG9yID0gdHlwZXMubGVuZ3RoID4gMSAmJiBpbmRleCA9PT0gdHlwZXMubGVuZ3RoIC0gMSA/ICdvciAnIDogJyc7XG4gICAgcmV0dXJuIG9yICsgYXJ0ICsgJyAnICsgdDtcbiAgfSkuam9pbignLCAnKTtcblxuICB2YXIgb2JqVHlwZSA9IHR5cGUob2JqKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICghdHlwZXMuc29tZShmdW5jdGlvbiAoZXhwZWN0ZWQpIHsgcmV0dXJuIG9ialR5cGUgPT09IGV4cGVjdGVkOyB9KSkge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgIGZsYWdNc2cgKyAnb2JqZWN0IHRlc3RlZCBtdXN0IGJlICcgKyBzdHIgKyAnLCBidXQgJyArIG9ialR5cGUgKyAnIGdpdmVuJyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHNzZmlcbiAgICApO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0QWN0dWFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0QWN0dWFsKG9iamVjdCwgW2FjdHVhbF0pXG4gKlxuICogUmV0dXJucyB0aGUgYGFjdHVhbGAgdmFsdWUgZm9yIGFuIEFzc2VydGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldEFjdHVhbFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QWN0dWFsKG9iaiwgYXJncykge1xuICByZXR1cm4gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IG9iai5fb2JqO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogIVxuICogQ2hhaSAtIGdldEZ1bmNOYW1lIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RnVuY05hbWUoY29uc3RydWN0b3JGbilcbiAqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24uXG4gKiBXaGVuIGEgbm9uLWZ1bmN0aW9uIGluc3RhbmNlIGlzIHBhc3NlZCwgcmV0dXJucyBgbnVsbGAuXG4gKiBUaGlzIGFsc28gaW5jbHVkZXMgYSBwb2x5ZmlsbCBmdW5jdGlvbiBpZiBgYUZ1bmMubmFtZWAgaXMgbm90IGRlZmluZWQuXG4gKlxuICogQG5hbWUgZ2V0RnVuY05hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciB0b1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jdGlvbk5hbWVNYXRjaCA9IC9cXHMqZnVuY3Rpb24oPzpcXHN8XFxzKlxcL1xcKlteKD86KlxcLyldK1xcKlxcL1xccyopKihbXlxcc1xcKFxcL10rKS87XG5mdW5jdGlvbiBnZXRGdW5jTmFtZShhRnVuYykge1xuICBpZiAodHlwZW9mIGFGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbmFtZSA9ICcnO1xuICBpZiAodHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYUZ1bmMubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBIZXJlIHdlIHJ1biBhIHBvbHlmaWxsIGlmIEZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSBhbmQgaWYgYUZ1bmMubmFtZSBpcyBub3QgZGVmaW5lZFxuICAgIHZhciBtYXRjaCA9IHRvU3RyaW5nLmNhbGwoYUZ1bmMpLm1hdGNoKGZ1bmN0aW9uTmFtZU1hdGNoKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UndmUgZ290IGEgYG5hbWVgIHByb3BlcnR5IHdlIGp1c3QgdXNlIGl0XG4gICAgbmFtZSA9IGFGdW5jLm5hbWU7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRGdW5jTmFtZTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCwgZW51bWVyYWJsZSBvciBub3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIHdoaWxlIChwcm90byAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGFkZFByb3BlcnR5KTtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLmluY2x1ZGVTdGFja1xuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIHN0YWNrIHRyYWNlXG4gICAqIGlzIGluY2x1ZGVkIGluIEFzc2VydGlvbiBlcnJvciBtZXNzYWdlLiBEZWZhdWx0IG9mIGZhbHNlXG4gICAqIHN1cHByZXNzZXMgc3RhY2sgdHJhY2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgPSB0cnVlOyAgLy8gZW5hYmxlIHN0YWNrIG9uIGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgaW5jbHVkZVN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5zaG93RGlmZlxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYHNob3dEaWZmYCBmbGFnIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdGhyb3duXG4gICAqIEFzc2VydGlvbkVycm9ycy4gYGZhbHNlYCB3aWxsIGFsd2F5cyBiZSBgZmFsc2VgOyBgdHJ1ZWBcbiAgICogd2lsbCBiZSB0cnVlIHdoZW4gdGhlIGFzc2VydGlvbiBoYXMgcmVxdWVzdGVkIGEgZGlmZlxuICAgKiBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzaG93RGlmZjogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZFxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgc2V0cyBsZW5ndGggdGhyZXNob2xkIGZvciBhY3R1YWwgYW5kXG4gICAqIGV4cGVjdGVkIHZhbHVlcyBpbiBhc3NlcnRpb24gZXJyb3JzLiBJZiB0aGlzIHRocmVzaG9sZCBpcyBleGNlZWRlZCwgZm9yXG4gICAqIGV4YW1wbGUgZm9yIGxhcmdlIGRhdGEgc3RydWN0dXJlcywgdGhlIHZhbHVlIGlzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nXG4gICAqIGxpa2UgYFsgQXJyYXkoMykgXWAgb3IgYHsgT2JqZWN0IChwcm9wMSwgcHJvcDIpIH1gLlxuICAgKlxuICAgKiBTZXQgaXQgdG8gemVybyBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRydW5jYXRpbmcgYWx0b2dldGhlci5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IHVzZXJmdWwgd2hlbiBkb2luZyBhc3NlcnRpb25zIG9uIGFycmF5czogaGF2aW5nIHRoaXNcbiAgICogc2V0IHRvIGEgcmVhc29uYWJsZSBsYXJnZSB2YWx1ZSBtYWtlcyB0aGUgZmFpbHVyZSBtZXNzYWdlcyByZWFkaWx5XG4gICAqIGluc3BlY3RhYmxlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgPSAwOyAgLy8gZGlzYWJsZSB0cnVuY2F0aW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB0cnVuY2F0ZVRocmVzaG9sZDogNDAsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcudXNlUHJveHlcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGRlZmluZXMgaWYgY2hhaSB3aWxsIHVzZSBhIFByb3h5IHRvIHRocm93XG4gICAqIGFuIGVycm9yIHdoZW4gYSBub24tZXhpc3RlbnQgcHJvcGVydHkgaXMgcmVhZCwgd2hpY2ggcHJvdGVjdHMgdXNlcnNcbiAgICogZnJvbSB0eXBvcyB3aGVuIHVzaW5nIHByb3BlcnR5LWJhc2VkIGFzc2VydGlvbnMuXG4gICAqXG4gICAqIFNldCBpdCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRoaXMgZmVhdHVyZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLnVzZVByb3h5ID0gZmFsc2U7ICAvLyBkaXNhYmxlIHVzZSBvZiBQcm94eVxuICAgKlxuICAgKiBUaGlzIGZlYXR1cmUgaXMgYXV0b21hdGljYWxseSBkaXNhYmxlZCByZWdhcmRsZXNzIG9mIHRoaXMgY29uZmlnIHZhbHVlXG4gICAqIGluIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgcHJveGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB1c2VQcm94eTogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5wcm94eUV4Y2x1ZGVkS2V5c1xuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgZGVmaW5lcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAqIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IgaWYgdGhleSBkbyBub3QgZXhpc3Qgb24gdGhlIGFzc2VydGlvbi5cbiAgICogVGhpcyBpcyBvbmx5IGFwcGxpZWQgaWYgdGhlIGVudmlyb25tZW50IENoYWkgaXMgcnVubmluZyBpbiBzdXBwb3J0cyBwcm94aWVzIGFuZFxuICAgKiBpZiB0aGUgYHVzZVByb3h5YCBjb25maWd1cmF0aW9uIHNldHRpbmcgaXMgZW5hYmxlZC5cbiAgICogQnkgZGVmYXVsdCwgYHRoZW5gIGFuZCBgaW5zcGVjdGAgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgdGhleSBkbyBub3QgZXhpc3Qgb24gdGhlXG4gICAqIGFzc2VydGlvbiBvYmplY3QgYmVjYXVzZSB0aGUgYC5pbnNwZWN0YCBwcm9wZXJ0eSBpcyByZWFkIGJ5IGB1dGlsLmluc3BlY3RgIChmb3IgZXhhbXBsZSwgd2hlblxuICAgKiB1c2luZyBgY29uc29sZS5sb2dgIG9uIHRoZSBhc3NlcnRpb24gb2JqZWN0KSBhbmQgYC50aGVuYCBpcyBuZWNlc3NhcnkgZm9yIHByb21pc2UgdHlwZS1jaGVja2luZy5cbiAgICpcbiAgICogICAgIC8vIEJ5IGRlZmF1bHQgdGhlc2Uga2V5cyB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGV5IGRvIG5vdCBleGlzdCBvbiB0aGUgYXNzZXJ0aW9uIG9iamVjdFxuICAgKiAgICAgY2hhaS5jb25maWcucHJveHlFeGNsdWRlZEtleXMgPSBbJ3RoZW4nLCAnaW5zcGVjdCddO1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwcm94eUV4Y2x1ZGVkS2V5czogWyd0aGVuJywgJ2luc3BlY3QnLCAndG9KU09OJ11cbn07XG4iLCIvLyBUaGlzIGlzIChhbG1vc3QpIGRpcmVjdGx5IGZyb20gTm9kZS5qcyB1dGlsc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvZjhjMzM1ZDBjYWY0N2YxNmQzMTQxM2Y4OWFhMjhlZGEzODc4ZTNhYS9saWIvdXRpbC5qc1xuXG52YXIgZ2V0TmFtZSA9IHJlcXVpcmUoJ2dldC1mdW5jLW5hbWUnKTtcbnZhciBnZXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRQcm9wZXJ0aWVzJyk7XG52YXIgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zcGVjdDtcblxuLyoqXG4gKiAjIyMgLmluc3BlY3Qob2JqLCBbc2hvd0hpZGRlbl0sIFtkZXB0aF0sIFtjb2xvcnNdKVxuICpcbiAqIEVjaG9lcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJpZXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0hpZGRlbiBGbGFnIHRoYXQgc2hvd3MgaGlkZGVuIChub3QgZW51bWVyYWJsZSlcbiAqICAgIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBEZXB0aCBpbiB3aGljaCB0byBkZXNjZW5kIGluIG9iamVjdC4gRGVmYXVsdCBpcyAyLlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnMgRmxhZyB0byB0dXJuIG9uIEFOU0kgZXNjYXBlIGNvZGVzIHRvIGNvbG9yIHRoZVxuICogICAgb3V0cHV0LiBEZWZhdWx0IGlzIGZhbHNlIChubyBjb2xvcmluZykuXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBpbnNwZWN0XG4gKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBjdHggPSB7XG4gICAgc2hvd0hpZGRlbjogc2hvd0hpZGRlbixcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHI7IH1cbiAgfTtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuXG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgJ25vZGVUeXBlJyBpbiBvYmplY3QgJiZcbiAgICAgIG9iamVjdC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gSWYgdGhpcyBpcyBhIERPTSBlbGVtZW50LCB0cnkgdG8gZ2V0IHRoZSBvdXRlciBIVE1MLlxuICBpZiAoaXNET01FbGVtZW50KHZhbHVlKSkge1xuICAgIGlmICgnb3V0ZXJIVE1MJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm91dGVySFRNTDtcbiAgICAgIC8vIFRoaXMgdmFsdWUgZG9lcyBub3QgaGF2ZSBhbiBvdXRlckhUTUwgYXR0cmlidXRlLFxuICAgICAgLy8gICBpdCBjb3VsZCBzdGlsbCBiZSBhbiBYTUwgZWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIHNlcmlhbGl6ZSBpdFxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnhtbFZlcnNpb24pIHtcbiAgICAgICAgICB2YXIgeG1sU2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XG4gICAgICAgICAgcmV0dXJuIHhtbFNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpcmVmb3ggMTEtIGRvIG5vdCBzdXBwb3J0IG91dGVySFRNTFxuICAgICAgICAgIC8vICAgSXQgZG9lcywgaG93ZXZlciwgc3VwcG9ydCBpbm5lckhUTUxcbiAgICAgICAgICAvLyAgIFVzZSB0aGUgZm9sbG93aW5nIHRvIHJlbmRlciB0aGUgZWxlbWVudFxuICAgICAgICAgIHZhciBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdfJyk7XG5cbiAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmFsdWUuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgICAgdmFyIGh0bWwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICAgICAgICAucmVwbGFjZSgnPjwnLCAnPicgKyB2YWx1ZS5pbm5lckhUTUwgKyAnPCcpO1xuICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYSBub24tbmF0aXZlIERPTSBpbXBsZW1lbnRhdGlvbixcbiAgICAgICAgLy8gICBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgZmxvdzpcbiAgICAgICAgLy8gICBwcmludGluZyB0aGUgZWxlbWVudCBhcyBpZiBpdCBpcyBhbiBvYmplY3QuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIgdmlzaWJsZUtleXMgPSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyh2YWx1ZSk7XG4gIHZhciBrZXlzID0gY3R4LnNob3dIaWRkZW4gPyBnZXRQcm9wZXJ0aWVzKHZhbHVlKSA6IHZpc2libGVLZXlzO1xuXG4gIHZhciBuYW1lLCBuYW1lU3VmZml4O1xuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgLy8gSW4gSUUsIGVycm9ycyBoYXZlIGEgc2luZ2xlIGBzdGFja2AgcHJvcGVydHksIG9yIGlmIHRoZXkgYXJlIHZhbmlsbGEgYEVycm9yYCxcbiAgLy8gYSBgc3RhY2tgIHBsdXMgYGRlc2NyaXB0aW9uYCBwcm9wZXJ0eTsgaWdub3JlIHRob3NlIGZvciBjb25zaXN0ZW5jeS5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IChpc0Vycm9yKHZhbHVlKSAmJiAoXG4gICAgICAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ3N0YWNrJykgfHxcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMiAmJiBrZXlzWzBdID09PSAnZGVzY3JpcHRpb24nICYmIGtleXNbMV0gPT09ICdzdGFjaycpXG4gICAgICkpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgICAgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJydcbiAgICAsIGFycmF5ID0gZmFsc2VcbiAgICAsIHR5cGVkQXJyYXkgPSBmYWxzZVxuICAgICwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICBpZiAoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgIHR5cGVkQXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2UgaWYgKHR5cGVkQXJyYXkpIHtcbiAgICByZXR1cm4gZm9ybWF0VHlwZWRBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAodmFsdWUgPT09IDAgJiYgKDEvdmFsdWUpID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCctMCcsICdudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSh2YWx1ZS50b1N0cmluZygpLCAnc3ltYm9sJyk7XG4gIH1cbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHZhciBzdHIgPSAnWyAnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA+PSBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgLSA3KSB7XG4gICAgICBzdHIgKz0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RyICs9IHZhbHVlW2ldICsgJywgJztcbiAgfVxuICBzdHIgKz0gJyBdJztcblxuICAvLyBSZW1vdmluZyB0cmFpbGluZyBgLCBgIGlmIHRoZSBhcnJheSB3YXMgbm90IHRydW5jYXRlZFxuICBpZiAoc3RyLmluZGV4T2YoJywgIF0nKSAhPT0gLTEpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgnLCAgXScsICcgXScpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZTtcbiAgdmFyIHByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KTtcbiAgdmFyIHN0cjtcblxuICBpZiAocHJvcERlc2NyaXB0b3IpIHtcbiAgICBpZiAocHJvcERlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICBpZiAocHJvcERlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BEZXNjcmlwdG9yLnNldCkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlzaWJsZUtleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KGFyKSB7XG4gIC8vIFVuZm9ydHVuYXRlbHkgdGhlcmUncyBubyB3YXkgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgVHlwZWRBcnJheVxuICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGl0J3Mgb25lIG9mIHRoZXNlIHR5cGVzXG4gIHJldHVybiAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiAvXFx3K0FycmF5XSQvLnRlc3Qob2JqZWN0VG9TdHJpbmcoYXIpKSk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhhcikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gdHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gdHlwZW9mIGQgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAub2JqRGlzcGxheShvYmplY3QpXG4gKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgbWF0Y2hlc1xuICogY3JpdGVyaWEgdG8gYmUgaW5zcGVjdGVkIGluLWxpbmUgZm9yIGVycm9yXG4gKiBtZXNzYWdlcyBvciBzaG91bGQgYmUgdHJ1bmNhdGVkLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGphdmFzY3JpcHQgb2JqZWN0IHRvIGluc3BlY3RcbiAqIEBuYW1lIG9iakRpc3BsYXlcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvYmpEaXNwbGF5KG9iaikge1xuICB2YXIgc3RyID0gaW5zcGVjdChvYmopXG4gICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgaWYgKGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCAmJiBzdHIubGVuZ3RoID49IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCkge1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICByZXR1cm4gIW9iai5uYW1lIHx8IG9iai5uYW1lID09PSAnJ1xuICAgICAgICA/ICdbRnVuY3Rpb25dJ1xuICAgICAgICA6ICdbRnVuY3Rpb246ICcgKyBvYmoubmFtZSArICddJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybiAnWyBBcnJheSgnICsgb2JqLmxlbmd0aCArICcpIF0nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAsIGtzdHIgPSBrZXlzLmxlbmd0aCA+IDJcbiAgICAgICAgICA/IGtleXMuc3BsaWNlKDAsIDIpLmpvaW4oJywgJykgKyAnLCAuLi4nXG4gICAgICAgICAgOiBrZXlzLmpvaW4oJywgJyk7XG4gICAgICByZXR1cm4gJ3sgT2JqZWN0ICgnICsga3N0ciArICcpIH0nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gbWVzc2FnZSBjb21wb3NpdGlvbiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKVxuICAsIGdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJylcbiAgLCBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0JylcbiAgLCBvYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKG9iamVjdCwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSlcbiAqXG4gKiBDb25zdHJ1Y3QgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZmxhZ3NcbiAqIGFuZCB0ZW1wbGF0ZSB0YWdzLiBUZW1wbGF0ZSB0YWdzIHdpbGwgcmV0dXJuXG4gKiBhIHN0cmluZ2lmaWVkIGluc3BlY3Rpb24gb2YgdGhlIG9iamVjdCByZWZlcmVuY2VkLlxuICpcbiAqIE1lc3NhZ2UgdGVtcGxhdGUgdGFnczpcbiAqIC0gYCN7dGhpc31gIGN1cnJlbnQgYXNzZXJ0ZWQgb2JqZWN0XG4gKiAtIGAje2FjdH1gIGFjdHVhbCB2YWx1ZVxuICogLSBgI3tleHB9YCBleHBlY3RlZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE1lc3NhZ2Uob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCB2YWwgPSBmbGFnKG9iaiwgJ29iamVjdCcpXG4gICAgLCBleHBlY3RlZCA9IGFyZ3NbM11cbiAgICAsIGFjdHVhbCA9IGdldEFjdHVhbChvYmosIGFyZ3MpXG4gICAgLCBtc2cgPSBuZWdhdGUgPyBhcmdzWzJdIDogYXJnc1sxXVxuICAgICwgZmxhZ01zZyA9IGZsYWcob2JqLCAnbWVzc2FnZScpO1xuXG4gIGlmKHR5cGVvZiBtc2cgPT09IFwiZnVuY3Rpb25cIikgbXNnID0gbXNnKCk7XG4gIG1zZyA9IG1zZyB8fCAnJztcbiAgbXNnID0gbXNnXG4gICAgLnJlcGxhY2UoLyNcXHt0aGlzXFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkodmFsKTsgfSlcbiAgICAucmVwbGFjZSgvI1xce2FjdFxcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KGFjdHVhbCk7IH0pXG4gICAgLnJlcGxhY2UoLyNcXHtleHBcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheShleHBlY3RlZCk7IH0pO1xuXG4gIHJldHVybiBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgKyBtc2cgOiBtc2c7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHJhbnNmZXJGbGFncyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwgPSB0cnVlKVxuICpcbiAqIFRyYW5zZmVyIGFsbCB0aGUgZmxhZ3MgZm9yIGBhc3NlcnRpb25gIHRvIGBvYmplY3RgLiBJZlxuICogYGluY2x1ZGVBbGxgIGlzIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBiYXNlIENoYWlcbiAqIGFzc2VydGlvbiBmbGFncyAobmFtZWx5IGBvYmplY3RgLCBgc3NmaWAsIGBsb2NrU3NmaWAsXG4gKiBhbmQgYG1lc3NhZ2VgKSB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZC5cbiAqXG4gKlxuICogICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKCk7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG5ld0Fzc2VydGlvbik7XG4gKlxuICogICAgIHZhciBhbm90aGVyQXNzZXJpdG9uID0gbmV3IEFzc2VydGlvbihteU9iaik7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIGFub3RoZXJBc3NlcnRpb24sIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Fzc2VydGlvbn0gYXNzZXJ0aW9uIHRoZSBhc3NlcnRpb24gdG8gdHJhbnNmZXIgdGhlIGZsYWdzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgdG87IHVzdWFsbHkgYSBuZXcgYXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRyYW5zZmVyRmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCkge1xuICB2YXIgZmxhZ3MgPSBhc3NlcnRpb24uX19mbGFncyB8fCAoYXNzZXJ0aW9uLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICBpZiAoIW9iamVjdC5fX2ZsYWdzKSB7XG4gICAgb2JqZWN0Ll9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaW5jbHVkZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBpbmNsdWRlQWxsIDogdHJ1ZTtcblxuICBmb3IgKHZhciBmbGFnIGluIGZsYWdzKSB7XG4gICAgaWYgKGluY2x1ZGVBbGwgfHxcbiAgICAgICAgKGZsYWcgIT09ICdvYmplY3QnICYmIGZsYWcgIT09ICdzc2ZpJyAmJiBmbGFnICE9PSAnbG9ja1NzZmknICYmIGZsYWcgIT0gJ21lc3NhZ2UnKSkge1xuICAgICAgb2JqZWN0Ll9fZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWxzIFN5bWJvbDogZmFsc2UsIFVpbnQ4QXJyYXk6IGZhbHNlLCBXZWFrTWFwOiBmYWxzZSAqL1xuLyohXG4gKiBkZWVwLWVxbFxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5mdW5jdGlvbiBGYWtlTWFwKCkge1xuICB0aGlzLl9rZXkgPSAnY2hhaS9kZWVwLWVxbF9fJyArIE1hdGgucmFuZG9tKCkgKyBEYXRlLm5vdygpO1xufVxuXG5GYWtlTWFwLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXRNYXAoa2V5KSB7XG4gICAgcmV0dXJuIGtleVt0aGlzLl9rZXldO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldE1hcChrZXksIHZhbHVlKSB7XG4gICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGtleSwgdGhpcy5fa2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIE1lbW9pemVNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBGYWtlTWFwO1xuLyohXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIE1lbW9pemVNYXAgaGFzIHJlY29yZGVkIGEgcmVzdWx0IG9mIHRoZSB0d28gb3BlcmFuZHNcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWVtb2l6ZU1hcH0gbWVtb2l6ZU1hcFxuICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwKSB7XG4gIC8vIFRlY2huaWNhbGx5LCBXZWFrTWFwIGtleXMgY2FuICpvbmx5KiBiZSBvYmplY3RzLCBub3QgcHJpbWl0aXZlcy5cbiAgaWYgKCFtZW1vaXplTWFwIHx8IGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICB2YXIgcmVzdWx0ID0gbGVmdEhhbmRNYXAuZ2V0KHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFNldCB0aGUgcmVzdWx0IG9mIHRoZSBlcXVhbGl0eSBpbnRvIHRoZSBNZW1vaXplTWFwXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG1lbW9pemVNYXAsIHJlc3VsdCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsZWZ0SGFuZE1hcCA9IG1lbW9pemVNYXAuZ2V0KGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZE1hcCkge1xuICAgIGxlZnRIYW5kTWFwLnNldChyaWdodEhhbmRPcGVyYW5kLCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIGxlZnRIYW5kTWFwID0gbmV3IE1lbW9pemVNYXAoKTtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgICBtZW1vaXplTWFwLnNldChsZWZ0SGFuZE9wZXJhbmQsIGxlZnRIYW5kTWFwKTtcbiAgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5tb2R1bGUuZXhwb3J0cy5NZW1vaXplTWFwID0gTWVtb2l6ZU1hcDtcblxuLyoqXG4gKiBBc3NlcnQgZGVlcGx5IG5lc3RlZCBzYW1lVmFsdWUgZXF1YWxpdHkgYmV0d2VlbiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElmIHdlIGhhdmUgYSBjb21wYXJhdG9yLCB3ZSBjYW4ndCBhc3N1bWUgYW55dGhpbmc7IHNvIGJhaWwgdG8gaXRzIGNoZWNrIGZpcnN0LlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKHNpbXBsZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gIH1cblxuICAvLyBEZWVwZXIgY29tcGFyaXNvbnMgYXJlIHB1c2hlZCB0aHJvdWdoIHRvIGEgbGFyZ2VyIGZ1bmN0aW9uXG4gIHJldHVybiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBNYW55IGNvbXBhcmlzb25zIGNhbiBiZSBjYW5jZWxlZCBvdXQgZWFybHkgdmlhIHNpbXBsZSBlcXVhbGl0eSBvciBwcmltaXRpdmUgY2hlY2tzLlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufG51bGx9IGVxdWFsIG1hdGNoXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCkge1xuICAvLyBFcXVhbCByZWZlcmVuY2VzIChleGNlcHQgZm9yIE51bWJlcnMpIGNhbiBiZSByZXR1cm5lZCBlYXJseVxuICBpZiAobGVmdEhhbmRPcGVyYW5kID09PSByaWdodEhhbmRPcGVyYW5kKSB7XG4gICAgLy8gSGFuZGxlICstMCBjYXNlc1xuICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgIT09IDAgfHwgMSAvIGxlZnRIYW5kT3BlcmFuZCA9PT0gMSAvIHJpZ2h0SGFuZE9wZXJhbmQ7XG4gIH1cblxuICAvLyBoYW5kbGUgTmFOIGNhc2VzXG4gIGlmIChcbiAgICBsZWZ0SGFuZE9wZXJhbmQgIT09IGxlZnRIYW5kT3BlcmFuZCAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJpZ2h0SGFuZE9wZXJhbmQgIT09IHJpZ2h0SGFuZE9wZXJhbmQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBBbnl0aGluZyB0aGF0IGlzIG5vdCBhbiAnb2JqZWN0JywgaS5lLiBzeW1ib2xzLCBmdW5jdGlvbnMsIGJvb2xlYW5zLCBudW1iZXJzLFxuICAvLyBzdHJpbmdzLCBhbmQgdW5kZWZpbmVkLCBjYW4gYmUgY29tcGFyZWQgYnkgcmVmZXJlbmNlLlxuICBpZiAoaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIC8vIEVhc3kgb3V0IGIvYyBpdCB3b3VsZCBoYXZlIHBhc3NlZCB0aGUgZmlyc3QgZXF1YWxpdHkgY2hlY2tcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogVGhlIG1haW4gbG9naWMgb2YgdGhlIGBkZWVwRXF1YWxgIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY29tcGFyYXRvcl0gKG9wdGlvbmFsKSBPdmVycmlkZSBkZWZhdWx0IGFsZ29yaXRobSwgZGV0ZXJtaW5pbmcgY3VzdG9tIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWVtb2l6ZV0gKG9wdGlvbmFsKSBQcm92aWRlIGEgY3VzdG9tIG1lbW9pemF0aW9uIG9iamVjdCB3aGljaCB3aWxsIGNhY2hlIHRoZSByZXN1bHRzIG9mXG4gICAgY29tcGxleCBvYmplY3RzIGZvciBhIHNwZWVkIGJvb3N0LiBCeSBwYXNzaW5nIGBmYWxzZWAgeW91IGNhbiBkaXNhYmxlIG1lbW9pemF0aW9uLCBidXQgdGhpcyB3aWxsIGNhdXNlIGNpcmN1bGFyXG4gICAgcmVmZXJlbmNlcyB0byBibG93IHRoZSBzdGFjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4qL1xuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5tZW1vaXplID0gb3B0aW9ucy5tZW1vaXplID09PSBmYWxzZSA/IGZhbHNlIDogb3B0aW9ucy5tZW1vaXplIHx8IG5ldyBNZW1vaXplTWFwKCk7XG4gIHZhciBjb21wYXJhdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3I7XG5cbiAgLy8gQ2hlY2sgaWYgYSBtZW1vaXplZCByZXN1bHQgZXhpc3RzLlxuICB2YXIgbWVtb2l6ZVJlc3VsdExlZnQgPSBtZW1vaXplQ29tcGFyZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSk7XG4gIGlmIChtZW1vaXplUmVzdWx0TGVmdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0TGVmdDtcbiAgfVxuICB2YXIgbWVtb2l6ZVJlc3VsdFJpZ2h0ID0gbWVtb2l6ZUNvbXBhcmUocmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdFJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1lbW9pemVSZXN1bHRSaWdodDtcbiAgfVxuXG4gIC8vIElmIGEgY29tcGFyYXRvciBpcyBwcmVzZW50LCB1c2UgaXQuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JSZXN1bHQgPSBjb21wYXJhdG9yKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgLy8gQ29tcGFyYXRvcnMgbWF5IHJldHVybiBudWxsLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gZ28gYmFjayB0byBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIGlmIChjb21wYXJhdG9yUmVzdWx0ID09PSBmYWxzZSB8fCBjb21wYXJhdG9yUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBjb21wYXJhdG9yUmVzdWx0KTtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yUmVzdWx0O1xuICAgIH1cbiAgICAvLyBUbyBhbGxvdyBjb21wYXJhdG9ycyB0byBvdmVycmlkZSAqYW55KiBiZWhhdmlvciwgd2UgcmFuIHRoZW0gZmlyc3QuIFNpbmNlIGl0IGRpZG4ndCBkZWNpZGVcbiAgICAvLyB3aGF0IHRvIGRvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byByZXR1cm4gdGhlIGJhc2ljIHRlc3RzIGZpcnN0IGJlZm9yZSB3ZSBtb3ZlIG9uLlxuICAgIHZhciBzaW1wbGVSZXN1bHQgPSBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IG1lbW9pemUgdGhpcywgaXQgdGFrZXMgbG9uZ2VyIHRvIHNldC9yZXRyaWV2ZSB0aGFuIHRvIGp1c3QgY29tcGFyZS5cbiAgICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlZnRIYW5kVHlwZSA9IHR5cGUobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kVHlwZSAhPT0gdHlwZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZW1wb3JhcmlseSBzZXQgdGhlIG9wZXJhbmRzIGluIHRoZSBtZW1vaXplIG9iamVjdCB0byBwcmV2ZW50IGJsb3dpbmcgdGhlIHN0YWNrXG4gIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIHRydWUpO1xuXG4gIHZhciByZXN1bHQgPSBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpO1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChsZWZ0SGFuZFR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICAvLyBJZiB0aGVzZSB0eXBlcyBhcmUgdGhlaXIgaW5zdGFuY2UgdHlwZXMgKGUuZy4gYG5ldyBOdW1iZXJgKSB0aGVuIHJlLWRlZXBFcXVhbCBhZ2FpbnN0IHRoZWlyIHZhbHVlc1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQudmFsdWVPZigpLCByaWdodEhhbmRPcGVyYW5kLnZhbHVlT2YoKSk7XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgICAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZDtcbiAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOlxuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIHJldHVybiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGNhc2UgJ0dlbmVyYXRvcic6XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdEYXRhVmlldyc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQuYnVmZmVyKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZC5idWZmZXIpLCBvcHRpb25zKTtcbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQpLCBuZXcgVWludDhBcnJheShyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdNYXAnOlxuICAgICAgcmV0dXJuIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7UmVnRXhwfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZC50b1N0cmluZygpID09PSByaWdodEhhbmRPcGVyYW5kLnRvU3RyaW5nKCk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gU2V0cy9NYXBzIGZvciBlcXVhbGl0eS4gRmFzdGVyIHRoYW4gb3RoZXIgZXF1YWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U2V0fSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7U2V0fSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgU2V0I2VudHJpZXMgb3IgU2V0I0BAaXRlcmF0b3IsIHNvIHdlIG5lZWQgbWFudWFsbHkgcG9wdWxhdGUgdXNpbmcgU2V0I2ZvckVhY2hcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplICE9PSByaWdodEhhbmRPcGVyYW5kLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGxlZnRIYW5kSXRlbXMgPSBbXTtcbiAgdmFyIHJpZ2h0SGFuZEl0ZW1zID0gW107XG4gIGxlZnRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIGxlZnRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByaWdodEhhbmRPcGVyYW5kLmZvckVhY2goZnVuY3Rpb24gZ2F0aGVyRW50cmllcyhrZXksIHZhbHVlKSB7XG4gICAgcmlnaHRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZEl0ZW1zLnNvcnQoKSwgcmlnaHRIYW5kSXRlbXMuc29ydCgpLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGZsYXQgaXRlcmFibGUgb2JqZWN0cyBzdWNoIGFzIEFycmF5cywgVHlwZWRBcnJheXMgb3IgTm9kZS5qcyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtJdGVyYWJsZX0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0gbGVmdEhhbmRPcGVyYW5kLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAhPT0gcmlnaHRIYW5kT3BlcmFuZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2luZGV4XSwgcmlnaHRIYW5kT3BlcmFuZFtpbmRleF0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGdlbmVyYXRvciBvYmplY3RzIHN1Y2ggYXMgdGhvc2UgcmV0dXJuZWQgYnkgZ2VuZXJhdG9yIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGdldEdlbmVyYXRvckVudHJpZXMobGVmdEhhbmRPcGVyYW5kKSwgZ2V0R2VuZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qIVxuICogR2V0cyBhbGwgaXRlcmF0b3IgZW50cmllcyBmcm9tIHRoZSBnaXZlbiBPYmplY3QuIElmIHRoZSBPYmplY3QgaGFzIG5vIEBAaXRlcmF0b3IgZnVuY3Rpb24sIHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXG4gKiBUaGlzIHdpbGwgY29uc3VtZSB0aGUgaXRlcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cyBkZXBlbmRpbmcgb24gdGhlIEBAaXRlcmF0b3IgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBlbnRyaWVzIGZyb20gdGhlIEBAaXRlcmF0b3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JFbnRyaWVzKHRhcmdldCkge1xuICBpZiAoaGFzSXRlcmF0b3JGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXRHZW5lcmF0b3JFbnRyaWVzKHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgIH0gY2F0Y2ggKGl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGVudHJpZXMgZnJvbSBhIEdlbmVyYXRvci4gVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGdlbmVyYXRvciAtIHdoaWNoIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzLlxuICpcbiAqIEBwYXJhbSB7R2VuZXJhdG9yfSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBHZW5lcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEdlbmVyYXRvckVudHJpZXMoZ2VuZXJhdG9yKSB7XG4gIHZhciBnZW5lcmF0b3JSZXN1bHQgPSBnZW5lcmF0b3IubmV4dCgpO1xuICB2YXIgYWNjdW11bGF0b3IgPSBbIGdlbmVyYXRvclJlc3VsdC52YWx1ZSBdO1xuICB3aGlsZSAoZ2VuZXJhdG9yUmVzdWx0LmRvbmUgPT09IGZhbHNlKSB7XG4gICAgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgICBhY2N1bXVsYXRvci5wdXNoKGdlbmVyYXRvclJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIGEgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBrZXlzIGZyb20gdGhlIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZUtleXModGFyZ2V0KSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuLyohXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBvYmplY3RzIGhhdmUgbWF0Y2hpbmcgdmFsdWVzLCBnaXZlbiBhIHNldCBvZiBrZXlzLiBEZWZlcnMgdG8gZGVlcEVxdWFsIGZvciB0aGUgZXF1YWxpdHkgY2hlY2sgb2ZcbiAqIGVhY2gga2V5LiBJZiBhbnkgdmFsdWUgb2YgdGhlIGdpdmVuIGtleSBpcyBub3QgZXF1YWwsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZSAoZWFybHkpLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0ga2V5cyBBbiBhcnJheSBvZiBrZXlzIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBvZiBsZWZ0SGFuZE9wZXJhbmQgYW5kIHJpZ2h0SGFuZE9wZXJhbmQgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24ga2V5c0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmRba2V5c1tpXV0sIHJpZ2h0SGFuZE9wZXJhbmRba2V5c1tpXV0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIE9iamVjdHMuIE9uY2UgYmFzaWMgc2FtZW5lc3MgaGFzIGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbCBkZWZlciB0byBgZGVlcEVxdWFsYFxuICogZm9yIGVhY2ggZW51bWVyYWJsZSBrZXkgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHZhciBsZWZ0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kS2V5cyA9IGdldEVudW1lcmFibGVLZXlzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCAmJiBsZWZ0SGFuZEtleXMubGVuZ3RoID09PSByaWdodEhhbmRLZXlzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kS2V5cy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kS2V5cy5zb3J0KCk7XG4gICAgaWYgKGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRLZXlzLCByaWdodEhhbmRLZXlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kS2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgbGVmdEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCk7XG4gIHZhciByaWdodEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRFbnRyaWVzLmxlbmd0aCAmJiBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSByaWdodEhhbmRFbnRyaWVzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRFbnRyaWVzLCByaWdodEhhbmRFbnRyaWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChsZWZ0SGFuZEtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwICYmXG4gICAgICByaWdodEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyohXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgcHJpbWl0aXZlLlxuICpcbiAqIFRoaXMgaW50ZW50aW9uYWxseSByZXR1cm5zIHRydWUgZm9yIGFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZSxcbiAqIGluY2x1ZGluZyBmdW5jdGlvbnMgYW5kIHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jztcbn1cbiIsInZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyohXG4gKiBDaGFpIC0gaXNQcm94eUVuYWJsZWQgaGVscGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmlzUHJveHlFbmFibGVkKClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgQ2hhaSdzIHByb3h5IHByb3RlY3Rpb24gZmVhdHVyZSBpcyBlbmFibGVkLiBJZlxuICogcHJveGllcyBhcmUgdW5zdXBwb3J0ZWQgb3IgZGlzYWJsZWQgdmlhIHRoZSB1c2VyJ3MgQ2hhaSBjb25maWcsIHRoZW4gcmV0dXJuXG4gKiBmYWxzZS4gT3RoZXJ3aXNlLCByZXR1cm4gdHJ1ZS5cbiAqXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBpc1Byb3h5RW5hYmxlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcm94eUVuYWJsZWQoKSB7XG4gIHJldHVybiBjb25maWcudXNlUHJveHkgJiYgXG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJztcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLmFkZFByb3BlcnR5KGN0eCwgbmFtZSwgZ2V0dGVyKVxuICpcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKCkge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuaW5zdGFuY2VvZihGb28pO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUuZm9vO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRQcm9wZXJ0eShjdHgsIG5hbWUsIGdldHRlcikge1xuICBnZXR0ZXIgPSBnZXR0ZXIgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHt9IDogZ2V0dGVyO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uIHByb3BlcnR5R2V0dGVyKCkge1xuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgcHJvcGVydHlHZXR0ZXJgIGNhdXNlcyB0aGlzIGZ1bmN0aW9uIHRvXG4gICAgICAgIC8vIGJlIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb24gZnJhbWVzIGZyb20gdGhlXG4gICAgICAgIC8vIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZlxuICAgICAgICAvLyB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldCBhbmQgcHJveHkgcHJvdGVjdGlvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gZWl0aGVyIHRoaXMgYXNzZXJ0aW9uIGhhcyBiZWVuXG4gICAgICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkXG4gICAgICAgIC8vIGZyb20gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnXG4gICAgICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdmVyd3JpdGluZyBhc3NlcnRpb24uIEluIHRoZSBzZWNvbmRcbiAgICAgICAgLy8gY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHByb3h5IHByb3RlY3Rpb24gaXMgZW5hYmxlZCwgdGhlbiB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlblxuICAgICAgICAvLyBzZXQgYnkgdGhlIHByb3h5IGdldHRlci5cbiAgICAgICAgaWYgKCFpc1Byb3h5RW5hYmxlZCgpICYmICFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIHByb3BlcnR5R2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG52YXIgZm5MZW5ndGhEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmdW5jdGlvbiAoKSB7fSwgJ2xlbmd0aCcpO1xuXG4vKiFcbiAqIENoYWkgLSBhZGRMZW5ndGhHdWFyZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmFkZExlbmd0aEd1YXJkKGZuLCBhc3NlcnRpb25OYW1lLCBpc0NoYWluYWJsZSlcbiAqXG4gKiBEZWZpbmUgYGxlbmd0aGAgYXMgYSBnZXR0ZXIgb24gdGhlIGdpdmVuIHVuaW52b2tlZCBtZXRob2QgYXNzZXJ0aW9uLiBUaGVcbiAqIGdldHRlciBhY3RzIGFzIGEgZ3VhcmQgYWdhaW5zdCBjaGFpbmluZyBgbGVuZ3RoYCBkaXJlY3RseSBvZmYgb2YgYW4gdW5pbnZva2VkXG4gKiBtZXRob2QgYXNzZXJ0aW9uLCB3aGljaCBpcyBhIHByb2JsZW0gYmVjYXVzZSBpdCByZWZlcmVuY2VzIGBmdW5jdGlvbmAnc1xuICogYnVpbHQtaW4gYGxlbmd0aGAgcHJvcGVydHkgaW5zdGVhZCBvZiBDaGFpJ3MgYGxlbmd0aGAgYXNzZXJ0aW9uLiBXaGVuIHRoZVxuICogZ2V0dGVyIGNhdGNoZXMgdGhlIHVzZXIgbWFraW5nIHRoaXMgbWlzdGFrZSwgaXQgdGhyb3dzIGFuIGVycm9yIHdpdGggYVxuICogaGVscGZ1bCBtZXNzYWdlLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyBpbiB3aGljaCB0aGlzIG1pc3Rha2UgY2FuIGJlIG1hZGUuIFRoZSBmaXJzdCB3YXkgaXMgYnlcbiAqIGNoYWluaW5nIHRoZSBgbGVuZ3RoYCBhc3NlcnRpb24gZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZCBjaGFpbmFibGVcbiAqIG1ldGhvZC4gSW4gdGhpcyBjYXNlLCBDaGFpIHN1Z2dlc3RzIHRoYXQgdGhlIHVzZXIgdXNlIGBsZW5ndGhPZmAgaW5zdGVhZC4gVGhlXG4gKiBzZWNvbmQgd2F5IGlzIGJ5IGNoYWluaW5nIHRoZSBgbGVuZ3RoYCBhc3NlcnRpb24gZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZFxuICogbm9uLWNoYWluYWJsZSBtZXRob2QuIE5vbi1jaGFpbmFibGUgbWV0aG9kcyBtdXN0IGJlIGludm9rZWQgcHJpb3IgdG9cbiAqIGNoYWluaW5nLiBJbiB0aGlzIGNhc2UsIENoYWkgc3VnZ2VzdHMgdGhhdCB0aGUgdXNlciBjb25zdWx0IHRoZSBkb2NzIGZvciB0aGVcbiAqIGdpdmVuIGFzc2VydGlvbi5cbiAqXG4gKiBJZiB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIHVuY29uZmlndXJhYmxlLCB0aGVuIHJldHVybiBgZm5gXG4gKiB3aXRob3V0IG1vZGlmaWNhdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgaW4gRVM2LCB0aGUgZnVuY3Rpb24ncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBjb25maWd1cmFibGUsIHNvIG9uY2VcbiAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgaXMgZHJvcHBlZCwgQ2hhaSdzIGBsZW5ndGhgIHByb3BlcnR5IGNhblxuICogcmVwbGFjZSB0aGUgYnVpbHQtaW4gZnVuY3Rpb24ncyBgbGVuZ3RoYCBwcm9wZXJ0eSwgYW5kIHRoaXMgbGVuZ3RoIGd1YXJkIHdpbGxcbiAqIG5vIGxvbmdlciBiZSBuZWNlc3NhcnkuIEluIHRoZSBtZWFuIHRpbWUsIG1haW50YWluaW5nIGNvbnNpc3RlbmN5IGFjcm9zcyBhbGxcbiAqIGVudmlyb25tZW50cyBpcyB0aGUgcHJpb3JpdHkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhc3NlcnRpb25OYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2hhaW5hYmxlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRMZW5ndGhHdWFyZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkTGVuZ3RoR3VhcmQgKGZuLCBhc3NlcnRpb25OYW1lLCBpc0NoYWluYWJsZSkge1xuICBpZiAoIWZuTGVuZ3RoRGVzYy5jb25maWd1cmFibGUpIHJldHVybiBmbjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdsZW5ndGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNDaGFpbmFibGUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIGFzc2VydGlvbk5hbWUgKyAnLmxlbmd0aC4gRHVlJyArXG4gICAgICAgICAgJyB0byBhIGNvbXBhdGliaWxpdHkgaXNzdWUsIFwibGVuZ3RoXCIgY2Fubm90IGRpcmVjdGx5IGZvbGxvdyBcIicgK1xuICAgICAgICAgIGFzc2VydGlvbk5hbWUgKyAnXCIuIFVzZSBcIicgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGhPZlwiIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGguIFNlZScgK1xuICAgICAgICAnIGRvY3MgZm9yIHByb3BlciB1c2FnZSBvZiBcIicgKyBhc3NlcnRpb25OYW1lICsgJ1wiLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZuO1xufTtcbiIsInZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgZ2V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0UHJvcGVydGllcycpO1xudmFyIGlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xuXG4vKiFcbiAqIENoYWkgLSBwcm94aWZ5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAucHJveGlmeShvYmplY3QpXG4gKlxuICogUmV0dXJuIGEgcHJveHkgb2YgZ2l2ZW4gb2JqZWN0IHRoYXQgdGhyb3dzIGFuIGVycm9yIHdoZW4gYSBub24tZXhpc3RlbnRcbiAqIHByb3BlcnR5IGlzIHJlYWQuIEJ5IGRlZmF1bHQsIHRoZSByb290IGNhdXNlIGlzIGFzc3VtZWQgdG8gYmUgYSBtaXNzcGVsbGVkXG4gKiBwcm9wZXJ0eSwgYW5kIHRodXMgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIG9mZmVyIGEgcmVhc29uYWJsZSBzdWdnZXN0aW9uIGZyb21cbiAqIHRoZSBsaXN0IG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIEhvd2V2ZXIsIGlmIGEgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSBpc1xuICogcHJvdmlkZWQsIHRoZW4gdGhlIHJvb3QgY2F1c2UgaXMgaW5zdGVhZCBhIGZhaWx1cmUgdG8gaW52b2tlIGEgbm9uLWNoYWluYWJsZVxuICogbWV0aG9kIHByaW9yIHRvIHJlYWRpbmcgdGhlIG5vbi1leGlzdGVudCBwcm9wZXJ0eS5cbiAqIFxuICogSWYgcHJveGllcyBhcmUgdW5zdXBwb3J0ZWQgb3IgZGlzYWJsZWQgdmlhIHRoZSB1c2VyJ3MgQ2hhaSBjb25maWcsIHRoZW5cbiAqIHJldHVybiBvYmplY3Qgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IG5vbkNoYWluYWJsZU1ldGhvZE5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHByb3hpZnlcbiAqL1xuXG52YXIgYnVpbHRpbnMgPSBbJ19fZmxhZ3MnLCAnX19tZXRob2RzJywgJ19vYmonLCAnYXNzZXJ0J107XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJveGlmeShvYmosIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1Byb3h5RW5hYmxlZCgpKSByZXR1cm4gb2JqO1xuXG4gIHJldHVybiBuZXcgUHJveHkob2JqLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAvLyBUaGlzIGNoZWNrIGlzIGhlcmUgYmVjYXVzZSB3ZSBzaG91bGQgbm90IHRocm93IGVycm9ycyBvbiBTeW1ib2wgcHJvcGVydGllc1xuICAgICAgLy8gc3VjaCBhcyBgU3ltYm9sLnRvU3RyaW5nVGFnYC5cbiAgICAgIC8vIFRoZSB2YWx1ZXMgZm9yIHdoaWNoIGFuIGVycm9yIHNob3VsZCBiZSB0aHJvd24gY2FuIGJlIGNvbmZpZ3VyZWQgdXNpbmdcbiAgICAgIC8vIHRoZSBgY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzYCBzZXR0aW5nLlxuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICBjb25maWcucHJveHlFeGNsdWRlZEtleXMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xICYmXG4gICAgICAgICAgIVJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHkpKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgbWVzc2FnZSBmb3IgaW52YWxpZCBwcm9wZXJ0eSBhY2Nlc3Mgb2Ygbm9uLWNoYWluYWJsZSBtZXRob2RzLlxuICAgICAgICBpZiAobm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBub25DaGFpbmFibGVNZXRob2ROYW1lICsgJy4nICtcbiAgICAgICAgICAgIHByb3BlcnR5ICsgJy4gU2VlIGRvY3MgZm9yIHByb3BlciB1c2FnZSBvZiBcIicgK1xuICAgICAgICAgICAgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmRlcmVkUHJvcGVydGllcyA9IGdldFByb3BlcnRpZXModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICByZXR1cm4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmXG4gICAgICAgICAgICBidWlsdGlucy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTE7XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdEaXN0YW5jZShwcm9wZXJ0eSwgYSkgLSBzdHJpbmdEaXN0YW5jZShwcm9wZXJ0eSwgYik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChvcmRlcmVkUHJvcGVydGllcy5sZW5ndGggJiZcbiAgICAgICAgICAgIHN0cmluZ0Rpc3RhbmNlKG9yZGVyZWRQcm9wZXJ0aWVzWzBdLCBwcm9wZXJ0eSkgPCA0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIHJlYXNvbmFibHkgY2xvc2UgdG8gYW4gZXhpc3RpbmcgQ2hhaSBwcm9wZXJ0eSxcbiAgICAgICAgICAvLyBzdWdnZXN0IHRoYXQgcHJvcGVydHkgdG8gdGhlIHVzZXIuXG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIHByb3BlcnR5ICtcbiAgICAgICAgICAgICcuIERpZCB5b3UgbWVhbiBcIicgKyBvcmRlcmVkUHJvcGVydGllc1swXSArICdcIj8nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSB0aGlzIHByb3h5IGdldHRlciBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLiBGb3IgcHJvcGVydHlcbiAgICAgIC8vIGFzc2VydGlvbnMsIHRoaXMgcHJldmVudHMgdGhlIHByb3h5IGdldHRlciBmcm9tIHNob3dpbmcgdXAgaW4gdGhlIHN0YWNrXG4gICAgICAvLyB0cmFjZSBzaW5jZSBpdCdzIGludm9rZWQgYmVmb3JlIHRoZSBwcm9wZXJ0eSBnZXR0ZXIuIEZvciBtZXRob2QgYW5kXG4gICAgICAvLyBjaGFpbmFibGUgbWV0aG9kIGFzc2VydGlvbnMsIHRoaXMgZmxhZyB3aWxsIGVuZCB1cCBnZXR0aW5nIGNoYW5nZWQgdG9cbiAgICAgIC8vIHRoZSBtZXRob2Qgd3JhcHBlciwgd2hpY2ggaXMgZ29vZCBzaW5jZSB0aGlzIGZyYW1lIHdpbGwgbm8gbG9uZ2VyIGJlIGluXG4gICAgICAvLyB0aGUgc3RhY2sgb25jZSB0aGUgbWV0aG9kIGlzIGludm9rZWQuIE5vdGUgdGhhdCBDaGFpIGJ1aWx0aW4gYXNzZXJ0aW9uXG4gICAgICAvLyBwcm9wZXJ0aWVzIHN1Y2ggYXMgYF9fZmxhZ3NgIGFyZSBza2lwcGVkIHNpbmNlIHRoaXMgaXMgb25seSBtZWFudCB0b1xuICAgICAgLy8gY2FwdHVyZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgYW4gYXNzZXJ0aW9uLiBUaGlzIHN0ZXAgaXMgYWxzbyBza2lwcGVkXG4gICAgICAvLyBpZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGh1cyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhc3NlcnRpb24gaXNcbiAgICAgIC8vIGJlaW5nIGNhbGxlZCBmcm9tIHdpdGhpbiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhhdCBjYXNlLCB0aGUgYHNzZmlgXG4gICAgICAvLyBmbGFnIGlzIGFscmVhZHkgc2V0IHRvIHRoZSBvdXRlciBhc3NlcnRpb24ncyBzdGFydGluZyBwb2ludC5cbiAgICAgIGlmIChidWlsdGlucy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEgJiYgIWZsYWcodGFyZ2V0LCAnbG9ja1NzZmknKSkge1xuICAgICAgICBmbGFnKHRhcmdldCwgJ3NzZmknLCBwcm94eUdldHRlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiAjIHN0cmluZ0Rpc3RhbmNlKHN0ckEsIHN0ckIpXG4gKiBSZXR1cm4gdGhlIExldmVuc2h0ZWluIGRpc3RhbmNlIGJldHdlZW4gdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyQVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ckJcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHN0cmluZyBkaXN0YW5jZSBiZXR3ZWVuIHN0ckEgYW5kIHN0ckJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ0Rpc3RhbmNlKHN0ckEsIHN0ckIsIG1lbW8pIHtcbiAgaWYgKCFtZW1vKSB7XG4gICAgLy8gYG1lbW9gIGlzIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgYSBjYWNoZSBvZiBkaXN0YW5jZXNcbiAgICAvLyBtZW1vW2ldW2pdIGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHN0ckEuc2xpY2UoMCwgaSkgYW5kXG4gICAgLy8gc3RyQi5zbGljZSgwLCBqKS5cbiAgICBtZW1vID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc3RyQS5sZW5ndGg7IGkrKykge1xuICAgICAgbWVtb1tpXSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbWVtb1tzdHJBLmxlbmd0aF0gfHwgIW1lbW9bc3RyQS5sZW5ndGhdW3N0ckIubGVuZ3RoXSkge1xuICAgIGlmIChzdHJBLmxlbmd0aCA9PT0gMCB8fCBzdHJCLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbWVtb1tzdHJBLmxlbmd0aF1bc3RyQi5sZW5ndGhdID0gTWF0aC5tYXgoc3RyQS5sZW5ndGgsIHN0ckIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVtb1tzdHJBLmxlbmd0aF1bc3RyQi5sZW5ndGhdID0gTWF0aC5taW4oXG4gICAgICAgIHN0cmluZ0Rpc3RhbmNlKHN0ckEuc2xpY2UoMCwgLTEpLCBzdHJCLCBtZW1vKSArIDEsXG4gICAgICAgIHN0cmluZ0Rpc3RhbmNlKHN0ckEsIHN0ckIuc2xpY2UoMCwgLTEpLCBtZW1vKSArIDEsXG4gICAgICAgIHN0cmluZ0Rpc3RhbmNlKHN0ckEuc2xpY2UoMCwgLTEpLCBzdHJCLnNsaWNlKDAsIC0xKSwgbWVtbykgK1xuICAgICAgICAgIChzdHJBLnNsaWNlKC0xKSA9PT0gc3RyQi5zbGljZSgtMSkgPyAwIDogMSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lbW9bc3RyQS5sZW5ndGhdW3N0ckIubGVuZ3RoXTtcbn1cbiIsIi8qIVxuICogQ2hhaSAtIGFkZE1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5hZGRNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZE1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgbWV0aG9kV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgbWV0aG9kV3JhcHBlcmAgY2F1c2VzIHRoaXMgZnVuY3Rpb24gdG8gYmUgdGhlXG4gICAgLy8gc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lcyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZlxuICAgIC8vIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWYgdGhlXG4gICAgLy8gYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldC5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkIGZyb21cbiAgICAvLyBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzXG4gICAgLy8gYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZVxuICAgIC8vIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgaWYgKCFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgbWV0aG9kV3JhcHBlcik7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH07XG5cbiAgYWRkTGVuZ3RoR3VhcmQobWV0aG9kV3JhcHBlciwgbmFtZSwgZmFsc2UpO1xuICBjdHhbbmFtZV0gPSBwcm94aWZ5KG1ldGhvZFdyYXBwZXIsIG5hbWUpO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZVByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgaXNQcm94eUVuYWJsZWQgPSByZXF1aXJlKCcuL2lzUHJveHlFbmFibGVkJyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAub3ZlcndyaXRlUHJvcGVydHkoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBwcm9wZXJ0eSBnZXR0ZXIgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgdmFsdWUuIE11c3QgcmV0dXJuIGZ1bmN0aW9uIHRvIHVzZSBhcyBnZXR0ZXIuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZVByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ29rJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai5uYW1lKS50by5lcXVhbCgnYmFyJyk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5vaztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZVByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb3ZlcndyaXRlUHJvcGVydHkoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgdmFyIF9nZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN0eCwgbmFtZSlcbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGlmIChfZ2V0ICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfZ2V0LmdldClcbiAgICBfc3VwZXIgPSBfZ2V0LmdldFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uIG92ZXJ3cml0aW5nUHJvcGVydHlHZXR0ZXIoKSB7XG4gICAgICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyYCBjYXVzZXMgdGhpc1xuICAgICAgICAvLyBmdW5jdGlvbiB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lc1xuICAgICAgICAvLyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWZcbiAgICAgICAgLy8gdGhlIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQgYW5kIHByb3h5IHByb3RlY3Rpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgICAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZFxuICAgICAgICAvLyBmcm9tIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBgc3NmaWAgZmxhZ1xuICAgICAgICAvLyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kXG4gICAgICAgIC8vIGNhc2UsIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBwcm94eSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQsIHRoZW4gdGhlIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgLy8gc2V0IGJ5IHRoZSBwcm94eSBnZXR0ZXIuXG4gICAgICAgIGlmICghaXNQcm94eUVuYWJsZWQoKSAmJiAhZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHRpbmcgdGhlIGBsb2NrU3NmaWAgZmxhZyB0byBgdHJ1ZWAgcHJldmVudHMgdGhlIG92ZXJ3cml0dGVuXG4gICAgICAgIC8vIGFzc2VydGlvbiBmcm9tIGNoYW5naW5nIHRoZSBgc3NmaWAgZmxhZy4gQnkgdGhpcyBwb2ludCwgdGhlIGBzc2ZpYFxuICAgICAgICAvLyBmbGFnIGlzIGFscmVhZHkgc2V0IHRvIHRoZSBjb3JyZWN0IHN0YXJ0aW5nIHBvaW50IGZvciB0aGlzIGFzc2VydGlvbi5cbiAgICAgICAgdmFyIG9yaWdMb2NrU3NmaSA9IGZsYWcodGhpcywgJ2xvY2tTc2ZpJyk7XG4gICAgICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgdHJ1ZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIoX3N1cGVyKS5jYWxsKHRoaXMpO1xuICAgICAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIG9yaWdMb2NrU3NmaSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgICAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5vdmVyd3JpdGVNZXRob2QoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBtZXRob2QgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgZnVuY3Rpb24uIE11c3QgcmV0dXJuIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkIGZvciBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZXF1YWwnLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLnZhbHVlKS50by5lcXVhbChzdHIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uZXF1YWwoJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJ3cml0ZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgX21ldGhvZCA9IGN0eFtuYW1lXVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfTtcblxuICBpZiAoX21ldGhvZCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX21ldGhvZClcbiAgICBfc3VwZXIgPSBfbWV0aG9kO1xuXG4gIHZhciBvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlcmAgY2F1c2VzIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lcyBmcm9tXG4gICAgLy8gdGhlIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWYgdGhlXG4gICAgLy8gYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldC5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkIGZyb21cbiAgICAvLyBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzXG4gICAgLy8gYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZVxuICAgIC8vIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgaWYgKCFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgb3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyKTtcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIHRoZSBgbG9ja1NzZmlgIGZsYWcgdG8gYHRydWVgIHByZXZlbnRzIHRoZSBvdmVyd3JpdHRlbiBhc3NlcnRpb25cbiAgICAvLyBmcm9tIGNoYW5naW5nIHRoZSBgc3NmaWAgZmxhZy4gQnkgdGhpcyBwb2ludCwgdGhlIGBzc2ZpYCBmbGFnIGlzIGFscmVhZHlcbiAgICAvLyBzZXQgdG8gdGhlIGNvcnJlY3Qgc3RhcnRpbmcgcG9pbnQgZm9yIHRoaXMgYXNzZXJ0aW9uLlxuICAgIHZhciBvcmlnTG9ja1NzZmkgPSBmbGFnKHRoaXMsICdsb2NrU3NmaScpO1xuICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgdHJ1ZSk7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfc3VwZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBvcmlnTG9ja1NzZmkpO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgfVxuXG4gIGFkZExlbmd0aEd1YXJkKG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlciwgbmFtZSwgZmFsc2UpO1xuICBjdHhbbmFtZV0gPSBwcm94aWZ5KG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlciwgbmFtZSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkQ2hhaW5pbmdNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBhZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBwcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIE1vZHVsZSB2YXJpYWJsZXNcbiAqL1xuXG4vLyBDaGVjayB3aGV0aGVyIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIGlzIHN1cHBvcnRlZFxudmFyIGNhblNldFByb3RvdHlwZSA9IHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbic7XG5cbi8vIFdpdGhvdXQgYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgc3VwcG9ydCwgdGhpcyBtb2R1bGUgd2lsbCBuZWVkIHRvIGFkZCBwcm9wZXJ0aWVzIHRvIGEgZnVuY3Rpb24uXG4vLyBIb3dldmVyLCBzb21lIG9mIGZ1bmN0aW9ucycgb3duIHByb3BzIGFyZSBub3QgY29uZmlndXJhYmxlIGFuZCBzaG91bGQgYmUgc2tpcHBlZC5cbnZhciB0ZXN0Rm4gPSBmdW5jdGlvbigpIHt9O1xudmFyIGV4Y2x1ZGVOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3RGbikuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0ZXN0Rm4sIG5hbWUpO1xuXG4gIC8vIE5vdGU6IFBoYW50b21KUyAxLnggaW5jbHVkZXMgYGNhbGxlZWAgYXMgb25lIG9mIGB0ZXN0Rm5gJ3Mgb3duIHByb3BlcnRpZXMsXG4gIC8vIGJ1dCB0aGVuIHJldHVybnMgYHVuZGVmaW5lZGAgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBjYWxsZWVgLiBBcyBhXG4gIC8vIHdvcmthcm91bmQsIHdlIHBlcmZvcm0gYW4gb3RoZXJ3aXNlIHVubmVjZXNzYXJ5IHR5cGUtY2hlY2sgZm9yIGBwcm9wRGVzY2AsXG4gIC8vIGFuZCB0aGVuIGZpbHRlciBpdCBvdXQgaWYgaXQncyBub3QgYW4gb2JqZWN0IGFzIGl0IHNob3VsZCBiZS5cbiAgaWYgKHR5cGVvZiBwcm9wRGVzYyAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuICFwcm9wRGVzYy5jb25maWd1cmFibGU7XG59KTtcblxuLy8gQ2FjaGUgYEZ1bmN0aW9uYCBwcm9wZXJ0aWVzXG52YXIgY2FsbCAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCxcbiAgICBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLyoqXG4gKiAjIyMgLmFkZENoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIGFuIG9iamVjdCwgc3VjaCB0aGF0IHRoZSBtZXRob2QgY2FuIGFsc28gYmUgY2hhaW5lZC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkQ2hhaW5hYmxlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAqXG4gKiBUaGUgcmVzdWx0IGNhbiB0aGVuIGJlIHVzZWQgYXMgYm90aCBhIG1ldGhvZCBhc3NlcnRpb24sIGV4ZWN1dGluZyBib3RoIGBtZXRob2RgIGFuZFxuICogYGNoYWluaW5nQmVoYXZpb3JgLCBvciBhcyBhIGxhbmd1YWdlIGNoYWluLCB3aGljaCBvbmx5IGV4ZWN1dGVzIGBjaGFpbmluZ0JlaGF2aW9yYC5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28uZXF1YWwoJ2ZvbycpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBtZXRob2QgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBgbmFtZWAsIHdoZW4gY2FsbGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkQ2hhaW5hYmxlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkQ2hhaW5hYmxlTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gIGlmICh0eXBlb2YgY2hhaW5pbmdCZWhhdmlvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gIH1cblxuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSB7XG4gICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICwgY2hhaW5pbmdCZWhhdmlvcjogY2hhaW5pbmdCZWhhdmlvclxuICB9O1xuXG4gIC8vIHNhdmUgdGhlIG1ldGhvZHMgc28gd2UgY2FuIG92ZXJ3cml0ZSB0aGVtIGxhdGVyLCBpZiB3ZSBuZWVkIHRvLlxuICBpZiAoIWN0eC5fX21ldGhvZHMpIHtcbiAgICBjdHguX19tZXRob2RzID0ge307XG4gIH1cbiAgY3R4Ll9fbWV0aG9kc1tuYW1lXSA9IGNoYWluYWJsZUJlaGF2aW9yO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uIGNoYWluYWJsZU1ldGhvZEdldHRlcigpIHtcbiAgICAgICAgY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvci5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBjaGFpbmFibGVNZXRob2RXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBjaGFpbmFibGVNZXRob2RXcmFwcGVyYCBjYXVzZXMgdGhpc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAvLyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZlxuICAgICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gdGhpcyBhc3NlcnRpb24gaXMgYmVpbmdcbiAgICAgICAgICAvLyBpbnZva2VkIGZyb20gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGlzIGNhc2UsIHRoZSBgc3NmaWBcbiAgICAgICAgICAvLyBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgb3ZlcndyaXRpbmcgYSBjaGFpbmFibGUgbWV0aG9kIG1lcmVseSByZXBsYWNlcyB0aGUgc2F2ZWRcbiAgICAgICAgICAvLyBtZXRob2RzIGluIGBjdHguX19tZXRob2RzYCBpbnN0ZWFkIG9mIGNvbXBsZXRlbHkgcmVwbGFjaW5nIHRoZVxuICAgICAgICAgIC8vIG92ZXJ3cml0dGVuIGFzc2VydGlvbi4gVGhlcmVmb3JlLCBhbiBvdmVyd3JpdGluZyBhc3NlcnRpb24gd29uJ3RcbiAgICAgICAgICAvLyBzZXQgdGhlIGBzc2ZpYCBvciBgbG9ja1NzZmlgIGZsYWdzLlxuICAgICAgICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGNoYWluYWJsZU1ldGhvZFdyYXBwZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXN1bHQgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExlbmd0aEd1YXJkKGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIG5hbWUsIHRydWUpO1xuXG4gICAgICAgIC8vIFVzZSBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAgIC8vIEluaGVyaXQgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgb2JqZWN0IGJ5IHJlcGxhY2luZyB0aGUgYEZ1bmN0aW9uYCBwcm90b3R5cGVcbiAgICAgICAgICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBgY2FsbGAgYW5kIGBhcHBseWAgbWV0aG9kcyBmcm9tIGBGdW5jdGlvbmBcbiAgICAgICAgICBwcm90b3R5cGUuY2FsbCA9IGNhbGw7XG4gICAgICAgICAgcHJvdG90eXBlLmFwcGx5ID0gYXBwbHk7XG4gICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWRlZmluZSBhbGwgcHJvcGVydGllcyAoc2xvdyEpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhc3NlcnRlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3R4KTtcbiAgICAgICAgICBhc3NlcnRlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGFzc2VydGVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVOYW1lcy5pbmRleE9mKGFzc2VydGVyTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhaW5hYmxlTWV0aG9kV3JhcHBlciwgYXNzZXJ0ZXJOYW1lLCBwZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIGNoYWluYWJsZU1ldGhvZFdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gcHJveGlmeShjaGFpbmFibGVNZXRob2RXcmFwcGVyKTtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBjaGFpbmFibGUgbWV0aG9kXG4gKiBhbmQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBvclxuICogcHJvcGVydHkuICBNdXN0IHJldHVybiBmdW5jdGlvbnMgdG8gYmUgdXNlZCBmb3JcbiAqIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdsZW5ndGhPZicsXG4gKiAgICAgICBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgKTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIC8gcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCAvIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgcHJvcGVydHlcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSBjdHguX19tZXRob2RzW25hbWVdO1xuXG4gIHZhciBfY2hhaW5pbmdCZWhhdmlvciA9IGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3I7XG4gIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiBvdmVyd3JpdGluZ0NoYWluYWJsZU1ldGhvZEdldHRlcigpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2hhaW5pbmdCZWhhdmlvcihfY2hhaW5pbmdCZWhhdmlvcikuY2FsbCh0aGlzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9O1xuXG4gIHZhciBfbWV0aG9kID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kO1xuICBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QgPSBmdW5jdGlvbiBvdmVyd3JpdGluZ0NoYWluYWJsZU1ldGhvZFdyYXBwZXIoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfbWV0aG9kKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH07XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gY29tcGFyZUJ5SW5zcGVjdCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyoqXG4gKiAjIyMgLmNvbXBhcmVCeUluc3BlY3QobWl4ZWQsIG1peGVkKVxuICpcbiAqIFRvIGJlIHVzZWQgYXMgYSBjb21wYXJlRnVuY3Rpb24gd2l0aCBBcnJheS5wcm90b3R5cGUuc29ydC4gQ29tcGFyZXMgZWxlbWVudHNcbiAqIHVzaW5nIGluc3BlY3QgaW5zdGVhZCBvZiBkZWZhdWx0IGJlaGF2aW9yIG9mIHVzaW5nIHRvU3RyaW5nIHNvIHRoYXQgU3ltYm9sc1xuICogYW5kIG9iamVjdHMgd2l0aCBpcnJlZ3VsYXIvbWlzc2luZyB0b1N0cmluZyBjYW4gc3RpbGwgYmUgc29ydGVkIHdpdGhvdXQgYVxuICogVHlwZUVycm9yLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGZpcnN0IGVsZW1lbnQgdG8gY29tcGFyZVxuICogQHBhcmFtIHtNaXhlZH0gc2Vjb25kIGVsZW1lbnQgdG8gY29tcGFyZVxuICogQHJldHVybnMge051bWJlcn0gLTEgaWYgJ2EnIHNob3VsZCBjb21lIGJlZm9yZSAnYic7IG90aGVyd2lzZSAxIFxuICogQG5hbWUgY29tcGFyZUJ5SW5zcGVjdFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbXBhcmVCeUluc3BlY3QoYSwgYikge1xuICByZXR1cm4gaW5zcGVjdChhKSA8IGluc3BlY3QoYikgPyAtMSA6IDE7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZGlyZWN0bHktb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzIG9mIGFuXG4gKiBvYmplY3QuIFRoaXMgZnVuY3Rpb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuICogcmV0dXJucyBib3RoIGVudW1lcmFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9sc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMob2JqKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSkuZW51bWVyYWJsZTtcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzJyk7XG5cbi8qKlxuICogIyMjIC5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBkaXJlY3RseS1vd25lZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBhbiBvYmplY3QuIFRoaXMgZnVuY3Rpb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgT2JqZWN0LmtleXMgb25seVxuICogcmV0dXJucyBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLCBub3QgZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmNvbmNhdChnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogIVxuICogQ2hhaSAtIGNoZWNrRXJyb3IgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5jaGVja0Vycm9yXG4gKlxuICogQ2hlY2tzIHRoYXQgYW4gZXJyb3IgY29uZm9ybXMgdG8gYSBnaXZlbiBzZXQgb2YgY3JpdGVyaWEgYW5kL29yIHJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogIyMjIC5jb21wYXRpYmxlSW5zdGFuY2UodGhyb3duLCBlcnJvckxpa2UpXG4gKlxuICogQ2hlY2tzIGlmIHR3byBpbnN0YW5jZXMgYXJlIGNvbXBhdGlibGUgKHN0cmljdCBlcXVhbCkuXG4gKiBSZXR1cm5zIGZhbHNlIGlmIGVycm9yTGlrZSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRXJyb3IsIGJlY2F1c2UgaW5zdGFuY2VzXG4gKiBjYW4gb25seSBiZSBjb21wYXRpYmxlIGlmIHRoZXkncmUgYm90aCBlcnJvciBpbnN0YW5jZXMuXG4gKlxuICogQG5hbWUgY29tcGF0aWJsZUluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSB0aHJvd24gZXJyb3JcbiAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29tcGF0aWJsZUluc3RhbmNlKHRocm93biwgZXJyb3JMaWtlKSB7XG4gIHJldHVybiBlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciAmJiB0aHJvd24gPT09IGVycm9yTGlrZTtcbn1cblxuLyoqXG4gKiAjIyMgLmNvbXBhdGlibGVDb25zdHJ1Y3Rvcih0aHJvd24sIGVycm9yTGlrZSlcbiAqXG4gKiBDaGVja3MgaWYgdHdvIGNvbnN0cnVjdG9ycyBhcmUgY29tcGF0aWJsZS5cbiAqIFRoaXMgZnVuY3Rpb24gY2FuIHJlY2VpdmUgZWl0aGVyIGFuIGVycm9yIGNvbnN0cnVjdG9yIG9yXG4gKiBhbiBlcnJvciBpbnN0YW5jZSBhcyB0aGUgYGVycm9yTGlrZWAgYXJndW1lbnQuXG4gKiBDb25zdHJ1Y3RvcnMgYXJlIGNvbXBhdGlibGUgaWYgdGhleSdyZSB0aGUgc2FtZSBvciBpZiBvbmUgaXNcbiAqIGFuIGluc3RhbmNlIG9mIGFub3RoZXIuXG4gKlxuICogQG5hbWUgY29tcGF0aWJsZUNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Vycm9yfSB0aHJvd24gZXJyb3JcbiAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29tcGF0aWJsZUNvbnN0cnVjdG9yKHRocm93biwgZXJyb3JMaWtlKSB7XG4gIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIElmIGBlcnJvckxpa2VgIGlzIGFuIGluc3RhbmNlIG9mIGFueSBlcnJvciB3ZSBjb21wYXJlIHRoZWlyIGNvbnN0cnVjdG9yc1xuICAgIHJldHVybiB0aHJvd24uY29uc3RydWN0b3IgPT09IGVycm9yTGlrZS5jb25zdHJ1Y3RvciB8fCB0aHJvd24gaW5zdGFuY2VvZiBlcnJvckxpa2UuY29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoZXJyb3JMaWtlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yIHx8IGVycm9yTGlrZSA9PT0gRXJyb3IpIHtcbiAgICAvLyBJZiBgZXJyb3JMaWtlYCBpcyBhIGNvbnN0cnVjdG9yIHRoYXQgaW5oZXJpdHMgZnJvbSBFcnJvciwgd2UgY29tcGFyZSBgdGhyb3duYCB0byBgZXJyb3JMaWtlYCBkaXJlY3RseVxuICAgIHJldHVybiB0aHJvd24uY29uc3RydWN0b3IgPT09IGVycm9yTGlrZSB8fCB0aHJvd24gaW5zdGFuY2VvZiBlcnJvckxpa2U7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogIyMjIC5jb21wYXRpYmxlTWVzc2FnZSh0aHJvd24sIGVyck1hdGNoZXIpXG4gKlxuICogQ2hlY2tzIGlmIGFuIGVycm9yJ3MgbWVzc2FnZSBpcyBjb21wYXRpYmxlIHdpdGggYSBtYXRjaGVyIChTdHJpbmcgb3IgUmVnRXhwKS5cbiAqIElmIHRoZSBtZXNzYWdlIGNvbnRhaW5zIHRoZSBTdHJpbmcgb3IgcGFzc2VzIHRoZSBSZWdFeHAgdGVzdCxcbiAqIGl0IGlzIGNvbnNpZGVyZWQgY29tcGF0aWJsZS5cbiAqXG4gKiBAbmFtZSBjb21wYXRpYmxlTWVzc2FnZVxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGVyck1hdGNoZXIgdG8gbG9vayBmb3IgaW50byB0aGUgbWVzc2FnZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjb21wYXRpYmxlTWVzc2FnZSh0aHJvd24sIGVyck1hdGNoZXIpIHtcbiAgdmFyIGNvbXBhcmlzb25TdHJpbmcgPSB0eXBlb2YgdGhyb3duID09PSAnc3RyaW5nJyA/IHRocm93biA6IHRocm93bi5tZXNzYWdlO1xuICBpZiAoZXJyTWF0Y2hlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBlcnJNYXRjaGVyLnRlc3QoY29tcGFyaXNvblN0cmluZyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVyck1hdGNoZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbXBhcmlzb25TdHJpbmcuaW5kZXhPZihlcnJNYXRjaGVyKSAhPT0gLTE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0RnVuY3Rpb25OYW1lKGNvbnN0cnVjdG9yRm4pXG4gKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLlxuICogVGhpcyBhbHNvIGluY2x1ZGVzIGEgcG9seWZpbGwgZnVuY3Rpb24gaWYgYGNvbnN0cnVjdG9yRm4ubmFtZWAgaXMgbm90IGRlZmluZWQuXG4gKlxuICogQG5hbWUgZ2V0RnVuY3Rpb25OYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvckZuXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZnVuY3Rpb25OYW1lTWF0Y2ggPSAvXFxzKmZ1bmN0aW9uKD86XFxzfFxccypcXC9cXCpbXig/OipcXC8pXStcXCpcXC9cXHMqKSooW15cXChcXC9dKykvO1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGNvbnN0cnVjdG9yRm4pIHtcbiAgdmFyIG5hbWUgPSAnJztcbiAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvckZuLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSGVyZSB3ZSBydW4gYSBwb2x5ZmlsbCBpZiBjb25zdHJ1Y3RvckZuLm5hbWUgaXMgbm90IGRlZmluZWRcbiAgICB2YXIgbWF0Y2ggPSBTdHJpbmcoY29uc3RydWN0b3JGbikubWF0Y2goZnVuY3Rpb25OYW1lTWF0Y2gpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gY29uc3RydWN0b3JGbi5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogIyMjIC5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKVxuICpcbiAqIEdldHMgdGhlIGNvbnN0cnVjdG9yIG5hbWUgZm9yIGFuIEVycm9yIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yIGl0c2VsZi5cbiAqXG4gKiBAbmFtZSBnZXRDb25zdHJ1Y3Rvck5hbWVcbiAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZShlcnJvckxpa2UpIHtcbiAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IGVycm9yTGlrZTtcbiAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc3RydWN0b3JOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKGVycm9yTGlrZS5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yTGlrZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIElmIGBlcnJgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBFcnJvciBpdCBpcyBhbiBlcnJvciBjb25zdHJ1Y3RvciBpdHNlbGYgb3IgYW5vdGhlciBmdW5jdGlvbi5cbiAgICAvLyBJZiB3ZSd2ZSBnb3QgYSBjb21tb24gZnVuY3Rpb24gd2UgZ2V0IGl0cyBuYW1lLCBvdGhlcndpc2Ugd2UgbWF5IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlXG4gICAgLy8gb2YgdGhlIGVycm9yIGp1c3QgaW4gY2FzZSBpdCdzIGEgcG9vcmx5LWNvbnN0cnVjdGVkIGVycm9yLiBQbGVhc2Ugc2VlIGNoYWlqcy9jaGFpL2lzc3Vlcy80NSB0byBrbm93IG1vcmUuXG4gICAgY29uc3RydWN0b3JOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKGVycm9yTGlrZSkudHJpbSgpIHx8XG4gICAgICAgIGdldEZ1bmN0aW9uTmFtZShuZXcgZXJyb3JMaWtlKCkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgfVxuXG4gIHJldHVybiBjb25zdHJ1Y3Rvck5hbWU7XG59XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKGVycm9yTGlrZSlcbiAqXG4gKiBHZXRzIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gYW4gZXJyb3IuXG4gKiBJZiBgZXJyYCBpcyBhIFN0cmluZyBpdHNlbGYsIHdlIHJldHVybiBpdC5cbiAqIElmIHRoZSBlcnJvciBoYXMgbm8gbWVzc2FnZSwgd2UgcmV0dXJuIGFuIGVtcHR5IHN0cmluZy5cbiAqXG4gKiBAbmFtZSBnZXRNZXNzYWdlXG4gKiBAcGFyYW0ge0Vycm9yfFN0cmluZ30gZXJyb3JMaWtlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2UoZXJyb3JMaWtlKSB7XG4gIHZhciBtc2cgPSAnJztcbiAgaWYgKGVycm9yTGlrZSAmJiBlcnJvckxpa2UubWVzc2FnZSkge1xuICAgIG1zZyA9IGVycm9yTGlrZS5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckxpa2UgPT09ICdzdHJpbmcnKSB7XG4gICAgbXNnID0gZXJyb3JMaWtlO1xuICB9XG5cbiAgcmV0dXJuIG1zZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhdGlibGVJbnN0YW5jZTogY29tcGF0aWJsZUluc3RhbmNlLFxuICBjb21wYXRpYmxlQ29uc3RydWN0b3I6IGNvbXBhdGlibGVDb25zdHJ1Y3RvcixcbiAgY29tcGF0aWJsZU1lc3NhZ2U6IGNvbXBhdGlibGVNZXNzYWdlLFxuICBnZXRNZXNzYWdlOiBnZXRNZXNzYWdlLFxuICBnZXRDb25zdHJ1Y3Rvck5hbWU6IGdldENvbnN0cnVjdG9yTmFtZSxcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBpc05hTiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE1IFNha3RoaXByaXlhbiBWYWlyYW1hbmkgPHRoZWNoYXJnaW5ndm9sY2Fub0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuaXNOYU4odmFsdWUpXG4gKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBOYU4gb3Igbm90LlxuICpcbiAqICAgICB1dGlscy5pc05hTihOYU4pOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtWYWx1ZX0gVGhlIHZhbHVlIHdoaWNoIGhhcyB0byBiZSBjaGVja2VkIGlmIGl0IGlzIE5hTlxuICogQG5hbWUgaXNOYU5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gIC8vIFJlZmVyIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc25hbi1udW1iZXJcbiAgLy8gc2VjdGlvbidzIE5PVEUuXG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbi8vIElmIEVDTUFTY3JpcHQgNidzIE51bWJlci5pc05hTiBpcyBwcmVzZW50LCBwcmVmZXIgdGhhdC5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzTmFOIHx8IGlzTmFOO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogRGVwZW5kZW5jaWVzIHRoYXQgYXJlIHVzZWQgZm9yIG11bHRpcGxlIGV4cG9ydHMgYXJlIHJlcXVpcmVkIGhlcmUgb25seSBvbmNlXG4gKi9cblxudmFyIHBhdGh2YWwgPSByZXF1aXJlKCdwYXRodmFsJyk7XG5cbi8qIVxuICogdGVzdCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50ZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XG5cbi8qIVxuICogdHlwZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxuLyohXG4gKiBleHBlY3RUeXBlcyB1dGlsaXR5XG4gKi9cbmV4cG9ydHMuZXhwZWN0VHlwZXMgPSByZXF1aXJlKCcuL2V4cGVjdFR5cGVzJyk7XG5cbi8qIVxuICogbWVzc2FnZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRNZXNzYWdlID0gcmVxdWlyZSgnLi9nZXRNZXNzYWdlJyk7XG5cbi8qIVxuICogYWN0dWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJyk7XG5cbi8qIVxuICogSW5zcGVjdCB1dGlsXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG5cbi8qIVxuICogT2JqZWN0IERpc3BsYXkgdXRpbFxuICovXG5cbmV4cG9ydHMub2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKiFcbiAqIEZsYWcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKiFcbiAqIEZsYWcgdHJhbnNmZXJyaW5nIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyohXG4gKiBEZWVwIGVxdWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmVxbCA9IHJlcXVpcmUoJ2RlZXAtZXFsJyk7XG5cbi8qIVxuICogRGVlcCBwYXRoIGluZm9cbiAqL1xuXG5leHBvcnRzLmdldFBhdGhJbmZvID0gcGF0aHZhbC5nZXRQYXRoSW5mbztcblxuLyohXG4gKiBDaGVjayBpZiBhIHByb3BlcnR5IGV4aXN0c1xuICovXG5cbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBwYXRodmFsLmhhc1Byb3BlcnR5O1xuXG4vKiFcbiAqIEZ1bmN0aW9uIG5hbWVcbiAqL1xuXG5leHBvcnRzLmdldE5hbWUgPSByZXF1aXJlKCdnZXQtZnVuYy1uYW1lJyk7XG5cbi8qIVxuICogYWRkIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5hZGRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vYWRkUHJvcGVydHknKTtcblxuLyohXG4gKiBhZGQgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRNZXRob2QgPSByZXF1aXJlKCcuL2FkZE1ldGhvZCcpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL292ZXJ3cml0ZVByb3BlcnR5Jyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIE1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVNZXRob2QnKTtcblxuLyohXG4gKiBBZGQgYSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL2FkZENoYWluYWJsZU1ldGhvZCcpO1xuXG4vKiFcbiAqIE92ZXJ3cml0ZSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCcpO1xuXG4vKiFcbiAqIENvbXBhcmUgYnkgaW5zcGVjdCBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmNvbXBhcmVCeUluc3BlY3QgPSByZXF1aXJlKCcuL2NvbXBhcmVCeUluc3BlY3QnKTtcblxuLyohXG4gKiBHZXQgb3duIGVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scyBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgPSByZXF1aXJlKCcuL2dldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMnKTtcblxuLyohXG4gKiBHZXQgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcycpO1xuXG4vKiFcbiAqIENoZWNrcyBlcnJvciBhZ2FpbnN0IGEgZ2l2ZW4gc2V0IG9mIGNyaXRlcmlhXG4gKi9cblxuZXhwb3J0cy5jaGVja0Vycm9yID0gcmVxdWlyZSgnY2hlY2stZXJyb3InKTtcblxuLyohXG4gKiBQcm94aWZ5IHV0aWxcbiAqL1xuXG5leHBvcnRzLnByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcblxuLyohXG4gKiBhZGRMZW5ndGhHdWFyZCB1dGlsXG4gKi9cblxuZXhwb3J0cy5hZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcblxuLyohXG4gKiBpc1Byb3h5RW5hYmxlZCBoZWxwZXJcbiAqL1xuXG5leHBvcnRzLmlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xuXG4vKiFcbiAqIGlzTmFOIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuaXNOYU4gPSByZXF1aXJlKCcuL2lzTmFOJyk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9jaGFpLCB1dGlsKSB7XG4gIC8qIVxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uRXJyb3IgPSBfY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgX2NoYWkuQXNzZXJ0aW9uID0gQXNzZXJ0aW9uO1xuXG4gIC8qIVxuICAgKiBBc3NlcnRpb24gQ29uc3RydWN0b3JcbiAgICpcbiAgICogQ3JlYXRlcyBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBgQXNzZXJ0aW9uYCBvYmplY3RzIGNvbnRhaW4gbWV0YWRhdGEgaW4gdGhlIGZvcm0gb2YgZmxhZ3MuIFRocmVlIGZsYWdzIGNhblxuICAgKiBiZSBhc3NpZ25lZCBkdXJpbmcgaW5zdGFudGlhdGlvbiBieSBwYXNzaW5nIGFyZ3VtZW50cyB0byB0aGlzIGNvbnN0cnVjdG9yOlxuICAgKlxuICAgKiAtIGBvYmplY3RgOiBUaGlzIGZsYWcgY29udGFpbnMgdGhlIHRhcmdldCBvZiB0aGUgYXNzZXJ0aW9uLiBGb3IgZXhhbXBsZSwgaW5cbiAgICogICB0aGUgYXNzZXJ0aW9uIGBleHBlY3QobnVtS2l0dGVucykudG8uZXF1YWwoNyk7YCwgdGhlIGBvYmplY3RgIGZsYWcgd2lsbFxuICAgKiAgIGNvbnRhaW4gYG51bUtpdHRlbnNgIHNvIHRoYXQgdGhlIGBlcXVhbGAgYXNzZXJ0aW9uIGNhbiByZWZlcmVuY2UgaXQgd2hlblxuICAgKiAgIG5lZWRlZC5cbiAgICpcbiAgICogLSBgbWVzc2FnZWA6IFRoaXMgZmxhZyBjb250YWlucyBhbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZSB0byBiZVxuICAgKiAgIHByZXBlbmRlZCB0byB0aGUgZXJyb3IgbWVzc2FnZSB0aGF0J3MgZ2VuZXJhdGVkIGJ5IHRoZSBhc3NlcnRpb24gd2hlbiBpdFxuICAgKiAgIGZhaWxzLlxuICAgKlxuICAgKiAtIGBzc2ZpYDogVGhpcyBmbGFnIHN0YW5kcyBmb3IgXCJzdGFydCBzdGFjayBmdW5jdGlvbiBpbmRpY2F0b3JcIi4gSXRcbiAgICogICBjb250YWlucyBhIGZ1bmN0aW9uIHJlZmVyZW5jZSB0aGF0IHNlcnZlcyBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yXG4gICAqICAgcmVtb3ZpbmcgZnJhbWVzIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mIHRoZSBlcnJvciB0aGF0J3MgY3JlYXRlZCBieSB0aGVcbiAgICogICBhc3NlcnRpb24gd2hlbiBpdCBmYWlscy4gVGhlIGdvYWwgaXMgdG8gcHJvdmlkZSBhIGNsZWFuZXIgc3RhY2sgdHJhY2UgdG9cbiAgICogICBlbmQgdXNlcnMgYnkgcmVtb3ZpbmcgQ2hhaSdzIGludGVybmFsIGZ1bmN0aW9ucy4gTm90ZSB0aGF0IGl0IG9ubHkgd29ya3NcbiAgICogICBpbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAsIGFuZCBvbmx5IHdoZW5cbiAgICogICBgQ2hhaS5jb25maWcuaW5jbHVkZVN0YWNrYCBoYXNuJ3QgYmVlbiBzZXQgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogLSBgbG9ja1NzZmlgOiBUaGlzIGZsYWcgY29udHJvbHMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGBzc2ZpYCBmbGFnXG4gICAqICAgc2hvdWxkIHJldGFpbiBpdHMgY3VycmVudCB2YWx1ZSwgZXZlbiBhcyBhc3NlcnRpb25zIGFyZSBjaGFpbmVkIG9mZiBvZlxuICAgKiAgIHRoaXMgb2JqZWN0LiBUaGlzIGlzIHVzdWFsbHkgc2V0IHRvIGB0cnVlYCB3aGVuIGNyZWF0aW5nIGEgbmV3IGFzc2VydGlvblxuICAgKiAgIGZyb20gd2l0aGluIGFub3RoZXIgYXNzZXJ0aW9uLiBJdCdzIGFsc28gdGVtcG9yYXJpbHkgc2V0IHRvIGB0cnVlYCBiZWZvcmVcbiAgICogICBhbiBvdmVyd3JpdHRlbiBhc3NlcnRpb24gZ2V0cyBjYWxsZWQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqIHRhcmdldCBvZiB0aGUgYXNzZXJ0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgKG9wdGlvbmFsKSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzc2ZpIChvcHRpb25hbCkgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIHN0YWNrIGZyYW1lc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvY2tTc2ZpIChvcHRpb25hbCkgd2hldGhlciBvciBub3QgdGhlIHNzZmkgZmxhZyBpcyBsb2NrZWRcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbiAob2JqLCBtc2csIHNzZmksIGxvY2tTc2ZpKSB7XG4gICAgZmxhZyh0aGlzLCAnc3NmaScsIHNzZmkgfHwgQXNzZXJ0aW9uKTtcbiAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIGxvY2tTc2ZpKTtcbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBvYmopO1xuICAgIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgcmV0dXJuIHV0aWwucHJveGlmeSh0aGlzKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdpbmNsdWRlU3RhY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLmluY2x1ZGVTdGFjaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuaW5jbHVkZVN0YWNrID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnc2hvd0RpZmYnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5zaG93RGlmZjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLnNob3dEaWZmID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZFByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwuYWRkQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlLCBleHBlY3RlZCwgYWN0dWFsLCBzaG93RGlmZilcbiAgICpcbiAgICogRXhlY3V0ZXMgYW4gZXhwcmVzc2lvbiBhbmQgY2hlY2sgZXhwZWN0YXRpb25zLiBUaHJvd3MgQXNzZXJ0aW9uRXJyb3IgZm9yIHJlcG9ydGluZyBpZiB0ZXN0IGRvZXNuJ3QgcGFzcy5cbiAgICpcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBwYXJhbSB7UGhpbG9zb3BoaWNhbH0gZXhwcmVzc2lvbiB0byBiZSB0ZXN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG1lc3NhZ2Ugb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuZWdhdGVkTWVzc2FnZSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbmVnYXRlZE1lc3NhZ2UgdG8gZGlzcGxheSBpZiBuZWdhdGVkIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWQgdmFsdWUgKHJlbWVtYmVyIHRvIGNoZWNrIGZvciBuZWdhdGlvbilcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsIChvcHRpb25hbCkgd2lsbCBkZWZhdWx0IHRvIGB0aGlzLm9iamBcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93RGlmZiAob3B0aW9uYWwpIHdoZW4gc2V0IHRvIGB0cnVlYCwgYXNzZXJ0IHdpbGwgZGlzcGxheSBhIGRpZmYgaW4gYWRkaXRpb24gdG8gdGhlIG1lc3NhZ2UgaWYgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwciwgbXNnLCBuZWdhdGVNc2csIGV4cGVjdGVkLCBfYWN0dWFsLCBzaG93RGlmZikge1xuICAgIHZhciBvayA9IHV0aWwudGVzdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChmYWxzZSAhPT0gc2hvd0RpZmYpIHNob3dEaWZmID0gdHJ1ZTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBleHBlY3RlZCAmJiB1bmRlZmluZWQgPT09IF9hY3R1YWwpIHNob3dEaWZmID0gZmFsc2U7XG4gICAgaWYgKHRydWUgIT09IGNvbmZpZy5zaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcblxuICAgIGlmICghb2spIHtcbiAgICAgIG1zZyA9IHV0aWwuZ2V0TWVzc2FnZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIGFjdHVhbCA9IHV0aWwuZ2V0QWN0dWFsKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBzaG93RGlmZjogc2hvd0RpZmZcbiAgICAgIH0sIChjb25maWcuaW5jbHVkZVN0YWNrKSA/IHRoaXMuYXNzZXJ0IDogZmxhZyh0aGlzLCAnc3NmaScpKTtcbiAgICB9XG4gIH07XG5cbiAgLyohXG4gICAqICMjIyAuX29ialxuICAgKlxuICAgKiBRdWljayByZWZlcmVuY2UgdG8gc3RvcmVkIGBhY3R1YWxgIHZhbHVlIGZvciBwbHVnaW4gZGV2ZWxvcGVycy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24ucHJvdG90eXBlLCAnX29iaicsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgICAgfVxuICAgICwgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbCk7XG4gICAgICB9XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCBfKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgQXNzZXJ0aW9uRXJyb3IgPSBjaGFpLkFzc2VydGlvbkVycm9yXG4gICAgLCBmbGFnID0gXy5mbGFnO1xuXG4gIC8qKlxuICAgKiAjIyMgTGFuZ3VhZ2UgQ2hhaW5zXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIHByb3ZpZGVkIGFzIGNoYWluYWJsZSBnZXR0ZXJzIHRvIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5XG4gICAqIG9mIHlvdXIgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogKipDaGFpbnMqKlxuICAgKlxuICAgKiAtIHRvXG4gICAqIC0gYmVcbiAgICogLSBiZWVuXG4gICAqIC0gaXNcbiAgICogLSB0aGF0XG4gICAqIC0gd2hpY2hcbiAgICogLSBhbmRcbiAgICogLSBoYXNcbiAgICogLSBoYXZlXG4gICAqIC0gd2l0aFxuICAgKiAtIGF0XG4gICAqIC0gb2ZcbiAgICogLSBzYW1lXG4gICAqIC0gYnV0XG4gICAqIC0gZG9lc1xuICAgKlxuICAgKiBAbmFtZSBsYW5ndWFnZSBjaGFpbnNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgWyAndG8nLCAnYmUnLCAnYmVlbidcbiAgLCAnaXMnLCAnYW5kJywgJ2hhcycsICdoYXZlJ1xuICAsICd3aXRoJywgJ3RoYXQnLCAnd2hpY2gnLCAnYXQnXG4gICwgJ29mJywgJ3NhbWUnLCAnYnV0JywgJ2RvZXMnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBBc3NlcnRpb24uYWRkUHJvcGVydHkoY2hhaW4pO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5ub3RcbiAgICpcbiAgICogTmVnYXRlcyBhbGwgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4uXG4gICAqXG4gICAqICAgICBleHBlY3QoZnVuY3Rpb24gKCkge30pLnRvLm5vdC50aHJvdygpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuZG9lcy5ub3QuaW5jbHVkZSgzKTtcbiAgICpcbiAgICogSnVzdCBiZWNhdXNlIHlvdSBjYW4gbmVnYXRlIGFueSBhc3NlcnRpb24gd2l0aCBgLm5vdGAgZG9lc24ndCBtZWFuIHlvdVxuICAgKiBzaG91bGQuIFdpdGggZ3JlYXQgcG93ZXIgY29tZXMgZ3JlYXQgcmVzcG9uc2liaWxpdHkuIEl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgdGhhdCB0aGUgb25lIGV4cGVjdGVkIG91dHB1dCB3YXMgcHJvZHVjZWQsIHJhdGhlciB0aGFuIGFzc2VydGluZ1xuICAgKiB0aGF0IG9uZSBvZiBjb3VudGxlc3MgdW5leHBlY3RlZCBvdXRwdXRzIHdhc24ndCBwcm9kdWNlZC4gU2VlIGluZGl2aWR1YWxcbiAgICogYXNzZXJ0aW9ucyBmb3Igc3BlY2lmaWMgZ3VpZGFuY2UuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8ubm90LmVxdWFsKDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQG5hbWUgbm90XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbm90JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lZ2F0ZScsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5lcXVhbGAsIGAuaW5jbHVkZWAsIGAubWVtYmVyc2AsIGAua2V5c2AsIGFuZCBgLnByb3BlcnR5YFxuICAgKiBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkIG9mIHN0cmljdFxuICAgKiAoYD09PWApIGVxdWFsaXR5LiBTZWUgdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwXG4gICAqIGVxdWFsaXR5IGFsZ29yaXRobTogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbHMgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmRlZXAuZXF1YWwoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5lcXVhbCh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uZGVlcC5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLm5vdC5pbmNsdWRlKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHg6IHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uZGVlcC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8ubm90LmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIG1lbWJlciBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5oYXZlLmRlZXAubWVtYmVycyhbe2E6IDF9XSk7XG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IHNldCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBrZXkgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFt7YTogMX1dKSkudG8uaGF2ZS5kZWVwLmtleXMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoW3thOiAxfV0pKS50by5ub3QuaGF2ZS5rZXlzKFt7YTogMX1dKTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMgcHJvcGVydHkgYHg6IHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8ubm90LmhhdmUucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZGVlcCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdkZWVwJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZFxuICAgKlxuICAgKiBFbmFibGVzIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gaW4gYWxsIGAucHJvcGVydHlgIGFuZCBgLmluY2x1ZGVgXG4gICAqIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzFdJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnYS5iWzFdJzogJ3knfSk7XG4gICAqXG4gICAqIElmIGAuYCBvciBgW11gIGFyZSBwYXJ0IG9mIGFuIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLCB0aGV5IGNhbiBiZSBlc2NhcGVkIGJ5XG4gICAqIGFkZGluZyB0d28gYmFja3NsYXNoZXMgYmVmb3JlIHRoZW0uXG4gICAqXG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogJ3gnfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdcXFxcLmEuXFxcXFtiXFxcXF0nKTtcbiAgICogICAgIGV4cGVjdCh7Jy5hJzogeydbYl0nOiAneCd9fSkudG8ubmVzdGVkLmluY2x1ZGUoeydcXFxcLmEuXFxcXFtiXFxcXF0nOiAneCd9KTtcbiAgICpcbiAgICogYC5uZXN0ZWRgIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGAub3duYC5cbiAgICpcbiAgICogQG5hbWUgbmVzdGVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbmVzdGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lc3RlZCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5vd25cbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLnByb3BlcnR5YCBhbmQgYC5pbmNsdWRlYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpblxuICAgKiB0byBpZ25vcmUgaW5oZXJpdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBPYmplY3QucHJvdG90eXBlLmIgPSAyO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd24ucHJvcGVydHkoJ2EnKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2InKS5idXQubm90Lm93bi5wcm9wZXJ0eSgnYicpOyBcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm93bi5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlKHtiOiAyfSkuYnV0Lm5vdC5vd24uaW5jbHVkZSh7YjogMn0pO1xuICAgKlxuICAgKiBgLm93bmAgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggYC5uZXN0ZWRgLlxuICAgKlxuICAgKiBAbmFtZSBvd25cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnb3duJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9yZGVyZWRcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLm1lbWJlcnNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdFxuICAgKiBtZW1iZXJzIGJlIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uaGF2ZS5vcmRlcmVkLm1lbWJlcnMoWzEsIDJdKVxuICAgKiAgICAgICAuYnV0Lm5vdC5oYXZlLm9yZGVyZWQubWVtYmVycyhbMiwgMV0pO1xuICAgKlxuICAgKiBXaGVuIGAuaW5jbHVkZWAgYW5kIGAub3JkZXJlZGAgYXJlIGNvbWJpbmVkLCB0aGUgb3JkZXJpbmcgYmVnaW5zIGF0IHRoZVxuICAgKiBzdGFydCBvZiBib3RoIGFycmF5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKFsxLCAyXSlcbiAgICogICAgICAgLmJ1dC5ub3QuaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoWzIsIDNdKTtcbiAgICpcbiAgICogQG5hbWUgb3JkZXJlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29yZGVyZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnb3JkZXJlZCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hbnlcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIG9ubHkgcmVxdWlyZSB0aGF0XG4gICAqIHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIGtleXMuIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mXG4gICAqIGAuYWxsYCwgd2hpY2ggcmVxdWlyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8ubm90LmhhdmUuYW55LmtleXMoJ2MnLCAnZCcpO1xuICAgKlxuICAgKiBTZWUgdGhlIGAua2V5c2AgZG9jIGZvciBndWlkYW5jZSBvbiB3aGVuIHRvIHVzZSBgLmFueWAgb3IgYC5hbGxgLlxuICAgKlxuICAgKiBAbmFtZSBhbnlcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbnknLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgZmFsc2UpO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiAjIyMgLmFsbFxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAua2V5c2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0IHRoZVxuICAgKiB0YXJnZXQgaGF2ZSBhbGwgb2YgdGhlIGdpdmVuIGtleXMuIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIGAuYW55YCwgd2hpY2hcbiAgICogb25seSByZXF1aXJlcyB0aGF0IHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIGtleXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGAuYWxsYCBpcyB1c2VkIGJ5IGRlZmF1bHQgd2hlbiBuZWl0aGVyIGAuYWxsYCBub3IgYC5hbnlgIGFyZVxuICAgKiBhZGRlZCBlYXJsaWVyIGluIHRoZSBjaGFpbi4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFkZCBgLmFsbGAgYW55d2F5XG4gICAqIGJlY2F1c2UgaXQgaW1wcm92ZXMgcmVhZGFiaWxpdHkuXG4gICAqXG4gICAqIFNlZSB0aGUgYC5rZXlzYCBkb2MgZm9yIGd1aWRhbmNlIG9uIHdoZW4gdG8gdXNlIGAuYW55YCBvciBgLmFsbGAuXG4gICAqXG4gICAqIEBuYW1lIGFsbFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdhbGwnLCB0cnVlKTtcbiAgICBmbGFnKHRoaXMsICdhbnknLCBmYWxzZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmEodHlwZVssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgdHlwZSBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gc3RyaW5nIGB0eXBlYC4gVHlwZXNcbiAgICogYXJlIGNhc2UgaW5zZW5zaXRpdmUuIFNlZSB0aGUgYHR5cGUtZGV0ZWN0YCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlXG4gICAqIHR5cGUgZGV0ZWN0aW9uIGFsZ29yaXRobTogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy90eXBlLWRldGVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5iZS5hbignb2JqZWN0Jyk7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUuYSgnbnVsbCcpO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUuYW4oJ3VuZGVmaW5lZCcpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBFcnJvcikudG8uYmUuYW4oJ2Vycm9yJyk7XG4gICAqICAgICBleHBlY3QoUHJvbWlzZS5yZXNvbHZlKCkpLnRvLmJlLmEoJ3Byb21pc2UnKTtcbiAgICogICAgIGV4cGVjdChuZXcgRmxvYXQzMkFycmF5KS50by5iZS5hKCdmbG9hdDMyYXJyYXknKTtcbiAgICogICAgIGV4cGVjdChTeW1ib2woKSkudG8uYmUuYSgnc3ltYm9sJyk7XG4gICAqXG4gICAqIGAuYWAgc3VwcG9ydHMgb2JqZWN0cyB0aGF0IGhhdmUgYSBjdXN0b20gdHlwZSBzZXQgdmlhIGBTeW1ib2wudG9TdHJpbmdUYWdgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge1xuICAgKiAgICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ215Q3VzdG9tVHlwZSdcbiAgICogICAgIH07XG4gICAqXG4gICAqICAgICBleHBlY3QobXlPYmopLnRvLmJlLmEoJ215Q3VzdG9tVHlwZScpLmJ1dC5ub3QuYW4oJ29iamVjdCcpO1xuICAgKlxuICAgKiBJdCdzIG9mdGVuIGJlc3QgdG8gdXNlIGAuYWAgdG8gY2hlY2sgYSB0YXJnZXQncyB0eXBlIGJlZm9yZSBtYWtpbmcgbW9yZVxuICAgKiBhc3NlcnRpb25zIG9uIHRoZSBzYW1lIHRhcmdldC4gVGhhdCB3YXksIHlvdSBhdm9pZCB1bmV4cGVjdGVkIGJlaGF2aW9yIGZyb21cbiAgICogYW55IGFzc2VydGlvbiB0aGF0IGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaW5jbHVkZXMoMik7XG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaXMuZW1wdHk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIHRoZSBleHBlY3RlZCB0eXBlLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdFxuICAgKiBpc24ndCBvbmUgb2YgbWFueSB1bmV4cGVjdGVkIHR5cGVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5hKCdzdHJpbmcnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLmFuKCdhcnJheScpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5hYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG9cbiAgICogc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmRcbiAgICogYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYSgnc3RyaW5nJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICpcbiAgICogYC5hYCBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgbGFuZ3VhZ2UgY2hhaW4gdG8gaW1wcm92ZSB0aGUgcmVhZGFiaWxpdHkgb2ZcbiAgICogeW91ciBhc3NlcnRpb25zLiBcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLmhhdmUuYS5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5hbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5hYC5cbiAgICpcbiAgICogQG5hbWUgYVxuICAgKiBAYWxpYXMgYW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFuICh0eXBlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBhcnRpY2xlID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHR5cGUuY2hhckF0KDApKSA/ICdhbiAnIDogJ2EgJztcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlID09PSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FuJywgYW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhJywgYW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUodmFsWywgbXNnXSlcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgc3RyaW5nLCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gc3RyaW5nIGB2YWxgXG4gICAqIGlzIGEgc3Vic3RyaW5nIG9mIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmluY2x1ZGUoJ2ZvbycpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYW4gYXJyYXksIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBhXG4gICAqIG1lbWJlciBvZiB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZSgyKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdCwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIG9iamVjdFxuICAgKiBgdmFsYCdzIHByb3BlcnRpZXMgYXJlIGEgc3Vic2V0IG9mIHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8uaW5jbHVkZSh7YTogMSwgYjogMn0pO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBTZXQgb3IgV2Vha1NldCwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGB2YWxgIGlzIGFcbiAgICogbWVtYmVyIG9mIHRoZSB0YXJnZXQuIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtIGlzIHVzZWQuXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMl0pKS50by5pbmNsdWRlKDIpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBNYXAsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBvbmUgb2ZcbiAgICogdGhlIHZhbHVlcyBvZiB0aGUgdGFyZ2V0LiBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXV0pKS50by5pbmNsdWRlKDIpO1xuICAgKlxuICAgKiBCZWNhdXNlIGAuaW5jbHVkZWAgZG9lcyBkaWZmZXJlbnQgdGhpbmdzIGJhc2VkIG9uIHRoZSB0YXJnZXQncyB0eXBlLCBpdCdzXG4gICAqIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgdXNpbmcgYC5pbmNsdWRlYC4gU2VlIHRoZSBgLmFgXG4gICAqIGRvYyBmb3IgaW5mbyBvbiB0ZXN0aW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaW5jbHVkZXMoMik7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQgdG8gY29tcGFyZSBhcnJheSBtZW1iZXJzIGFuZFxuICAgKiBvYmplY3QgcHJvcGVydGllcy4gQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHlcbiAgICogaW5zdGVhZCAoV2Vha1NldCB0YXJnZXRzIGFyZSBub3Qgc3VwcG9ydGVkKS4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3RcbiAgICogcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5kZWVwLmluY2x1ZGUoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmluY2x1ZGUoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5kZWVwLmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGFsbCBvZiB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBhcmUgc2VhcmNoZWQgd2hlbiB3b3JraW5nIHdpdGhcbiAgICogb2JqZWN0cy4gVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluaGVyaXRlZCBhbmQvb3Igbm9uLWVudW1lcmFibGUuXG4gICAqIEFkZCBgLm93bmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZXhjbHVkZSB0aGUgdGFyZ2V0J3MgaW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgZnJvbSB0aGUgc2VhcmNoLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm93bi5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlKHtiOiAyfSkuYnV0Lm5vdC5vd24uaW5jbHVkZSh7YjogMn0pO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYSB0YXJnZXQgb2JqZWN0IGlzIGFsd2F5cyBvbmx5IHNlYXJjaGVkIGZvciBgdmFsYCdzIG93blxuICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAub3duYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiAyfX0pLnRvLmRlZXAub3duLmluY2x1ZGUoe2E6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBBZGQgYC5uZXN0ZWRgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGVuYWJsZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIHdoZW5cbiAgICogcmVmZXJlbmNpbmcgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnYS5iWzFdJzogJ3knfSk7XG4gICAqXG4gICAqIElmIGAuYCBvciBgW11gIGFyZSBwYXJ0IG9mIGFuIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLCB0aGV5IGNhbiBiZSBlc2NhcGVkIGJ5XG4gICAqIGFkZGluZyB0d28gYmFja3NsYXNoZXMgYmVmb3JlIHRoZW0uXG4gICAqXG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogMn19KS50by5uZXN0ZWQuaW5jbHVkZSh7J1xcXFwuYS5cXFxcW2JcXFxcXSc6IDJ9KTtcbiAgICpcbiAgICogYC5kZWVwYCBhbmQgYC5uZXN0ZWRgIGNhbiBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFt7YzogM31dfX0pLnRvLmRlZXAubmVzdGVkLmluY2x1ZGUoeydhLmJbMF0nOiB7YzogM319KTtcbiAgICpcbiAgICogYC5vd25gIGFuZCBgLm5lc3RlZGAgY2Fubm90IGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmluY2x1ZGVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5ub3QuaW5jbHVkZSgndGFjbycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmluY2x1ZGUoNCk7XG4gICAqIFxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC5pbmNsdWRlYCB3aGVuIHRoZSB0YXJnZXQgaXMgYW4gb2JqZWN0LlxuICAgKiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieSBhc3NlcnRpbmcgdGhhdCB0aGVcbiAgICogdGFyZ2V0IG9iamVjdCBkb2Vzbid0IGhhdmUgYWxsIG9mIGB2YWxgJ3Mga2V5L3ZhbHVlIHBhaXJzIGJ1dCBtYXkgb3IgbWF5XG4gICAqIG5vdCBoYXZlIHNvbWUgb2YgdGhlbS4gSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzXG4gICAqIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBvYmplY3QgaXNuJ3QgZXZlbiBleHBlY3RlZCB0byBoYXZlIGB2YWxgJ3Mga2V5cywgaXQnc1xuICAgKiBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2M6IDN9KS50by5ub3QuaGF2ZS5hbnkua2V5cygnYScsICdiJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2M6IDN9KS50by5ub3QuaW5jbHVkZSh7YTogMSwgYjogMn0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIGB2YWxgJ3Mga2V5cywgaXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCB0aGF0IGVhY2ggb2YgdGhlIHByb3BlcnRpZXMgaGFzIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW5cbiAgICogYXNzZXJ0aW5nIHRoYXQgZWFjaCBwcm9wZXJ0eSBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnkgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDMsIGI6IDR9KS50by5pbmNsdWRlKHthOiAzLCBiOiA0fSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDMsIGI6IDR9KS50by5ub3QuaW5jbHVkZSh7YTogMSwgYjogMn0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5pbmNsdWRlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlKDQsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10sICdub29vIHdoeSBmYWlsPz8nKS50by5pbmNsdWRlKDQpO1xuICAgKlxuICAgKiBgLmluY2x1ZGVgIGNhbiBhbHNvIGJlIHVzZWQgYXMgYSBsYW5ndWFnZSBjaGFpbiwgY2F1c2luZyBhbGwgYC5tZW1iZXJzYCBhbmRcbiAgICogYC5rZXlzYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoZSB0YXJnZXQgdG8gYmUgYVxuICAgKiBzdXBlcnNldCBvZiB0aGUgZXhwZWN0ZWQgc2V0LCByYXRoZXIgdGhhbiBhbiBpZGVudGljYWwgc2V0LiBOb3RlIHRoYXRcbiAgICogYC5tZW1iZXJzYCBpZ25vcmVzIGR1cGxpY2F0ZXMgaW4gdGhlIHN1YnNldCB3aGVuIGAuaW5jbHVkZWAgaXMgYWRkZWQuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0J3Mga2V5cyBhcmUgYSBzdXBlcnNldCBvZiBbJ2EnLCAnYiddIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5pbmNsdWRlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLm5vdC5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBpcyBhIHN1cGVyc2V0IG9mIFsxLCAyXSBidXQgbm90IGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFsxLCAyXSk7XG4gICAqXG4gICAqICAgICAvLyBEdXBsaWNhdGVzIGluIHRoZSBzdWJzZXQgYXJlIGlnbm9yZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMSwgMiwgMiwgMl0pO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYWRkaW5nIGAuYW55YCBlYXJsaWVyIGluIHRoZSBjaGFpbiBjYXVzZXMgdGhlIGAua2V5c2AgYXNzZXJ0aW9uXG4gICAqIHRvIGlnbm9yZSBgLmluY2x1ZGVgLlxuICAgKlxuICAgKiAgICAgLy8gQm90aCBhc3NlcnRpb25zIGFyZSBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmluY2x1ZGUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAuaW5jbHVkZXNgLCBgLmNvbnRhaW5gLCBhbmQgYC5jb250YWluc2AgY2FuIGJlIHVzZWRcbiAgICogaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5pbmNsdWRlYC5cbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAYWxpYXMgY29udGFpblxuICAgKiBAYWxpYXMgaW5jbHVkZXNcbiAgICogQGFsaWFzIGNvbnRhaW5zXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gU2FtZVZhbHVlWmVybyhhLCBiKSB7XG4gICAgcmV0dXJuIChfLmlzTmFOKGEpICYmIF8uaXNOYU4oYikpIHx8IGEgPT09IGI7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgZmxhZyh0aGlzLCAnY29udGFpbnMnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgXG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbmVnYXRlID0gZmxhZyh0aGlzLCAnbmVnYXRlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBpc0RlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgZGVzY3JpcHRvciA9IGlzRGVlcCA/ICdkZWVwICcgOiAnJztcblxuICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcblxuICAgIHZhciBpbmNsdWRlZCA9IGZhbHNlO1xuXG4gICAgc3dpdGNoIChvYmpUeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpbmNsdWRlZCA9IG9iai5pbmRleE9mKHZhbCkgIT09IC0xO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnd2Vha3NldCc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgICBmbGFnTXNnICsgJ3VuYWJsZSB0byB1c2UgLmRlZXAuaW5jbHVkZSB3aXRoIFdlYWtTZXQnLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3NmaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmNsdWRlZCA9IG9iai5oYXModmFsKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgIHZhciBpc0VxbCA9IGlzRGVlcCA/IF8uZXFsIDogU2FtZVZhbHVlWmVybztcbiAgICAgICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IGluY2x1ZGVkIHx8IGlzRXFsKGl0ZW0sIHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpbmNsdWRlZCA9IGluY2x1ZGVkIHx8IF8uZXFsKGl0ZW0sIHZhbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBvYmouaGFzKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBfLmVxbChpdGVtLCB2YWwpO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBvYmouaW5kZXhPZih2YWwpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVGhpcyBibG9jayBpcyBmb3IgYXNzZXJ0aW5nIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgICAgICAvLyBgXy5leHBlY3RUeXBlc2AgaXNuJ3QgdXNlZCBoZXJlIGJlY2F1c2UgYC5pbmNsdWRlYCBzaG91bGQgd29yayB3aXRoXG4gICAgICAgIC8vIG9iamVjdHMgd2l0aCBhIGN1c3RvbSBgQEB0b1N0cmluZ1RhZ2AuXG4gICAgICAgIGlmICh2YWwgIT09IE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgICAgZmxhZ01zZyArICdvYmplY3QgdGVzdGVkIG11c3QgYmUgYW4gYXJyYXksIGEgbWFwLCBhbiBvYmplY3QsJ1xuICAgICAgICAgICAgICArICcgYSBzZXQsIGEgc3RyaW5nLCBvciBhIHdlYWtzZXQsIGJ1dCAnICsgb2JqVHlwZSArICcgZ2l2ZW4nLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3NmaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICAgICAgLCBmaXJzdEVyciA9IG51bGxcbiAgICAgICAgICAsIG51bUVycnMgPSAwO1xuICBcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHZhciBwcm9wQXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbihvYmopO1xuICAgICAgICAgIF8udHJhbnNmZXJGbGFncyh0aGlzLCBwcm9wQXNzZXJ0aW9uLCB0cnVlKTtcbiAgICAgICAgICBmbGFnKHByb3BBc3NlcnRpb24sICdsb2NrU3NmaScsIHRydWUpO1xuICBcbiAgICAgICAgICBpZiAoIW5lZ2F0ZSB8fCBwcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHByb3BBc3NlcnRpb24ucHJvcGVydHkocHJvcCwgdmFsW3Byb3BdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9wQXNzZXJ0aW9uLnByb3BlcnR5KHByb3AsIHZhbFtwcm9wXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIV8uY2hlY2tFcnJvci5jb21wYXRpYmxlQ29uc3RydWN0b3IoZXJyLCBBc3NlcnRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0RXJyID09PSBudWxsKSBmaXJzdEVyciA9IGVycjtcbiAgICAgICAgICAgIG51bUVycnMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgICAgLy8gV2hlbiB2YWxpZGF0aW5nIC5ub3QuaW5jbHVkZSB3aXRoIG11bHRpcGxlIHByb3BlcnRpZXMsIHdlIG9ubHkgd2FudFxuICAgICAgICAvLyB0byB0aHJvdyBhbiBhc3NlcnRpb24gZXJyb3IgaWYgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCxcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSB0aHJvdyB0aGUgZmlyc3QgcHJvcGVydHkgYXNzZXJ0aW9uIGVycm9yIHRoYXQgd2VcbiAgICAgICAgLy8gZW5jb3VudGVyZWQuXG4gICAgICAgIGlmIChuZWdhdGUgJiYgcHJvcHMubGVuZ3RoID4gMSAmJiBudW1FcnJzID09PSBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBmaXJzdEVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXNzZXJ0IGluY2x1c2lvbiBpbiBjb2xsZWN0aW9uIG9yIHN1YnN0cmluZyBpbiBhIHN0cmluZy5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGluY2x1ZGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvICcgKyBkZXNjcmlwdG9yICsgJ2luY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCAnICsgZGVzY3JpcHRvciArICdpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWlucycsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZXMnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG5cbiAgLyoqXG4gICAqICMjIyAub2tcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbG9vc2VseSAoYD09YCkgZXF1YWwgdG8gYHRydWVgLiBIb3dldmVyLCBpdCdzXG4gICAqIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIG9yIGRlZXBseSBlcXVhbCB0b1xuICAgKiBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm9rYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgwKS50by5lcXVhbCgwKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgwKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUub2s7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydXRoeSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc3knKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudHJ1ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGB0cnVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnRydWVgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuIG5vdFxuICAgKiBlcXVhbCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5ub3QuYmUudHJ1ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnRydWU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUudHJ1ZTtcbiAgICpcbiAgICogQG5hbWUgdHJ1ZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3RydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IGZhbHNlIDogdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhbHNlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZmFsc2VgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBgZmFsc2VgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8ubm90LmJlLmZhbHNlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuZmFsc2U7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5mYWxzZTtcbiAgICpcbiAgICogQG5hbWUgZmFsc2VcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmYWxzZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmFsc2UgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IHRydWUgOiBmYWxzZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm51bGxcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgbnVsbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5udWxsYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhbiBub3RcbiAgICogZXF1YWwgdG8gYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5udWxsOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEBuYW1lIG51bGxcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdudWxsJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBudWxsJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgbnVsbCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC51bmRlZmluZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC51bmRlZmluZWRgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudW5kZWZpbmVkOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQG5hbWUgdW5kZWZpbmVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndW5kZWZpbmVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB1bmRlZmluZWQgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHVuZGVmaW5lZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIHVuZGVmaW5lZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5OYU5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXhhY3RseSBgTmFOYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChOYU4pLnRvLmJlLk5hTjtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5OYU5gLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuIG5vdFxuICAgKiBlcXVhbCB0byBgTmFOYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uZXF1YWwoJ2ZvbycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuTmFOOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLk5hTjtcbiAgICpcbiAgICogQG5hbWUgTmFOXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnTmFOJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmlzTmFOKGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIE5hTidcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgTmFOJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0XG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5vdCBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGVpdGhlciBgbnVsbGAgb3JcbiAgICogYHVuZGVmaW5lZGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvXG4gICAqIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMCkudG8uZXF1YWwoMCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMCkudG8uZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmV4aXN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwsICdub29vIHdoeSBmYWlsPz8nKS50by5leGlzdDtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBleGlzdCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGV4aXN0J1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVtcHR5XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIHN0cmluZyBvciBhcnJheSwgYC5lbXB0eWAgYXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQnc1xuICAgKiBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGAwYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbXSkudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3QoJycpLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBtYXAgb3Igc2V0LCBgLmVtcHR5YCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBzaXplYFxuICAgKiBwcm9wZXJ0eSBpcyBzdHJpY3RseSBlcXVhbCB0byBgMGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IFNldCgpKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdChuZXcgTWFwKCkpLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBgLmVtcHR5YCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldFxuICAgKiBkb2Vzbid0IGhhdmUgYW55IG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIFByb3BlcnRpZXMgd2l0aCBTeW1ib2wtYmFzZWRcbiAgICoga2V5cyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgY291bnQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBCZWNhdXNlIGAuZW1wdHlgIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZSwgaXQnc1xuICAgKiBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlIHVzaW5nIGAuZW1wdHlgLiBTZWUgdGhlIGAuYWBcbiAgICogZG9jIGZvciBpbmZvIG9uIHRlc3RpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5hbignYXJyYXknKS50aGF0LmlzLmVtcHR5O1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmVtcHR5YC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgY29udGFpbnMgaXRzIGV4cGVjdGVkIG51bWJlciBvZiB2YWx1ZXMsXG4gICAqIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0J3Mgbm90IGVtcHR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5iZS5lbXB0eTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMiwgM10pKS50by5oYXZlLnByb3BlcnR5KCdzaXplJywgMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMiwgM10pKS50by5ub3QuYmUuZW1wdHk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KE9iamVjdC5rZXlzKHthOiAxfSkpLnRvLmhhdmUubGVuZ3RoT2YoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuZW1wdHk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBAbmFtZSBlbXB0eVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgaXRlbXNDb3VudDtcblxuICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcblxuICAgIHN3aXRjaCAoXy50eXBlKHZhbCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaXRlbXNDb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGl0ZW1zQ291bnQgPSB2YWwuc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWFrbWFwJzpcbiAgICAgIGNhc2UgJ3dlYWtzZXQnOlxuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICcuZW1wdHkgd2FzIHBhc3NlZCBhIHdlYWsgY29sbGVjdGlvbicsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgdmFyIG1zZyA9IGZsYWdNc2cgKyAnLmVtcHR5IHdhcyBwYXNzZWQgYSBmdW5jdGlvbiAnICsgXy5nZXROYW1lKHZhbCk7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cudHJpbSgpLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZhbCAhPT0gT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgICBmbGFnTXNnICsgJy5lbXB0eSB3YXMgcGFzc2VkIG5vbi1zdHJpbmcgcHJpbWl0aXZlICcgKyBfLmluc3BlY3QodmFsKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNzZmlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1zQ291bnQgPSBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgMCA9PT0gaXRlbXNDb3VudFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBlbXB0eSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGVtcHR5J1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFyZ3VtZW50c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiB0ZXN0ICgpIHtcbiAgICogICAgICAgZXhwZWN0KGFyZ3VtZW50cykudG8uYmUuYXJndW1lbnRzO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiAgICAgdGVzdCgpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmFyZ3VtZW50c2AuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgd2hpY2ggdHlwZSB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCBpdHMgbm90IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5hcmd1bWVudHM7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYXJndW1lbnRzO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5Bcmd1bWVudHNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuYXJndW1lbnRzYC5cbiAgICpcbiAgICogQG5hbWUgYXJndW1lbnRzXG4gICAqIEBhbGlhcyBBcmd1bWVudHNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2tBcmd1bWVudHMgKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB0eXBlID0gXy50eXBlKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdBcmd1bWVudHMnID09PSB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFyZ3VtZW50cyBidXQgZ290ICcgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhcmd1bWVudHMnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ0FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbCh2YWxbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIHRoZSBnaXZlbiBgdmFsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uZXF1YWwoJ2ZvbycpO1xuICAgKiBcbiAgICogQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlIHRoZVxuICAgKiBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWxzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5kZWVwLmVxdWFsKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXF1YWwoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFscyBgWzEsIDJdYFxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uZGVlcC5lcXVhbChbMSwgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8ubm90LmVxdWFsKFsxLCAyXSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXF1YWxgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5lcXVhbCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuZXF1YWxgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmVxdWFsKDIpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmVxdWFsc2AgYW5kIGBlcWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5lcXVhbGAuXG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBhbGlhcyBlcXVhbHNcbiAgICogQGFsaWFzIGVxXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RXF1YWwgKHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkZWVwJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVxbCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IG9ialxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHRoaXMuX29ialxuICAgICAgICAsIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWwnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFscycsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXEnLCBhc3NlcnRFcXVhbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXFsKG9ialssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYG9iamAuIFNlZSB0aGVcbiAgICogYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBpcyBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFsIHRvIHthOiAxfVxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHthOiAxfSkuYnV0Lm5vdC5lcXVhbCh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWwgdG8gWzEsIDJdXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5lcWwoWzEsIDJdKS5idXQubm90LmVxdWFsKFsxLCAyXSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXFsYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyXG4gICAqIHRoYW4gbm90IGRlZXBseSBlcXVhbCB0byBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHthOiAxfSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXFsKHtiOiAyfSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmVxbGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHtiOiAyfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmVxbCh7YjogMn0pO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5lcWxzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmVxbGAuXG4gICAqXG4gICAqIFRoZSBgLmRlZXAuZXF1YWxgIGFzc2VydGlvbiBpcyBhbG1vc3QgaWRlbnRpY2FsIHRvIGAuZXFsYCBidXQgd2l0aCBvbmVcbiAgICogZGlmZmVyZW5jZTogYC5kZWVwLmVxdWFsYCBjYXVzZXMgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29ucyB0byBhbHNvIGJlIHVzZWRcbiAgICogZm9yIGFueSBvdGhlciBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogQG5hbWUgZXFsXG4gICAqIEBhbGlhcyBlcWxzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RXFsKG9iaiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIF8uZXFsKG9iaiwgZmxhZyh0aGlzLCAnb2JqZWN0JykpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCBvYmpcbiAgICAgICwgdGhpcy5fb2JqXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFsJywgYXNzZXJ0RXFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFscycsIGFzc2VydEVxbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYWJvdmUoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hYm92ZSgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYWJvdmVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYWJvdmVgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hYm92ZSgyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmFib3ZlKDIpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmd0YCBhbmQgYC5ncmVhdGVyVGhhbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5hYm92ZWAuXG4gICAqXG4gICAqIEBuYW1lIGFib3ZlXG4gICAqIEBhbGlhcyBndFxuICAgKiBAYWxpYXMgZ3JlYXRlclRoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEFib3ZlIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGFib3ZlIG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGFib3ZlIG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdhYm92ZScsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3QnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2dyZWF0ZXJUaGFuJywgYXNzZXJ0QWJvdmUpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlYXN0KG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlblxuICAgKiBudW1iZXIgb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0b1xuICAgKiBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYXQubGVhc3QoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXJcbiAgICogYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5sZWFzdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5sZWFzdGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmF0LmxlYXN0KDIsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYXQubGVhc3QoMik7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmd0ZWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5sZWFzdGAuXG4gICAqXG4gICAqIEBuYW1lIGxlYXN0XG4gICAqIEBhbGlhcyBndGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlYXN0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbGVhc3QgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbGVhc3QgbXVzdCBiZSBhIG51bWJlcic7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhdCBsZWFzdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVhc3QnLCBhc3NlcnRMZWFzdCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0ZScsIGFzc2VydExlYXN0KTtcblxuICAvKipcbiAgICogIyMjIC5iZWxvdyhuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIG9yIGRhdGUgYG5gIHJlc3BlY3RpdmVseS5cbiAgICogSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmJlbG93KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgbGVzcyB0aGFuIHRoZSBnaXZlbiBudW1iZXIgYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLmJlbG93KDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5iZWxvdyg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYmVsb3dgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5iZS5iZWxvdygxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYmVsb3dgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5iZWxvdygxLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmJlbG93KDEpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmx0YCBhbmQgYC5sZXNzVGhhbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5iZWxvd2AuXG4gICAqXG4gICAqIEBuYW1lIGJlbG93XG4gICAqIEBhbGlhcyBsdFxuICAgKiBAYWxpYXMgbGVzc1RoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEJlbG93IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gYmVsb3cgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gYmVsb3cgbXVzdCBiZSBhIG51bWJlcic7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGJlbG93ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDwgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdiZWxvdycsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHQnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlc3NUaGFuJywgYXNzZXJ0QmVsb3cpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1vc3QoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlclxuICAgKiBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0c1xuICAgKiBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hdC5tb3N0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hdC5tb3N0KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLmF0Lm1vc3QoNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubW9zdCg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubW9zdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8ubm90LmJlLmF0Lm1vc3QoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLm1vc3RgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hdC5tb3N0KDEsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgyLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYXQubW9zdCgxKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAubHRlYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLm1vc3RgLlxuICAgKlxuICAgKiBAbmFtZSBtb3N0XG4gICAqIEBhbGlhcyBsdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE1vc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBkb0xlbmd0aCA9IGZsYWcodGhpcywgJ2RvTGVuZ3RoJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBtc2dQcmVmaXggPSAoKGZsYWdNc2cpID8gZmxhZ01zZyArICc6ICcgOiAnJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBuVHlwZSA9IF8udHlwZShuKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZTtcblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbW9zdCBtdXN0IGJlIGEgZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChuVHlwZSAhPT0gJ251bWJlcicgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBtb3N0IG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPD0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbW9zdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtb3N0JywgYXNzZXJ0TW9zdCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0ZScsIGFzc2VydE1vc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLndpdGhpbihzdGFydCwgZmluaXNoWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW5cbiAgICogbnVtYmVyIG9yIGRhdGUgYHN0YXJ0YCwgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIG9yIGRhdGUgYGZpbmlzaGAgcmVzcGVjdGl2ZWx5LlxuICAgKiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWRcbiAgICogdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUud2l0aGluKDEsIDMpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS53aXRoaW4oMiwgMyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLndpdGhpbigxLCAyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIGBzdGFydGAsIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBgZmluaXNoYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi53aXRoaW4oMiwgNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC53aXRoaW5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS53aXRoaW4oMiwgNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLndpdGhpbmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDQpLnRvLmJlLndpdGhpbigxLCAzLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoNCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLndpdGhpbigxLCAzKTtcbiAgICpcbiAgICogQG5hbWUgd2l0aGluXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBsb3dlciBib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbmlzaCB1cHBlciBib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3dpdGhpbicsIGZ1bmN0aW9uIChzdGFydCwgZmluaXNoLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgc3RhcnRUeXBlID0gXy50eXBlKHN0YXJ0KS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGZpbmlzaFR5cGUgPSBfLnR5cGUoZmluaXNoKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZVxuICAgICAgLCByYW5nZSA9IChzdGFydFR5cGUgPT09ICdkYXRlJyAmJiBmaW5pc2hUeXBlID09PSAnZGF0ZScpXG4gICAgICAgICAgPyBzdGFydC50b1VUQ1N0cmluZygpICsgJy4uJyArIGZpbmlzaC50b1VUQ1N0cmluZygpXG4gICAgICAgICAgOiBzdGFydCArICcuLicgKyBmaW5pc2g7XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgKHN0YXJ0VHlwZSAhPT0gJ2RhdGUnIHx8IGZpbmlzaFR5cGUgIT09ICdkYXRlJykpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50cyB0byB3aXRoaW4gbXVzdCBiZSBkYXRlcyc7XG4gICAgfSBlbHNlIGlmICgoc3RhcnRUeXBlICE9PSAnbnVtYmVyJyB8fCBmaW5pc2hUeXBlICE9PSAnbnVtYmVyJykgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudHMgdG8gd2l0aGluIG11c3QgYmUgbnVtYmVycyc7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA+PSBzdGFydCAmJiBsZW4gPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCB3aXRoaW4gJyArIHJhbmdlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IHN0YXJ0ICYmIG9iaiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZW9mKGNvbnN0cnVjdG9yWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkgeyB9XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IENhdCgpKS50by5iZS5hbi5pbnN0YW5jZW9mKENhdCk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5iZS5hbi5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5pbnN0YW5jZW9mYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5hbi5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogYC5pbnN0YW5jZW9mYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hbi5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogRHVlIHRvIGxpbWl0YXRpb25zIGluIEVTNSwgYC5pbnN0YW5jZW9mYCBtYXkgbm90IGFsd2F5cyB3b3JrIGFzIGV4cGVjdGVkXG4gICAqIHdoZW4gdXNpbmcgYSB0cmFuc3BpbGVyIHN1Y2ggYXMgQmFiZWwgb3IgVHlwZVNjcmlwdC4gSW4gcGFydGljdWxhciwgaXQgbWF5XG4gICAqIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzIHdoZW4gc3ViY2xhc3NpbmcgYnVpbHQtaW4gb2JqZWN0IHN1Y2ggYXNcbiAgICogYEFycmF5YCwgYEVycm9yYCwgYW5kIGBNYXBgLiBTZWUgeW91ciB0cmFuc3BpbGVyJ3MgZG9jcyBmb3IgZGV0YWlsczpcbiAgICpcbiAgICogLSAoW0JhYmVsXShodHRwczovL2JhYmVsanMuaW8vZG9jcy91c2FnZS9jYXZlYXRzLyNjbGFzc2VzKSlcbiAgICogLSAoW1R5cGVTY3JpcHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0JyZWFraW5nLUNoYW5nZXMjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrKSlcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuaW5zdGFuY2VPZmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5pbnN0YW5jZW9mYC5cbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VvZlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQGFsaWFzIGluc3RhbmNlT2ZcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2VPZiAoY29uc3RydWN0b3IsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgdmFyIHRhcmdldCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgdmFyIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgdmFyIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJyk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGlzSW5zdGFuY2VPZiA9IHRhcmdldCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJ1RoZSBpbnN0YW5jZW9mIGFzc2VydGlvbiBuZWVkcyBhIGNvbnN0cnVjdG9yIGJ1dCAnXG4gICAgICAgICAgICArIF8udHlwZShjb25zdHJ1Y3RvcikgKyAnIHdhcyBnaXZlbi4nLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBfLmdldE5hbWUoY29uc3RydWN0b3IpO1xuICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICBuYW1lID0gJ2FuIHVubmFtZWQgY29uc3RydWN0b3InO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpc0luc3RhbmNlT2ZcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZW9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlT2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShuYW1lWywgdmFsWywgbXNnXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJyk7XG4gICAqXG4gICAqIFdoZW4gYHZhbGAgaXMgcHJvdmlkZWQsIGAucHJvcGVydHlgIGFsc28gYXNzZXJ0cyB0aGF0IHRoZSBwcm9wZXJ0eSdzIHZhbHVlXG4gICAqIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBgdmFsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAxKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkgaXMgdXNlZC4gQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGVcbiAgICogY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3JcbiAgICogaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIHByb3BlcnR5IGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogVGhlIHRhcmdldCdzIGVudW1lcmFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFsd2F5cyBpbmNsdWRlZFxuICAgKiBpbiB0aGUgc2VhcmNoLiBCeSBkZWZhdWx0LCBib3RoIG93biBhbmQgaW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlIGluY2x1ZGVkLlxuICAgKiBBZGQgYC5vd25gIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGV4Y2x1ZGUgaW5oZXJpdGVkIHByb3BlcnRpZXMgZnJvbSB0aGVcbiAgICogc2VhcmNoLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duLnByb3BlcnR5KCdhJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93bi5wcm9wZXJ0eSgnYScsIDEpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYicpLmJ1dC5ub3Qub3duLnByb3BlcnR5KCdiJyk7IFxuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm93bmAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5oYXZlLmRlZXAub3duLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogQWRkIGAubmVzdGVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBlbmFibGUgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiB3aGVuXG4gICAqIHJlZmVyZW5jaW5nIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzFdJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdhLmJbMV0nLCAneScpO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6ICd4J319KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnXFxcXC5hLlxcXFxbYlxcXFxdJyk7XG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAubmVzdGVkYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbe2M6IDN9XX19KVxuICAgKiAgICAgICAudG8uaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzBdJywge2M6IDN9KTtcbiAgICpcbiAgICogYC5vd25gIGFuZCBgLm5lc3RlZGAgY2Fubm90IGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqIFxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC5wcm9wZXJ0eWAgd2hlbiBwcm92aWRpbmcgYHZhbGAuIFRoZVxuICAgKiBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAsIG9yIHRoYXQgaXRcbiAgICogZG9lcyBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCBidXQgaXRzIHZhbHVlIGlzbid0IGVxdWFsIHRvXG4gICAqIHRoZSBnaXZlbiBgdmFsYC4gSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzXG4gICAqIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpc24ndCBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5XG4gICAqIGBuYW1lYCwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYScpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2EnLCAxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCxcbiAgICogaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXJcbiAgICogdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnkgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDN9KS50by5oYXZlLnByb3BlcnR5KCdhJywgMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDN9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYScsIDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5wcm9wZXJ0eWAgY2hhbmdlcyB0aGUgdGFyZ2V0IG9mIGFueSBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpblxuICAgKiB0byBiZSB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZyb20gdGhlIG9yaWdpbmFsIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJykudGhhdC5pcy5hKCdudW1iZXInKTtcbiAgICpcbiAgICogYC5wcm9wZXJ0eWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgYHZhbGAsIG9ubHkgdXNlIHRoZVxuICAgKiBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJywgMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAyKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2InLCB1bmRlZmluZWQsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogXG4gICAqIFRoZSBhYm92ZSBhc3NlcnRpb24gaXNuJ3QgdGhlIHNhbWUgdGhpbmcgYXMgbm90IHByb3ZpZGluZyBgdmFsYC4gSW5zdGVhZCxcbiAgICogaXQncyBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgYSBgYmAgcHJvcGVydHkgdGhhdCdzIGVxdWFsIHRvXG4gICAqIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBUaGUgYXNzZXJ0aW9ucyBgLm93blByb3BlcnR5YCBhbmQgYC5oYXZlT3duUHJvcGVydHlgIGNhbiBiZSB1c2VkXG4gICAqIGludGVyY2hhbmdlYWJseSB3aXRoIGAub3duLnByb3BlcnR5YC5cbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsIChvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEByZXR1cm5zIHZhbHVlIG9mIHByb3BlcnR5IGZvciBjaGFpbmluZ1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRQcm9wZXJ0eSAobmFtZSwgdmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBpc05lc3RlZCA9IGZsYWcodGhpcywgJ25lc3RlZCcpXG4gICAgICAsIGlzT3duID0gZmxhZyh0aGlzLCAnb3duJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuXG4gICAgaWYgKGlzTmVzdGVkICYmIGlzT3duKSB7XG4gICAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgIGZsYWdNc2cgKyAnVGhlIFwibmVzdGVkXCIgYW5kIFwib3duXCIgZmxhZ3MgY2Fubm90IGJlIGNvbWJpbmVkLicsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgc3NmaVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgIGZsYWdNc2cgKyAnVGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHNzZmlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGlzRGVlcCA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKVxuICAgICAgLCBwYXRoSW5mbyA9IGlzTmVzdGVkID8gXy5nZXRQYXRoSW5mbyhvYmosIG5hbWUpIDogbnVsbFxuICAgICAgLCB2YWx1ZSA9IGlzTmVzdGVkID8gcGF0aEluZm8udmFsdWUgOiBvYmpbbmFtZV07XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9ICcnO1xuICAgIGlmIChpc0RlZXApIGRlc2NyaXB0b3IgKz0gJ2RlZXAgJztcbiAgICBpZiAoaXNPd24pIGRlc2NyaXB0b3IgKz0gJ293biAnO1xuICAgIGlmIChpc05lc3RlZCkgZGVzY3JpcHRvciArPSAnbmVzdGVkICc7XG4gICAgZGVzY3JpcHRvciArPSAncHJvcGVydHkgJztcblxuICAgIHZhciBoYXNQcm9wZXJ0eTtcbiAgICBpZiAoaXNPd24pIGhhc1Byb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgbmFtZSk7XG4gICAgZWxzZSBpZiAoaXNOZXN0ZWQpIGhhc1Byb3BlcnR5ID0gcGF0aEluZm8uZXhpc3RzO1xuICAgIGVsc2UgaGFzUHJvcGVydHkgPSBfLmhhc1Byb3BlcnR5KG9iaiwgbmFtZSk7XG5cbiAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBuZWdhdGVkIGFzc2VydGlvbiBmb3IgYm90aCBuYW1lIGFuZCB2YWwsIG1lcmVseSBoYXZpbmdcbiAgICAvLyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgaXNuJ3QgZW5vdWdoIHRvIGNhdXNlIHRoZSBhc3NlcnRpb24gdG9cbiAgICAvLyBmYWlsLiBJdCBtdXN0IGJvdGggaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGF0IHByb3BlcnR5IG11c3QgZXF1YWwgdGhlIGdpdmVuIHZhbC4gVGhlcmVmb3JlLCBza2lwIHRoaXMgYXNzZXJ0aW9uIGluXG4gICAgLy8gZmF2b3Igb2YgdGhlIG5leHQuXG4gICAgaWYgKCFuZWdhdGUgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaGFzUHJvcGVydHlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaGFzUHJvcGVydHkgJiYgKGlzRGVlcCA/IF8uZXFsKHZhbCwgdmFsdWUpIDogdmFsID09PSB2YWx1ZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2V4cH0sIGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2FjdH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdmFsdWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsdWUpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncHJvcGVydHknLCBhc3NlcnRQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHkgKG5hbWUsIHZhbHVlLCBtc2cpIHtcbiAgICBmbGFnKHRoaXMsICdvd24nLCB0cnVlKTtcbiAgICBhc3NlcnRQcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eURlc2NyaXB0b3IobmFtZVssIGRlc2NyaXB0b3JbLCBtc2ddXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGl0cyBvd24gcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICogYG5hbWVgLiBFbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCBpbiB0aGVcbiAgICogc2VhcmNoLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnKTtcbiAgICpcbiAgICogV2hlbiBgZGVzY3JpcHRvcmAgaXMgcHJvdmlkZWQsIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYCBhbHNvIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgcHJvcGVydHkncyBkZXNjcmlwdG9yIGlzIGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYGRlc2NyaXB0b3JgLiBTZWVcbiAgICogdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMSxcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2InKTtcbiAgICogXG4gICAqIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIG5lZ2F0ZSBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgd2hlbiBwcm92aWRpbmdcbiAgICogYSBgZGVzY3JpcHRvcmAuIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5XG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBhIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aFxuICAgKiB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCwgb3IgdGhhdCBpdCBkb2VzIGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlXG4gICAqIGdpdmVuIGtleSBgbmFtZWAgYnV0IGl0cyBub3QgZGVlcGx5IGVxdWFsIHRvIHRoZSBnaXZlbiBgZGVzY3JpcHRvcmAuIEl0J3NcbiAgICogb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW5cbiAgICogYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gaGF2ZSBhIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aCB0aGUgZ2l2ZW5cbiAgICoga2V5IGBuYW1lYCwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8ubm90LmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDEsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlIGdpdmVuXG4gICAqIGtleSBgbmFtZWAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcHJvcGVydHkgaGFzIGl0cyBleHBlY3RlZFxuICAgKiBkZXNjcmlwdG9yLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnlcbiAgICogdW5leHBlY3RlZCBkZXNjcmlwdG9ycy5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDN9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDMsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8ubm90LmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMSxcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgY2hhbmdlcyB0aGUgdGFyZ2V0IG9mIGFueSBhc3NlcnRpb25zIHRoYXQgZm9sbG93XG4gICAqIGluIHRoZSBjaGFpbiB0byBiZSB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICogdGFyZ2V0IG9iamVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJylcbiAgICogICAgICAgLnRoYXQuaGFzLnByb3BlcnR5KCdlbnVtZXJhYmxlJywgdHJ1ZSk7XG4gICAqXG4gICAqIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGFcbiAgICogY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvXG4gICAqIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZ1xuICAgKiBgZGVzY3JpcHRvcmAsIG9ubHkgdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDIsXG4gICAqICAgICB9LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMixcbiAgICogICAgIH0pO1xuICAgKiBcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSlcbiAgICogICAgICAgLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdiJywgdW5kZWZpbmVkLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqIFRoZSBhYm92ZSBhc3NlcnRpb24gaXNuJ3QgdGhlIHNhbWUgdGhpbmcgYXMgbm90IHByb3ZpZGluZyBgZGVzY3JpcHRvcmAuXG4gICAqIEluc3RlYWQsIGl0J3MgYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgaGFzIGEgYGJgIHByb3BlcnR5XG4gICAqIGRlc2NyaXB0b3IgdGhhdCdzIGRlZXBseSBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogVGhlIGFsaWFzIGAuaGF2ZU93blByb3BlcnR5RGVzY3JpcHRvcmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgLlxuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yIChuYW1lLCBkZXNjcmlwdG9yLCBtc2cpIHtcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBkZXNjcmlwdG9yO1xuICAgICAgZGVzY3JpcHRvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgYWN0dWFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0KG9iaiksIG5hbWUpO1xuICAgIGlmIChhY3R1YWxEZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIF8uZXFsKGRlc2NyaXB0b3IsIGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpICsgJywgZ290ICcgKyBfLmluc3BlY3QoYWN0dWFsRGVzY3JpcHRvcilcbiAgICAgICAgLCAnZXhwZWN0ZWQgdGhlIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvbiAje3RoaXN9IHRvIG5vdCBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpXG4gICAgICAgICwgZGVzY3JpcHRvclxuICAgICAgICAsIGFjdHVhbERlc2NyaXB0b3JcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGFuIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICApO1xuICAgIH1cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWxEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5RGVzY3JpcHRvcicsIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvcik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXJcbiAgICogYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5sZW5ndGhPZmAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLCByYXRoZXIgdGhhbiBub3QgZXF1YWwgdG8gb25lIG9mIG1hbnkgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5oYXZlLmxlbmd0aE9mKDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5sZW5ndGhPZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5sZW5ndGhPZigyKTtcbiAgICpcbiAgICogYC5sZW5ndGhPZmAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluLCBjYXVzaW5nIGFsbCBgLmFib3ZlYCxcbiAgICogYC5iZWxvd2AsIGAubGVhc3RgLCBgLm1vc3RgLCBhbmQgYC53aXRoaW5gIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlXG4gICAqIGNoYWluIHRvIHVzZSB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgYXMgdGhlIHRhcmdldC4gSG93ZXZlciwgaXQnc1xuICAgKiBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBlcXVhbCB0byBpdHNcbiAgICogZXhwZWN0ZWQgbGVuZ3RoLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdHMgYGxlbmd0aGAgcHJvcGVydHkgZmFsbHNcbiAgICogd2l0aGluIHNvbWUgcmFuZ2Ugb2YgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hdC5sZWFzdCgzKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubW9zdCgzKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsNCk7XG4gICAqXG4gICAqIER1ZSB0byBhIGNvbXBhdGliaWxpdHkgaXNzdWUsIHRoZSBhbGlhcyBgLmxlbmd0aGAgY2FuJ3QgYmUgY2hhaW5lZCBkaXJlY3RseVxuICAgKiBvZmYgb2YgYW4gdW5pbnZva2VkIG1ldGhvZCBzdWNoIGFzIGAuYWAuIFRoZXJlZm9yZSwgYC5sZW5ndGhgIGNhbid0IGJlIHVzZWRcbiAgICogaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5sZW5ndGhPZmAgaW4gZXZlcnkgc2l0dWF0aW9uLiBJdCdzIHJlY29tbWVuZGVkIHRvXG4gICAqIGFsd2F5cyB1c2UgYC5sZW5ndGhPZmAgaW5zdGVhZCBvZiBgLmxlbmd0aGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmEubGVuZ3RoKDMpOyAvLyBpbmNvbXBhdGlibGU7IHRocm93cyBlcnJvclxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5hLmxlbmd0aE9mKDMpOyAgLy8gcGFzc2VzIGFzIGV4cGVjdGVkXG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBhbGlhcyBsZW5ndGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aENoYWluICgpIHtcbiAgICBmbGFnKHRoaXMsICdkb0xlbmd0aCcsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsZW4gPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGxlblxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnbGVuZ3RoT2YnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaChyZVssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG1hdGNoZXMgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5tYXRjaCgvXmZvby8pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm1hdGNoYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubm90Lm1hdGNoKC90YWNvLyk7XG4gICAqXG4gICAqIGAubWF0Y2hgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL3RhY28vLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicsICdub29vIHdoeSBmYWlsPz8nKS50by5tYXRjaCgvdGFjby8pO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5tYXRjaGVzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLm1hdGNoYC5cbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQGFsaWFzIG1hdGNoZXNcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0TWF0Y2gocmUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmUuZXhlYyhvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG1hdGNoICcgKyByZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gbWF0Y2ggJyArIHJlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21hdGNoJywgYXNzZXJ0TWF0Y2gpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaGVzJywgYXNzZXJ0TWF0Y2gpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmluZyhzdHJbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBzdHJpbmcgY29udGFpbnMgdGhlIGdpdmVuIHN1YnN0cmluZyBgc3RyYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoJ2JhcicpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnN0cmluZ2AuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm5vdC5oYXZlLnN0cmluZygndGFjbycpO1xuICAgKlxuICAgKiBgLnN0cmluZ2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLnN0cmluZygvdGFjby8sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJywgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUuc3RyaW5nKC90YWNvLyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzdHJpbmcnLCBmdW5jdGlvbiAoc3RyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdzdHJpbmcnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB+b2JqLmluZGV4T2Yoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5rZXlzKGtleTFbLCBrZXkyWywgLi4uXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG9iamVjdCwgYXJyYXksIG1hcCwgb3Igc2V0IGhhcyB0aGUgZ2l2ZW4ga2V5cy4gT25seVxuICAgKiB0aGUgdGFyZ2V0J3Mgb3duIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2VhcmNoLiBcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdCBvciBhcnJheSwga2V5cyBjYW4gYmUgcHJvdmlkZWQgYXMgb25lIG9yIG1vcmVcbiAgICogc3RyaW5nIGFyZ3VtZW50cywgYSBzaW5nbGUgYXJyYXkgYXJndW1lbnQsIG9yIGEgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4gSW5cbiAgICogdGhlIGxhdHRlciBjYXNlLCBvbmx5IHRoZSBrZXlzIGluIHRoZSBnaXZlbiBvYmplY3QgbWF0dGVyOyB0aGUgdmFsdWVzIGFyZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3QoWyd4JywgJ3knXSkudG8uaGF2ZS5hbGwua2V5cygwLCAxKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoWydhJywgJ2InXSk7XG4gICAqICAgICBleHBlY3QoWyd4JywgJ3knXSkudG8uaGF2ZS5hbGwua2V5cyhbMCwgMV0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cyh7YTogNCwgYjogNX0pOyAvLyBpZ25vcmUgNCBhbmQgNVxuICAgKiAgICAgZXhwZWN0KFsneCcsICd5J10pLnRvLmhhdmUuYWxsLmtleXMoezA6IDQsIDE6IDV9KTsgLy8gaWdub3JlIDQgYW5kIDVcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbWFwIG9yIHNldCwgZWFjaCBrZXkgbXVzdCBiZSBwcm92aWRlZCBhcyBhIHNlcGFyYXRlXG4gICAqIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXV0pKS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsnYScsICdiJ10pKS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQmVjYXVzZSBgLmtleXNgIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZSwgaXQnc1xuICAgKiBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlIHVzaW5nIGAua2V5c2AuIFNlZSB0aGUgYC5hYCBkb2NcbiAgICogZm9yIGluZm8gb24gdGVzdGluZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5iZS5hbignb2JqZWN0JykudGhhdC5oYXMuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkIHRvIGNvbXBhcmUga2V5cyBvZiBtYXBzIGFuZFxuICAgKiBzZXRzLiBBZGQgYC5kZWVwYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkLiBTZWVcbiAgICogdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBzZXQgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMga2V5IGB7YTogMX1gXG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLmhhdmUuYWxsLmRlZXAua2V5cyhbe2E6IDF9XSk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLm5vdC5oYXZlLmFsbC5rZXlzKFt7YTogMX1dKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHRhcmdldCBtdXN0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzIGFuZCBubyBtb3JlLiBBZGRcbiAgICogYC5hbnlgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG9ubHkgcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdFxuICAgKiBvbmUgb2YgdGhlIGdpdmVuIGtleXMuIEFsc28sIGFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlXG4gICAqIGAua2V5c2AuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBhZGQgYC5hbnlgIHdoZW4gbmVnYXRpbmcgYC5rZXlzYCwgYW5kIHRvIHVzZVxuICAgKiBgLmFsbGAgd2hlbiBhc3NlcnRpbmcgYC5rZXlzYCB3aXRob3V0IG5lZ2F0aW9uLlxuICAgKlxuICAgKiBXaGVuIG5lZ2F0aW5nIGAua2V5c2AsIGAuYW55YCBpcyBwcmVmZXJyZWQgYmVjYXVzZSBgLm5vdC5hbnkua2V5c2AgYXNzZXJ0c1xuICAgKiBleGFjdGx5IHdoYXQncyBleHBlY3RlZCBvZiB0aGUgb3V0cHV0LCB3aGVyZWFzIGAubm90LmFsbC5rZXlzYCBjcmVhdGVzXG4gICAqIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBkb2Vzbid0IGhhdmUgYW55IG9mIHRoZSBnaXZlbiBrZXlzXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5ub3QuaGF2ZS5hbnkua2V5cygnYycsICdkJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgZG9lc24ndCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW5cbiAgICogICAgIC8vIGtleXMgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgc29tZSBvZiB0aGVtXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5ub3QuaGF2ZS5hbGwua2V5cygnYycsICdkJyk7XG4gICAqXG4gICAqIFdoZW4gYXNzZXJ0aW5nIGAua2V5c2Agd2l0aG91dCBuZWdhdGlvbiwgYC5hbGxgIGlzIHByZWZlcnJlZCBiZWNhdXNlXG4gICAqIGAuYWxsLmtleXNgIGFzc2VydHMgZXhhY3RseSB3aGF0J3MgZXhwZWN0ZWQgb2YgdGhlIG91dHB1dCwgd2hlcmVhc1xuICAgKiBgLmFueS5rZXlzYCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBoYXMgYWxsIHRoZSBnaXZlbiBrZXlzXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlblxuICAgKiAgICAgLy8ga2V5cyBidXQgbWF5IG9yIG1heSBub3QgaGF2ZSBtb3JlIG9mIHRoZW1cbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYC5hbGxgIGlzIHVzZWQgYnkgZGVmYXVsdCB3aGVuIG5laXRoZXIgYC5hbGxgIG5vciBgLmFueWAgYXBwZWFyXG4gICAqIGVhcmxpZXIgaW4gdGhlIGNoYWluLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYWRkIGAuYWxsYCBhbnl3YXkgYmVjYXVzZVxuICAgKiBpdCBpbXByb3ZlcyByZWFkYWJpbGl0eS5cbiAgICpcbiAgICogICAgIC8vIEJvdGggYXNzZXJ0aW9ucyBhcmUgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUua2V5cygnYScsICdiJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5pbmNsdWRlYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCdzIGtleXMgYmUgYVxuICAgKiBzdXBlcnNldCBvZiB0aGUgZXhwZWN0ZWQga2V5cywgcmF0aGVyIHRoYW4gaWRlbnRpY2FsIHNldHMuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0J3Mga2V5cyBhcmUgYSBzdXBlcnNldCBvZiBbJ2EnLCAnYiddIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5pbmNsdWRlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLm5vdC5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogSG93ZXZlciwgaWYgYC5hbnlgIGFuZCBgLmluY2x1ZGVgIGFyZSBjb21iaW5lZCwgb25seSB0aGUgYC5hbnlgIHRha2VzXG4gICAqIGVmZmVjdC4gVGhlIGAuaW5jbHVkZWAgaXMgaWdub3JlZCBpbiB0aGlzIGNhc2UuXG4gICAqXG4gICAqICAgICAvLyBCb3RoIGFzc2VydGlvbnMgYXJlIGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLmtleSgnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5rZXlgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAua2V5c2AuXG4gICAqXG4gICAqIEBuYW1lIGtleXNcbiAgICogQGFsaWFzIGtleVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ3xBcnJheXxPYmplY3R9IGtleXNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0S2V5cyAoa2V5cykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iailcbiAgICAgICwga2V5c1R5cGUgPSBfLnR5cGUoa2V5cylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBpc0RlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgc3RyXG4gICAgICAsIGRlZXBTdHIgPSAnJ1xuICAgICAgLCBvayA9IHRydWVcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKTtcblxuICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcbiAgICB2YXIgbWl4ZWRBcmdzTXNnID0gZmxhZ01zZyArICd3aGVuIHRlc3Rpbmcga2V5cyBhZ2FpbnN0IGFuIG9iamVjdCBvciBhbiBhcnJheSB5b3UgbXVzdCBnaXZlIGEgc2luZ2xlIEFycmF5fE9iamVjdHxTdHJpbmcgYXJndW1lbnQgb3IgbXVsdGlwbGUgU3RyaW5nIGFyZ3VtZW50cyc7XG5cbiAgICBpZiAob2JqVHlwZSA9PT0gJ01hcCcgfHwgb2JqVHlwZSA9PT0gJ1NldCcpIHtcbiAgICAgIGRlZXBTdHIgPSBpc0RlZXAgPyAnZGVlcGx5ICcgOiAnJztcbiAgICAgIGFjdHVhbCA9IFtdO1xuXG4gICAgICAvLyBNYXAgYW5kIFNldCAnLmtleXMnIGFyZW4ndCBzdXBwb3J0ZWQgaW4gSUUgMTEuIFRoZXJlZm9yZSwgdXNlIC5mb3JFYWNoLlxuICAgICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7IGFjdHVhbC5wdXNoKGtleSkgfSk7XG5cbiAgICAgIGlmIChrZXlzVHlwZSAhPT0gJ0FycmF5Jykge1xuICAgICAgICBrZXlzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBhY3R1YWwgPSBfLmdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzKG9iaik7XG5cbiAgICAgIHN3aXRjaCAoa2V5c1R5cGUpIHtcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1peGVkQXJnc01zZywgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobWl4ZWRBcmdzTXNnLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAga2V5cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgc3RyaW5naWZ5IG5vbi1TeW1ib2xzIGJlY2F1c2UgU3ltYm9scyB3b3VsZCBiZWNvbWUgXCJTeW1ib2woKVwiXG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCcgPyB2YWwgOiBTdHJpbmcodmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihmbGFnTXNnICsgJ2tleXMgcmVxdWlyZWQnLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aFxuICAgICAgLCBhbnkgPSBmbGFnKHRoaXMsICdhbnknKVxuICAgICAgLCBhbGwgPSBmbGFnKHRoaXMsICdhbGwnKVxuICAgICAgLCBleHBlY3RlZCA9IGtleXNcbiAgICAgICwgYWN0dWFsO1xuXG4gICAgaWYgKCFhbnkgJiYgIWFsbCkge1xuICAgICAgYWxsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYW55XG4gICAgaWYgKGFueSkge1xuICAgICAgb2sgPSBleHBlY3RlZC5zb21lKGZ1bmN0aW9uKGV4cGVjdGVkS2V5KSB7XG4gICAgICAgIHJldHVybiBhY3R1YWwuc29tZShmdW5jdGlvbihhY3R1YWxLZXkpIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5lcWwoZXhwZWN0ZWRLZXksIGFjdHVhbEtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZEtleSA9PT0gYWN0dWFsS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYWxsXG4gICAgaWYgKGFsbCkge1xuICAgICAgb2sgPSBleHBlY3RlZC5ldmVyeShmdW5jdGlvbihleHBlY3RlZEtleSkge1xuICAgICAgICByZXR1cm4gYWN0dWFsLnNvbWUoZnVuY3Rpb24oYWN0dWFsS2V5KSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXFsKGV4cGVjdGVkS2V5LCBhY3R1YWxLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWRLZXkgPT09IGFjdHVhbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgICBvayA9IG9rICYmIGtleXMubGVuZ3RoID09IGFjdHVhbC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gS2V5IHN0cmluZ1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfLmluc3BlY3Qoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgaWYgKGFsbCkge1xuICAgICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBhbmQgJyArIGxhc3Q7XG4gICAgICB9XG4gICAgICBpZiAoYW55KSB7XG4gICAgICAgIHN0ciA9IGtleXMuam9pbignLCAnKSArICcsIG9yICcgKyBsYXN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBfLmluc3BlY3Qoa2V5c1swXSk7XG4gICAgfVxuXG4gICAgLy8gRm9ybVxuICAgIHN0ciA9IChsZW4gPiAxID8gJ2tleXMgJyA6ICdrZXkgJykgKyBzdHI7XG5cbiAgICAvLyBIYXZlIC8gaW5jbHVkZVxuICAgIHN0ciA9IChmbGFnKHRoaXMsICdjb250YWlucycpID8gJ2NvbnRhaW4gJyA6ICdoYXZlICcpICsgc3RyO1xuXG4gICAgLy8gQXNzZXJ0aW9uXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9rXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvICcgKyBkZWVwU3RyICsgc3RyXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCAnICsgZGVlcFN0ciArIHN0clxuICAgICAgLCBleHBlY3RlZC5zbGljZSgwKS5zb3J0KF8uY29tcGFyZUJ5SW5zcGVjdClcbiAgICAgICwgYWN0dWFsLnNvcnQoXy5jb21wYXJlQnlJbnNwZWN0KVxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleXMnLCBhc3NlcnRLZXlzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5JywgYXNzZXJ0S2V5cyk7XG5cbiAgLyoqXG4gICAqICMjIyAudGhyb3coW2Vycm9yTGlrZV0sIFtlcnJNc2dNYXRjaGVyXSwgW21zZ10pXG4gICAqXG4gICAqIFdoZW4gbm8gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYC50aHJvd2AgaW52b2tlcyB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZFxuICAgKiBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKiBcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KCk7XG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBhbmQgaXQncyBhbiBlcnJvciBjb25zdHJ1Y3RvciwgYC50aHJvd2BcbiAgICogaW52b2tlcyB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHRoYXQncyBhblxuICAgKiBpbnN0YW5jZSBvZiB0aGF0IGVycm9yIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGFuIGVycm9yIGluc3RhbmNlLCBgLnRocm93YCBpbnZva2VzXG4gICAqIHRoZSB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gdGhhdCdzIHN0cmljdGx5XG4gICAqIChgPT09YCkgZXF1YWwgdG8gdGhhdCBlcnJvciBpbnN0YW5jZS5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhlcnIpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYSBzdHJpbmcsIGAudGhyb3dgIGludm9rZXMgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB3aXRoIGEgbWVzc2FnZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoYXQgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coJ3NhbG1vbicpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYSByZWd1bGFyIGV4cHJlc3Npb24sIGAudGhyb3dgXG4gICAqIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB3aXRoIGFcbiAgICogbWVzc2FnZSB0aGF0IG1hdGNoZXMgdGhhdCByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdygvc2FsbW9uLyk7XG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGFuZCB0aGUgZmlyc3QgaXMgYW4gZXJyb3IgaW5zdGFuY2Ugb3JcbiAgICogY29uc3RydWN0b3IsIGFuZCB0aGUgc2Vjb25kIGlzIGEgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYC50aHJvd2BcbiAgICogaW52b2tlcyB0aGUgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gdGhhdCBmdWxmaWxscyBib3RoXG4gICAqIGNvbmRpdGlvbnMgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpO1xuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3NhbG1vbicpO1xuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IsIC9zYWxtb24vKTtcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coZXJyLCAnc2FsbW9uJyk7XG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KGVyciwgL3NhbG1vbi8pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnRocm93YC5cbiAgICogICAgIFxuICAgKiAgICAgdmFyIGdvb2RGbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KCk7XG4gICAqIFxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC50aHJvd2Agd2hlbiBwcm92aWRpbmcgYW55IGFyZ3VtZW50cy5cbiAgICogVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlXG4gICAqIHRhcmdldCBlaXRoZXIgZG9lc24ndCB0aHJvdyBhbiBlcnJvciwgb3IgdGhhdCBpdCB0aHJvd3MgYW4gZXJyb3IgYnV0IG9mIGFcbiAgICogZGlmZmVyZW50IHR5cGUgdGhhbiB0aGUgZ2l2ZW4gdHlwZSwgb3IgdGhhdCBpdCB0aHJvd3MgYW4gZXJyb3Igb2YgdGhlIGdpdmVuXG4gICAqIHR5cGUgYnV0IHdpdGggYSBtZXNzYWdlIHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoZSBnaXZlbiBzdHJpbmcuIEl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW5cbiAgICogYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3IsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIGdvb2RGbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coUmVmZXJlbmNlRXJyb3IsICd4Jyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3IsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogdGhhdCB0aGUgZXJyb3IgaXMgb2YgaXRzIGV4cGVjdGVkIHR5cGUsIGFuZCBoYXMgYSBtZXNzYWdlIHRoYXQgaW5jbHVkZXMgYW5cbiAgICogZXhwZWN0ZWQgc3RyaW5nLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnlcbiAgICogdW5leHBlY3RlZCB0eXBlcywgYW5kIGRvZXNuJ3QgaGF2ZSBhIG1lc3NhZ2UgdGhhdCBpbmNsdWRlcyBzb21lIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3NhbG1vbicpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by5ub3QudGhyb3coUmVmZXJlbmNlRXJyb3IsICd4Jyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLnRocm93YCBjaGFuZ2VzIHRoZSB0YXJnZXQgb2YgYW55IGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvXG4gICAqIGJlIHRoZSBlcnJvciBvYmplY3QgdGhhdCdzIHRocm93bi5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIGVyci5jb2RlID0gNDI7XG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yKS53aXRoLnByb3BlcnR5KCdjb2RlJywgNDIpO1xuICAgKlxuICAgKiBgLnRocm93YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXMgdXNlXG4gICAqIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3gnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoZ29vZEZuLCAnbm9vbyB3aHkgZmFpbD8/JykudG8udGhyb3coKTtcbiAgICpcbiAgICogRHVlIHRvIGxpbWl0YXRpb25zIGluIEVTNSwgYC50aHJvd2AgbWF5IG5vdCBhbHdheXMgd29yayBhcyBleHBlY3RlZCB3aGVuXG4gICAqIHVzaW5nIGEgdHJhbnNwaWxlciBzdWNoIGFzIEJhYmVsIG9yIFR5cGVTY3JpcHQuIEluIHBhcnRpY3VsYXIsIGl0IG1heVxuICAgKiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aGVuIHN1YmNsYXNzaW5nIHRoZSBidWlsdC1pbiBgRXJyb3JgIG9iamVjdCBhbmRcbiAgICogdGhlbiBwYXNzaW5nIHRoZSBzdWJjbGFzc2VkIGNvbnN0cnVjdG9yIHRvIGAudGhyb3dgLiBTZWUgeW91ciB0cmFuc3BpbGVyJ3NcbiAgICogZG9jcyBmb3IgZGV0YWlsczpcbiAgICpcbiAgICogLSAoW0JhYmVsXShodHRwczovL2JhYmVsanMuaW8vZG9jcy91c2FnZS9jYXZlYXRzLyNjbGFzc2VzKSlcbiAgICogLSAoW1R5cGVTY3JpcHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0JyZWFraW5nLUNoYW5nZXMjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrKSlcbiAgICpcbiAgICogQmV3YXJlIG9mIHNvbWUgY29tbW9uIG1pc3Rha2VzIHdoZW4gdXNpbmcgdGhlIGB0aHJvd2AgYXNzZXJ0aW9uLiBPbmUgY29tbW9uXG4gICAqIG1pc3Rha2UgaXMgdG8gYWNjaWRlbnRhbGx5IGludm9rZSB0aGUgZnVuY3Rpb24geW91cnNlbGYgaW5zdGVhZCBvZiBsZXR0aW5nXG4gICAqIHRoZSBgdGhyb3dgIGFzc2VydGlvbiBpbnZva2UgdGhlIGZ1bmN0aW9uIGZvciB5b3UuIEZvciBleGFtcGxlLCB3aGVuXG4gICAqIHRlc3RpbmcgaWYgYSBmdW5jdGlvbiBuYW1lZCBgZm5gIHRocm93cywgcHJvdmlkZSBgZm5gIGluc3RlYWQgb2YgYGZuKClgIGFzXG4gICAqIHRoZSB0YXJnZXQgZm9yIHRoZSBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KCk7ICAgICAvLyBHb29kISBUZXN0cyBgZm5gIGFzIGRlc2lyZWRcbiAgICogICAgIGV4cGVjdChmbigpKS50by50aHJvdygpOyAgIC8vIEJhZCEgVGVzdHMgcmVzdWx0IG9mIGBmbigpYCwgbm90IGBmbmBcbiAgICpcbiAgICogSWYgeW91IG5lZWQgdG8gYXNzZXJ0IHRoYXQgeW91ciBmdW5jdGlvbiBgZm5gIHRocm93cyB3aGVuIHBhc3NlZCBjZXJ0YWluXG4gICAqIGFyZ3VtZW50cywgdGhlbiB3cmFwIGEgY2FsbCB0byBgZm5gIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHsgZm4oNDIpOyB9KS50by50aHJvdygpOyAgLy8gRnVuY3Rpb24gZXhwcmVzc2lvblxuICAgKiAgICAgZXhwZWN0KCgpID0+IGZuKDQyKSkudG8udGhyb3coKTsgICAgICAgICAgICAgLy8gRVM2IGFycm93IGZ1bmN0aW9uXG4gICAqXG4gICAqIEFub3RoZXIgY29tbW9uIG1pc3Rha2UgaXMgdG8gcHJvdmlkZSBhbiBvYmplY3QgbWV0aG9kIChvciBhbnkgc3RhbmQtYWxvbmVcbiAgICogZnVuY3Rpb24gdGhhdCByZWxpZXMgb24gYHRoaXNgKSBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBhc3NlcnRpb24uIERvaW5nIHNvIGlzXG4gICAqIHByb2JsZW1hdGljIGJlY2F1c2UgdGhlIGB0aGlzYCBjb250ZXh0IHdpbGwgYmUgbG9zdCB3aGVuIHRoZSBmdW5jdGlvbiBpc1xuICAgKiBpbnZva2VkIGJ5IGAudGhyb3dgOyB0aGVyZSdzIG5vIHdheSBmb3IgaXQgdG8ga25vdyB3aGF0IGB0aGlzYCBpcyBzdXBwb3NlZFxuICAgKiB0byBiZS4gVGhlcmUgYXJlIHR3byB3YXlzIGFyb3VuZCB0aGlzIHByb2JsZW0uIE9uZSBzb2x1dGlvbiBpcyB0byB3cmFwIHRoZVxuICAgKiBtZXRob2Qgb3IgZnVuY3Rpb24gY2FsbCBpbnNpZGUgb2YgYW5vdGhlciBmdW5jdGlvbi4gQW5vdGhlciBzb2x1dGlvbiBpcyB0b1xuICAgKiB1c2UgYGJpbmRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHsgY2F0Lm1lb3coKTsgfSkudG8udGhyb3coKTsgIC8vIEZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICogICAgIGV4cGVjdCgoKSA9PiBjYXQubWVvdygpKS50by50aHJvdygpOyAgICAgICAgICAgICAvLyBFUzYgYXJyb3cgZnVuY3Rpb25cbiAgICogICAgIGV4cGVjdChjYXQubWVvdy5iaW5kKGNhdCkpLnRvLnRocm93KCk7ICAgICAgICAgICAvLyBCaW5kXG4gICAqXG4gICAqIEZpbmFsbHksIGl0J3Mgd29ydGggbWVudGlvbmluZyB0aGF0IGl0J3MgYSBiZXN0IHByYWN0aWNlIGluIEphdmFTY3JpcHQgdG9cbiAgICogb25seSB0aHJvdyBgRXJyb3JgIGFuZCBkZXJpdmF0aXZlcyBvZiBgRXJyb3JgIHN1Y2ggYXMgYFJlZmVyZW5jZUVycm9yYCxcbiAgICogYFR5cGVFcnJvcmAsIGFuZCB1c2VyLWRlZmluZWQgb2JqZWN0cyB0aGF0IGV4dGVuZCBgRXJyb3JgLiBObyBvdGhlciB0eXBlIG9mXG4gICAqIHZhbHVlIHdpbGwgZ2VuZXJhdGUgYSBzdGFjayB0cmFjZSB3aGVuIGluaXRpYWxpemVkLiBXaXRoIHRoYXQgc2FpZCwgdGhlXG4gICAqIGB0aHJvd2AgYXNzZXJ0aW9uIGRvZXMgdGVjaG5pY2FsbHkgc3VwcG9ydCBhbnkgdHlwZSBvZiB2YWx1ZSBiZWluZyB0aHJvd24sXG4gICAqIG5vdCBqdXN0IGBFcnJvcmAgYW5kIGl0cyBkZXJpdmF0aXZlcy5cbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC50aHJvd3NgIGFuZCBgLlRocm93YCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aFxuICAgKiBgLnRocm93YC5cbiAgICpcbiAgICogQG5hbWUgdGhyb3dcbiAgICogQGFsaWFzIHRocm93c1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtFcnJvcnxFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2VcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBlcnJNc2dNYXRjaGVyIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQHJldHVybnMgZXJyb3IgZm9yIGNoYWluaW5nIChudWxsIGlmIG5vIGVycm9yKVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRUaHJvd3MgKGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKSB8fCBmYWxzZTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIGVycm9yTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjYXVnaHRFcnI7XG4gICAgdHJ5IHtcbiAgICAgIG9iaigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2F1Z2h0RXJyID0gZXJyO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdGhlIG5lZ2F0ZSBmbGFnIGVuYWJsZWQgYW5kIGF0IGxlYXN0IG9uZSB2YWxpZCBhcmd1bWVudCBpdCBtZWFucyB3ZSBkbyBleHBlY3QgYW4gZXJyb3JcbiAgICAvLyBidXQgd2Ugd2FudCBpdCB0byBtYXRjaCBhIGdpdmVuIHNldCBvZiBjcml0ZXJpYVxuICAgIHZhciBldmVyeUFyZ0lzVW5kZWZpbmVkID0gZXJyb3JMaWtlID09PSB1bmRlZmluZWQgJiYgZXJyTXNnTWF0Y2hlciA9PT0gdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgd2UndmUgZ290IHRoZSBuZWdhdGUgZmxhZyBlbmFibGVkIGFuZCBib3RoIGFyZ3MsIHdlIHNob3VsZCBvbmx5IGZhaWwgaWYgYm90aCBhcmVuJ3QgY29tcGF0aWJsZVxuICAgIC8vIFNlZSBJc3N1ZSAjNTUxIGFuZCBQUiAjNjgzQEdpdEh1YlxuICAgIHZhciBldmVyeUFyZ0lzRGVmaW5lZCA9IEJvb2xlYW4oZXJyb3JMaWtlICYmIGVyck1zZ01hdGNoZXIpO1xuICAgIHZhciBlcnJvckxpa2VGYWlsID0gZmFsc2U7XG4gICAgdmFyIGVyck1zZ01hdGNoZXJGYWlsID0gZmFsc2U7XG5cbiAgICAvLyBDaGVja2luZyBpZiBlcnJvciB3YXMgdGhyb3duXG4gICAgaWYgKGV2ZXJ5QXJnSXNVbmRlZmluZWQgfHwgIWV2ZXJ5QXJnSXNVbmRlZmluZWQgJiYgIW5lZ2F0ZSkge1xuICAgICAgLy8gV2UgbmVlZCB0aGlzIHRvIGRpc3BsYXkgcmVzdWx0cyBjb3JyZWN0bHkgYWNjb3JkaW5nIHRvIHRoZWlyIHR5cGVzXG4gICAgICB2YXIgZXJyb3JMaWtlU3RyaW5nID0gJ2FuIGVycm9yJztcbiAgICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBlcnJvckxpa2VTdHJpbmcgPSAnI3tleHB9JztcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3JMaWtlKSB7XG4gICAgICAgIGVycm9yTGlrZVN0cmluZyA9IF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgY2F1Z2h0RXJyXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgJyArIGVycm9yTGlrZVN0cmluZ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyBhbiBlcnJvciBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICwgZXJyb3JMaWtlICYmIGVycm9yTGlrZS50b1N0cmluZygpXG4gICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID9cbiAgICAgICAgICAgIGNhdWdodEVyci50b1N0cmluZygpIDogKHR5cGVvZiBjYXVnaHRFcnIgPT09ICdzdHJpbmcnID8gY2F1Z2h0RXJyIDogY2F1Z2h0RXJyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGNhdWdodEVycikpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JMaWtlICYmIGNhdWdodEVycikge1xuICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgaW5zdGFuY2VzIG9ubHkgaWYgYGVycm9yTGlrZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYEVycm9yYFxuICAgICAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHZhciBpc0NvbXBhdGlibGVJbnN0YW5jZSA9IF8uY2hlY2tFcnJvci5jb21wYXRpYmxlSW5zdGFuY2UoY2F1Z2h0RXJyLCBlcnJvckxpa2UpO1xuXG4gICAgICAgIGlmIChpc0NvbXBhdGlibGVJbnN0YW5jZSA9PT0gbmVnYXRlKSB7XG4gICAgICAgICAgLy8gVGhlc2UgY2hlY2tzIHdlcmUgY3JlYXRlZCB0byBlbnN1cmUgd2Ugd29uJ3QgZmFpbCB0b28gc29vbiB3aGVuIHdlJ3ZlIGdvdCBib3RoIGFyZ3MgYW5kIGEgbmVnYXRlXG4gICAgICAgICAgLy8gU2VlIElzc3VlICM1NTEgYW5kIFBSICM2ODNAR2l0SHViXG4gICAgICAgICAgaWYgKGV2ZXJ5QXJnSXNEZWZpbmVkICYmIG5lZ2F0ZSkge1xuICAgICAgICAgICAgZXJyb3JMaWtlRmFpbCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfScgKyAoY2F1Z2h0RXJyICYmICFuZWdhdGUgPyAnIGJ1dCAje2FjdH0gd2FzIHRocm93bicgOiAnJylcbiAgICAgICAgICAgICAgLCBlcnJvckxpa2UudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAsIGNhdWdodEVyci50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb21wYXRpYmxlQ29uc3RydWN0b3IgPSBfLmNoZWNrRXJyb3IuY29tcGF0aWJsZUNvbnN0cnVjdG9yKGNhdWdodEVyciwgZXJyb3JMaWtlKTtcbiAgICAgIGlmIChpc0NvbXBhdGlibGVDb25zdHJ1Y3RvciA9PT0gbmVnYXRlKSB7XG4gICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVycm9yTGlrZUZhaWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfScgKyAoY2F1Z2h0RXJyID8gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nIDogJycpXG4gICAgICAgICAgICAsIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yTGlrZS50b1N0cmluZygpIDogZXJyb3JMaWtlICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSlcbiAgICAgICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID8gY2F1Z2h0RXJyLnRvU3RyaW5nKCkgOiBjYXVnaHRFcnIgJiYgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShjYXVnaHRFcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2F1Z2h0RXJyICYmIGVyck1zZ01hdGNoZXIgIT09IHVuZGVmaW5lZCAmJiBlcnJNc2dNYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIGNvbXBhdGlibGUgbWVzc2FnZXNcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9ICdpbmNsdWRpbmcnO1xuICAgICAgaWYgKGVyck1zZ01hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcGxhY2Vob2xkZXIgPSAnbWF0Y2hpbmcnXG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NvbXBhdGlibGVNZXNzYWdlID0gXy5jaGVja0Vycm9yLmNvbXBhdGlibGVNZXNzYWdlKGNhdWdodEVyciwgZXJyTXNnTWF0Y2hlcik7XG4gICAgICBpZiAoaXNDb21wYXRpYmxlTWVzc2FnZSA9PT0gbmVnYXRlKSB7XG4gICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVyck1zZ01hdGNoZXJGYWlsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciAnICsgcGxhY2Vob2xkZXIgKyAnICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90ICcgKyBwbGFjZWhvbGRlciArICcgI3tleHB9J1xuICAgICAgICAgICAgLCAgZXJyTXNnTWF0Y2hlclxuICAgICAgICAgICAgLCAgXy5jaGVja0Vycm9yLmdldE1lc3NhZ2UoY2F1Z2h0RXJyKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGFzc2VydGlvbnMgZmFpbGVkIGFuZCBib3RoIHNob3VsZCd2ZSBtYXRjaGVkIHdlIHRocm93IGFuIGVycm9yXG4gICAgaWYgKGVycm9yTGlrZUZhaWwgJiYgZXJyTXNnTWF0Y2hlckZhaWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBuZWdhdGVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nICsgKGNhdWdodEVyciA/ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJyA6ICcnKVxuICAgICAgICAsIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yTGlrZS50b1N0cmluZygpIDogZXJyb3JMaWtlICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSlcbiAgICAgICAgLCAoY2F1Z2h0RXJyIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVnaHRFcnIudG9TdHJpbmcoKSA6IGNhdWdodEVyciAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGNhdWdodEVycikpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGNhdWdodEVycik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvd3MnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdUaHJvdycsIGFzc2VydFRocm93cyk7XG5cbiAgLyoqXG4gICAqICMjIyAucmVzcG9uZFRvKG1ldGhvZFssIG1zZ10pXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGAucmVzcG9uZFRvYCBhc3NlcnRzIHRoYXQgdGhlXG4gICAqIHRhcmdldCBoYXMgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBgbWV0aG9kYC4gVGhlIG1ldGhvZCBjYW4gYmUgb3duIG9yXG4gICAqIGluaGVyaXRlZCwgYW5kIGl0IGNhbiBiZSBlbnVtZXJhYmxlIG9yIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgQ2F0KCkpLnRvLnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBmdW5jdGlvbiwgYC5yZXNwb25kVG9gIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3NcbiAgICogYHByb3RvdHlwZWAgcHJvcGVydHkgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAuIEFnYWluLCB0aGVcbiAgICogbWV0aG9kIGNhbiBiZSBvd24gb3IgaW5oZXJpdGVkLCBhbmQgaXQgY2FuIGJlIGVudW1lcmFibGUgb3Igbm9uLWVudW1lcmFibGUuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkudG8ucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIEFkZCBgLml0c2VsZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZm9yY2UgYC5yZXNwb25kVG9gIHRvIHRyZWF0IHRoZVxuICAgKiB0YXJnZXQgYXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBldmVuIGlmIGl0J3MgYSBmdW5jdGlvbi4gVGh1cywgaXQgYXNzZXJ0c1xuICAgKiB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBoYXMgYSBtZXRob2Qgd2l0aCB0aGVcbiAgICogZ2l2ZW4gbmFtZSBgbWV0aG9kYC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqICAgICBDYXQuaGlzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkuaXRzZWxmLnRvLnJlc3BvbmRUbygnaGlzcycpLmJ1dC5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIFdoZW4gbm90IGFkZGluZyBgLml0c2VsZmAsIGl0J3MgaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZVxuICAgKiB1c2luZyBgLnJlc3BvbmRUb2AuIFNlZSB0aGUgYC5hYCBkb2MgZm9yIGluZm8gb24gY2hlY2tpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgQ2F0KCkpLnRvLmJlLmFuKCdvYmplY3QnKS50aGF0LnJlc3BvbmRzVG8oJ21lb3cnKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5yZXNwb25kVG9gLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gRG9nICgpIHt9XG4gICAqICAgICBEb2cucHJvdG90eXBlLmJhcmsgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgRG9nKCkpLnRvLm5vdC5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogYC5yZXNwb25kVG9gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7fSkudG8ucmVzcG9uZFRvKCdtZW93JywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHt9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8ucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLnJlc3BvbmRzVG9gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAucmVzcG9uZFRvYC5cbiAgICpcbiAgICogQG5hbWUgcmVzcG9uZFRvXG4gICAqIEBhbGlhcyByZXNwb25kc1RvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmRUbyAobWV0aG9kLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgaXRzZWxmID0gZmxhZyh0aGlzLCAnaXRzZWxmJylcbiAgICAgICwgY29udGV4dCA9ICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb2JqICYmICFpdHNlbGYpXG4gICAgICAgID8gb2JqLnByb3RvdHlwZVttZXRob2RdXG4gICAgICAgIDogb2JqW21ldGhvZF07XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbnRleHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRUbycsIHJlc3BvbmRUbyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRzVG8nLCByZXNwb25kVG8pO1xuXG4gIC8qKlxuICAgKiAjIyMgLml0c2VsZlxuICAgKlxuICAgKiBGb3JjZXMgYWxsIGAucmVzcG9uZFRvYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBiZWhhdmUgYXMgaWZcbiAgICogdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGV2ZW4gaWYgaXQncyBhIGZ1bmN0aW9uLiBUaHVzLCBpdFxuICAgKiBjYXVzZXMgYC5yZXNwb25kVG9gIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuXG4gICAqIG5hbWUsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBoYXMgYVxuICAgKiBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqICAgICBDYXQuaGlzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkuaXRzZWxmLnRvLnJlc3BvbmRUbygnaGlzcycpLmJ1dC5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGl0c2VsZlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2l0c2VsZicsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdpdHNlbGYnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2F0aXNmeShtYXRjaGVyWywgbXNnXSlcbiAgICpcbiAgICogSW52b2tlcyB0aGUgZ2l2ZW4gYG1hdGNoZXJgIGZ1bmN0aW9uIHdpdGggdGhlIHRhcmdldCBiZWluZyBwYXNzZWQgYXMgdGhlXG4gICAqIGZpcnN0IGFyZ3VtZW50LCBhbmQgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSByZXR1cm5lZCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDA7IFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuc2F0aXNmeWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAyO1xuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIGAuc2F0aXNmeWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAyO1xuICAgKiAgICAgfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkge1xuICAgKiAgICAgICByZXR1cm4gbnVtID4gMjtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5zYXRpc2ZpZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuc2F0aXNmeWAuXG4gICAqXG4gICAqIEBuYW1lIHNhdGlzZnlcbiAgICogQGFsaWFzIHNhdGlzZmllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBzYXRpc2Z5IChtYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIHJlc3VsdCA9IG1hdGNoZXIob2JqKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmVzdWx0XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHNhdGlzZnkgJyArIF8ub2JqRGlzcGxheShtYXRjaGVyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3Qgc2F0aXNmeScgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgZmxhZyh0aGlzLCAnbmVnYXRlJykgPyBmYWxzZSA6IHRydWVcbiAgICAgICwgcmVzdWx0XG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3NhdGlzZnknLCBzYXRpc2Z5KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmaWVzJywgc2F0aXNmeSk7XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhleHBlY3RlZCwgZGVsdGFbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciB0aGF0J3Mgd2l0aGluIGEgZ2l2ZW4gKy8tIGBkZWx0YWAgcmFuZ2VcbiAgICogb2YgdGhlIGdpdmVuIG51bWJlciBgZXhwZWN0ZWRgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlXG4gICAqIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uZXF1YWwoMS41KTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygxLCAwLjUpO1xuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygyLCAwLjUpO1xuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygxLCAxKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5jbG9zZVRvYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmVxdWFsKDEuNSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMS41KS50by5ub3QuYmUuY2xvc2VUbygzLCAxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuY2xvc2VUb2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygzLCAxLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMS41LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuY2xvc2VUbygzLCAxKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuYXBwcm94aW1hdGVseWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5jbG9zZVRvYC5cbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAYWxpYXMgYXBwcm94aW1hdGVseVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBjbG9zZVRvKGV4cGVjdGVkLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGVsdGEgIT09ICdudW1iZXInKSB7XG4gICAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICd0aGUgYXJndW1lbnRzIHRvIGNsb3NlVG8gb3IgYXBwcm94aW1hdGVseSBtdXN0IGJlIG51bWJlcnMnLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBNYXRoLmFicyhvYmogLSBleHBlY3RlZCkgPD0gZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBjbG9zZSB0byAnICsgZXhwZWN0ZWQgKyAnICsvLSAnICsgZGVsdGFcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xvc2VUbycsIGNsb3NlVG8pO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdhcHByb3hpbWF0ZWx5JywgY2xvc2VUbyk7XG5cbiAgLy8gTm90ZTogRHVwbGljYXRlcyBhcmUgaWdub3JlZCBpZiB0ZXN0aW5nIGZvciBpbmNsdXNpb24gaW5zdGVhZCBvZiBzYW1lbmVzcy5cbiAgZnVuY3Rpb24gaXNTdWJzZXRPZihzdWJzZXQsIHN1cGVyc2V0LCBjbXAsIGNvbnRhaW5zLCBvcmRlcmVkKSB7XG4gICAgaWYgKCFjb250YWlucykge1xuICAgICAgaWYgKHN1YnNldC5sZW5ndGggIT09IHN1cGVyc2V0Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3VwZXJzZXQgPSBzdXBlcnNldC5zbGljZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzZXQuZXZlcnkoZnVuY3Rpb24oZWxlbSwgaWR4KSB7XG4gICAgICBpZiAob3JkZXJlZCkgcmV0dXJuIGNtcCA/IGNtcChlbGVtLCBzdXBlcnNldFtpZHhdKSA6IGVsZW0gPT09IHN1cGVyc2V0W2lkeF07XG5cbiAgICAgIGlmICghY21wKSB7XG4gICAgICAgIHZhciBtYXRjaElkeCA9IHN1cGVyc2V0LmluZGV4T2YoZWxlbSk7XG4gICAgICAgIGlmIChtYXRjaElkeCA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2ggZnJvbSBzdXBlcnNldCBzbyBub3QgY291bnRlZCB0d2ljZSBpZiBkdXBsaWNhdGUgaW4gc3Vic2V0LlxuICAgICAgICBpZiAoIWNvbnRhaW5zKSBzdXBlcnNldC5zcGxpY2UobWF0Y2hJZHgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1cGVyc2V0LnNvbWUoZnVuY3Rpb24oZWxlbTIsIG1hdGNoSWR4KSB7XG4gICAgICAgIGlmICghY21wKGVsZW0sIGVsZW0yKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIFJlbW92ZSBtYXRjaCBmcm9tIHN1cGVyc2V0IHNvIG5vdCBjb3VudGVkIHR3aWNlIGlmIGR1cGxpY2F0ZSBpbiBzdWJzZXQuXG4gICAgICAgIGlmICghY29udGFpbnMpIHN1cGVyc2V0LnNwbGljZShtYXRjaElkeCwgMSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5tZW1iZXJzKHNldFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGFycmF5IGhhcyB0aGUgc2FtZSBtZW1iZXJzIGFzIHRoZSBnaXZlbiBhcnJheVxuICAgKiBgc2V0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubWVtYmVycyhbMiwgMSwgM10pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCAxLCAyXSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIG1lbWJlcnMgYXJlIGNvbXBhcmVkIHVzaW5nIHN0cmljdCAoYD09PWApIGVxdWFsaXR5LiBBZGQgYC5kZWVwYFxuICAgKiBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkLiBTZWUgdGhlIGBkZWVwLWVxbGBcbiAgICogcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBtZW1iZXIgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uaGF2ZS5kZWVwLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaGF2ZS5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgb3JkZXIgZG9lc24ndCBtYXR0ZXIuIEFkZCBgLm9yZGVyZWRgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvXG4gICAqIHJlcXVpcmUgdGhhdCBtZW1iZXJzIGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUub3JkZXJlZC5tZW1iZXJzKFsxLCAyLCAzXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm1lbWJlcnMoWzIsIDEsIDNdKVxuICAgKiAgICAgICAuYnV0Lm5vdC5vcmRlcmVkLm1lbWJlcnMoWzIsIDEsIDNdKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYm90aCBhcnJheXMgbXVzdCBiZSB0aGUgc2FtZSBzaXplLiBBZGQgYC5pbmNsdWRlYCBlYXJsaWVyIGluXG4gICAqIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCdzIG1lbWJlcnMgYmUgYSBzdXBlcnNldCBvZiB0aGVcbiAgICogZXhwZWN0ZWQgbWVtYmVycy4gTm90ZSB0aGF0IGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgaW4gdGhlIHN1YnNldCB3aGVuXG4gICAqIGAuaW5jbHVkZWAgaXMgYWRkZWQuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgaXMgYSBzdXBlcnNldCBvZiBbMSwgMl0gYnV0IG5vdCBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMSwgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmhhdmUubWVtYmVycyhbMSwgMl0pO1xuICAgKlxuICAgKiAgICAgLy8gRHVwbGljYXRlcyBpbiB0aGUgc3Vic2V0IGFyZSBpZ25vcmVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDIsIDIsIDJdKTtcbiAgICpcbiAgICogYC5kZWVwYCwgYC5vcmRlcmVkYCwgYW5kIGAuaW5jbHVkZWAgY2FuIGFsbCBiZSBjb21iaW5lZC4gSG93ZXZlciwgaWZcbiAgICogYC5pbmNsdWRlYCBhbmQgYC5vcmRlcmVkYCBhcmUgY29tYmluZWQsIHRoZSBvcmRlcmluZyBiZWdpbnMgYXQgdGhlIHN0YXJ0IG9mXG4gICAqIGJvdGggYXJyYXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFt7YTogMX0sIHtiOiAyfSwge2M6IDN9XSlcbiAgICogICAgICAgLnRvLmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoW3thOiAxfSwge2I6IDJ9XSlcbiAgICogICAgICAgLmJ1dC5ub3QuaW5jbHVkZS5kZWVwLm9yZGVyZWQubWVtYmVycyhbe2I6IDJ9LCB7YzogM31dKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5tZW1iZXJzYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQgYXJyYXkgZG9lc24ndCBoYXZlIGFsbCBvZiB0aGUgc2FtZSBtZW1iZXJzIGFzXG4gICAqIHRoZSBnaXZlbiBhcnJheSBgc2V0YCBidXQgbWF5IG9yIG1heSBub3QgaGF2ZSBzb21lIG9mIHRoZW0uIEl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uXG4gICAqIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8ubm90LmluY2x1ZGUoMykuYW5kLm5vdC5pbmNsdWRlKDQpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8ubm90LmhhdmUubWVtYmVycyhbMywgNF0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5tZW1iZXJzYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5oYXZlLm1lbWJlcnMoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5tZW1iZXJzKFsxLCAyLCAzXSk7XG4gICAqXG4gICAqIEBuYW1lIG1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtZW1iZXJzJywgZnVuY3Rpb24gKHN1YnNldCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5iZS5hbignYXJyYXknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1YnNldCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICB2YXIgY29udGFpbnMgPSBmbGFnKHRoaXMsICdjb250YWlucycpO1xuICAgIHZhciBvcmRlcmVkID0gZmxhZyh0aGlzLCAnb3JkZXJlZCcpO1xuXG4gICAgdmFyIHN1YmplY3QsIGZhaWxNc2csIGZhaWxOZWdhdGVNc2csIGxlbmd0aENoZWNrO1xuXG4gICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICBzdWJqZWN0ID0gb3JkZXJlZCA/ICdhbiBvcmRlcmVkIHN1cGVyc2V0JyA6ICdhIHN1cGVyc2V0JztcbiAgICAgIGZhaWxNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgc3ViamVjdCArICcgb2YgI3tleHB9JztcbiAgICAgIGZhaWxOZWdhdGVNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgJyArIHN1YmplY3QgKyAnIG9mICN7ZXhwfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YmplY3QgPSBvcmRlcmVkID8gJ29yZGVyZWQgbWVtYmVycycgOiAnbWVtYmVycyc7XG4gICAgICBmYWlsTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSB0aGUgc2FtZSAnICsgc3ViamVjdCArICcgYXMgI3tleHB9JztcbiAgICAgIGZhaWxOZWdhdGVNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSB0aGUgc2FtZSAnICsgc3ViamVjdCArICcgYXMgI3tleHB9JztcbiAgICB9XG5cbiAgICB2YXIgY21wID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gXy5lcWwgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wLCBjb250YWlucywgb3JkZXJlZClcbiAgICAgICwgZmFpbE1zZ1xuICAgICAgLCBmYWlsTmVnYXRlTXNnXG4gICAgICAsIHN1YnNldFxuICAgICAgLCBvYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9uZU9mKGxpc3RbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG1lbWJlciBvZiB0aGUgZ2l2ZW4gYXJyYXkgYGxpc3RgLiBIb3dldmVyLFxuICAgKiBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub25lT2YoWzEsIDIsIDNdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIENvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgdXNpbmcgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkuXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAub25lT2ZgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5vbmVPZihbMiwgMywgNF0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5vbmVPZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9uZU9mKFsyLCAzLCA0XSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5vbmVPZihbMiwgMywgNF0pO1xuICAgKlxuICAgKiBAbmFtZSBvbmVPZlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBsaXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBvbmVPZiAobGlzdCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24obGlzdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbGlzdC5pbmRleE9mKGV4cGVjdGVkKSA+IC0xXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG9uZSBvZiAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBvbmUgb2YgI3tleHB9J1xuICAgICAgLCBsaXN0XG4gICAgICAsIGV4cGVjdGVkXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ29uZU9mJywgb25lT2YpO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlKHN1YmplY3RbLCBwcm9wWywgbXNnXV0pXG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBgLmNoYW5nZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBmdW5jdGlvblxuICAgKiBgc3ViamVjdGAgcmV0dXJucyBhIGRpZmZlcmVudCB2YWx1ZSB3aGVuIGl0J3MgaW52b2tlZCBiZWZvcmUgdGhlIHRhcmdldFxuICAgKiBmdW5jdGlvbiBjb21wYXJlZCB0byB3aGVuIGl0J3MgaW52b2tlZCBhZnRlcndhcmQuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCBgc3ViamVjdGAgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgdmFyIGRvdHMgPSAnJ1xuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgZG90cyArPSAnLic7IH1cbiAgICogICAgICAgLCBnZXREb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG90czsgfTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZ2V0RG90cygpKS50by5lcXVhbCgnJyk7XG4gICAqICAgICBhZGREb3QoKTtcbiAgICogICAgIGV4cGVjdChnZXREb3RzKCkpLnRvLmVxdWFsKCcuJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGREb3QpLnRvLmNoYW5nZShnZXREb3RzKTtcbiAgICpcbiAgICogV2hlbiB0d28gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYC5jaGFuZ2VgIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIGdpdmVuIG9iamVjdCBgc3ViamVjdGAncyBgcHJvcGAgcHJvcGVydHkgaXMgZGlmZmVyZW50IGJlZm9yZSBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIGFmdGVyd2FyZC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtkb3RzOiAnJ31cbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IG15T2JqLmRvdHMgKz0gJy4nOyB9O1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChteU9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZG90cycsICcnKTtcbiAgICogICAgIGFkZERvdCgpO1xuICAgKiAgICAgZXhwZWN0KG15T2JqKS50by5oYXZlLnByb3BlcnR5KCdkb3RzJywgJy4nKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZERvdCkudG8uY2hhbmdlKG15T2JqLCAnZG90cycpO1xuICAgKlxuICAgKiBTdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkIHRvIGNvbXBhcmUgYmVmb3JlIGFuZCBhZnRlciB2YWx1ZXMuXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuY2hhbmdlYC5cbiAgICpcbiAgICogICAgIHZhciBkb3RzID0gJydcbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cbiAgICogICAgICAgLCBnZXREb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG90czsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKGdldERvdHMpO1xuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge2RvdHM6ICcnfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKG15T2JqLCAnZG90cycpO1xuICAgKlxuICAgKiBgLmNoYW5nZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzXG4gICAqIHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7ZG90czogJyd9XG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBteU9iai5kb3RzICs9ICcuJzsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGREb3QpLnRvLm5vdC5jaGFuZ2UobXlPYmosICdkb3RzJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgdmFyIGRvdHMgPSAnJ1xuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgZG90cyArPSAnLic7IH1cbiAgICogICAgICAgLCBnZXREb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG90czsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGREb3QsICdub29vIHdoeSBmYWlsPz8nKS50by5ub3QuY2hhbmdlKGdldERvdHMpO1xuICAgKlxuICAgKiBgLmNoYW5nZWAgYWxzbyBjYXVzZXMgYWxsIGAuYnlgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvXG4gICAqIGFzc2VydCBob3cgbXVjaCBhIG51bWVyaWMgc3ViamVjdCB3YXMgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZCBieS4gSG93ZXZlcixcbiAgICogaXQncyBkYW5nZXJvdXMgdG8gdXNlIGAuY2hhbmdlLmJ5YC4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzXG4gICAqIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGluY3JlYXNlcyBieVxuICAgKiB0aGUgZ2l2ZW4gZGVsdGEsIG9yIHRoYXQgaXQgZGVjcmVhc2VzIGJ5IHRoZSBnaXZlbiBkZWx0YS4gSXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb25cbiAgICogdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmNoYW5nZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuY2hhbmdlYC5cbiAgICpcbiAgICogQG5hbWUgY2hhbmdlXG4gICAqIEBhbGlhcyBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0Q2hhbmdlcyAoc3ViamVjdCwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGZuID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24oZm4sIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbDtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0W3Byb3BdO1xuICAgIH1cblxuICAgIGZuKCk7XG5cbiAgICB2YXIgZmluYWwgPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IHN1YmplY3QoKSA6IHN1YmplY3RbcHJvcF07XG4gICAgdmFyIG1zZ09iaiA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gaW5pdGlhbCA6ICcuJyArIHByb3A7XG5cbiAgICAvLyBUaGlzIGdldHMgZmxhZ2dlZCBiZWNhdXNlIG9mIHRoZSAuYnkoZGVsdGEpIGFzc2VydGlvblxuICAgIGZsYWcodGhpcywgJ2RlbHRhTXNnT2JqJywgbXNnT2JqKTtcbiAgICBmbGFnKHRoaXMsICdpbml0aWFsRGVsdGFWYWx1ZScsIGluaXRpYWwpO1xuICAgIGZsYWcodGhpcywgJ2ZpbmFsRGVsdGFWYWx1ZScsIGZpbmFsKTtcbiAgICBmbGFnKHRoaXMsICdkZWx0YUJlaGF2aW9yJywgJ2NoYW5nZScpO1xuICAgIGZsYWcodGhpcywgJ3JlYWxEZWx0YScsIGZpbmFsICE9PSBpbml0aWFsKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaW5pdGlhbCAhPT0gZmluYWxcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIGNoYW5nZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCBjaGFuZ2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2NoYW5nZScsIGFzc2VydENoYW5nZXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjaGFuZ2VzJywgYXNzZXJ0Q2hhbmdlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2Uoc3ViamVjdFssIHByb3BbLCBtc2ddXSlcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGAuaW5jcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICogYHN1YmplY3RgIHJldHVybnMgYSBncmVhdGVyIG51bWJlciB3aGVuIGl0J3MgaW52b2tlZCBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIHdoZW4gaXQncyBpbnZva2VkIGJlZm9yZWhhbmQuIGAuaW5jcmVhc2VgIGFsc29cbiAgICogY2F1c2VzIGFsbCBgLmJ5YCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBhc3NlcnQgaG93IG11Y2hcbiAgICogZ3JlYXRlciBvZiBhIG51bWJlciBpcyByZXR1cm5lZC4gSXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSByZXR1cm5cbiAgICogdmFsdWUgaW5jcmVhc2VkIGJ5IHRoZSBleHBlY3RlZCBhbW91bnQsIHJhdGhlciB0aGFuIGFzc2VydGluZyBpdCBpbmNyZWFzZWRcbiAgICogYnkgYW55IGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyB2YWwgKz0gMjsgfVxuICAgKiAgICAgICAsIGdldFZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKGdldFZhbCkuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShnZXRWYWwpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0d28gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYC5pbmNyZWFzZWAgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogZ2l2ZW4gb2JqZWN0IGBzdWJqZWN0YCdzIGBwcm9wYCBwcm9wZXJ0eSBpcyBncmVhdGVyIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gYmVmb3JlaGFuZC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5pbmNyZWFzZWAuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgc3ViamVjdCBlaXRoZXIgZGVjcmVhc2VzLCBvciB0aGF0IGl0IHN0YXlzIHRoZSBzYW1lLlxuICAgKiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuXG4gICAqIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgc3ViamVjdCBpcyBleHBlY3RlZCB0byBkZWNyZWFzZSwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IGl0XG4gICAqIGRlY3JlYXNlZCBieSB0aGUgZXhwZWN0ZWQgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLm5vdC5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gc3RheSB0aGUgc2FtZSwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKG15T2JqLCAndmFsJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmluY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmluY3JlYXNlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXNcbiAgICogdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmluY3JlYXNlKGdldFZhbCk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmluY3JlYXNlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5pbmNyZWFzZWAuXG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlXG4gICAqIEBhbGlhcyBpbmNyZWFzZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHN1YmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRJbmNyZWFzZXMgKHN1YmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluaXRpYWw7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdFtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyXG4gICAgbmV3IEFzc2VydGlvbihpbml0aWFsLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdudW1iZXInKTtcblxuICAgIGZuKCk7XG5cbiAgICB2YXIgZmluYWwgPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IHN1YmplY3QoKSA6IHN1YmplY3RbcHJvcF07XG4gICAgdmFyIG1zZ09iaiA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gaW5pdGlhbCA6ICcuJyArIHByb3A7XG5cbiAgICBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicsIG1zZ09iaik7XG4gICAgZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnLCBpbml0aWFsKTtcbiAgICBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnLCBmaW5hbCk7XG4gICAgZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicsICdpbmNyZWFzZScpO1xuICAgIGZsYWcodGhpcywgJ3JlYWxEZWx0YScsIGZpbmFsIC0gaW5pdGlhbCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGZpbmFsIC0gaW5pdGlhbCA+IDBcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIGluY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90IGluY3JlYXNlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbmNyZWFzZScsIGFzc2VydEluY3JlYXNlcyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luY3JlYXNlcycsIGFzc2VydEluY3JlYXNlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2Uoc3ViamVjdFssIHByb3BbLCBtc2ddXSlcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGAuZGVjcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICogYHN1YmplY3RgIHJldHVybnMgYSBsZXNzZXIgbnVtYmVyIHdoZW4gaXQncyBpbnZva2VkIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gd2hlbiBpdCdzIGludm9rZWQgYmVmb3JlaGFuZC4gYC5kZWNyZWFzZWAgYWxzb1xuICAgKiBjYXVzZXMgYWxsIGAuYnlgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIGFzc2VydCBob3cgbXVjaFxuICAgKiBsZXNzZXIgb2YgYSBudW1iZXIgaXMgcmV0dXJuZWQuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcmV0dXJuXG4gICAqIHZhbHVlIGRlY3JlYXNlZCBieSB0aGUgZXhwZWN0ZWQgYW1vdW50LCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgaXQgZGVjcmVhc2VkXG4gICAqIGJ5IGFueSBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgdmFsID0gMVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyB2YWwgLT0gMjsgfVxuICAgKiAgICAgICAsIGdldFZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UoZ2V0VmFsKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UoZ2V0VmFsKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAuZGVjcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIGdpdmVuIG9iamVjdCBgc3ViamVjdGAncyBgcHJvcGAgcHJvcGVydHkgaXMgbGVzc2VyIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gYmVmb3JlaGFuZC4gXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZGVjcmVhc2VgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGluY3JlYXNlcywgb3IgdGhhdCBpdCBzdGF5cyB0aGUgc2FtZS5cbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlblxuICAgKiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gaW5jcmVhc2UsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCBpdFxuICAgKiBpbmNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5ub3QuZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqIFxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIHN0YXkgdGhlIHNhbWUsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShteU9iaiwgJ3ZhbCcpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5kZWNyZWFzZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzXG4gICAqIHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3AsICdub29vIHdoeSBmYWlsPz8nKS50by5kZWNyZWFzZShnZXRWYWwpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5kZWNyZWFzZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuZGVjcmVhc2VgLlxuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZVxuICAgKiBAYWxpYXMgZGVjcmVhc2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RGVjcmVhc2VzIChzdWJqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihmbiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsO1xuICAgIGlmICghcHJvcCkge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3RbcHJvcF07XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlclxuICAgIG5ldyBBc3NlcnRpb24oaW5pdGlhbCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnbnVtYmVyJyk7XG5cbiAgICBmbigpO1xuXG4gICAgdmFyIGZpbmFsID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBzdWJqZWN0KCkgOiBzdWJqZWN0W3Byb3BdO1xuICAgIHZhciBtc2dPYmogPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IGluaXRpYWwgOiAnLicgKyBwcm9wO1xuXG4gICAgZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonLCBtc2dPYmopO1xuICAgIGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJywgaW5pdGlhbCk7XG4gICAgZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJywgZmluYWwpO1xuICAgIGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InLCAnZGVjcmVhc2UnKTtcbiAgICBmbGFnKHRoaXMsICdyZWFsRGVsdGEnLCBpbml0aWFsIC0gZmluYWwpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBmaW5hbCAtIGluaXRpYWwgPCAwXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBkZWNyZWFzZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCBkZWNyZWFzZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZGVjcmVhc2UnLCBhc3NlcnREZWNyZWFzZXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdkZWNyZWFzZXMnLCBhc3NlcnREZWNyZWFzZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJ5KGRlbHRhWywgbXNnXSlcbiAgICpcbiAgICogV2hlbiBmb2xsb3dpbmcgYW4gYC5pbmNyZWFzZWAgYXNzZXJ0aW9uIGluIHRoZSBjaGFpbiwgYC5ieWAgYXNzZXJ0cyB0aGF0XG4gICAqIHRoZSBzdWJqZWN0IG9mIHRoZSBgLmluY3JlYXNlYCBhc3NlcnRpb24gaW5jcmVhc2VkIGJ5IHRoZSBnaXZlbiBgZGVsdGFgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTtcbiAgICpcbiAgICogV2hlbiBmb2xsb3dpbmcgYSBgLmRlY3JlYXNlYCBhc3NlcnRpb24gaW4gdGhlIGNoYWluLCBgLmJ5YCBhc3NlcnRzIHRoYXQgdGhlXG4gICAqIHN1YmplY3Qgb2YgdGhlIGAuZGVjcmVhc2VgIGFzc2VydGlvbiBkZWNyZWFzZWQgYnkgdGhlIGdpdmVuIGBkZWx0YWAuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTtcbiAgICpcbiAgICogV2hlbiBmb2xsb3dpbmcgYSBgLmNoYW5nZWAgYXNzZXJ0aW9uIGluIHRoZSBjaGFpbiwgYC5ieWAgYXNzZXJ0cyB0aGF0IHRoZVxuICAgKiBzdWJqZWN0IG9mIHRoZSBgLmNoYW5nZWAgYXNzZXJ0aW9uIGVpdGhlciBpbmNyZWFzZWQgb3IgZGVjcmVhc2VkIGJ5IHRoZVxuICAgKiBnaXZlbiBgZGVsdGFgLiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byB1c2UgYC5jaGFuZ2UuYnlgLiBUaGUgcHJvYmxlbSBpc1xuICAgKiB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucy4gSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZVxuICAgKiBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHNcbiAgICogdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYnlgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHN1YmplY3QgY2hhbmdlZCBieSBpdHMgZXhwZWN0ZWQgZGVsdGEsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IGl0IGRpZG4ndCBjaGFuZ2UgYnkgb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIGRlbHRhcy5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ1dC5ub3QuYnkoMyk7XG4gICAqXG4gICAqIGAuYnlgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZSB0b1xuICAgKiBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZFxuICAgKiBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KGFkZFR3bywgJ25vb28gd2h5IGZhaWw/PycpLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMyk7XG4gICAqXG4gICAqIEBuYW1lIGJ5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RGVsdGEoZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgdmFyIG1zZ09iaiA9IGZsYWcodGhpcywgJ2RlbHRhTXNnT2JqJyk7XG4gICAgdmFyIGluaXRpYWwgPSBmbGFnKHRoaXMsICdpbml0aWFsRGVsdGFWYWx1ZScpO1xuICAgIHZhciBmaW5hbCA9IGZsYWcodGhpcywgJ2ZpbmFsRGVsdGFWYWx1ZScpO1xuICAgIHZhciBiZWhhdmlvciA9IGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InKTtcbiAgICB2YXIgcmVhbERlbHRhID0gZmxhZyh0aGlzLCAncmVhbERlbHRhJyk7XG5cbiAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICBpZiAoYmVoYXZpb3IgPT09ICdjaGFuZ2UnKSB7XG4gICAgICBleHByZXNzaW9uID0gTWF0aC5hYnMoZmluYWwgLSBpbml0aWFsKSA9PT0gTWF0aC5hYnMoZGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByZXNzaW9uID0gcmVhbERlbHRhID09PSBNYXRoLmFicyhkZWx0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBleHByZXNzaW9uXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byAnICsgYmVoYXZpb3IgKyAnIGJ5ICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90ICcgKyBiZWhhdmlvciArICcgYnkgJyArIGRlbHRhXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2J5JywgYXNzZXJ0RGVsdGEpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4dGVuc2libGVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXh0ZW5zaWJsZSwgd2hpY2ggbWVhbnMgdGhhdCBuZXcgcHJvcGVydGllcyBjYW5cbiAgICogYmUgYWRkZWQgdG8gaXQuIFByaW1pdGl2ZXMgYXJlIG5ldmVyIGV4dGVuc2libGUuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5iZS5leHRlbnNpYmxlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmV4dGVuc2libGVgLlxuICAgKlxuICAgKiAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pXG4gICAqICAgICAgICwgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pXG4gICAqICAgICAgICwgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9uRXh0ZW5zaWJsZU9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3Qoc2VhbGVkT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5leHRlbnNpYmxlO1xuICAgKlxuICAgKiBAbmFtZSBleHRlbnNpYmxlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZXh0ZW5zaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIGEgcHJpbWl0aXZlLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIG5vbi1leHRlbnNpYmxlIG9yZGluYXJ5IG9iamVjdCwgc2ltcGx5IHJldHVybiBmYWxzZS5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNFeHRlbnNpYmxlXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3IgZm9yIEVTNSBlbnZpcm9ubWVudHMuXG5cbiAgICB2YXIgaXNFeHRlbnNpYmxlID0gb2JqID09PSBPYmplY3Qob2JqKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKG9iaik7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzRXh0ZW5zaWJsZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBleHRlbnNpYmxlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgZXh0ZW5zaWJsZSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zZWFsZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc2VhbGVkLCB3aGljaCBtZWFucyB0aGF0IG5ldyBwcm9wZXJ0aWVzIGNhbid0IGJlXG4gICAqIGFkZGVkIHRvIGl0LCBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2FuJ3QgYmUgcmVjb25maWd1cmVkIG9yIGRlbGV0ZWQuXG4gICAqIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW4gc3RpbGwgYmUgcmVhc3NpZ25lZFxuICAgKiB0byBkaWZmZXJlbnQgdmFsdWVzLiBQcmltaXRpdmVzIGFyZSBhbHdheXMgc2VhbGVkLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzZWFsZWRPYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5zZWFsZWQ7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuc2VhbGVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5zZWFsZWQ7XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuc2VhbGVkO1xuICAgKlxuICAgKiBAbmFtZSBzZWFsZWRcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdzZWFsZWQnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICAvLyBJbiBFUzUsIGlmIHRoZSBhcmd1bWVudCB0byB0aGlzIG1ldGhvZCBpcyBhIHByaW1pdGl2ZSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBzZWFsZWQgb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIHRydWUuXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1NlYWxlZFxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIGZvciBFUzUgZW52aXJvbm1lbnRzLlxuXG4gICAgdmFyIGlzU2VhbGVkID0gb2JqID09PSBPYmplY3Qob2JqKSA/IE9iamVjdC5pc1NlYWxlZChvYmopIDogdHJ1ZTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaXNTZWFsZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgc2VhbGVkJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgc2VhbGVkJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZyb3plblxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBmcm96ZW4sIHdoaWNoIG1lYW5zIHRoYXQgbmV3IHByb3BlcnRpZXMgY2FuJ3QgYmVcbiAgICogYWRkZWQgdG8gaXQsIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW4ndCBiZSByZWFzc2lnbmVkIHRvIGRpZmZlcmVudFxuICAgKiB2YWx1ZXMsIHJlY29uZmlndXJlZCwgb3IgZGVsZXRlZC4gUHJpbWl0aXZlcyBhcmUgYWx3YXlzIGZyb3plbi5cbiAgICpcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLmJlLmZyb3plbjtcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5mcm96ZW47XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZnJvemVuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5mcm96ZW47XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZnJvemVuO1xuICAgKlxuICAgKiBAbmFtZSBmcm96ZW5cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmcm96ZW4nLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICAvLyBJbiBFUzUsIGlmIHRoZSBhcmd1bWVudCB0byB0aGlzIG1ldGhvZCBpcyBhIHByaW1pdGl2ZSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBmcm96ZW4gb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIHRydWUuXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0Zyb3plblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIGZvciBFUzUgZW52aXJvbm1lbnRzLlxuXG4gICAgdmFyIGlzRnJvemVuID0gb2JqID09PSBPYmplY3Qob2JqKSA/IE9iamVjdC5pc0Zyb3plbihvYmopIDogdHJ1ZTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaXNGcm96ZW5cbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZnJvemVuJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgZnJvemVuJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZpbml0ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciwgYW5kIGlzbid0IGBOYU5gIG9yIHBvc2l0aXZlL25lZ2F0aXZlXG4gICAqIGBJbmZpbml0eWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuZmluaXRlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmZpbml0ZWAuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgc3ViamVjdCBlaXRoZXIgaXNuJ3QgYSBudW1iZXIsIG9yIHRoYXQgaXQncyBgTmFOYCwgb3JcbiAgICogdGhhdCBpdCdzIHBvc2l0aXZlIGBJbmZpbml0eWAsIG9yIHRoYXQgaXQncyBuZWdhdGl2ZSBgSW5maW5pdHlgLiBJdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuXG4gICAqIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIGJlIGEgbnVtYmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIHRoYXQgaXQncyB0aGUgZXhwZWN0ZWQgdHlwZSwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgaXNuJ3Qgb25lIG9mXG4gICAqIG1hbnkgdW5leHBlY3RlZCB0eXBlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUgYE5hTmAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseVxuICAgKiB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KE5hTikudG8uYmUuTmFOOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KE5hTikudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSBwb3NpdGl2ZSBpbmZpbml0eSwgaXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoSW5maW5pdHkpLnRvLmVxdWFsKEluZmluaXR5KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChJbmZpbml0eSkudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSBuZWdhdGl2ZSBpbmZpbml0eSwgaXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoLUluZmluaXR5KS50by5lcXVhbCgtSW5maW5pdHkpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KC1JbmZpbml0eSkudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5maW5pdGU7XG4gICAqXG4gICAqIEBuYW1lIGZpbml0ZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2Zpbml0ZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYSBmaW5pdGUgbnVtYmVyJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYSBmaW5pdGUgbnVtYmVyJ1xuICAgICk7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgY2hhaS5leHBlY3QgPSBmdW5jdGlvbiAodmFsLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBjaGFpLkFzc2VydGlvbih2YWwsIG1lc3NhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhaWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdLCBbb3BlcmF0b3JdKVxuICAgKlxuICAgKiBUaHJvdyBhIGZhaWx1cmUuXG4gICAqXG4gICAqIEBuYW1lIGZhaWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBjaGFpLmV4cGVjdC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ2V4cGVjdC5mYWlsKCknO1xuICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgIH0sIGNoYWkuZXhwZWN0LmZhaWwpO1xuICB9O1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuXG4gIGZ1bmN0aW9uIGxvYWRTaG91bGQgKCkge1xuICAgIC8vIGV4cGxpY2l0bHkgZGVmaW5lIHRoaXMgbWV0aG9kIGFzIGZ1bmN0aW9uIGFzIHRvIGhhdmUgaXQncyBuYW1lIHRvIGluY2x1ZGUgYXMgYHNzZmlgXG4gICAgZnVuY3Rpb24gc2hvdWxkR2V0dGVyKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmdcbiAgICAgICAgICB8fCB0aGlzIGluc3RhbmNlb2YgTnVtYmVyXG4gICAgICAgICAgfHwgdGhpcyBpbnN0YW5jZW9mIEJvb2xlYW5cbiAgICAgICAgICB8fCB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcy52YWx1ZU9mKCksIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTZXR0ZXIodmFsdWUpIHtcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2NoYWkvaXNzdWVzLzg2OiB0aGlzIG1ha2VzXG4gICAgICAvLyBgd2hhdGV2ZXIuc2hvdWxkID0gc29tZVZhbHVlYCBhY3R1YWxseSBzZXQgYHNvbWVWYWx1ZWAsIHdoaWNoIGlzXG4gICAgICAvLyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgYGdsb2JhbC5zaG91bGQgPSByZXF1aXJlKCdjaGFpJykuc2hvdWxkKClgLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB3ZSBoYXZlIHRvIHVzZSBbW0RlZmluZVByb3BlcnR5XV0gaW5zdGVhZCBvZiBbW1B1dF1dXG4gICAgICAvLyBzaW5jZSBvdGhlcndpc2Ugd2Ugd291bGQgdHJpZ2dlciB0aGlzIHZlcnkgc2V0dGVyIVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaG91bGQnLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG1vZGlmeSBPYmplY3QucHJvdG90eXBlIHRvIGhhdmUgYHNob3VsZGBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ3Nob3VsZCcsIHtcbiAgICAgIHNldDogc2hvdWxkU2V0dGVyXG4gICAgICAsIGdldDogc2hvdWxkR2V0dGVyXG4gICAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIHNob3VsZCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICAgKlxuICAgICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGZhaWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAgICogQG5hbWVzcGFjZSBCRERcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdzaG91bGQuZmFpbCgpJztcbiAgICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgICAgfSwgc2hvdWxkLmZhaWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgbm9uLXN0cmljdCBlcXVhbGl0eSAoYD09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIGVxdWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC50aHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IsIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIHRocm93XG4gICAgICogQGFsaWFzIFRocm93XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmV4aXN0XG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGZvbyA9ICdoaSc7XG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLmV4aXN0KGZvbywgJ2ZvbyBleGlzdHMnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIGV4aXN0XG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5leGlzdDtcbiAgICB9XG5cbiAgICAvLyBuZWdhdGlvblxuICAgIHNob3VsZC5ub3QgPSB7fVxuXG4gICAgLyoqXG4gICAgICogIyMjIC5ub3QuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QuZXF1YWwoMywgNCwgJ3RoZXNlIG51bWJlcnMgYXJlIG5vdCBlcXVhbCcpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LmVxdWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8ubm90LmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLnRocm93KGZ1bmN0aW9uLCBbY29uc3RydWN0b3IvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICogYGNvbnN0cnVjdG9yYCwgb3IgYWx0ZXJuYXRlbHkgdGhhdCBpdCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LnRocm93KGZuLCBFcnJvciwgJ2Z1bmN0aW9uIGRvZXMgbm90IHRocm93Jyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QudGhyb3dcbiAgICAgKiBAYWxpYXMgbm90LlRocm93XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5ub3QuVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAubm90LmV4aXN0XG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGJhciA9IG51bGw7XG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC5leGlzdChiYXIsICdiYXIgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC5leGlzdFxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5leGlzdDtcbiAgICB9XG5cbiAgICBzaG91bGRbJ3Rocm93J10gPSBzaG91bGRbJ1Rocm93J107XG4gICAgc2hvdWxkLm5vdFsndGhyb3cnXSA9IHNob3VsZC5ub3RbJ1Rocm93J107XG5cbiAgICByZXR1cm4gc2hvdWxkO1xuICB9O1xuXG4gIGNoYWkuc2hvdWxkID0gbG9hZFNob3VsZDtcbiAgY2hhaS5TaG91bGQgPSBsb2FkU2hvdWxkO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuXG4gIC8qIVxuICAgKiBDaGFpIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICAvKipcbiAgICogIyMjIGFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlKVxuICAgKlxuICAgKiBXcml0ZSB5b3VyIG93biB0ZXN0IGV4cHJlc3Npb25zLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0KCdmb28nICE9PSAnYmFyJywgJ2ZvbyBpcyBub3QgYmFyJyk7XG4gICAqICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShbXSksICdlbXB0eSBhcnJheXMgYXJlIGFycmF5cycpO1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBleHByZXNzaW9uIHRvIHRlc3QgZm9yIHRydXRoaW5lc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gZGlzcGxheSBvbiBlcnJvclxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdmFyIGFzc2VydCA9IGNoYWkuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHJlc3MsIGVycm1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihudWxsLCBudWxsLCBjaGFpLmFzc2VydCwgdHJ1ZSk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cHJlc3NcbiAgICAgICwgZXJybXNnXG4gICAgICAsICdbIG5lZ2F0aW9uIG1lc3NhZ2UgdW5hdmFpbGFibGUgXSdcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhaWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdLCBbb3BlcmF0b3JdKVxuICAgKlxuICAgKiBUaHJvdyBhIGZhaWx1cmUuIE5vZGUuanMgYGFzc2VydGAgbW9kdWxlLWNvbXBhdGlibGUuXG4gICAqXG4gICAqIEBuYW1lIGZhaWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZmFpbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvcikge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdhc3NlcnQuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBhc3NlcnQuZmFpbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc09rKCdldmVyeXRoaW5nJywgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5pc09rKGZhbHNlLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgaXNPa1xuICAgKiBAYWxpYXMgb2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzT2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNPaywgdHJ1ZSkuaXMub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90T2soJ2V2ZXJ5dGhpbmcnLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9rKGZhbHNlLCAndGhpcyB3aWxsIHBhc3MnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPa1xuICAgKiBAYWxpYXMgbm90T2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RPaywgdHJ1ZSkuaXMubm90Lm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGVxdWFsaXR5IChgPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmVxdWFsLCB0cnVlKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgPT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgICAsIHRydWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RXF1YWwsIHRydWUpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCAhPSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBlcXVhbGl0eSAoYD09PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIHRydWUsICd0aGVzZSBib29sZWFucyBhcmUgc3RyaWN0bHkgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LnN0cmljdEVxdWFsLCB0cnVlKS50by5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgaW5lcXVhbGl0eSAoYCE9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKDMsICczJywgJ25vIGNvZXJjaW9uIGZvciBzdHJpY3QgZXF1YWxpdHknKTtcbiAgICpcbiAgICogQG5hbWUgbm90U3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLCB0cnVlKS50by5ub3QuZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGFjdHVhbGAgaXMgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnZ3JlZW4nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhbGlhcyBkZWVwU3RyaWN0RXF1YWxcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBFcXVhbCA9IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5kZWVwRXF1YWwsIHRydWUpLnRvLmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGBhY3R1YWxgIGlzIG5vdCBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdqYXNtaW5lJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RGVlcEVxdWFsLCB0cnVlKS50by5ub3QuZXFsKGV4cCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQWJvdmUodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBYm92ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAoPikgYHZhbHVlVG9CZUFib3ZlYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Fib3ZlKDUsIDIsICc1IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAyJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQWJvdmVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUFib3ZlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Fib3ZlID0gZnVuY3Rpb24gKHZhbCwgYWJ2LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBYm92ZSwgdHJ1ZSkudG8uYmUuYWJvdmUoYWJ2KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBdExlYXN0KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQXRMZWFzdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAoPj0pIGB2YWx1ZVRvQmVBdExlYXN0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TGVhc3QoNSwgMiwgJzUgaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyJyk7XG4gICAqICAgICBhc3NlcnQuaXNBdExlYXN0KDMsIDMsICczIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0F0TGVhc3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUF0TGVhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRMZWFzdCA9IGZ1bmN0aW9uICh2YWwsIGF0bHN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBdExlYXN0LCB0cnVlKS50by5iZS5sZWFzdChhdGxzdCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQmVsb3codmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVCZWxvdywgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGxlc3MgdGhhbiAoPCkgYHZhbHVlVG9CZUJlbG93YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0JlbG93KDMsIDYsICczIGlzIHN0cmljdGx5IGxlc3MgdGhhbiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQmVsb3dcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUJlbG93XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0JlbG93ID0gZnVuY3Rpb24gKHZhbCwgYmx3LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNCZWxvdywgdHJ1ZSkudG8uYmUuYmVsb3coYmx3KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBdE1vc3QodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBdE1vc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKDw9KSBgdmFsdWVUb0JlQXRNb3N0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TW9zdCgzLCA2LCAnMyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNicpO1xuICAgKiAgICAgYXNzZXJ0LmlzQXRNb3N0KDQsIDQsICc0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byA0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXRNb3N0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBdE1vc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRNb3N0ID0gZnVuY3Rpb24gKHZhbCwgYXRtc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0F0TW9zdCwgdHJ1ZSkudG8uYmUubW9zdChhdG1zdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNUcnVlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gdHJ1ZTtcbiAgICogICAgIGFzc2VydC5pc1RydWUodGVhU2VydmVkLCAndGhlIHRlYSBoYXMgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNUcnVlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1RydWUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNUcnVlLCB0cnVlKS5pc1sndHJ1ZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90VHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgdHJ1ZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RUcnVlKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90VHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90VHJ1ZSwgdHJ1ZSkudG8ubm90LmVxdWFsKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRmFsc2UodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgZmFsc2UuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqICAgICBhc3NlcnQuaXNGYWxzZSh0ZWFTZXJ2ZWQsICdubyB0ZWEgeWV0PyBobW0uLi4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNGYWxzZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGYWxzZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0ZhbHNlLCB0cnVlKS5pc1snZmFsc2UnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RGYWxzZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90RmFsc2UsIHRydWUpLnRvLm5vdC5lcXVhbChmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG51bGwuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOdWxsKGVyciwgJ3RoZXJlIHdhcyBubyBlcnJvcicpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc051bGwsIHRydWUpLnRvLmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgbnVsbC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdWxsKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90TnVsbCwgdHJ1ZSkudG8ubm90LmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTmFOXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB2YWx1ZSBpcyBOYU4uXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOYU4oTmFOLCAnTmFOIGlzIE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOYU4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOYU4sIHRydWUpLnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE5hTlxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgbm90IE5hTi5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdE5hTig0LCAnNCBpcyBub3QgTmFOJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TmFOXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBhc3NlcnQuaXNOb3ROYU4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3ROYU4sIHRydWUpLm5vdC50by5iZS5OYU47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXhpc3RzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciBmb28gPSAnaGknO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmV4aXN0cyhmb28sICdmb28gaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgJyk7XG4gICAqXG4gICAqIEBuYW1lIGV4aXN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXhpc3RzID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmV4aXN0cywgdHJ1ZSkudG8uZXhpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RXhpc3RzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVpdGhlciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgYmFyID0gbnVsbFxuICAgKiAgICAgICAsIGJhejtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFeGlzdHMoYmFyKTtcbiAgICogICAgIGFzc2VydC5ub3RFeGlzdHMoYmF6LCAnYmF6IGlzIGVpdGhlciBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RFeGlzdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEV4aXN0cyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5ub3RFeGlzdHMsIHRydWUpLnRvLm5vdC5leGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzVW5kZWZpbmVkLCB0cnVlKS50by5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ2N1cCBvZiBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc0RlZmluZWQodGVhLCAndGVhIGhhcyBiZWVuIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNEZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0RlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNEZWZpbmVkLCB0cnVlKS50by5ub3QuZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Z1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBzZXJ2ZVRlYSgpIHsgcmV0dXJuICdjdXAgb2YgdGVhJzsgfTtcbiAgICogICAgIGFzc2VydC5pc0Z1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGNhbiBoYXZlIHRlYSBub3cnKTtcbiAgICpcbiAgICogQG5hbWUgaXNGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Z1bmN0aW9uLCB0cnVlKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEZ1bmN0aW9uLCB0cnVlKS50by5ub3QuYmUuYSgnZnVuY3Rpb24nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc09iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0JyAoYXMgcmV2ZWFsZWQgYnkgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICogX1RoZSBhc3NlcnRpb24gZG9lcyBub3QgbWF0Y2ggc3ViY2xhc3NlZCBvYmplY3RzLl9cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSB7IG5hbWU6ICdDaGFpJywgc2VydmU6ICd3aXRoIHNwaWNlcycgfTtcbiAgICogICAgIGFzc2VydC5pc09iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNPYmplY3QsIHRydWUpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9ICdjaGFpJ1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KG51bGwsICdudWxsIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90T2JqZWN0LCB0cnVlKS50by5ub3QuYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gWyAnZ3JlZW4nLCAnY2hhaScsICdvb2xvbmcnIF07XG4gICAqICAgICBhc3NlcnQuaXNBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0FycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQXJyYXksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90QXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9ICdncmVlbnxjaGFpfG9vbG9uZyc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEFycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEFycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90QXJyYXksIHRydWUpLnRvLm5vdC5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1N0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9ICdjaGFpJztcbiAgICogICAgIGFzc2VydC5pc1N0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1N0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNTdHJpbmcsIHRydWUpLnRvLmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gNDtcbiAgICogICAgIGFzc2VydC5pc05vdFN0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFN0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RTdHJpbmcsIHRydWUpLnRvLm5vdC5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc051bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTnVtYmVyLCB0cnVlKS50by5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gJzIgY3VwcyBwbGVhc2UnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVtYmVyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE51bWJlciwgdHJ1ZSkudG8ubm90LmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0Zpbml0ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIuIFVubGlrZSBgLmlzTnVtYmVyYCwgdGhpcyB3aWxsIGZhaWwgZm9yIGBOYU5gIGFuZCBgSW5maW5pdHlgLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAyO1xuICAgKiAgICAgYXNzZXJ0LmlzRmluaXRlKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNGaW5pdGUoTmFOKTsgLy8gdGhyb3dzXG4gICAqXG4gICAqIEBuYW1lIGlzRmluaXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGaW5pdGUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNGaW5pdGUsIHRydWUpLnRvLmJlLmZpbml0ZTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Jvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gdHJ1ZVxuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Jvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Jvb2xlYW4sIHRydWUpLnRvLmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEJvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gJ3llcCdcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSAnbm9wZSc7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90Qm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90Qm9vbGVhbiwgdHJ1ZSkudG8ubm90LmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50eXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQudHlwZU9mKHsgdGVhOiAnY2hhaScgfSwgJ29iamVjdCcsICd3ZSBoYXZlIGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihbJ2NoYWknLCAnamFzbWluZSddLCAnYXJyYXknLCAnd2UgaGF2ZSBhbiBhcnJheScpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigndGVhJywgJ3N0cmluZycsICd3ZSBoYXZlIGEgc3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKC90ZWEvLCAncmVnZXhwJywgJ3dlIGhhdmUgYSByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YobnVsbCwgJ251bGwnLCAnd2UgaGF2ZSBhIG51bGwnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YodW5kZWZpbmVkLCAndW5kZWZpbmVkJywgJ3dlIGhhdmUgYW4gdW5kZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIHR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LnR5cGVPZiwgdHJ1ZSkudG8uYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RUeXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIF9ub3RfIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90VHlwZU9mKCd0ZWEnLCAnbnVtYmVyJywgJ3N0cmluZ3MgYXJlIG5vdCBudW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZW9mIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5ub3RUeXBlT2YsIHRydWUpLnRvLm5vdC5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFRlYSgnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0Lmluc3RhbmNlT2YsIHRydWUpLnRvLmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBTdHJpbmcoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQubm90SW5zdGFuY2VPZiwgdHJ1ZSlcbiAgICAgIC50by5ub3QuYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGVcbiAgICogaW5jbHVzaW9uIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXksIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLCBvciBhIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKFsxLDIsM10sIDIsICdhcnJheSBjb250YWlucyB2YWx1ZScpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoJ2Zvb2JhcicsICdmb28nLCAnc3RyaW5nIGNvbnRhaW5zIHN1YnN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9LCB7IGZvbzogJ2JhcicgfSwgJ29iamVjdCBjb250YWlucyBwcm9wZXJ0eScpO1xuICAgKlxuICAgKiBTdHJpY3QgZXF1YWxpdHkgKD09PSkgaXMgdXNlZC4gV2hlbiBhc3NlcnRpbmcgdGhlIGluY2x1c2lvbiBvZiBhIHZhbHVlIGluXG4gICAqIGFuIGFycmF5LCB0aGUgYXJyYXkgaXMgc2VhcmNoZWQgZm9yIGFuIGVsZW1lbnQgdGhhdCdzIHN0cmljdGx5IGVxdWFsIHRvIHRoZVxuICAgKiBnaXZlbiB2YWx1ZS4gV2hlbiBhc3NlcnRpbmcgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QsIHRoZSBvYmplY3RcbiAgICogaXMgc2VhcmNoZWQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBrZXlzLCBjaGVja2luZyB0aGF0IGVhY2ggb25lIGlzIHByZXNlbnRcbiAgICogYW5kIHN0cmljdHkgZXF1YWwgdG8gdGhlIGdpdmVuIHByb3BlcnR5IHZhbHVlLiBGb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZShbb2JqMSwgb2JqMl0sIG9iajEpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzogb2JqMX0pO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzogb2JqMSwgYmFyOiBvYmoyfSk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmluY2x1ZGUsIHRydWUpLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0XG4gICAqIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXksIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLCBvciBhIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFsxLDIsM10sIDQsICdhcnJheSBkb2Vzbid0IGNvbnRhaW4gdmFsdWUnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKCdmb29iYXInLCAnYmF6JywgJ3N0cmluZyBkb2Vzbid0IGNvbnRhaW4gc3Vic3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSh7IGZvbzogJ2JhcicsIGhlbGxvOiAndW5pdmVyc2UnIH0sIHsgZm9vOiAnYmF6JyB9LCAnb2JqZWN0IGRvZXNuJ3QgY29udGFpbiBwcm9wZXJ0eScpO1xuICAgKlxuICAgKiBTdHJpY3QgZXF1YWxpdHkgKD09PSkgaXMgdXNlZC4gV2hlbiBhc3NlcnRpbmcgdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZSBpbiBhblxuICAgKiBhcnJheSwgdGhlIGFycmF5IGlzIHNlYXJjaGVkIHRvIGNvbmZpcm0gdGhlIGFic2VuY2Ugb2YgYW4gZWxlbWVudCB0aGF0J3NcbiAgICogc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGdpdmVuIHZhbHVlLiBXaGVuIGFzc2VydGluZyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluXG4gICAqIGFuIG9iamVjdCwgdGhlIG9iamVjdCBpcyBzZWFyY2hlZCB0byBjb25maXJtIHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlblxuICAgKiBwcm9wZXJ0eSBrZXlzIGlzIGVpdGhlciBub3QgcHJlc2VudCBvciBub3Qgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGdpdmVuXG4gICAqIHByb3BlcnR5IHZhbHVlLiBGb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZShbb2JqMSwgb2JqMl0sIHthOiAxfSk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX19KTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajEsIGJhcjoge2I6IDJ9fSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGUsIHRydWUpLm5vdC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBpbmNsdWRlcyBgbmVlZGxlYC4gQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZVxuICAgKiBpbmNsdXNpb24gb2YgYSB2YWx1ZSBpbiBhbiBhcnJheSBvciBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICogRGVlcCBlcXVhbGl0eSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0LmRlZXBJbmNsdWRlKFtvYmoxLCBvYmoyXSwge2E6IDF9KTtcbiAgICogICAgIGFzc2VydC5kZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX19KTtcbiAgICogICAgIGFzc2VydC5kZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX0sIGJhcjoge2I6IDJ9fSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuZGVlcEluY2x1ZGUsIHRydWUpLmRlZXAuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0XG4gICAqIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXkgb3IgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqIERlZXAgZXF1YWxpdHkgaXMgdXNlZC5cbiAgICpcbiAgICogICAgIHZhciBvYmoxID0ge2E6IDF9XG4gICAqICAgICAgICwgb2JqMiA9IHtiOiAyfTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwSW5jbHVkZShbb2JqMSwgb2JqMl0sIHthOiA5fSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDl9fSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9LCBiYXI6IHtiOiA5fX0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwSW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwSW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlLCB0cnVlKS5ub3QuZGVlcC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqIFxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy4gXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gXG4gICAqIG9iamVjdC5cbiAgICogRW5hYmxlcyB0aGUgdXNlIG9mIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIHJlZmVyZW5jaW5nIG5lc3RlZCBcbiAgICogcHJvcGVydGllcy5cbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICogXG4gICAqICAgICBhc3NlcnQubmVzdGVkSW5jbHVkZSh7Jy5hJzogeydiJzogJ3gnfX0sIHsnXFxcXC5hLltiXSc6ICd4J30pO1xuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUoeydhJzogeydbYl0nOiAneCd9fSwgeydhLlxcXFxbYlxcXFxdJzogJ3gnfSk7XG4gICAqIFxuICAgKiBAbmFtZSBuZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljIFxuICAgKi8gXG5cbiAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5uZXN0ZWRJbmNsdWRlLCB0cnVlKS5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKiBcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgZG9lcyBub3QgaW5jbHVkZSAnbmVlZGxlJy4gXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIFxuICAgKiBvYmplY3QuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWQgXG4gICAqIHByb3BlcnRpZXMuIFxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKiBcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J2InOiAneCd9fSwgeydcXFxcLmEuYic6ICd5J30pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUoeydhJzogeydbYl0nOiAneCd9fSwgeydhLlxcXFxbYlxcXFxdJzogJ3knfSk7XG4gICAqIFxuICAgKiBAbmFtZSBub3ROZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljIFxuICAgKi8gXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLm5vdC5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBOZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICogXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIFxuICAgKiBvYmplY3Qgd2hpbGUgY2hlY2tpbmcgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWQgXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqIFxuICAgKiAgICAgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlKHthOiB7YjogW3t4OiAxfV19fSwgeydhLmJbMF0nOiB7eDogMX19KTtcbiAgICogICAgIGFzc2VydC5kZWVwTmVzdGVkSW5jbHVkZSh7Jy5hJzogeydbYl0nOiB7eDogMX19fSwgeydcXFxcLmEuXFxcXFtiXFxcXF0nOiB7eDogMX19KTtcbiAgICogICAgXG4gICAqIEBuYW1lIGRlZXBOZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljIFxuICAgKi9cblxuICBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLmRlZXAubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwTmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqIFxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBkb2VzIG5vdCBpbmNsdWRlICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBcbiAgICogb2JqZWN0IHdoaWxlIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkIFxuICAgKiBwcm9wZXJ0aWVzLlxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKiBcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkSW5jbHVkZSh7YToge2I6IFt7eDogMX1dfX0sIHsnYS5iWzBdJzoge3k6IDF9fSlcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkSW5jbHVkZSh7Jy5hJzogeydbYl0nOiB7eDogMX19fSwgeydcXFxcLmEuXFxcXFtiXFxcXF0nOiB7eTogMn19KTtcbiAgICogICAgXG4gICAqIEBuYW1lIG5vdERlZXBOZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljIFxuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLm5vdC5kZWVwLm5lc3RlZC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3duSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqIFxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBcbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzLlxuICAgKiBcbiAgICogICAgIGFzc2VydC5vd25JbmNsdWRlKHsgYTogMSB9LCB7IGE6IDEgfSk7XG4gICAqIFxuICAgKiBAbmFtZSBvd25JbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5vd25JbmNsdWRlLCB0cnVlKS5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKiBcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIFxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMuXG4gICAqIFxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICogXG4gICAqICAgICBhc3NlcnQubm90T3duSW5jbHVkZSh7IGE6IDEgfSwgeyBiOiAyIH0pO1xuICAgKiBcbiAgICogQG5hbWUgbm90T3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90T3duSW5jbHVkZSwgdHJ1ZSkubm90Lm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKiBcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gXG4gICAqIG9iamVjdCB3aGlsZSBpZ25vcmluZyBpbmhlcml0ZWQgcHJvcGVydGllcyBhbmQgY2hlY2tpbmcgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAqIFxuICAgKiAgICAgIGFzc2VydC5kZWVwT3duSW5jbHVkZSh7YToge2I6IDJ9fSwge2E6IHtiOiAyfX0pO1xuICAgKiAgICAgIFxuICAgKiBAbmFtZSBkZWVwT3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBPd25JbmNsdWRlLCB0cnVlKVxuICAgICAgLmRlZXAub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAubm90RGVlcE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKiBcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIFxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMgYW5kIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKiBcbiAgICogICAgICBhc3NlcnQubm90RGVlcE93bkluY2x1ZGUoe2E6IHtiOiAyfX0sIHthOiB7YzogM319KTtcbiAgICogICAgICBcbiAgICogQG5hbWUgbm90RGVlcE93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBPd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3REZWVwT3duSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5ub3QuZGVlcC5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubWF0Y2gsIHRydWUpLnRvLm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RNYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGRvZXMgbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBkb2VzIG5vdCBtYXRjaCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RNYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RNYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90TWF0Y2gsIHRydWUpLnRvLm5vdC5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RvU3RyaW5nJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5wcm9wZXJ0eSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkXG4gICAqIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgIHdpdGggYSB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAqICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LnByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZFxuICAgKiBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgKiAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgYmFkJyk7XG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAnY29mZmVlJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgbm90UHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90UHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCB3aXRoIGEgdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkXG4gICAqIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgYmxhY2s6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ29vbG9uZycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICdjb2ZmZWUnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLiBJbmhlcml0ZWRcbiAgICogcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25Qcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm93blByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm93blByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLmhhdmUub3duLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgLiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUnKTtcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSh7fSwgJ3RvU3RyaW5nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5vd24ucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIGFuZCBhIHZhbHVlXG4gICAqIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25Qcm9wZXJ0eVZhbCh7IGNvZmZlZTogJ2lzIGdvb2QnfSwgJ2NvZmZlZScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQub3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YFxuICAgKiB3aXRoIGEgdmFsdWUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGB2YWx1ZWAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICogKD09PSkuIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE93blByb3BlcnR5VmFsKHsgdGVhOiAnaXMgYmV0dGVyJ30sICd0ZWEnLCAnaXMgd29yc2UnKTtcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCh7fSwgJ3RvU3RyaW5nJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90T3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwT3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIGFuZCBhIHZhbHVlXG4gICAqIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay4gSW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwT3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRlZXBPd25Qcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmRlZXAub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwT3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgXG4gICAqIHdpdGggYSB2YWx1ZSBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBibGFjazogJ21hdGNoYScgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnb29sb25nJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ2NvZmZlZScsIHsgZ3JlZW46ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7fSwgJ3RvU3RyaW5nJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBPd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuZGVlcC5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCwgd2hpY2ggY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yXG4gICAqIG5lc3RlZCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQubmVzdGVkUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJyk7XG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaFxuICAgKiBjYW4gYmUgYSBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgbmVzdGVkIHJlZmVyZW5jZS4gVGhlXG4gICAqIHByb3BlcnR5IGNhbm5vdCBleGlzdCBvbiB0aGUgb2JqZWN0IG5vciBhbnl3aGVyZSBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5vb2xvbmcnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TmVzdGVkUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBuZXN0ZWRcbiAgICogcmVmZXJlbmNlLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdtYXRjaGEnKTtcbiAgICpcbiAgICogQG5hbWUgbmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoXG4gICAqIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdrb25hY2hhJyk7XG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3ROZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwTmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aCBhIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBuZXN0ZWRcbiAgICogcmVmZXJlbmNlLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgbWF0Y2hhOiAneXVtJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE5lc3RlZFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoXG4gICAqIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgb29sb25nOiAneXVtJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgbWF0Y2hhOiAneXVjaycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuYmxhY2snLCB7IG1hdGNoYTogJ3l1bScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmRlZXAubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhPZihvYmplY3QsIGxlbmd0aCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgYGxlbmd0aGAgcHJvcGVydHkgd2l0aCB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoWzEsMiwzXSwgMywgJ2FycmF5IGhhcyBsZW5ndGggb2YgMycpO1xuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKCdmb29iYXInLCA2LCAnc3RyaW5nIGhhcyBsZW5ndGggb2YgNicpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubGVuZ3RoT2YgPSBmdW5jdGlvbiAoZXhwLCBsZW4sIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5sZW5ndGhPZiwgdHJ1ZSkudG8uaGF2ZS5sZW5ndGhPZihsZW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmhhc0FueUtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQW55S2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2lEb250RXhpc3QnLCAnYmF6J10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7Zm9vOiAzMCwgaURvbnRFeGlzdDogOTksIGJhejogMTMzN30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9LCAna2V5J10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddKSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGhhc0FueUtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbnlLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lmhhc0FueUtleXMsIHRydWUpLnRvLmhhdmUuYW55LmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5oYXNBbGxLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYWxsIGFuZCBvbmx5IGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnYmFyJywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGJhcjogOTksIGJhejogMTMzN10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9LCAna2V5J10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddKTtcbiAgICpcbiAgICogQG5hbWUgaGFzQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQWxsS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbGxLZXlzLCB0cnVlKS50by5oYXZlLmFsbC5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuY29udGFpbnNBbGxLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYWxsIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQgYnV0IG1heSBoYXZlIG1vcmUga2V5cyBub3QgbGlzdGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ2ZvbycsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnYmFyJywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7Zm9vOiAzMCwgYmF6OiAxMzM3fSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGJhcjogOTksIGJhejogMTMzN30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe2ZvbzogMX1dKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9LCAna2V5J10pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7Zm9vOiAnYmFyJ31dKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddKTtcbiAgICpcbiAgICogQG5hbWUgY29udGFpbnNBbGxLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jb250YWluc0FsbEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuY29udGFpbnNBbGxLZXlzLCB0cnVlKVxuICAgICAgLnRvLmNvbnRhaW4uYWxsLmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFueUtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBub25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnb25lJywgJ3R3bycsICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtvbmU6IDEsIHR3bzogMiwgZXhhbXBsZTogJ2Zvbyd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQW55S2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbnkua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydvbmUnLCAndHdvJywgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge29uZTogMSwgdHdvOiAyLCBleGFtcGxlOiAnZm9vJ30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe29uZTogJ3R3byd9LCAnZXhhbXBsZSddKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe29uZTogJ3R3byd9LCAnZXhhbXBsZSddKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbGxLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFsbC5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaGFzQW55RGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFt7dHdvOiAndHdvJ30sICd2YWx1ZVR3byddXSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge3RocmVlOiAndGhyZWUnfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFsbEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbnlEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbnlEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmFueS5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmhhc0FsbERlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYWxsIGFuZCBvbmx5IGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ31dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgaGFzQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbGxEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbGxEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmNvbnRhaW5zQWxsRGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGNvbnRhaW5zIGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgY29udGFpbnNBbGxEZWVwS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5jb250YWluLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQW55RGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBub25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7dGhpc0RvZXNOb3Q6ICdleGlzdCd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe3R3ZW50eTogJ3R3ZW50eSd9LCB7ZmlmdHk6ICdmaWZ0eSd9XSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7dHdlbnR5OiAndHdlbnR5J30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3t0d2VudHk6ICd0d2VudHknfSwge2ZpZnR5OiAnZmlmdHknfV0pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFueURlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFueS5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQWxsRGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7dGhpc0RvZXNOb3Q6ICdleGlzdCd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe3R3ZW50eTogJ3R3ZW50eSd9LCB7b25lOiAnb25lJ31dKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHt0d2VudHk6ICd0d2VudHknfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7ZmlmdHk6ICdmaWZ0eSd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYWxsLmRlZXAua2V5cyhrZXlzKTtcbiAgfVxuXG4gLyoqXG4gICAqICMjIyAudGhyb3dzKGZuLCBbZXJyb3JMaWtlL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBjb25zdHJ1Y3RvciwgYXNzZXJ0cyB0aGF0IGBmbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuXG4gICAqIGluc3RhbmNlIG9mIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGluc3RhbmNlLCBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biBpcyB0aGUgc2FtZVxuICAgKiBpbnN0YW5jZSBhcyBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVyck1zZ01hdGNoZXJgIGlzIHByb3ZpZGVkLCBpdCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIHdpbGwgaGF2ZSBhXG4gICAqIG1lc3NhZ2UgbWF0Y2hpbmcgYGVyck1zZ01hdGNoZXJgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgZXJyb3JJbnN0YW5jZSk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvciwgJ0Vycm9yIHRocm93biBtdXN0IGJlIGEgUmVmZXJlbmNlRXJyb3IgYW5kIGhhdmUgdGhpcyBtc2cnKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIGVycm9ySW5zdGFuY2UsICdFcnJvciB0aHJvd24gbXVzdCBiZSB0aGUgc2FtZSBlcnJvckluc3RhbmNlIGFuZCBoYXZlIHRoaXMgbXNnJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvciwgL0Vycm9yIHRocm93biBtdXN0IGJlIGEgUmVmZXJlbmNlRXJyb3IgYW5kIG1hdGNoIHRoaXMvKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIGVycm9ySW5zdGFuY2UsIC9FcnJvciB0aHJvd24gbXVzdCBiZSB0aGUgc2FtZSBlcnJvckluc3RhbmNlIGFuZCBtYXRjaCB0aGlzLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93c1xuICAgKiBAYWxpYXMgdGhyb3dcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3RvcnxFcnJvcn0gZXJyb3JMaWtlXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gZXJyTXNnTWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiAoZm4sIGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZXJyb3JMaWtlIHx8IGVycm9yTGlrZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJyTXNnTWF0Y2hlciA9IGVycm9yTGlrZTtcbiAgICAgIGVycm9yTGlrZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFzc2VydEVyciA9IG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LnRocm93cywgdHJ1ZSlcbiAgICAgIC50by50aHJvdyhlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIpO1xuICAgIHJldHVybiBmbGFnKGFzc2VydEVyciwgJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RUaHJvdyhmbiwgW2Vycm9yTGlrZS9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIElmIGBlcnJvckxpa2VgIGlzIGFuIGBFcnJvcmAgY29uc3RydWN0b3IsIGFzc2VydHMgdGhhdCBgZm5gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhblxuICAgKiBpbnN0YW5jZSBvZiBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBpbnN0YW5jZSwgYXNzZXJ0cyB0aGF0IHRoZSBlcnJvciB0aHJvd24gaXMgX25vdF8gdGhlIHNhbWVcbiAgICogaW5zdGFuY2UgYXMgYGVycm9yTGlrZWAuXG4gICAqIElmIGBlcnJNc2dNYXRjaGVyYCBpcyBwcm92aWRlZCwgaXQgYWxzbyBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biB3aWxsIF9ub3RfIGhhdmUgYVxuICAgKiBtZXNzYWdlIG1hdGNoaW5nIGBlcnJNc2dNYXRjaGVyYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sICdBbnkgRXJyb3IgdGhyb3duIG11c3Qgbm90IGhhdmUgdGhpcyBtZXNzYWdlJyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCAvQW55IEVycm9yIHRocm93biBtdXN0IG5vdCBtYXRjaCB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBFcnJvcik7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBlcnJvckluc3RhbmNlKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAnRXJyb3IgbXVzdCBub3QgaGF2ZSB0aGlzIG1lc3NhZ2UnKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIGVycm9ySW5zdGFuY2UsICdFcnJvciBtdXN0IG5vdCBoYXZlIHRoaXMgbWVzc2FnZScpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IsIC9FcnJvciBtdXN0IG5vdCBtYXRjaCB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBlcnJvckluc3RhbmNlLCAvRXJyb3IgbXVzdCBub3QgbWF0Y2ggdGhpcy8pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90VGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2VcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBlcnJNc2dNYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBlcnJvckxpa2UgfHwgZXJyb3JMaWtlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnJNc2dNYXRjaGVyID0gZXJyb3JMaWtlO1xuICAgICAgZXJyb3JMaWtlID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90VGhyb3csIHRydWUpXG4gICAgICAudG8ubm90LnRocm93KGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3BlcmF0b3IodmFsMSwgb3BlcmF0b3IsIHZhbDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQ29tcGFyZXMgdHdvIHZhbHVlcyB1c2luZyBgb3BlcmF0b3JgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc8JywgMiwgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPicsIDIsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBvcGVyYXRvclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWwxXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWwyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vcGVyYXRvciA9IGZ1bmN0aW9uICh2YWwsIG9wZXJhdG9yLCB2YWwyLCBtc2cpIHtcbiAgICB2YXIgb2s7XG4gICAgc3dpdGNoKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlICc9PSc6XG4gICAgICAgIG9rID0gdmFsID09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgb2sgPSB2YWwgPT09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPic6XG4gICAgICAgIG9rID0gdmFsID4gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc+PSc6XG4gICAgICAgIG9rID0gdmFsID49IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIG9rID0gdmFsIDwgdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc8PSc6XG4gICAgICAgIG9rID0gdmFsIDw9IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnIT0nOlxuICAgICAgICBvayA9IHZhbCAhPSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgIG9rID0gdmFsICE9PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1zZyA9IG1zZyA/IG1zZyArICc6ICcgOiBtc2c7XG4gICAgICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIG1zZyArICdJbnZhbGlkIG9wZXJhdG9yIFwiJyArIG9wZXJhdG9yICsgJ1wiJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgYXNzZXJ0Lm9wZXJhdG9yXG4gICAgICAgICk7XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihvaywgbXNnLCBhc3NlcnQub3BlcmF0b3IsIHRydWUpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMilcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gbm90IGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKSApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oYWN0dWFsLCBleHBlY3RlZCwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgYGV4cGVjdGVkYCwgdG8gd2l0aGluIGEgKy8tIGBkZWx0YWAgcmFuZ2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY2xvc2VUbygxLjUsIDEsIDAuNSwgJ251bWJlcnMgYXJlIGNsb3NlJyk7XG4gICAqXG4gICAqIEBuYW1lIGNsb3NlVG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jbG9zZVRvID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBkZWx0YSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmNsb3NlVG8sIHRydWUpLnRvLmJlLmNsb3NlVG8oZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuYXBwcm94aW1hdGVseShhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5hcHByb3hpbWF0ZWx5KDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgYXBwcm94aW1hdGVseVxuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmFwcHJveGltYXRlbHkgPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuYXBwcm94aW1hdGVseSwgdHJ1ZSlcbiAgICAgIC50by5iZS5hcHByb3hpbWF0ZWx5KGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMyBdLCAnc2FtZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZU1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5zYW1lTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuXG4gICAqIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U2FtZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgNSwgMSwgMyBdLCAnbm90IHNhbWUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZURlZXBNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgW3sgYjogMiB9LCB7IGE6IDEgfSwgeyBjOiAzIH1dLCAnc2FtZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuc2FtZS5kZWVwLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lRGVlcE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci5cbiAgICogVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U2FtZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbeyBiOiAyIH0sIHsgYTogMSB9LCB7IGY6IDUgfV0sICdub3Qgc2FtZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUuZGVlcC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZU9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICogVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMSwgMiwgMyBdLCAnc2FtZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuc2FtZS5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIHRoZSBzYW1lXG4gICAqIG9yZGVyLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFNhbWVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdub3Qgc2FtZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZURlZXBPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sICdzYW1lIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZVxuICAgKiBvcmRlci4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyB6OiA1IH0gXSwgJ25vdCBzYW1lIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGE6IDEgfSwgeyBjOiAzIH0gXSwgJ25vdCBzYW1lIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLmRlZXAub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZU1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMiBdLCAnaW5jbHVkZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlTWVtYmVycyhbIDEsIDIsIDMgXSwgWyA1LCAxIF0sICdub3QgaW5jbHVkZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZU1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZURlZXBNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGEgZGVlcFxuICAgKiBlcXVhbGl0eSBjaGVjay4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYTogMSB9LCB7IGI6IDIgfSBdLCAnaW5jbHVkZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLmRlZXAubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZURlZXBNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogZGVlcCBlcXVhbGl0eSBjaGVjay4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgZjogNSB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5kZWVwLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHlcbiAgICogY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDEsIDIgXSwgJ2luY2x1ZGUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHlcbiAgICogY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEgXSwgJ25vdCBpbmNsdWRlIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAzIF0sICdub3QgaW5jbHVkZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eVxuICAgKiBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYTogMSB9LCB7IGI6IDIgfSBdLCAnaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eVxuICAgKiBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYTogMSB9LCB7IGY6IDUgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGE6IDEgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGM6IDMgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5kZWVwLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAub25lT2YoaW5MaXN0LCBsaXN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBub24tb2JqZWN0LCBub24tYXJyYXkgdmFsdWUgYGluTGlzdGAgYXBwZWFycyBpbiB0aGUgZmxhdCBhcnJheSBgbGlzdGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub25lT2YoMSwgWyAyLCAxIF0sICdOb3QgZm91bmQgaW4gbGlzdCcpO1xuICAgKlxuICAgKiBAbmFtZSBvbmVPZlxuICAgKiBAcGFyYW0geyp9IGluTGlzdFxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBsaXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vbmVPZiA9IGZ1bmN0aW9uIChpbkxpc3QsIGxpc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oaW5MaXN0LCBtc2csIGFzc2VydC5vbmVPZiwgdHJ1ZSkudG8uYmUub25lT2YobGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5jaGFuZ2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDIyIH07XG4gICAqICAgICBhc3NlcnQuY2hhbmdlcyhmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jaGFuZ2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5jaGFuZ2VzLCB0cnVlKS50by5jaGFuZ2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gICAvKipcbiAgICogIyMjIC5jaGFuZ2VzQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYnkgYW4gYW1vdW50IChkZWx0YSkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCArPSAyIH07XG4gICAqICAgICBhc3NlcnQuY2hhbmdlc0J5KGZuLCBvYmosICd2YWwnLCAyKTtcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlc0J5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jaGFuZ2VzQnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmNoYW5nZXNCeSwgdHJ1ZSlcbiAgICAgIC50by5jaGFuZ2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdENoYW5nZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2ZvbycpOyB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90Q2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdENoYW5nZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UsIHRydWUpXG4gICAgICAudG8ubm90LmNoYW5nZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlc0J1dE5vdEJ5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgb3Igb2YgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMTAgfTtcbiAgICogICAgIGFzc2VydC5jaGFuZ2VzQnV0Tm90QnkoZm4sIG9iaiwgJ3ZhbCcsIDUpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzQnV0Tm90QnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNoYW5nZXNCdXROb3RCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuY2hhbmdlc0J1dE5vdEJ5LCB0cnVlKVxuICAgICAgLnRvLmNoYW5nZShvYmosIHByb3ApLmJ1dC5ub3QuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGluY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAxMyB9O1xuICAgKiAgICAgYXNzZXJ0LmluY3JlYXNlcyhmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY3JlYXNlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmluY3JlYXNlcywgdHJ1ZSlcbiAgICAgIC50by5pbmNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2VzQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGluY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCArPSAxMCB9O1xuICAgKiAgICAgYXNzZXJ0LmluY3JlYXNlc0J5KGZuLCBvYmosICd2YWwnLCAxMCk7XG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlc0J5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXNCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuaW5jcmVhc2VzQnksIHRydWUpXG4gICAgICAudG8uaW5jcmVhc2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90SW5jcmVhc2UoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgaW5jcmVhc2UgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gOCB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RJbmNyZWFzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlc0J1dE5vdEJ5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGluY3JlYXNlIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzQnV0Tm90QnkoZm4sIG9iaiwgJ3ZhbCcsIDEwKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzQnV0Tm90QnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY3JlYXNlc0J1dE5vdEJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5pbmNyZWFzZXNCdXROb3RCeSwgdHJ1ZSlcbiAgICAgIC50by5pbmNyZWFzZShvYmosIHByb3ApLmJ1dC5ub3QuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZGVjcmVhc2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVjcmVhc2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZGVjcmVhc2VzLCB0cnVlKVxuICAgICAgLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZXNCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgLT0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRlY3JlYXNlc0J5KGZuLCBvYmosICd2YWwnLCA1KTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzQnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlY3JlYXNlc0J5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kZWNyZWFzZXNCeSwgdHJ1ZSlcbiAgICAgIC50by5kZWNyZWFzZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3REZWNyZWFzZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTUgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90RGVjcmVhc2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90RGVjcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90RGVjcmVhc2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90RGVjcmVhc2UsIHRydWUpXG4gICAgICAudG8ubm90LmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90RGVjcmVhc2VCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdERlY3JlYXNlQnkoZm4sIG9iaiwgJ3ZhbCcsIDEpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90RGVjcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZUJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdERlY3JlYXNlQnksIHRydWUpXG4gICAgICAudG8ubm90LmRlY3JlYXNlKG9iaiwgcHJvcCkuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzQnV0Tm90QnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRlY3JlYXNlc0J1dE5vdEJ5KGZuLCBvYmosICd2YWwnLCAxKTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzQnV0Tm90QnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlY3JlYXNlc0J1dE5vdEJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kZWNyZWFzZXNCdXROb3RCeSwgdHJ1ZSlcbiAgICAgIC50by5kZWNyZWFzZShvYmosIHByb3ApLmJ1dC5ub3QuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyohXG4gICAqICMjIyAuaWZFcnJvcihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgaWYgdmFsdWUgaXMgbm90IGEgZmFsc2UgdmFsdWUsIGFuZCB0aHJvd3MgaWYgaXQgaXMgYSB0cnVlIHZhbHVlLlxuICAgKiBUaGlzIGlzIGFkZGVkIHRvIGFsbG93IGZvciBjaGFpIHRvIGJlIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgTm9kZSdzXG4gICAqIGFzc2VydCBjbGFzcy5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0kgYW0gYSBjdXN0b20gZXJyb3InKTtcbiAgICogICAgIGFzc2VydC5pZkVycm9yKGVycik7IC8vIFJldGhyb3dzIGVyciFcbiAgICpcbiAgICogQG5hbWUgaWZFcnJvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHRocm93KHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRXh0ZW5zaWJsZShvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBleHRlbnNpYmxlIChjYW4gaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdCkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNFeHRlbnNpYmxlKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNFeHRlbnNpYmxlXG4gICAqIEBhbGlhcyBleHRlbnNpYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNFeHRlbnNpYmxlID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzRXh0ZW5zaWJsZSwgdHJ1ZSkudG8uYmUuZXh0ZW5zaWJsZTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEV4dGVuc2libGUob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gZXh0ZW5zaWJsZS5cbiAgICpcbiAgICogICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKG5vbkV4dGVuc2libGVPYmplY3QpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShzZWFsZWRPYmplY3QpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEV4dGVuc2libGVcbiAgICogQGFsaWFzIG5vdEV4dGVuc2libGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEV4dGVuc2libGUgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlLCB0cnVlKS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1NlYWxlZChvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBzZWFsZWQgKGNhbm5vdCBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0XG4gICAqIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW5ub3QgYmUgcmVtb3ZlZCkuXG4gICAqXG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc1NlYWxlZChzZWFsZWRPYmplY3QpO1xuICAgKiAgICAgYXNzZXJ0LmlzU2VhbGVkKGZyb3plbk9iamVjdCk7XG4gICAqXG4gICAqIEBuYW1lIGlzU2VhbGVkXG4gICAqIEBhbGlhcyBzZWFsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1NlYWxlZCA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc1NlYWxlZCwgdHJ1ZSkudG8uYmUuc2VhbGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U2VhbGVkKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIHNlYWxlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdFNlYWxlZCh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90U2VhbGVkXG4gICAqIEBhbGlhcyBub3RTZWFsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFNlYWxlZCA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc05vdFNlYWxlZCwgdHJ1ZSkudG8ubm90LmJlLnNlYWxlZDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Zyb3plbihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmcm96ZW4gKGNhbm5vdCBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0XG4gICAqIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW5ub3QgYmUgbW9kaWZpZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKiAgICAgYXNzZXJ0LmZyb3plbihmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Zyb3plblxuICAgKiBAYWxpYXMgZnJvemVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGcm96ZW4gPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNGcm96ZW4sIHRydWUpLnRvLmJlLmZyb3plbjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZyb3plbihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBfbm90XyBmcm96ZW4uXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RGcm96ZW4oe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZyb3plblxuICAgKiBAYWxpYXMgbm90RnJvemVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGcm96ZW4gPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNOb3RGcm96ZW4sIHRydWUpLnRvLm5vdC5iZS5mcm96ZW47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNFbXB0eSh0YXJnZXQpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGRvZXMgbm90IGNvbnRhaW4gYW55IHZhbHVlcy5cbiAgICogRm9yIGFycmF5cyBhbmQgc3RyaW5ncywgaXQgY2hlY2tzIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICogRm9yIGBNYXBgIGFuZCBgU2V0YCBpbnN0YW5jZXMsIGl0IGNoZWNrcyB0aGUgYHNpemVgIHByb3BlcnR5LlxuICAgKiBGb3Igbm9uLWZ1bmN0aW9uIG9iamVjdHMsIGl0IGdldHMgdGhlIGNvdW50IG9mIG93blxuICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkoW10pO1xuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkoJycpO1xuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkobmV3IE1hcCk7XG4gICAqICAgICBhc3NlcnQuaXNFbXB0eSh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzRW1wdHlcbiAgICogQGFsaWFzIGVtcHR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xNYXB8U2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRW1wdHksIHRydWUpLnRvLmJlLmVtcHR5O1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RW1wdHkodGFyZ2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBjb250YWlucyB2YWx1ZXMuXG4gICAqIEZvciBhcnJheXMgYW5kIHN0cmluZ3MsIGl0IGNoZWNrcyB0aGUgYGxlbmd0aGAgcHJvcGVydHkuXG4gICAqIEZvciBgTWFwYCBhbmQgYFNldGAgaW5zdGFuY2VzLCBpdCBjaGVja3MgdGhlIGBzaXplYCBwcm9wZXJ0eS5cbiAgICogRm9yIG5vbi1mdW5jdGlvbiBvYmplY3RzLCBpdCBnZXRzIHRoZSBjb3VudCBvZiBvd25cbiAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KFsxLCAyXSk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eSgnMzQnKTtcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KG5ldyBTZXQoWzUsIDZdKSk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eSh7IGtleTogNyB9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RFbXB0eVxuICAgKiBAYWxpYXMgbm90RW1wdHlcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfE1hcHxTZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEVtcHR5ID0gZnVuY3Rpb24odmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RFbXB0eSwgdHJ1ZSkudG8ubm90LmJlLmVtcHR5O1xuICB9O1xuXG4gIC8qIVxuICAgKiBBbGlhc2VzLlxuICAgKi9cblxuICAoZnVuY3Rpb24gYWxpYXMobmFtZSwgYXMpe1xuICAgIGFzc2VydFthc10gPSBhc3NlcnRbbmFtZV07XG4gICAgcmV0dXJuIGFsaWFzO1xuICB9KVxuICAoJ2lzT2snLCAnb2snKVxuICAoJ2lzTm90T2snLCAnbm90T2snKVxuICAoJ3Rocm93cycsICd0aHJvdycpXG4gICgndGhyb3dzJywgJ1Rocm93JylcbiAgKCdpc0V4dGVuc2libGUnLCAnZXh0ZW5zaWJsZScpXG4gICgnaXNOb3RFeHRlbnNpYmxlJywgJ25vdEV4dGVuc2libGUnKVxuICAoJ2lzU2VhbGVkJywgJ3NlYWxlZCcpXG4gICgnaXNOb3RTZWFsZWQnLCAnbm90U2VhbGVkJylcbiAgKCdpc0Zyb3plbicsICdmcm96ZW4nKVxuICAoJ2lzTm90RnJvemVuJywgJ25vdEZyb3plbicpXG4gICgnaXNFbXB0eScsICdlbXB0eScpXG4gICgnaXNOb3RFbXB0eScsICdub3RFbXB0eScpO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciB1c2VkID0gW107XG5cbi8qIVxuICogQ2hhaSB2ZXJzaW9uXG4gKi9cblxuZXhwb3J0cy52ZXJzaW9uID0gJzQuMS4yJztcblxuLyohXG4gKiBBc3NlcnRpb24gRXJyb3JcbiAqL1xuXG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG5cbi8qIVxuICogVXRpbHMgZm9yIHBsdWdpbnMgKG5vdCBleHBvcnRlZClcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vY2hhaS91dGlscycpO1xuXG4vKipcbiAqICMgLnVzZShmdW5jdGlvbilcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBleHRlbmQgdGhlIGludGVybmFscyBvZiBDaGFpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAcmV0dXJucyB7dGhpc30gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICBmbihleHBvcnRzLCB1dGlsKTtcbiAgICB1c2VkLnB1c2goZm4pO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG59O1xuXG4vKiFcbiAqIFV0aWxpdHkgRnVuY3Rpb25zXG4gKi9cblxuZXhwb3J0cy51dGlsID0gdXRpbDtcblxuLyohXG4gKiBDb25maWd1cmF0aW9uXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY2hhaS9jb25maWcnKTtcbmV4cG9ydHMuY29uZmlnID0gY29uZmlnO1xuXG4vKiFcbiAqIFByaW1hcnkgYEFzc2VydGlvbmAgcHJvdG90eXBlXG4gKi9cblxudmFyIGFzc2VydGlvbiA9IHJlcXVpcmUoJy4vY2hhaS9hc3NlcnRpb24nKTtcbmV4cG9ydHMudXNlKGFzc2VydGlvbik7XG5cbi8qIVxuICogQ29yZSBBc3NlcnRpb25zXG4gKi9cblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NoYWkvY29yZS9hc3NlcnRpb25zJyk7XG5leHBvcnRzLnVzZShjb3JlKTtcblxuLyohXG4gKiBFeHBlY3QgaW50ZXJmYWNlXG4gKi9cblxudmFyIGV4cGVjdCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvZXhwZWN0Jyk7XG5leHBvcnRzLnVzZShleHBlY3QpO1xuXG4vKiFcbiAqIFNob3VsZCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgc2hvdWxkID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9zaG91bGQnKTtcbmV4cG9ydHMudXNlKHNob3VsZCk7XG5cbi8qIVxuICogQXNzZXJ0IGludGVyZmFjZVxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2Fzc2VydCcpO1xuZXhwb3J0cy51c2UoYXNzZXJ0KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvY2hhaScpO1xuIiwiKGZ1bmN0aW9uKGNoYWlEb20pIHtcbiAgaWYgKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gY2hhaURvbVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjaGFpRG9tXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjaGFpLnVzZShjaGFpRG9tKVxuICB9XG59KGZ1bmN0aW9uKGNoYWksIHV0aWxzKSB7XG4gIHZhciBmbGFnID0gdXRpbHMuZmxhZyxcblxuICBlbFRvU3RyaW5nID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgZGVzY1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdCkge1xuICAgICAgaWYgKGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdlbXB0eSBOb2RlTGlzdCdcbiAgICAgIGRlc2MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbCwgMCwgNSkubWFwKGVsVG9TdHJpbmcpLmpvaW4oJywgJylcbiAgICAgIHJldHVybiBlbC5sZW5ndGggPiA1ID8gZGVzYyArICcuLi4gKCsnICsgKGVsLmxlbmd0aCAtIDUpICsgJyBtb3JlKScgOiBkZXNjXG4gICAgfVxuICAgIGlmICghKGVsIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhlbClcbiAgICB9XG5cbiAgICBkZXNjID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVsLmlkKSB7XG4gICAgICBkZXNjICs9ICcjJyArIGVsLmlkXG4gICAgfVxuICAgIGlmIChlbC5jbGFzc05hbWUpIHtcbiAgICAgIGRlc2MgKz0gJy4nICsgU3RyaW5nKGVsLmNsYXNzTmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLicpXG4gICAgfVxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwuYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIubmFtZSAhPT0gJ2NsYXNzJyAmJiBhdHRyLm5hbWUgIT09ICdpZCcpIHtcbiAgICAgICAgZGVzYyArPSAnWycgKyBhdHRyLm5hbWUgKyAoYXR0ci52YWx1ZSA/ICc9XCInICsgYXR0ci52YWx1ZSArICdcIl0nIDogJ10nKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGRlc2NcbiAgfSxcblxuICBhdHRyQXNzZXJ0ID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKVxuXG4gICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSB8fCB1bmRlZmluZWQgPT09IHZhbCkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICEhZWwuYXR0cmlidXRlc1tuYW1lXVxuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgYW4gYXR0cmlidXRlICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSBhbiBhdHRyaWJ1dGUgI3tleHB9J1xuICAgICAgICAsIG5hbWVcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB2YWwgPT09IGFjdHVhbFxuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgYW4gYXR0cmlidXRlICcgKyB1dGlscy5pbnNwZWN0KG5hbWUpICsgJyB3aXRoIHRoZSB2YWx1ZSAje2V4cH0sIGJ1dCB0aGUgdmFsdWUgd2FzICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSBhbiBhdHRyaWJ1dGUgJyArIHV0aWxzLmluc3BlY3QobmFtZSkgKyAnIHdpdGggdGhlIHZhbHVlICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCBhY3R1YWxcbiAgICAgIClcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWwpXG4gIH1cblxuICB1dGlscy5lbFRvU3RyaW5nID0gZWxUb1N0cmluZ1xuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2F0dHInLCBhdHRyQXNzZXJ0KVxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2F0dHJpYnV0ZScsIGF0dHJBc3NlcnQpXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdjbGFzcycsIGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIGNsYXNzICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgY2xhc3MgI3tleHB9J1xuICAgICAgLCBjbGFzc05hbWVcbiAgICApXG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdpZCcsIGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGVsLmlkID09IGlkXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgaWQgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSBpZCAje2V4cH0nXG4gICAgICAsIGlkXG4gICAgKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaHRtbCcsIGZ1bmN0aW9uKGh0bWwpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKSwgYWN0dWFsID0gZmxhZyh0aGlzLCAnb2JqZWN0JykuaW5uZXJIVE1MXG5cbiAgICBpZiAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGFjdHVhbC5pbmRleE9mKGh0bWwpID49IDBcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3thY3R9IHRvIGNvbnRhaW4gSFRNTCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7YWN0fSBub3QgdG8gY29udGFpbiBIVE1MICN7ZXhwfSdcbiAgICAgICAgLCBodG1sXG4gICAgICAgICwgYWN0dWFsXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBhY3R1YWwgPT09IGh0bWxcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIEhUTUwgI3tleHB9LCBidXQgdGhlIEhUTUwgd2FzICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSBIVE1MICN7ZXhwfSdcbiAgICAgICAgLCBodG1sXG4gICAgICAgICwgYWN0dWFsXG4gICAgICApXG4gICAgfVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGV4dCcsIGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGNvbnRhaW5zID0gZmxhZyh0aGlzLCAnY29udGFpbnMnKSwgYWN0dWFsLCByZXN1bHRcblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiB3aW5kb3cuTm9kZUxpc3QpIHtcbiAgICAgIGFjdHVhbCA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvYmosIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC50ZXh0Q29udGVudCB9KVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgcmVzdWx0ID0gY29udGFpbnMgP1xuICAgICAgICAgIHRleHRbZmxhZyh0aGlzLCAnbmVnYXRlJykgPyAnc29tZScgOiAnZXZlcnknXShmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChvYmosIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC50ZXh0Q29udGVudCA9PT0gdCB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgOlxuICAgICAgICAgIHV0aWxzLmVxbChhY3R1YWwsIHRleHQpXG5cbiAgICAgICAgYWN0dWFsID0gYWN0dWFsLmpvaW4oKVxuICAgICAgICB0ZXh0ID0gdGV4dC5qb2luKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbCA9IGFjdHVhbC5qb2luKCcnKVxuICAgICAgICByZXN1bHQgPSBjb250YWlucyA/IGFjdHVhbC5pbmRleE9mKHRleHQpID49IDAgOiBhY3R1YWwgPT09IHRleHRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWN0dWFsID0gZmxhZyh0aGlzLCAnb2JqZWN0JykudGV4dENvbnRlbnRcbiAgICAgIHJlc3VsdCA9IGNvbnRhaW5zID8gYWN0dWFsLmluZGV4T2YodGV4dCkgPj0gMCA6IGFjdHVhbCA9PT0gdGV4dFxuICAgIH1cblxuICAgIHZhciBvYmpEZXNjID0gZWxUb1N0cmluZyhvYmopXG4gICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmVzdWx0XG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBvYmpEZXNjICsgJyB0byBjb250YWluICN7ZXhwfSwgYnV0IHRoZSB0ZXh0IHdhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBvYmpEZXNjICsgJyBub3QgdG8gY29udGFpbiAje2V4cH0sIGJ1dCB0aGUgdGV4dCB3YXMgI3thY3R9J1xuICAgICAgICAsIHRleHRcbiAgICAgICAgLCBhY3R1YWxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgdG8gaGF2ZSB0ZXh0ICN7ZXhwfSwgYnV0IHRoZSB0ZXh0IHdhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBvYmpEZXNjICsgJyBub3QgdG8gaGF2ZSB0ZXh0ICN7ZXhwfSdcbiAgICAgICAgLCB0ZXh0XG4gICAgICAgICwgYWN0dWFsXG4gICAgICApXG4gICAgfVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgndmFsdWUnLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLCBhY3R1YWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKS52YWx1ZVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JykudmFsdWUgPT09IHZhbHVlXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgdmFsdWUgI3tleHB9LCBidXQgdGhlIHZhbHVlIHdhcyAje2FjdH0nXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIHZhbHVlICN7ZXhwfSdcbiAgICAgICwgdmFsdWVcbiAgICAgICwgYWN0dWFsXG4gICAgKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmoubGVuZ3RoID4gMFxuICAgICAgICAgICwgJ2V4cGVjdGVkIGFuIGVtcHR5IE5vZGVMaXN0IHRvIGhhdmUgbm9kZXMnXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGV4aXN0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdlbXB0eScsIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmouY2hpbGRyZW4ubGVuZ3RoID09PSAwXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gYmUgZW1wdHknXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2Ygd2luZG93Lk5vZGVMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iai5sZW5ndGggPT09IDBcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBiZSBlbXB0eSdcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgYmUgZW1wdHknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLFxuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYWN0dWFsTGVuZ3RoID0gb2JqLmNoaWxkcmVuID8gb2JqLmNoaWxkcmVuLmxlbmd0aCA6IG9iai5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICAgIGFjdHVhbExlbmd0aCA9PT0gbGVuZ3RoXG4gICAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBoYXZlICN7ZXhwfSBjaGlsZHJlbiBidXQgaXQgaGFkICN7YWN0fSBjaGlsZHJlbidcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBoYXZlICN7ZXhwfSBjaGlsZHJlbidcbiAgICAgICAgICAgICwgbGVuZ3RoXG4gICAgICAgICAgICAsIGFjdHVhbExlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcylcbiAgICAgIH1cbiAgICB9XG4gIClcblxuXG4gIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnbWF0Y2gnLCBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmoubWF0Y2hlcyhzZWxlY3RvcilcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBtYXRjaCAje2V4cH0nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IG1hdGNoICN7ZXhwfSdcbiAgICAgICAgICAsIHNlbGVjdG9yXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2Ygd2luZG93Lk5vZGVMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICghIW9iai5sZW5ndGggJiYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LmNhbGwob2JqLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwubWF0Y2hlcyhzZWxlY3RvcikgfSkpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbWF0Y2ggI3tleHB9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBtYXRjaCAje2V4cH0nXG4gICAgICAgICAgLCBzZWxlY3RvclxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2NvbnRhaW4nLFxuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN1Yml0ZW0pIHtcbiAgICAgICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN1Yml0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgISFvYmoucXVlcnlTZWxlY3RvcihzdWJpdGVtKVxuICAgICAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBjb250YWluICN7ZXhwfSdcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGNvbnRhaW4gI3tleHB9J1xuICAgICAgICAgICAgICAsIHN1Yml0ZW0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICBvYmouY29udGFpbnMoc3ViaXRlbSlcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gY29udGFpbiAnICsgZWxUb1N0cmluZyhzdWJpdGVtKVxuICAgICAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgY29udGFpbiAnICsgZWxUb1N0cmluZyhzdWJpdGVtKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpXG4gICAgICB9XG4gICAgfVxuICApXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkUHJvcGVydHkoJ2Rpc3BsYXllZCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLFxuICAgICAgICBhY3R1YWwgPSBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXNwbGF5IDogZWwuc3R5bGUuZGlzcGxheVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBhY3R1YWwgIT09ICdub25lJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBiZSBkaXNwbGF5ZWQsIGJ1dCBpdCB3YXMgbm90J1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBub3QgYmUgZGlzcGxheWVkLCBidXQgaXQgd2FzIGFzICcgKyBhY3R1YWxcbiAgICAgICwgYWN0dWFsXG4gICAgKVxuICB9KVxufSkpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBjaGFpU3R5bGVcblxuZnVuY3Rpb24gY2hhaVN0eWxlKGNoYWksIHV0aWxzKSB7XG4gIGNvbnN0IHtBc3NlcnRpb259ID0gY2hhaVxuICBjb25zdCB7ZmxhZ30gPSB1dGlsc1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3N0eWxlJywgZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlID0gJycpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIGNvbnN0IGlzTm9uQ29sb3JzID0gc3R5bGVbcHJvcGVydHldID09PSAncmdiYSgwLCAwLCAwLCAwKScgLy8gd2Via2l0XG4gICAgICB8fCBzdHlsZVtwcm9wZXJ0eV0gPT09ICd0cmFuc3BhcmVudCcgLy8gZmlyZWZveFxuXG4gICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IGlzTm9uQ29sb3JzXG4gICAgICA/ICcnXG4gICAgICA6IHN0eWxlW3Byb3BlcnR5XVxuXG4gICAgY29uc3QgYXNzZXJ0aW9uID0gdmFsdWVcbiAgICAgID8gY29tcGFyZUNTU1ZhbHVlKHByb3BlcnR5VmFsdWUsIHZhbHVlKVxuICAgICAgOiBCb29sZWFuKHByb3BlcnR5VmFsdWUpXG5cbiAgICBjb25zdCBlbGVtZW50VGFnID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGNvbnN0IHRocm93TWVzc2FnZSA9IGBleHBlY3QgJHtlbGVtZW50VGFnfSB0byBoYXZlIHske3Byb3BlcnR5fTogJHt2YWx1ZX19LCBpcyByZWNlaXZpbmcgeyR7cHJvcGVydHl9OiAke3Byb3BlcnR5VmFsdWV9fWBcbiAgICBjb25zdCB0aHJvd01lc3NhZ2VOZWdhdGl2ZSA9IGBleHBlY3QgJHtlbGVtZW50VGFnfSB0byBub3QgaGF2ZSB7JHtwcm9wZXJ0eX06ICR7dmFsdWV9fSwgaXMgcmVjZWl2aW5nIHske3Byb3BlcnR5fTogJHtwcm9wZXJ0eVZhbHVlfX1gXG5cbiAgICB0aGlzLmFzc2VydChhc3NlcnRpb24sIHRocm93TWVzc2FnZSwgdGhyb3dNZXNzYWdlTmVnYXRpdmUsIHZhbHVlKVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZUNTU1ZhbHVlKGNvbXB1dGVkLCBleHBlY3RlZCkge1xuICAgICAgY29uc3QgcHJvcGVydHlIaWZlbkNhc2UgPSBwcm9wZXJ0eS5yZXBsYWNlKC9bQS1aXS9nLCAobWF0Y2gpID0+ICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKCkpXG4gICAgICBjb25zdCBmYWtlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGZha2Uuc3R5bGUuZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZVxuICAgICAgZmFrZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eUhpZmVuQ2FzZSwgZXhwZWN0ZWQsICdpbXBvcnRhbnQnKVxuICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICAgIGlmcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKVxuICAgICAgaWZyYW1lLmFwcGVuZENoaWxkKGZha2UpXG4gICAgICBjb25zdCBmYWtlU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShmYWtlKVxuICAgICAgY29uc3QgdmFsdWUgPSBmYWtlU3R5bGVbcHJvcGVydHldXG5cbiAgICAgIGNvbnN0IGhhc0F1dG9WYWx1ZSA9IHZhbHVlLmluY2x1ZGVzKCdhdXRvJylcbiAgICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHZhbHVlKS5yZXBsYWNlKC9hdXRvL2csICcoXFxcXGQrKC5cXFxcZCspP3B4fGF1dG8pJykpXG5cbiAgICAgIHJldHVybiBoYXNBdXRvVmFsdWVcbiAgICAgICAgPyByZWcudGVzdChjb21wdXRlZClcbiAgICAgICAgOiBjb21wdXRlZCA9PT0gdmFsdWVcbiAgICB9XG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JlZ0V4cC5lc2NhcGUvYmxvYi9tYXN0ZXIvcG9seWZpbGwuanNcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCh2YWx1ZSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qICFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG52YXIgZ2V0UHJvdG90eXBlT2ZFeGlzdHMgPSB0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nO1xudmFyIHByb21pc2VFeGlzdHMgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogc2VsZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIGlzRG9tID0gJ2xvY2F0aW9uJyBpbiBnbG9iYWxPYmplY3QgJiYgJ2RvY3VtZW50JyBpbiBnbG9iYWxPYmplY3Q7XG52YXIgaHRtbEVsZW1lbnRFeGlzdHMgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIGlzQXJyYXlFeGlzdHMgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcbnZhciBtYXBFeGlzdHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFeGlzdHMgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrTWFwRXhpc3RzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtTZXRFeGlzdHMgPSB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZGF0YVZpZXdFeGlzdHMgPSB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbEl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEVudHJpZXNFeGlzdHMgPSBzZXRFeGlzdHMgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBtYXBFbnRyaWVzRXhpc3RzID0gbWFwRXhpc3RzICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgc2V0SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZkV4aXN0cyAmJiBzZXRFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgU2V0KCkuZW50cmllcygpKTtcbnZhciBtYXBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mRXhpc3RzICYmIG1hcEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBNYXAoKS5lbnRyaWVzKCkpO1xudmFyIGFycmF5SXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgYXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgc3RyaW5nSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJydbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciB0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCA9IDg7XG52YXIgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoID0gLTE7XG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2VzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LFxuICogbm9ybWFsaXNpbmcgYmVoYXZpb3VyIGFjcm9zcyBlbmdpbmUgdmVyc2lvbnMgJiB3ZWxsIG9wdGltaXNlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZURldGVjdChvYmopIHtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDMsMDM5LDAzNSBvcHMvc2VjIMKxMS42MiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAxLDQyNCwxMzggb3BzL3NlYyDCsTQuNTQlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMSw2NTMsMTUzIG9wcy9zZWMgwrExLjkxJSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDksOTc4LDY2MCBvcHMvc2VjIMKxMS45MiUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAyLDU1Niw3Njkgb3BzL3NlYyDCsTEuNzMlICg3NyBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMzgsNTY0LDc5NiBvcHMvc2VjIMKxMS4xNSUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAzMSwxNDgsOTQwIG9wcy9zZWMgwrExLjEwJSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDMyLDY3OSwzMzAgb3BzL3NlYyDCsTEuOTAlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggMzIsMzYzLDM2OCBvcHMvc2VjIMKxMS4wNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAzMSwyOTYsODcwIG9wcy9zZWMgwrEwLjk2JSAoODMgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgdmFyIHR5cGVvZk9iaiA9IHR5cGVvZiBvYmo7XG4gIGlmICh0eXBlb2ZPYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGVvZk9iajtcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAyOCw2NDUsNzY1IG9wcy9zZWMgwrExLjE3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDM2LDQyOCw5NjIgb3BzL3NlYyDCsTEuMzclICg4NCBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdylgYFxuICAgKiAgLSBOb2RlID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFBoYW50b21KUyA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgRWRnZSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpYGBcbiAgICogIC0gQ2hyb21lIFdvcmtlciA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94IFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIFNhZmFyaSBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSAxMSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSBFZGdlIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqL1xuICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QpIHtcbiAgICByZXR1cm4gJ2dsb2JhbCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMiw4ODgsMzUyIG9wcy9zZWMgwrEwLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIyLDQ3OSw2NTAgb3BzL3NlYyDCsTAuOTYlICg4MSBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAoaXNBcnJheUV4aXN0cyAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gJ0FycmF5JztcbiAgfVxuXG4gIGlmIChpc0RvbSkge1xuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2xvY2F0aW9uKVxuICAgICAqIFdoYXRXRyBIVE1MJDcuNy4zIC0gVGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cubG9jYXRpb24pYGBcbiAgICAgKiAgLSBJRSA8PTExID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0LmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG9jdW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkMy4xLjEgLSBUaGUgYERvY3VtZW50YCBvYmplY3RcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTI2ODA5MjY4KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiAgICAgICBXaGF0V0cgSFRNTCBzdGF0ZXM6XG4gICAgICogICAgICAgICA+IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIFdpbmRvdyBvYmplY3RzIG11c3QgYWxzbyBoYXZlIGFcbiAgICAgKiAgICAgICAgID4gd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSwgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgbmFtZWRcbiAgICAgKiAgICAgICAgID4gSFRNTERvY3VtZW50IHdob3NlIHZhbHVlIGlzIHRoZSBEb2N1bWVudCBpbnRlcmZhY2Ugb2JqZWN0LlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpYGBcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiAnRG9jdW1lbnQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjbWltZXR5cGVhcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBNaW1lVHlwZUFycmF5XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IubWltZVR5cGVzKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TTWltZVR5cGVzQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5taW1lVHlwZXMpIHtcbiAgICAgIHJldHVybiAnTWltZVR5cGVBcnJheSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBQbHVnaW5BcnJheVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLnBsdWdpbnMpYGBcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNQbHVnaW5zQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5wbHVnaW5zKSB7XG4gICAgICByZXR1cm4gJ1BsdWdpbkFycmF5JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuNC40IC0gVGhlIGBibG9ja3F1b3RlYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MUXVvdGVFbGVtZW50YFxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IEhUTUxCbG9ja0VsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAoaHRtbEVsZW1lbnRFeGlzdHMgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdCTE9DS1FVT1RFJykge1xuICAgICAgcmV0dXJuICdIVE1MUXVvdGVFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlZGF0YWNlbGxlbGVtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50YFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpKVxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAoaHRtbEVsZW1lbnRFeGlzdHMgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgIHJldHVybiAnSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlaGVhZGVyY2VsbGVsZW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudGBcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSlcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKGh0bWxFbGVtZW50RXhpc3RzICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnVEgnKSB7XG4gICAgICByZXR1cm4gJ0hUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50JztcbiAgICB9XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDYyNSw2NDQgb3BzL3NlYyDCsTEuNTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCAxLDI3OSw4NTIgb3BzL3NlYyDCsTIuOTElICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCAxLDE3OCwxODUgb3BzL3NlYyDCsTEuOTUlICg4MyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCAxLDAwOCwzODAgb3BzL3NlYyDCsTIuMjUlICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCAxLDEyOCwwNDAgb3BzL3NlYyDCsTIuMTElICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCAxLDE3MCwxMTkgb3BzL3NlYyDCsTIuODglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCAxLDE3NiwzNDggb3BzL3NlYyDCsTUuNzklICg4NiBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCAxLDA1OCw3MDcgb3BzL3NlYyDCsTQuOTQlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCAxLDExMCw2MzMgb3BzL3NlYyDCsTQuMjAlICg4MCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDcsMTA1LDY3MSBvcHMvc2VjIMKxMTMuNDclICg2NCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCA1LDg4Nyw5MTIgb3BzL3NlYyDCsTEuNDYlICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCA2LDQ5MSw2NjEgb3BzL3NlYyDCsTEuNzYlICg3OSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCA2LDU1OSw3OTUgb3BzL3NlYyDCsTEuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCA2LDQ2Myw5NjYgb3BzL3NlYyDCsTEuNDMlICg4NSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCA1LDY0MSw4NDEgb3BzL3NlYyDCsTMuNDklICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCA2LDU4Myw1MTEgb3BzL3NlYyDCsTEuOTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCA2LDYwNiwwNzggb3BzL3NlYyDCsTEuNzQlICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCA2LDYwMiwyMjQgb3BzL3NlYyDCsTEuNzclICg4MyBydW5zIHNhbXBsZWQpXG4gICovXG4gIHZhciBzdHJpbmdUYWcgPSAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICBpZiAodHlwZW9mIHN0cmluZ1RhZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyaW5nVGFnO1xuICB9XG5cbiAgaWYgKGdldFByb3RvdHlwZU9mRXhpc3RzKSB7XG4gICAgdmFyIG9ialByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDEsNzcyLDM4NSBvcHMvc2VjIMKxMS44NSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICAqICAgcmVnZXggY29uc3RydWN0b3IgIHggMiwxNDMsNjM0IG9wcy9zZWMgwrEyLjQ2JSAoNzggcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMyw5MjgsMDA5IG9wcy9zZWMgwrEwLjY1JSAoNzggcnVucyBzYW1wbGVkKVxuICAgICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAzLDkzMSwxMDggb3BzL3NlYyDCsTAuNTglICg4NCBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAob2JqUHJvdG90eXBlID09PSBSZWdFeHAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1JlZ0V4cCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMiwxMzAsMDc0IG9wcy9zZWMgwrE0LjQyJSAoNjggcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMyw5NTMsNzc5IG9wcy9zZWMgwrExLjM1JSAoNzcgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG9ialByb3RvdHlwZSA9PT0gRGF0ZS5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnRGF0ZSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtcHJvbWlzZS5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjUuNC41LjQgLSBQcm9taXNlLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJQcm9taXNlXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQcm9taXNlLnJlc29sdmUoKSlgYFxuICAgICAqICAtIENocm9tZSA8PTQ3ID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gRWRnZSA8PTIwID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gRmlyZWZveCAyOS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAgICogIC0gU2FmYXJpIDcuMS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAgICovXG4gICAgaWYgKHByb21pc2VFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBQcm9taXNlLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdQcm9taXNlJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICBzZXQgICAgICAgICAgICAgICAgeCAyLDIyMiwxODYgb3BzL3NlYyDCsTEuMzElICg4MiBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICBzZXQgICAgICAgICAgICAgICAgeCA0LDU0NSw4Nzkgb3BzL3NlYyDCsTEuMTMlICg4MyBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gU2V0LnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdTZXQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDIsMzk2LDg0MiBvcHMvc2VjIMKxMS41OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDQsMTgzLDk0NSBvcHMvc2VjIMKxNi41OSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBNYXAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ01hcCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgd2Vha3NldCAgICAgICAgICAgIHggMSwzMjMsMjIwIG9wcy9zZWMgwrEyLjE3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgd2Vha3NldCAgICAgICAgICAgIHggNCwyMzcsNTEwIG9wcy9zZWMgwrEyLjAxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKHdlYWtTZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrU2V0LnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdXZWFrU2V0JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICB3ZWFrbWFwICAgICAgICAgICAgeCAxLDUwMCwyNjAgb3BzL3NlYyDCsTIuMDIlICg3OCBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICB3ZWFrbWFwICAgICAgICAgICAgeCAzLDg4MSwzODQgb3BzL3NlYyDCsTEuNDUlICg4MiBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAod2Vha01hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtNYXAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1dlYWtNYXAnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLWRhdGF2aWV3LnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyNC4yLjQuMjEgLSBEYXRhVmlldy5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiRGF0YVZpZXdcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKGRhdGFWaWV3RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ0RhdGFWaWV3JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lbWFwaXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIzLjEuNS4yLjIgLSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIk1hcCBJdGVyYXRvclwiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpLmVudHJpZXMoKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBtYXBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdNYXAgSXRlcmF0b3InO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVzZXRpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjMuMi41LjIuMiAtICVTZXRJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU2V0IEl0ZXJhdG9yXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgU2V0KCkuZW50cmllcygpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHNldEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1NldCBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIyLjEuNS4yLjIgLSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiQXJyYXkgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChhcnJheUl0ZXJhdG9yRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gYXJyYXlJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdBcnJheSBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyMS4xLjUuMi4yIC0gJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTdHJpbmcgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1N0cmluZyBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggMiw0MjQsMzIwIG9wcy9zZWMgwrExLjY3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggNSw4MzgsMDAwIG9wcy9zZWMgwrEwLjk5JSAoODQgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG9ialByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3RcbiAgICAucHJvdG90eXBlXG4gICAgLnRvU3RyaW5nXG4gICAgLmNhbGwob2JqKVxuICAgIC5zbGljZSh0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCwgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnR5cGVEZXRlY3QgPSBtb2R1bGUuZXhwb3J0cztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbHMgU3ltYm9sOiB0cnVlLCBVaW50OEFycmF5OiB0cnVlLCBXZWFrTWFwOiB0cnVlICovXG4vKiFcbiAqIGRlZXAtZXFsXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcbmZ1bmN0aW9uIEZha2VNYXAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbn1cbkZha2VNYXAucHJvdG90eXBlID0ge1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXJNYXAoKSB7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXRNYXAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldE1hcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5rZXlzLmluZGV4T2Yoa2V5KV07XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gZGVsZXRlTWFwKGtleSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdCh0aGlzLnZhbHVlcy5zbGljZShpbmRleCArIDEpKTtcbiAgICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cy5zbGljZSgwLCBpbmRleCkuY29uY2F0KHRoaXMua2V5cy5zbGljZShpbmRleCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG52YXIgTWVtb2l6ZU1hcCA9IG51bGw7XG5pZiAodHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgTWVtb2l6ZU1hcCA9IFdlYWtNYXA7XG59IGVsc2Uge1xuICBNZW1vaXplTWFwID0gRmFrZU1hcDtcbn1cblxuLyohXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIE1lbW9pemVNYXAgaGFzIHJlY29yZGVkIGEgcmVzdWx0IG9mIHRoZSB0d28gb3BlcmFuZHNcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWVtb2l6ZU1hcH0gbWVtb2l6ZU1hcFxuICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwKSB7XG4gIC8vIFRlY2huaWNhbGx5LCBXZWFrTWFwIGtleXMgY2FuICpvbmx5KiBiZSBvYmplY3RzLCBub3QgcHJpbWl0aXZlcy5cbiAgaWYgKCFtZW1vaXplTWFwIHx8IGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICB2YXIgcmVzdWx0ID0gbGVmdEhhbmRNYXAuZ2V0KHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFNldCB0aGUgcmVzdWx0IG9mIHRoZSBlcXVhbGl0eSBpbnRvIHRoZSBNZW1vaXplTWFwXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG1lbW9pemVNYXAsIHJlc3VsdCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsZWZ0SGFuZE1hcCA9IG1lbW9pemVNYXAuZ2V0KGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZE1hcCkge1xuICAgIGxlZnRIYW5kTWFwLnNldChyaWdodEhhbmRPcGVyYW5kLCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIGxlZnRIYW5kTWFwID0gbmV3IE1lbW9pemVNYXAoKTtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgICBtZW1vaXplTWFwLnNldChsZWZ0SGFuZE9wZXJhbmQsIGxlZnRIYW5kTWFwKTtcbiAgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5tb2R1bGUuZXhwb3J0cy5NZW1vaXplTWFwID0gTWVtb2l6ZU1hcDtcblxuLyoqXG4gKiBBc3NlcnQgZGVlcGx5IG5lc3RlZCBzYW1lVmFsdWUgZXF1YWxpdHkgYmV0d2VlbiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElmIHdlIGhhdmUgYSBjb21wYXJhdG9yLCB3ZSBjYW4ndCBhc3N1bWUgYW55dGhpbmc7IHNvIGJhaWwgdG8gaXRzIGNoZWNrIGZpcnN0LlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKHNpbXBsZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gIH1cblxuICAvLyBEZWVwZXIgY29tcGFyaXNvbnMgYXJlIHB1c2hlZCB0aHJvdWdoIHRvIGEgbGFyZ2VyIGZ1bmN0aW9uXG4gIHJldHVybiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBNYW55IGNvbXBhcmlzb25zIGNhbiBiZSBjYW5jZWxlZCBvdXQgZWFybHkgdmlhIHNpbXBsZSBlcXVhbGl0eSBvciBwcmltaXRpdmUgY2hlY2tzLlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufG51bGx9IGVxdWFsIG1hdGNoXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCkge1xuICAvLyBFcXVhbCByZWZlcmVuY2VzIChleGNlcHQgZm9yIE51bWJlcnMpIGNhbiBiZSByZXR1cm5lZCBlYXJseVxuICBpZiAobGVmdEhhbmRPcGVyYW5kID09PSByaWdodEhhbmRPcGVyYW5kKSB7XG4gICAgLy8gSGFuZGxlICstMCBjYXNlc1xuICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgIT09IDAgfHwgMSAvIGxlZnRIYW5kT3BlcmFuZCA9PT0gMSAvIHJpZ2h0SGFuZE9wZXJhbmQ7XG4gIH1cblxuICAvLyBoYW5kbGUgTmFOIGNhc2VzXG4gIGlmIChcbiAgICBsZWZ0SGFuZE9wZXJhbmQgIT09IGxlZnRIYW5kT3BlcmFuZCAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJpZ2h0SGFuZE9wZXJhbmQgIT09IHJpZ2h0SGFuZE9wZXJhbmQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBBbnl0aGluZyB0aGF0IGlzIG5vdCBhbiAnb2JqZWN0JywgaS5lLiBzeW1ib2xzLCBmdW5jdGlvbnMsIGJvb2xlYW5zLCBudW1iZXJzLFxuICAvLyBzdHJpbmdzLCBhbmQgdW5kZWZpbmVkLCBjYW4gYmUgY29tcGFyZWQgYnkgcmVmZXJlbmNlLlxuICBpZiAoaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIC8vIEVhc3kgb3V0IGIvYyBpdCB3b3VsZCBoYXZlIHBhc3NlZCB0aGUgZmlyc3QgZXF1YWxpdHkgY2hlY2tcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogVGhlIG1haW4gbG9naWMgb2YgdGhlIGBkZWVwRXF1YWxgIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY29tcGFyYXRvcl0gKG9wdGlvbmFsKSBPdmVycmlkZSBkZWZhdWx0IGFsZ29yaXRobSwgZGV0ZXJtaW5pbmcgY3VzdG9tIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWVtb2l6ZV0gKG9wdGlvbmFsKSBQcm92aWRlIGEgY3VzdG9tIG1lbW9pemF0aW9uIG9iamVjdCB3aGljaCB3aWxsIGNhY2hlIHRoZSByZXN1bHRzIG9mXG4gICAgY29tcGxleCBvYmplY3RzIGZvciBhIHNwZWVkIGJvb3N0LiBCeSBwYXNzaW5nIGBmYWxzZWAgeW91IGNhbiBkaXNhYmxlIG1lbW9pemF0aW9uLCBidXQgdGhpcyB3aWxsIGNhdXNlIGNpcmN1bGFyXG4gICAgcmVmZXJlbmNlcyB0byBibG93IHRoZSBzdGFjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4qL1xuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5tZW1vaXplID0gb3B0aW9ucy5tZW1vaXplID09PSBmYWxzZSA/IGZhbHNlIDogb3B0aW9ucy5tZW1vaXplIHx8IG5ldyBNZW1vaXplTWFwKCk7XG4gIHZhciBjb21wYXJhdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3I7XG5cbiAgLy8gQ2hlY2sgaWYgYSBtZW1vaXplZCByZXN1bHQgZXhpc3RzLlxuICB2YXIgbWVtb2l6ZVJlc3VsdExlZnQgPSBtZW1vaXplQ29tcGFyZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSk7XG4gIGlmIChtZW1vaXplUmVzdWx0TGVmdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0TGVmdDtcbiAgfVxuICB2YXIgbWVtb2l6ZVJlc3VsdFJpZ2h0ID0gbWVtb2l6ZUNvbXBhcmUocmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdFJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1lbW9pemVSZXN1bHRSaWdodDtcbiAgfVxuXG4gIC8vIElmIGEgY29tcGFyYXRvciBpcyBwcmVzZW50LCB1c2UgaXQuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JSZXN1bHQgPSBjb21wYXJhdG9yKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgLy8gQ29tcGFyYXRvcnMgbWF5IHJldHVybiBudWxsLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gZ28gYmFjayB0byBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIGlmIChjb21wYXJhdG9yUmVzdWx0ID09PSBmYWxzZSB8fCBjb21wYXJhdG9yUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBjb21wYXJhdG9yUmVzdWx0KTtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yUmVzdWx0O1xuICAgIH1cbiAgICAvLyBUbyBhbGxvdyBjb21wYXJhdG9ycyB0byBvdmVycmlkZSAqYW55KiBiZWhhdmlvciwgd2UgcmFuIHRoZW0gZmlyc3QuIFNpbmNlIGl0IGRpZG4ndCBkZWNpZGVcbiAgICAvLyB3aGF0IHRvIGRvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byByZXR1cm4gdGhlIGJhc2ljIHRlc3RzIGZpcnN0IGJlZm9yZSB3ZSBtb3ZlIG9uLlxuICAgIHZhciBzaW1wbGVSZXN1bHQgPSBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IG1lbW9pemUgdGhpcywgaXQgdGFrZXMgbG9uZ2VyIHRvIHNldC9yZXRyaWV2ZSB0aGFuIHRvIGp1c3QgY29tcGFyZS5cbiAgICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlZnRIYW5kVHlwZSA9IHR5cGUobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kVHlwZSAhPT0gdHlwZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZW1wb3JhcmlseSBzZXQgdGhlIG9wZXJhbmRzIGluIHRoZSBtZW1vaXplIG9iamVjdCB0byBwcmV2ZW50IGJsb3dpbmcgdGhlIHN0YWNrXG4gIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIHRydWUpO1xuXG4gIHZhciByZXN1bHQgPSBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpO1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChsZWZ0SGFuZFR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICAvLyBJZiB0aGVzZSB0eXBlcyBhcmUgdGhlaXIgaW5zdGFuY2UgdHlwZXMgKGUuZy4gYG5ldyBOdW1iZXJgKSB0aGVuIHJlLWRlZXBFcXVhbCBhZ2FpbnN0IHRoZWlyIHZhbHVlc1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQudmFsdWVPZigpLCByaWdodEhhbmRPcGVyYW5kLnZhbHVlT2YoKSk7XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgICAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZDtcbiAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOlxuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIHJldHVybiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGNhc2UgJ0dlbmVyYXRvcic6XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdEYXRhVmlldyc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQuYnVmZmVyKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZC5idWZmZXIpLCBvcHRpb25zKTtcbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQpLCBuZXcgVWludDhBcnJheShyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdNYXAnOlxuICAgICAgcmV0dXJuIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7UmVnRXhwfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZC50b1N0cmluZygpID09PSByaWdodEhhbmRPcGVyYW5kLnRvU3RyaW5nKCk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gU2V0cy9NYXBzIGZvciBlcXVhbGl0eS4gRmFzdGVyIHRoYW4gb3RoZXIgZXF1YWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U2V0fSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7U2V0fSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgU2V0I2VudHJpZXMgb3IgU2V0I0BAaXRlcmF0b3IsIHNvIHdlIG5lZWQgbWFudWFsbHkgcG9wdWxhdGUgdXNpbmcgU2V0I2ZvckVhY2hcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplICE9PSByaWdodEhhbmRPcGVyYW5kLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGxlZnRIYW5kSXRlbXMgPSBbXTtcbiAgdmFyIHJpZ2h0SGFuZEl0ZW1zID0gW107XG4gIGxlZnRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIGxlZnRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByaWdodEhhbmRPcGVyYW5kLmZvckVhY2goZnVuY3Rpb24gZ2F0aGVyRW50cmllcyhrZXksIHZhbHVlKSB7XG4gICAgcmlnaHRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZEl0ZW1zLnNvcnQoKSwgcmlnaHRIYW5kSXRlbXMuc29ydCgpLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGZsYXQgaXRlcmFibGUgb2JqZWN0cyBzdWNoIGFzIEFycmF5cywgVHlwZWRBcnJheXMgb3IgTm9kZS5qcyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtJdGVyYWJsZX0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0gbGVmdEhhbmRPcGVyYW5kLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAhPT0gcmlnaHRIYW5kT3BlcmFuZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2luZGV4XSwgcmlnaHRIYW5kT3BlcmFuZFtpbmRleF0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGdlbmVyYXRvciBvYmplY3RzIHN1Y2ggYXMgdGhvc2UgcmV0dXJuZWQgYnkgZ2VuZXJhdG9yIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGdldEdlbmVyYXRvckVudHJpZXMobGVmdEhhbmRPcGVyYW5kKSwgZ2V0R2VuZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qIVxuICogR2V0cyBhbGwgaXRlcmF0b3IgZW50cmllcyBmcm9tIHRoZSBnaXZlbiBPYmplY3QuIElmIHRoZSBPYmplY3QgaGFzIG5vIEBAaXRlcmF0b3IgZnVuY3Rpb24sIHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXG4gKiBUaGlzIHdpbGwgY29uc3VtZSB0aGUgaXRlcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cyBkZXBlbmRpbmcgb24gdGhlIEBAaXRlcmF0b3IgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBlbnRyaWVzIGZyb20gdGhlIEBAaXRlcmF0b3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JFbnRyaWVzKHRhcmdldCkge1xuICBpZiAoaGFzSXRlcmF0b3JGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXRHZW5lcmF0b3JFbnRyaWVzKHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgIH0gY2F0Y2ggKGl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGVudHJpZXMgZnJvbSBhIEdlbmVyYXRvci4gVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGdlbmVyYXRvciAtIHdoaWNoIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzLlxuICpcbiAqIEBwYXJhbSB7R2VuZXJhdG9yfSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBHZW5lcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEdlbmVyYXRvckVudHJpZXMoZ2VuZXJhdG9yKSB7XG4gIHZhciBnZW5lcmF0b3JSZXN1bHQgPSBnZW5lcmF0b3IubmV4dCgpO1xuICB2YXIgYWNjdW11bGF0b3IgPSBbIGdlbmVyYXRvclJlc3VsdC52YWx1ZSBdO1xuICB3aGlsZSAoZ2VuZXJhdG9yUmVzdWx0LmRvbmUgPT09IGZhbHNlKSB7XG4gICAgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgICBhY2N1bXVsYXRvci5wdXNoKGdlbmVyYXRvclJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIGEgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBrZXlzIGZyb20gdGhlIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZUtleXModGFyZ2V0KSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuLyohXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBvYmplY3RzIGhhdmUgbWF0Y2hpbmcgdmFsdWVzLCBnaXZlbiBhIHNldCBvZiBrZXlzLiBEZWZlcnMgdG8gZGVlcEVxdWFsIGZvciB0aGUgZXF1YWxpdHkgY2hlY2sgb2ZcbiAqIGVhY2gga2V5LiBJZiBhbnkgdmFsdWUgb2YgdGhlIGdpdmVuIGtleSBpcyBub3QgZXF1YWwsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZSAoZWFybHkpLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0ga2V5cyBBbiBhcnJheSBvZiBrZXlzIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBvZiBsZWZ0SGFuZE9wZXJhbmQgYW5kIHJpZ2h0SGFuZE9wZXJhbmQgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24ga2V5c0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmRba2V5c1tpXV0sIHJpZ2h0SGFuZE9wZXJhbmRba2V5c1tpXV0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIE9iamVjdHMuIE9uY2UgYmFzaWMgc2FtZW5lc3MgaGFzIGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbCBkZWZlciB0byBgZGVlcEVxdWFsYFxuICogZm9yIGVhY2ggZW51bWVyYWJsZSBrZXkgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHZhciBsZWZ0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kS2V5cyA9IGdldEVudW1lcmFibGVLZXlzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCAmJiBsZWZ0SGFuZEtleXMubGVuZ3RoID09PSByaWdodEhhbmRLZXlzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kS2V5cy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kS2V5cy5zb3J0KCk7XG4gICAgaWYgKGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRLZXlzLCByaWdodEhhbmRLZXlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kS2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgbGVmdEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCk7XG4gIHZhciByaWdodEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRFbnRyaWVzLmxlbmd0aCAmJiBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSByaWdodEhhbmRFbnRyaWVzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRFbnRyaWVzLCByaWdodEhhbmRFbnRyaWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChsZWZ0SGFuZEtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwICYmXG4gICAgICByaWdodEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyohXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgcHJpbWl0aXZlLlxuICpcbiAqIFRoaXMgaW50ZW50aW9uYWxseSByZXR1cm5zIHRydWUgZm9yIGFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZSxcbiAqIGluY2x1ZGluZyBmdW5jdGlvbnMgYW5kIHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jztcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKVxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpXG5cbnZhciBERUZBVUxUX1RPTEVSQU5DRSA9IDFlLTZcblxuLyoqXG4gKiBzbWFsbCB1dGlsaXR5IGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiBpc051bWJlciAodmFsKSB7XG4gIHJldHVybiB0eXBlKHZhbCkgPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIGJvdGhOdW1iZXJzIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gaXNOdW1iZXIocmlnaHQpICYmIGlzTnVtYmVyKGxlZnQpXG59XG5cbmZ1bmN0aW9uIGFsbW9zdEVxdWFsIChsZWZ0LCByaWdodCwgdG9sKSB7XG4gIHJldHVybiBNYXRoLmFicyhsZWZ0IC0gcmlnaHQpIDw9IHRvbFxufVxuXG4vKipcbiAqIE1ha2VzIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gZGVlcEVxdWFsLlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIG51bGwgaWYgYm90aCBhcmd1bWVudHMgYXJlIG5vdCBudW1iZXJzLFxuICogaW5kaWNhdGluZyB0aGF0IGRlZXBFcXVhbCBzaG91bGQgcHJvY2VlZCB3aXRoIG90aGVyIGVxdWFsaXR5IGNoZWNrc1xuICovXG5mdW5jdGlvbiBjb21wYXJhdG9yICh0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChib3RoTnVtYmVycyhsZWZ0LCByaWdodCkpIHtcbiAgICAgIHJldHVybiBhbG1vc3RFcXVhbChsZWZ0LCByaWdodCwgdG9sZXJhbmNlKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogU2V0cyBnbG9iYWwgdG9sZXJhbmNlIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIGNoYWkudXNlXG4gKiBAc2VlIGh0dHA6Ly9jaGFpanMuY29tL2d1aWRlL3BsdWdpbnMvXG4gKi9cbmZ1bmN0aW9uIGNoYWlBbG1vc3QgKGN1c3RvbVRvbGVyYW5jZSkge1xuICB2YXIgc3RhbmRhcmRUb2xlcmFuY2UgPSBjdXN0b21Ub2xlcmFuY2UgfHwgREVGQVVMVF9UT0xFUkFOQ0VcblxuICByZXR1cm4gZnVuY3Rpb24gKGNoYWksIHV0aWxzKSB7XG4gICAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgdmFyIGZsYWcgPSB1dGlscy5mbGFnXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNoYWxsb3cgZXF1YWxpdHkgZnVuY3Rpb24gdG8gb3ZlcnJpZGVcbiAgICAgKiAuZXF1YWwsIC5lcXVhbHMsIC5lcSB0aGF0IHRlc3RzICdhbG1vc3QnIGVxdWFsaXR5XG4gICAgICogaWYgYm90aCB2YWx1ZXMgYXJlIG51bWJlcnMgYW5kIGEgJ3RvbGVyYW5jZScgZmxhZyBpcyBzZXQuXG4gICAgICogU2VuZHMgdG8gZGVlcCBlcXVhbGl0eSBjaGVjayBpZiBkZWVwIGZsYWcgaXMgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcnJpZGVBc3NlcnRFcXVhbCAoX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXNzZXJ0RXF1YWwgKHZhbCwgbXNnKSB7XG4gICAgICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpXG5cbiAgICAgICAgdmFyIGRlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IGZsYWcodGhpcywgJ3RvbGVyYW5jZScpXG5cbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcWwodmFsKVxuICAgICAgICB9IGVsc2UgaWYgKHRvbGVyYW5jZSAmJiBib3RoTnVtYmVycyh2YWwsIHRoaXMuX29iaikpIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChhbG1vc3RFcXVhbCh2YWwsIHRoaXMuX29iaiwgdG9sZXJhbmNlKSxcbiAgICAgICAgICAgICdleHBlY3RlZCAje3RoaXN9IHRvIGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgdGhpcy5fb2JqLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZGVlcCBlcXVhbGl0eSBmdW5jdGlvbiB0byBvdmVycmlkZVxuICAgICAqIC5lcWwsIC5lcWxzIHRoYXQgdGVzdHMgJ2FsbW9zdCcgZXF1YWxpdHkgaWYgYm90aCBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWVzIGFyZSBudW1iZXJzIGFuZCB0b2xlcmFuY2UgZmxhZyBpcyBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVycmlkZUFzc2VydEVxbCAoX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXNzZXJ0RXFsICh2YWwsIG1zZykge1xuICAgICAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKVxuXG4gICAgICAgIHZhciB0b2xlcmFuY2UgPSBmbGFnKHRoaXMsICd0b2xlcmFuY2UnKVxuXG4gICAgICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGRlZXBFcXVhbCh2YWwsIHRoaXMuX29iaiwgeyBjb21wYXJhdG9yOiBjb21wYXJhdG9yKHRvbGVyYW5jZSkgfSksXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgYWxtb3N0IGVxdWFsICN7ZXhwfScsXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgdGhpcy5fb2JqLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC5hbG1vc3QoKSBtZXRob2QuIFRvIGJlIHVzZWQgYXQgdGhlIGVuZCBvZiB0aGUgY2hhaW4gbGlrZTpcbiAgICAgKiBleHBlY3QoNCkudG8ubm90LmJlLmFsbW9zdCg1LCAxLjUpLiBTaW1wbHkgYWRkcyB0b2xlcmFuY2UgZmxhZyB0aGVuIGNhbGxzXG4gICAgICogLmVxdWFsLiBUaGlzIHdpbGwgcmVkaXJlY3QgdG8gLmVxbCBpZiBkZWVwIGZsYWcgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWV0aG9kICh2YWwsIHRvbGVyYW5jZU92ZXJyaWRlKSB7XG4gICAgICB2YXIgdG9sZXJhbmNlID0gdG9sZXJhbmNlT3ZlcnJpZGUgfHwgc3RhbmRhcmRUb2xlcmFuY2VcblxuICAgICAgZmxhZyh0aGlzLCAndG9sZXJhbmNlJywgdG9sZXJhbmNlKVxuXG4gICAgICByZXR1cm4gdGhpcy5lcXVhbCh2YWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogLmFsbW9zdCBjaGFpbmFibGUgcHJvcGVydHkgdG8gYmUgdXNlZCBsaWtlOlxuICAgICAqIGV4cGVjdCgzLjk5OTk5OTk5KS50by5hbG1vc3QuZXF1YWwoNCkuIFNpbXBseSBhZGRzXG4gICAgICogdG9sZXJhbmNlIGZsYWcgdG8gYmUgcmVhZCBieSBlcXVhbGl0eSBjaGVja2luZyBtZXRob2RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgICBmbGFnKHRoaXMsICd0b2xlcmFuY2UnLCBzdGFuZGFyZFRvbGVyYW5jZSlcbiAgICB9XG5cbiAgICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbG1vc3QnLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG5cbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcXVhbCcsIG92ZXJyaWRlQXNzZXJ0RXF1YWwpXG4gICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXF1YWxzJywgb3ZlcnJpZGVBc3NlcnRFcXVhbClcbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcScsIG92ZXJyaWRlQXNzZXJ0RXF1YWwpXG5cbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWwnLCBvdmVycmlkZUFzc2VydEVxbClcbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWxzJywgb3ZlcnJpZGVBc3NlcnRFcWwpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGFpQWxtb3N0XG4iLCIvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIFN5bWJvbCAqL1xuLypqc2hpbnQgLVcwNTYgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWxzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgc3RyaW5ncywgbWVzc2FnZXMsIHByZWRpY2F0ZXMsIGZ1bmN0aW9ucywgYXNzZXJ0LCBub3QsIG1heWJlLFxuICAgICAgY29sbGVjdGlvbnMsIHNsaWNlLCBuZWdpbmYsIHBvc2luZiwgaXNBcnJheSwgaGF2ZVN5bWJvbHM7XG5cbiAgc3RyaW5ncyA9IHtcbiAgICB2OiAndmFsdWUnLFxuICAgIG46ICdudW1iZXInLFxuICAgIHM6ICdzdHJpbmcnLFxuICAgIGI6ICdib29sZWFuJyxcbiAgICBvOiAnb2JqZWN0JyxcbiAgICB0OiAndHlwZScsXG4gICAgYTogJ2FycmF5JyxcbiAgICBhbDogJ2FycmF5LWxpa2UnLFxuICAgIGk6ICdpdGVyYWJsZScsXG4gICAgZDogJ2RhdGUnLFxuICAgIGY6ICdmdW5jdGlvbicsXG4gICAgbDogJ2xlbmd0aCdcbiAgfTtcblxuICBtZXNzYWdlcyA9IHt9O1xuICBwcmVkaWNhdGVzID0ge307XG5cbiAgW1xuICAgIHsgbjogJ2VxdWFsJywgZjogZXF1YWwsIHM6ICd2JyB9LFxuICAgIHsgbjogJ3VuZGVmaW5lZCcsIGY6IGlzVW5kZWZpbmVkLCBzOiAndicgfSxcbiAgICB7IG46ICdudWxsJywgZjogaXNOdWxsLCBzOiAndicgfSxcbiAgICB7IG46ICdhc3NpZ25lZCcsIGY6IGFzc2lnbmVkLCBzOiAndicgfSxcbiAgICB7IG46ICdwcmltaXRpdmUnLCBmOiBwcmltaXRpdmUsIHM6ICd2JyB9LFxuICAgIHsgbjogJ2luY2x1ZGVzJywgZjogaW5jbHVkZXMsIHM6ICd2JyB9LFxuICAgIHsgbjogJ3plcm8nLCBmOiB6ZXJvIH0sXG4gICAgeyBuOiAnaW5maW5pdHknLCBmOiBpbmZpbml0eSB9LFxuICAgIHsgbjogJ251bWJlcicsIGY6IG51bWJlciB9LFxuICAgIHsgbjogJ2ludGVnZXInLCBmOiBpbnRlZ2VyIH0sXG4gICAgeyBuOiAnZXZlbicsIGY6IGV2ZW4gfSxcbiAgICB7IG46ICdvZGQnLCBmOiBvZGQgfSxcbiAgICB7IG46ICdncmVhdGVyJywgZjogZ3JlYXRlciB9LFxuICAgIHsgbjogJ2xlc3MnLCBmOiBsZXNzIH0sXG4gICAgeyBuOiAnYmV0d2VlbicsIGY6IGJldHdlZW4gfSxcbiAgICB7IG46ICdncmVhdGVyT3JFcXVhbCcsIGY6IGdyZWF0ZXJPckVxdWFsIH0sXG4gICAgeyBuOiAnbGVzc09yRXF1YWwnLCBmOiBsZXNzT3JFcXVhbCB9LFxuICAgIHsgbjogJ2luUmFuZ2UnLCBmOiBpblJhbmdlIH0sXG4gICAgeyBuOiAncG9zaXRpdmUnLCBmOiBwb3NpdGl2ZSB9LFxuICAgIHsgbjogJ25lZ2F0aXZlJywgZjogbmVnYXRpdmUgfSxcbiAgICB7IG46ICdzdHJpbmcnLCBmOiBzdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2VtcHR5U3RyaW5nJywgZjogZW1wdHlTdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ25vbkVtcHR5U3RyaW5nJywgZjogbm9uRW1wdHlTdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2NvbnRhaW5zJywgZjogY29udGFpbnMsIHM6ICdzJyB9LFxuICAgIHsgbjogJ21hdGNoJywgZjogbWF0Y2gsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2Jvb2xlYW4nLCBmOiBib29sZWFuLCBzOiAnYicgfSxcbiAgICB7IG46ICdvYmplY3QnLCBmOiBvYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ2VtcHR5T2JqZWN0JywgZjogZW1wdHlPYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ25vbkVtcHR5T2JqZWN0JywgZjogbm9uRW1wdHlPYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ2luc3RhbmNlU3RyaWN0JywgZjogaW5zdGFuY2VTdHJpY3QsIHM6ICd0JyB9LFxuICAgIHsgbjogJ2luc3RhbmNlJywgZjogaW5zdGFuY2UsIHM6ICd0JyB9LFxuICAgIHsgbjogJ2xpa2UnLCBmOiBsaWtlLCBzOiAndCcgfSxcbiAgICB7IG46ICdhcnJheScsIGY6IGFycmF5LCBzOiAnYScgfSxcbiAgICB7IG46ICdlbXB0eUFycmF5JywgZjogZW1wdHlBcnJheSwgczogJ2EnIH0sXG4gICAgeyBuOiAnbm9uRW1wdHlBcnJheScsIGY6IG5vbkVtcHR5QXJyYXksIHM6ICdhJyB9LFxuICAgIHsgbjogJ2FycmF5TGlrZScsIGY6IGFycmF5TGlrZSwgczogJ2FsJyB9LFxuICAgIHsgbjogJ2l0ZXJhYmxlJywgZjogaXRlcmFibGUsIHM6ICdpJyB9LFxuICAgIHsgbjogJ2RhdGUnLCBmOiBkYXRlLCBzOiAnZCcgfSxcbiAgICB7IG46ICdmdW5jdGlvbicsIGY6IGlzRnVuY3Rpb24sIHM6ICdmJyB9LFxuICAgIHsgbjogJ2hhc0xlbmd0aCcsIGY6IGhhc0xlbmd0aCwgczogJ2wnIH0sXG4gIF0ubWFwKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG4gPSBkYXRhLm47XG4gICAgbWVzc2FnZXNbbl0gPSAnSW52YWxpZCAnICsgc3RyaW5nc1tkYXRhLnMgfHwgJ24nXTtcbiAgICBwcmVkaWNhdGVzW25dID0gZGF0YS5mO1xuICB9KTtcblxuICBmdW5jdGlvbnMgPSB7XG4gICAgYXBwbHk6IGFwcGx5LFxuICAgIG1hcDogbWFwLFxuICAgIGFsbDogYWxsLFxuICAgIGFueTogYW55XG4gIH07XG5cbiAgY29sbGVjdGlvbnMgPSBbICdhcnJheScsICdhcnJheUxpa2UnLCAnaXRlcmFibGUnLCAnb2JqZWN0JyBdO1xuICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgbmVnaW5mID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBwb3NpbmYgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICBoYXZlU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbic7XG5cbiAgZnVuY3Rpb25zID0gbWl4aW4oZnVuY3Rpb25zLCBwcmVkaWNhdGVzKTtcbiAgYXNzZXJ0ID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKGFzc2VydE1vZGlmaWVyLCBhc3NlcnRJbXBsKTtcbiAgbm90ID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKG5vdE1vZGlmaWVyLCBub3RJbXBsKTtcbiAgbWF5YmUgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMobWF5YmVNb2RpZmllciwgbWF5YmVJbXBsKTtcbiAgYXNzZXJ0Lm5vdCA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG5vdCk7XG4gIGFzc2VydC5tYXliZSA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlKTtcblxuICBjb2xsZWN0aW9ucy5mb3JFYWNoKGNyZWF0ZU9mUHJlZGljYXRlcyk7XG4gIGNyZWF0ZU9mTW9kaWZpZXJzKGFzc2VydCwgYXNzZXJ0TW9kaWZpZXIpO1xuICBjcmVhdGVPZk1vZGlmaWVycyhub3QsIG5vdE1vZGlmaWVyKTtcbiAgY29sbGVjdGlvbnMuZm9yRWFjaChjcmVhdGVNYXliZU9mTW9kaWZpZXJzKTtcblxuICBleHBvcnRGdW5jdGlvbnMobWl4aW4oZnVuY3Rpb25zLCB7XG4gICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgbm90OiBub3QsXG4gICAgbWF5YmU6IG1heWJlXG4gIH0pKTtcblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlcXVhbGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbGhzYCBhbmQgYHJoc2AgYXJlIHN0cmljdGx5IGVxdWFsLCB3aXRob3V0IGNvZXJjaW9uLlxuICAgKiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGVxdWFsIChsaHMsIHJocykge1xuICAgIHJldHVybiBsaHMgPT09IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgdW5kZWZpbmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBudWxsYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBudWxsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc051bGwgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFzc2lnbmVkYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2lnbmVkIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgcHJpbWl0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHByaW1pdGl2ZSB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBwcmltaXRpdmUgKGRhdGEpIHtcbiAgICB2YXIgdHlwZTtcblxuICAgIHN3aXRjaCAoZGF0YSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gdHlwZW9mIGRhdGE7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IChoYXZlU3ltYm9scyAmJiB0eXBlID09PSAnc3ltYm9sJyk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGB6ZXJvYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyB6ZXJvLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiB6ZXJvIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbmZpbml0eWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW5maW5pdHksIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluZmluaXR5IChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IG5lZ2luZiB8fCBkYXRhID09PSBwb3NpbmY7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBudW1iZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBudW1iZXIgKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgPiBuZWdpbmYgJiYgZGF0YSA8IHBvc2luZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGludGVnZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGludGVnZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGludGVnZXIgKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgJSAxID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZXZlbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gZXZlbiBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGV2ZW4gKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgJSAyID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgb2RkYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBvZGQgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBvZGQgKGRhdGEpIHtcbiAgICByZXR1cm4gaW50ZWdlcihkYXRhKSAmJiBkYXRhICUgMiAhPT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGdyZWF0ZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgaXMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIGByaHNgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBncmVhdGVyIChsaHMsIHJocykge1xuICAgIHJldHVybiBudW1iZXIobGhzKSAmJiBsaHMgPiByaHM7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBsZXNzYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBsaHNgIGlzIGEgbnVtYmVyIGxlc3MgdGhhbiBgcmhzYCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbGVzcyAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzIDwgcmhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYmV0d2VlbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBudW1iZXIgYmV0d2VlbiBgeGAgYW5kIGB5YCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmV0d2VlbiAoZGF0YSwgeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIGdyZWF0ZXIoZGF0YSwgeCkgJiYgZGF0YSA8IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlc3MoZGF0YSwgeCkgJiYgZGF0YSA+IHk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBncmVhdGVyT3JFcXVhbGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbGhzYCBpcyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHJoc2AsIGZhbHNlXG4gICAqIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdyZWF0ZXJPckVxdWFsIChsaHMsIHJocykge1xuICAgIHJldHVybiBudW1iZXIobGhzKSAmJiBsaHMgPj0gcmhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbGVzc09yRXF1YWxgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgaXMgYSBudW1iZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGByaHNgLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBsZXNzT3JFcXVhbCAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzIDw9IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGluUmFuZ2VgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbnVtYmVyIGluIHRoZSByYW5nZSBgeC4ueWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluUmFuZ2UgKGRhdGEsIHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiBncmVhdGVyT3JFcXVhbChkYXRhLCB4KSAmJiBkYXRhIDw9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlc3NPckVxdWFsKGRhdGEsIHgpICYmIGRhdGEgPj0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHBvc2l0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHBvc2l0aXZlIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcG9zaXRpdmUgKGRhdGEpIHtcbiAgICByZXR1cm4gZ3JlYXRlcihkYXRhLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5lZ2F0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIG5lZ2F0aXZlIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVnYXRpdmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbGVzcyhkYXRhLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZyAoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eVN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgdGhlIGVtcHR5IHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHlTdHJpbmcgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gJyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBub25FbXB0eVN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBub24tZW1wdHkgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBub25FbXB0eVN0cmluZyAoZGF0YSkge1xuICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YSAhPT0gJyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBjb250YWluc2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgdGhhdCBjb250YWlucyBgc3Vic3RyaW5nYCwgZmFsc2VcbiAgICogb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gY29udGFpbnMgKGRhdGEsIHN1YnN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YS5pbmRleE9mKHN1YnN0cmluZykgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbWF0Y2hgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIHRoYXQgbWF0Y2hlcyBgcmVnZXhgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaCAoZGF0YSwgcmVnZXgpIHtcbiAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmICEhIGRhdGEubWF0Y2gocmVnZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYm9vbGVhbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBib29sZWFuIHZhbHVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBib29sZWFuIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IGZhbHNlIHx8IGRhdGEgPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBvYmplY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgcGxhaW4tb2xkIEpTIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JqZWN0IChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eU9iamVjdGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBlbXB0eU9iamVjdCAoZGF0YSkge1xuICAgIHJldHVybiBvYmplY3QoZGF0YSkgJiYgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbm9uRW1wdHlPYmplY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbm9uLWVtcHR5IG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9uRW1wdHlPYmplY3QgKGRhdGEpIHtcbiAgICByZXR1cm4gb2JqZWN0KGRhdGEpICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZVN0cmljdGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gaW5zdGFuY2Ugb2YgYHByb3RvdHlwZWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluc3RhbmNlU3RyaWN0IChkYXRhLCBwcm90b3R5cGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBwcm90b3R5cGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gaW5zdGFuY2Ugb2YgYHByb3RvdHlwZWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogRmFsbHMgYmFjayB0byB0ZXN0aW5nIGNvbnN0cnVjdG9yLm5hbWUgYW5kIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICogaWYgdGhlIGluaXRpYWwgaW5zdGFuY2VvZiB0ZXN0IGZhaWxzLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zdGFuY2UgKGRhdGEsIHByb3RvdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VTdHJpY3QoZGF0YSwgcHJvdG90eXBlKSB8fFxuICAgICAgICBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09IHByb3RvdHlwZS5uYW1lIHx8XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgJyArIHByb3RvdHlwZS5uYW1lICsgJ10nO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbGlrZWAuXG4gICAqXG4gICAqIFRlc3RzIHdoZXRoZXIgYGRhdGFgICdxdWFja3MgbGlrZSBhIGR1Y2snLiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGhhcyBhbGxcbiAgICogb2YgdGhlIHByb3BlcnRpZXMgb2YgYGFyY2hldHlwZWAgKHRoZSAnZHVjaycpLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBsaWtlIChkYXRhLCBhcmNoZXR5cGUpIHtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhcmNoZXR5cGUpIHtcbiAgICAgIGlmIChhcmNoZXR5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IGZhbHNlIHx8IHR5cGVvZiBkYXRhW25hbWVdICE9PSB0eXBlb2YgYXJjaGV0eXBlW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdChkYXRhW25hbWVdKSAmJiBsaWtlKGRhdGFbbmFtZV0sIGFyY2hldHlwZVtuYW1lXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhcnJheWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5IChkYXRhKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eUFycmF5YC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBlbXB0eSBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHlBcnJheSAoZGF0YSkge1xuICAgIHJldHVybiBhcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5vbkVtcHR5QXJyYXlgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbm9uLWVtcHR5IGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBub25FbXB0eUFycmF5IChkYXRhKSB7XG4gICAgcmV0dXJuIGFycmF5KGRhdGEpICYmIGdyZWF0ZXIoZGF0YS5sZW5ndGgsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYXJyYXlMaWtlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlMaWtlIChkYXRhKSB7XG4gICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGdyZWF0ZXJPckVxdWFsKGRhdGEubGVuZ3RoLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGl0ZXJhYmxlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBpdGVyYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmFibGUgKGRhdGEpIHtcbiAgICBpZiAoISBoYXZlU3ltYm9scykge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGBhcnJheUxpa2VgIHByZWRpY2F0ZSBpbiBwcmUtRVM2IGVudmlyb25tZW50cy5cbiAgICAgIHJldHVybiBhcnJheUxpa2UoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGlzRnVuY3Rpb24oZGF0YVtTeW1ib2wuaXRlcmF0b3JdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGluY2x1ZGVzYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBjb250YWlucyBgdmFsdWVgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpbmNsdWRlcyAoZGF0YSwgdmFsdWUpIHtcbiAgICB2YXIgaXRlcmF0b3IsIGl0ZXJhdGlvbiwga2V5cywgbGVuZ3RoLCBpO1xuXG4gICAgaWYgKCEgYXNzaWduZWQoZGF0YSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZVN5bWJvbHMgJiYgZGF0YVtTeW1ib2wuaXRlcmF0b3JdICYmIGlzRnVuY3Rpb24oZGF0YS52YWx1ZXMpKSB7XG4gICAgICBpdGVyYXRvciA9IGRhdGEudmFsdWVzKCk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaXRlcmF0aW9uID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb24udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCEgaXRlcmF0aW9uLmRvbmUpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGRhdGFba2V5c1tpXV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGhhc0xlbmd0aGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaGFzIGEgbGVuZ3RoIHByb3BlcnR5IHRoYXQgZXF1YWxzIGBsZW5ndGhgLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNMZW5ndGggKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiBhc3NpZ25lZChkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gbGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZGF0ZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSB2YWxpZCBkYXRlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBkYXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyaWN0KGRhdGEsIERhdGUpICYmIGludGVnZXIoZGF0YS5nZXRUaW1lKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZnVuY3Rpb25gLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhcHBseWAuXG4gICAqXG4gICAqIE1hcHMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBgZGF0YWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJlZGljYXRlIGFuZCByZXR1cm5zXG4gICAqIHRoZSByZXN1bHQgYXJyYXkuIElmIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiB0aGVcbiAgICogZGF0YSwgYSBzaW5nbGUgcHJlZGljYXRlIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseSAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgIGFzc2VydC5hcnJheShkYXRhKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZXMpKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzc2VydC5hcnJheShwcmVkaWNhdGVzKTtcbiAgICBhc3NlcnQuaGFzTGVuZ3RoKGRhdGEsIHByZWRpY2F0ZXMubGVuZ3RoKTtcblxuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcHJlZGljYXRlc1tpbmRleF0odmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbWFwYC5cbiAgICpcbiAgICogTWFwcyBlYWNoIHZhbHVlIGZyb20gdGhlIGBkYXRhYCB0byB0aGUgY29ycmVzcG9uZGluZyBwcmVkaWNhdGUgYW5kIHJldHVybnNcbiAgICogdGhlIHJlc3VsdCBvYmplY3QuIFN1cHBvcnRzIG5lc3RlZCBvYmplY3RzLiBJZiB0aGUgYGRhdGFgIGlzIG5vdCBuZXN0ZWQgYW5kXG4gICAqIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiBpdCwgYSBzaW5nbGUgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBtYXAgKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlcykpIHtcbiAgICAgIHJldHVybiBtYXBTaW1wbGUoZGF0YSwgcHJlZGljYXRlcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0Lm9iamVjdChwcmVkaWNhdGVzKTtcblxuICAgIHJldHVybiBtYXBDb21wbGV4KGRhdGEsIHByZWRpY2F0ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwU2ltcGxlIChkYXRhLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcHJlZGljYXRlKGRhdGFba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwQ29tcGxleCAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNba2V5XTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlKSkge1xuICAgICAgICBpZiAobm90LmFzc2lnbmVkKGRhdGEpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSAhIXByZWRpY2F0ZS5tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJlZGljYXRlKGRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0KHByZWRpY2F0ZSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtYXBDb21wbGV4KGRhdGFba2V5XSwgcHJlZGljYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhbGxgXG4gICAqXG4gICAqIENoZWNrIHRoYXQgYWxsIGJvb2xlYW4gdmFsdWVzIGFyZSB0cnVlXG4gICAqIGluIGFuIGFycmF5IChyZXR1cm5lZCBmcm9tIGBhcHBseWApXG4gICAqIG9yIG9iamVjdCAocmV0dXJuZWQgZnJvbSBgbWFwYCkuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhbGwgKGRhdGEpIHtcbiAgICBpZiAoYXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiB0ZXN0QXJyYXkoZGF0YSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGFzc2VydC5vYmplY3QoZGF0YSk7XG5cbiAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0QXJyYXkgKGRhdGEsIHJlc3VsdCkge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gIXJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RPYmplY3QgKGRhdGEsIHJlc3VsdCkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuXG4gICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgICAgICBpZiAob2JqZWN0KHZhbHVlKSAmJiB0ZXN0T2JqZWN0KHZhbHVlLCByZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICFyZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhbnlgXG4gICAqXG4gICAqIENoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGJvb2xlYW4gdmFsdWUgaXMgdHJ1ZVxuICAgKiBpbiBhbiBhcnJheSAocmV0dXJuZWQgZnJvbSBgYXBwbHlgKVxuICAgKiBvciBvYmplY3QgKHJldHVybmVkIGZyb20gYG1hcGApLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gYW55IChkYXRhKSB7XG4gICAgaWYgKGFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gdGVzdEFycmF5KGRhdGEsIHRydWUpO1xuICAgIH1cblxuICAgIGFzc2VydC5vYmplY3QoZGF0YSk7XG5cbiAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1peGluICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgbW9kaWZpZXIgYGFzc2VydGAuXG4gICAqXG4gICAqIFRocm93cyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0TW9kaWZpZXIgKHByZWRpY2F0ZSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFzc2VydFByZWRpY2F0ZShwcmVkaWNhdGUsIGFyZ3VtZW50cywgZGVmYXVsdE1lc3NhZ2UpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRQcmVkaWNhdGUgKHByZWRpY2F0ZSwgYXJncywgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICB2YXIgYXJnQ291bnQgPSBwcmVkaWNhdGUubCB8fCBwcmVkaWNhdGUubGVuZ3RoO1xuICAgIHZhciBtZXNzYWdlID0gYXJnc1thcmdDb3VudF07XG4gICAgdmFyIEVycm9yVHlwZSA9IGFyZ3NbYXJnQ291bnQgKyAxXTtcbiAgICBhc3NlcnRJbXBsKFxuICAgICAgcHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3MpLFxuICAgICAgbm9uRW1wdHlTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UsXG4gICAgICBpc0Z1bmN0aW9uKEVycm9yVHlwZSkgPyBFcnJvclR5cGUgOiBUeXBlRXJyb3JcbiAgICApO1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW1wbCAodmFsdWUsIG1lc3NhZ2UsIEVycm9yVHlwZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgKEVycm9yVHlwZSB8fCBFcnJvcikobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtb2RpZmllciBgbm90YC5cbiAgICpcbiAgICogTmVnYXRlcyBgcHJlZGljYXRlYC5cbiAgICovXG4gIGZ1bmN0aW9uIG5vdE1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm90SW1wbChwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBtb2RpZmllZFByZWRpY2F0ZS5sID0gcHJlZGljYXRlLmxlbmd0aDtcbiAgICByZXR1cm4gbW9kaWZpZWRQcmVkaWNhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBub3RJbXBsICh2YWx1ZSkge1xuICAgIHJldHVybiAhdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIG1vZGlmaWVyIGBtYXliZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBwcmVkaWNhdGUgYXJndW1lbnQgaXMgIG51bGwgb3IgdW5kZWZpbmVkLFxuICAgKiBvdGhlcndpc2UgcHJvcGFnYXRlcyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gYHByZWRpY2F0ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBtYXliZU1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobm90LmFzc2lnbmVkKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIG1vZGlmaWVkUHJlZGljYXRlLmwgPSBwcmVkaWNhdGUubGVuZ3RoO1xuXG4gICAgLy8gSGFja2lzaGx5IGluZGljYXRlIHRoYXQgdGhpcyBpcyBhIG1heWJlLnh4eCBwcmVkaWNhdGUuXG4gICAgLy8gV2l0aG91dCB0aGlzIGZsYWcsIHRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byBpdGVyYXRlXG4gICAgLy8gdGhyb3VnaCB0aGUgbWF5YmUgcHJlZGljYXRlcyBvciB1c2UgaW5kZXhPZiB0byBjaGVjayxcbiAgICAvLyB3aGljaCB3b3VsZCBiZSB0aW1lLWNvbnN1bWluZy5cbiAgICBtb2RpZmllZFByZWRpY2F0ZS5tID0gdHJ1ZTtcblxuICAgIHJldHVybiBtb2RpZmllZFByZWRpY2F0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW1wbCAodmFsdWUpIHtcbiAgICBpZiAoYXNzaWduZWQodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtb2RpZmllciBgb2ZgLlxuICAgKlxuICAgKiBBcHBsaWVzIHRoZSBjaGFpbmVkIHByZWRpY2F0ZSB0byBtZW1iZXJzIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb2ZNb2RpZmllciAodGFyZ2V0LCB0eXBlLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiwgYXJncztcblxuICAgICAgY29sbGVjdGlvbiA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKHRhcmdldCA9PT0gJ21heWJlJyAmJiBub3QuYXNzaWduZWQoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbGxlY3Rpb24gPSBjb2VyY2VDb2xsZWN0aW9uKHR5cGUsIGNvbGxlY3Rpb24pO1xuICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHRhcmdldCAhPT0gJ21heWJlJyB8fCBhc3NpZ25lZChpdGVtKSkgJiZcbiAgICAgICAgICAgICFwcmVkaWNhdGUuYXBwbHkobnVsbCwgWyBpdGVtIF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIGZvci4uLm9mIHdoZW4gRVM2IGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgdGhyb3cgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBtb2RpZmllZFByZWRpY2F0ZS5sID0gcHJlZGljYXRlLmxlbmd0aDtcbiAgICByZXR1cm4gbW9kaWZpZWRQcmVkaWNhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2VyY2VDb2xsZWN0aW9uICh0eXBlLCBjb2xsZWN0aW9uKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIGFycmF5TGlrZTpcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoY29sbGVjdGlvbik7XG4gICAgICBjYXNlIG9iamVjdDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMgKG1vZGlmaWVyLCBvYmplY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMoWyBtb2RpZmllciwgcHJlZGljYXRlcywgb2JqZWN0IF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMgKGFyZ3MpIHtcbiAgICB2YXIgbW9kaWZpZXIsIG9iamVjdCwgZnVuY3Rpb25zLCByZXN1bHQ7XG5cbiAgICBtb2RpZmllciA9IGFyZ3Muc2hpZnQoKTtcbiAgICBvYmplY3QgPSBhcmdzLnBvcCgpO1xuICAgIGZ1bmN0aW9ucyA9IGFyZ3MucG9wKCk7XG5cbiAgICByZXN1bHQgPSBvYmplY3QgfHwge307XG5cbiAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG1vZGlmaWVyLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGZ1bmN0aW9uc1trZXldLCBtZXNzYWdlc1trZXldKSlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIgKG1vZGlmaWVyLCBtb2RpZmllZCkge1xuICAgIHJldHVybiBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhbIG1vZGlmaWVyLCBtb2RpZmllZCwgbnVsbCBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9mUHJlZGljYXRlcyAoa2V5KSB7XG4gICAgcHJlZGljYXRlc1trZXldLm9mID0gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMoXG4gICAgICBbIG9mTW9kaWZpZXIuYmluZChudWxsLCBudWxsKSwgcHJlZGljYXRlc1trZXldLCBwcmVkaWNhdGVzLCBudWxsIF1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2ZNb2RpZmllcnMgKGJhc2UsIG1vZGlmaWVyKSB7XG4gICAgY29sbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBiYXNlW2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKG1vZGlmaWVyLCBwcmVkaWNhdGVzW2tleV0ub2YpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWF5YmVPZk1vZGlmaWVycyAoa2V5KSB7XG4gICAgbWF5YmVba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFxuICAgICAgWyBvZk1vZGlmaWVyLmJpbmQobnVsbCwgJ21heWJlJyksIHByZWRpY2F0ZXNba2V5XSwgcHJlZGljYXRlcywgbnVsbCBdXG4gICAgKTtcbiAgICBhc3NlcnQubWF5YmVba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlW2tleV0ub2YpO1xuICAgIGFzc2VydC5ub3Rba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG5vdFtrZXldLm9mKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cG9ydEZ1bmN0aW9ucyAoZnVuY3Rpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICE9PSBudWxsICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFscy5jaGVjayA9IGZ1bmN0aW9ucztcbiAgICB9XG4gIH1cbn0odGhpcykpO1xuIiwiY29uc3QgY2hlY2sgPSByZXF1aXJlKCdjaGVjay10eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjaGFpKSA9PiB7XG5cbiAgY29uc3QgdHlwZXMgPSBbJ251bWJlcicsICdzdHJpbmcnLCAnYm9vbGVhbicsICdvYmplY3QnLCAnYXJyYXknLCAnZGF0ZScsICdmdW5jdGlvbiddO1xuXG4gIHR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QodHlwZSwgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgY2hlY2tbdHlwZV0odGhpcy5fb2JqKSxcbiAgICAgICAgYGV4cGVjdGVkICN7dGhpc30gdG8gYmUgJHt0eXBlfWAsXG4gICAgICAgIGBleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSAke3R5cGV9YFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbn07IiwiZnVuY3Rpb24gcGx1Z2luKGNoYWksIHV0aWxzKSB7XG5cbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBlbnRyeSBpcyBhbiBldmVudCBlbWl0dGVyLlxuICAgKiBVc2VzIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCBpZiBhdmFpbGFibGUgdG8gcXVpY2tseSBjaGVjayBgaW5zdGFuY2VvZmAuICBPdGhlcndpc2UsIGNoZWNrcyB0aGF0IGNvbW1vbiBtZXRob2RzXG4gICAqIHRvIGV2ZW50IGVtaXR0ZXJzIGFyZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEdyYWNlZnVsbHkgaGFuZGxlcyBjdXN0b20gaW1wbGVtZW50YXRpb25zIG9mIGV2ZW50IGVtaXR0ZXJzIGV2ZW4gaWYgRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0IGFyZSBhdmFpbGFibGUsXG4gICAqIGNoZWNraW5nIG1ldGhvZHMgaWYgdGhlIGVtaXR0ZXIgZG9lc24ndCBpbmhlcml0IGZyb20gdGhlIGdsb2JhbCBlbWl0dGVyLlxuICAqL1xuICBmdW5jdGlvbiBpc0VtaXR0ZXIoKSB7XG4gICAgLy8gRWFzeSBjaGVjazogaWYgTm9kZSdzIEV2ZW50RW1pdHRlciBvciB3aW5kb3cuRXZlbnRFbWl0dGVyIGV4aXN0LCBjaGVjayBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGl0LlxuICAgIGlmKHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyICE9PSBudWxsICYmIHRoaXMuX29iaiBpbnN0YW5jZW9mIEV2ZW50RW1pdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRFbWl0dGVyXCIpO1xuICAgIH1cblxuICAgIC8vIEVhc3kgY2hlY2s6IGlmIHRoZSBicm93c2VyJ3MgRXZlbnRUYXJnZXQgZXhpc3RzLCBjaGVjayBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGl0LlxuICAgIGlmKHR5cGVvZiBFdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudFRhcmdldCAhPT0gbnVsbCAmJiB0aGlzLl9vYmogaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRUYXJnZXRcIik7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHRoaXMuX29iajtcblxuICAgIC8vIENoZWNrIGZvciBOb2RlLmpzIHN0eWxlIGV2ZW50IGVtaXR0ZXJzIHdpdGggXCJvblwiLCBcImVtaXRcIiwgZXRjLlxuICAgIHZhciBub2RlID0gW1wib25cIiwgXCJlbWl0XCJdLmV2ZXJ5KGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmpbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0pO1xuXG4gICAgaWYobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRFbWl0dGVyXCIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBCcm93c2VyLWJhc2VkIGV2ZW50IGVtaXR0ZXJzIHdpdGggXCJhZGRFdmVudExpc3RlbmVyXCIsIGV0Yy5cbiAgICB2YXIgYnJvd3NlciA9IFtcImFkZEV2ZW50TGlzdGVuZXJcIiwgXCJkaXNwYXRjaEV2ZW50XCIsIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiXS5ldmVyeShmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcblxuICAgIGlmKGJyb3dzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydCh0cnVlLCBcIlwiLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIEV2ZW50RW1pdHRlclwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChmYWxzZSwgXCJleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFuIEV2ZW50RW1pdHRlclwiLCBcIlwiKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoXCJlbWl0dGVyXCIsIGlzRW1pdHRlcik7XG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eShcInRhcmdldFwiLCBpc0VtaXR0ZXIpO1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoXCJlbWl0XCIsIGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHRoaXMuX29iaikudG8uYmUuYW4uZW1pdHRlcjtcblxuICAgIG5ldyBBc3NlcnRpb24obmFtZSkudG8uYmUuYShcInN0cmluZ1wiKTtcbiAgICB2YXIgb2JqID0gdGhpcy5fb2JqO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFzc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuYXNzZXJ0LmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHV0aWxzLmZsYWcodGhpcywgJ3RpbWVvdXQnKSB8fCAxNTAwO1xuXG4gICAgaWYodXRpbHMuZmxhZyh0aGlzLCAnbmVnYXRlJykpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBldmVudCBkb2Vzbid0IGZpcmUgYmVmb3JlIHRpbWVvdXRcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgb2JqLm9uKG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGRvbmUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGVtaXQgXCIrbmFtZStcIi5cIik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihkb25lKSB7IHJldHVybjsgfVxuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZXZlbnQgZmlyZXNcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgb2JqLm9uKG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGRvbmUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihkb25lKSB7IHJldHVybjsgfVxuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJleHBlY3RlZCAje3RoaXN9IHRvIGVtaXQgXCIrbmFtZStcIi5cIik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbn1cblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHBsdWdpbjtcbn1cbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfSk7XG59XG5lbHNlIHtcbiAgLy8gT3RoZXIgZW52aXJvbm1lbnQgKHVzdWFsbHkgPHNjcmlwdD4gdGFnKTogcGx1ZyBpbiB0byBnbG9iYWwgY2hhaSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgY2hhaS51c2UocGx1Z2luKTtcbn1cbiIsImltcG9ydCBDU1MgZnJvbSdxdWlja2Nzcyc7dmFyIHJlZ2lzdGVyZWQ7XG5yZWdpc3RlcmVkID0gZmFsc2U7XG5mdW5jdGlvbiByZWdpc3RlckFuaW1hdGlvbnMgKCkge1xuICBpZiAocmVnaXN0ZXJlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICBDU1MuYW5pbWF0aW9uKCdjaGVja21hcmtBbmltYXRlU3VjY2Vzc1RpcCcsIHtcbiAgICAnMCUsIDU0JSc6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogM1xuICAgIH0sXG4gICAgJzcwJSc6IHtcbiAgICAgIHdpZHRoOiAxNCxcbiAgICAgIGxlZnQ6IC0yLFxuICAgICAgdG9wOiA4XG4gICAgfSxcbiAgICAnODQlJzoge1xuICAgICAgd2lkdGg6IDUsXG4gICAgICBsZWZ0OiA1LFxuICAgICAgdG9wOiAxMFxuICAgIH0sXG4gICAgJzEwMCUnOiB7XG4gICAgICB3aWR0aDogOCxcbiAgICAgIGxlZnQ6IDMsXG4gICAgICB0b3A6IDEwXG4gICAgfVxuICB9KTtcbiAgQ1NTLmFuaW1hdGlvbignY2hlY2ttYXJrQW5pbWF0ZVN1Y2Nlc3NMb25nJywge1xuICAgICcwJSwgNjUlJzoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICByaWdodDogMTIsXG4gICAgICB0b3A6IDEyXG4gICAgfSxcbiAgICAnODQlJzoge1xuICAgICAgd2lkdGg6IDE0LFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDdcbiAgICB9LFxuICAgICcxMDAlJzoge1xuICAgICAgd2lkdGg6IDEyLFxuICAgICAgcmlnaHQ6IDIsXG4gICAgICB0b3A6IDhcbiAgICB9XG4gIH0pO1xuICBDU1MuYW5pbWF0aW9uKCdjaGVja21hcmtBbmltYXRlRXJyb3InLCB7XG4gICAgJzAlLCA2NSUnOiB7XG4gICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwLjQpJyxcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgICc4NCUnOiB7XG4gICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxLjE1KSdcbiAgICB9LFxuICAgICcxMDAlJzoge1xuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gICAgfVxuICB9KTtcbiAgQ1NTLmFuaW1hdGlvbignY2hlY2ttYXJrUm90YXRlUGxhY2Vob2xkZXInLCB7XG4gICAgJzAlLCA1JSc6IHtcbiAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtNDVkZWcpJ1xuICAgIH0sXG4gICAgJzEyJSwgMTAwJSc6IHtcbiAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtNDA1ZGVnKSdcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQ1NTLmFuaW1hdGlvbignZmllbGRFcnJvclNoYWtlJywge1xuICAgICcwJSwgNTAlJzoge1xuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTBweCknXG4gICAgfSxcbiAgICAnMjUlLCA3NSUnOiB7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDEwcHgpJ1xuICAgIH0sXG4gICAgJzEwMCUnOiB7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDBweCknXG4gICAgfVxuICB9KTtcbn1leHBvcnQgZGVmYXVsdCByZWdpc3RlckFuaW1hdGlvbnM7IiwiaW1wb3J0IElTXyBmcm9tJ0BkYW5pZWxrYWxlbi9pcyc7dmFyIElTO1xuXG5JUyA9IElTXy5jcmVhdGUoJ25hdGl2ZXMnLCAnZG9tJyk7XG5JUy5sb2FkKHtcbiAgLy8gZmllbGQ6ICh0YXJnZXQpLT4gdGFyZ2V0IGFuZCB0YXJnZXQgaW5zdGFuY2VvZiBGaWVsZFxuICByZWdleDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBSZWdFeHA7XG4gIH0sXG4gIG9iamVjdGFibGU6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gSVMub2JqZWN0KHRhcmdldCkgfHwgSVMuZnVuY3Rpb24odGFyZ2V0KTtcbiAgfVxufSk7XG52YXIgSVMkMSA9IElTO2V4cG9ydCBkZWZhdWx0IElTJDE7IiwiLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICh3aW5kb3cuY29uc29sZSA9PSBudWxsKSB7XG4gIHdpbmRvdy5jb25zb2xlID0ge307XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbmlmIChjb25zb2xlLmxvZyA9PSBudWxsKSB7XG4gIGNvbnNvbGUubG9nID0gZnVuY3Rpb24gKCkge307XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbmlmIChjb25zb2xlLndhcm4gPT0gbnVsbCkge1xuICBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZztcbn0iLCIoZnVuY3Rpb24odCl7aWYodD1mdW5jdGlvbihlLGkscyl7cmV0dXJuIGZ1bmN0aW9uKG4pe2lmKCFpW25dKXRocm93IEVycm9yKG4rXCIgaXMgbm90IGEgbW9kdWxlXCIpO3JldHVybiBlW25dP2Vbbl0uZXhwb3J0czooZVtuXT17ZXhwb3J0czp7fX0sZVtuXS5leHBvcnRzPWlbbl0uY2FsbChzLHQsZVtuXSxlW25dLmV4cG9ydHMpKX19KHt9LHswOmZ1bmN0aW9uKHQsZSxpKXt2YXIgcz0wLG49XCJwdXNoIHBvcCBzaGlmdCB1bnNoaWZ0IHNwbGljZSByZXZlcnNlIHNvcnRcIi5zcGxpdChcIiBcIikscj17fSxoPXt9LG89W1wie3tcIixcIn19XCJdLHU9T2JqZWN0LmNyZWF0ZSh7c2lsZW50OiExfSx7cGxhY2Vob2xkZXI6e2dldDpmdW5jdGlvbigpe3JldHVybiBvfSxzZXQ6ZnVuY3Rpb24odCl7Ty5pQSh0KSYmMj09PXQubGVuZ3RoJiYobz10LEMoKSl9fX0pLGM9e2RlbGF5OiExLHRocm90dGxlOiExLHNpbXBsZVNlbGVjdG9yOiExLHByb21pc2VUcmFuc2Zvcm1zOiExLGRpc3BhdGNoRXZlbnRzOiExLHNlbmRBcnJheUNvcGllczohMSx1cGRhdGVFdmVuSWZTYW1lOiExLHVwZGF0ZU9uQmluZDohMH0sYT1PYmplY3QuZGVmaW5lUHJvcGVydHksZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLGw9bnVsbCxwPWZ1bmN0aW9uKCl7aWYoIWwpe3ZhciB0PWw9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTt0LmluaXRFdmVudChcImNoYW5nZVwiLCEwLCExKSx0Ll9zYj0hMH1yZXR1cm4gbH0sZD0hKFwiY2xhc3NOYW1lXCJpbiBFbGVtZW50LnByb3RvdHlwZSYmZihFbGVtZW50LnByb3RvdHlwZSxcImNsYXNzTmFtZVwiKS5nZXQpLHY9XCJpbm5lcldpZHRoIGlubmVySGVpZ2h0IG91dGVyV2lkdGggb3V0ZXJIZWlnaHQgc2Nyb2xsWCBzY3JvbGxZIHBhZ2VYT2Zmc2V0IHBhZ2VZT2Zmc2V0IHNjcmVlblggc2NyZWVuWSBzY3JlZW5MZWZ0IHNjcmVlblRvcFwiLnNwbGl0KFwiIFwiKSxiPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudUFTKGV8fHRoaXMpfSxnPWZ1bmN0aW9uKCl7cmV0dXJuXCJcIisgKytzfSx5PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCl9LF89ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24oaSxzLG4pe3JldHVybiBIKGkscyxuLHQsZSl9fSxtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuc1V8fCh0LnNVPW5ldyBSKGZ1bmN0aW9uKCl7cmV0dXJuIGU/dC5zVih0LmZEVigpLHQsITApOnQudUFTKHQpfSxcIkZ1bmNcIix7fSkpfSxEPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQmJi0xIT09dC5pbmRleE9mKGUpfSxPPXtpRDpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0saUE6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBBcnJheX0saU86ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQmJnR9LGlTOmZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fSxpTjpmdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH0saUY6ZnVuY3Rpb24odCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH0saUJJOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgWH0saUI6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBSfSxpc0k6ZnVuY3Rpb24odCl7cmV0dXJuIE8uaU8odCkmJk8uaU4odC5sZW5ndGgpfSxETTpmdW5jdGlvbih0KXtyZXR1cm4gdC5ub2RlTmFtZSYmMT09PXQubm9kZVR5cGV9LGRJOmZ1bmN0aW9uKHQpe3JldHVyblwiSU5QVVRcIj09PSh0PXQubm9kZU5hbWUpfHxcIlRFWFRBUkVBXCI9PT10fHxcIlNFTEVDVFwiPT09dH0sZFI6ZnVuY3Rpb24odCl7cmV0dXJuXCJyYWRpb1wiPT09dC50eXBlfSxkQzpmdW5jdGlvbih0KXtyZXR1cm5cImNoZWNrYm94XCI9PT10LnR5cGV9LGVDOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgTm9kZUxpc3R8fHQgaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbnx8d2luZG93LmpRdWVyeSYmdCBpbnN0YW5jZW9mIGpRdWVyeX0sZUFTOmZ1bmN0aW9uKHQpe3ZhciBlPXRbMF0udHlwZTtyZXR1cm5bXS5maWx0ZXIuY2FsbCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT1lfSkubGVuZ3RoPT09dC5sZW5ndGh9LGROOmZ1bmN0aW9uKHQpe3JldHVybiBPLkRNKHQpfHx0PT09d2luZG93fHx0PT09ZG9jdW1lbnR9fSxNPWZ1bmN0aW9uKHQsZSxpKXt2YXIgcztyZXR1cm4ocz1mKHQsZSkpPyhpJiYocy5jb25maWd1cmFibGU9ITApLHMpOih0PU9iamVjdC5nZXRQcm90b3R5cGVPZih0KSk/TSh0LGUsITApOnZvaWQgMH0sST1mdW5jdGlvbih0LGUsaSl7dmFyIHM7aWYodC5PRHx8KHQuT0Q9TShlLHQucHIpKSxpKW4uZm9yRWFjaChmdW5jdGlvbihpKXtyZXR1cm4gYShlLGkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpmdW5jdGlvbigpe3ZhciBzPUFycmF5LnByb3RvdHlwZVtpXS5hcHBseShlLGFyZ3VtZW50cyk7cmV0dXJuIHQudUFTKHQpLHN9fSl9KTtlbHNlIGlmKFwiUHJveHlcIj09PXQudHlwZSl7dmFyIGg9dC5vUj10LnZhbHVlO2lmKHQudmFsdWU9e3Jlc3VsdDpudWxsLGFyZ3M6bnVsbH0sTy5pRihoKSl7dmFyIG89W10uc2xpY2UsdT1zPWZ1bmN0aW9uKCl7dmFyIGk9by5jYWxsKGFyZ3VtZW50cyk7cmV0dXJuIHQudmFsdWUuYXJncz1pPXQudGZTP3QudGZTKGkpOmksdC52YWx1ZS5yZXN1bHQ9aT1oLmFwcGx5KGUsaSksdC51QVModCksaX07YShlLHQucHIse2NvbmZpZ3VyYWJsZTp0LmlzTD0hMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX0sc2V0OmZ1bmN0aW9uKGUpe08uaUYoZSk/ZSE9PWgmJihlIT09cyYmKGg9dC5vUj1lKSx1IT09cyYmKHU9cykpOnU9ZX19KX19ZWxzZSBpZighKEQodC50eXBlLFwiRE9NXCIpfHx0Lm9iamVjdD09PXdpbmRvdyYmRCh2LHQucHIpKSl7KGk9dC5PRHx8cikuZ2V0JiYodC5PRz1pLmdldC5iaW5kKGUpKSxpLnNldCYmKHQuT1M9aS5zZXQuYmluZChlKSk7dmFyIGM9KGM9aS5jb25maWd1cmFibGUpJiZlLmNvbnN0cnVjdG9yIT09Q1NTU3R5bGVEZWNsYXJhdGlvbjtpZihkJiZ0LkRNJiZ0LnByIGluIGUuY2xvbmVOb2RlKCExKSYmKHQuT0Q9Yz0hMSx0LmlzTD0hMCx0Lk9HPWZ1bmN0aW9uKCl7cmV0dXJuIHQub2JqZWN0W3QucHJdfSx0Lk9TPWZ1bmN0aW9uKGUpe3JldHVybiB0Lm9iamVjdFt0LnByXT1lfSksYyl7Yz1cIkFycmF5XCI9PT10LnR5cGU7dmFyIGY9IXQuT1MmJiFjO2EoZSx0LnByLHtjb25maWd1cmFibGU6dC5pc0w9ITAsZW51bWVyYWJsZTppLmVudW1lcmFibGUsZ2V0OnQuT0d8fGZ1bmN0aW9uKCl7cmV0dXJuIHQudmFsdWV9LHNldDpmdW5jdGlvbihlKXt0LnNWKGUsdCxmKX19KSxjJiZJKHQsZVt0LnByXSwhMCl9fX0saj1mdW5jdGlvbih0LGUsaSl7aWYoaSl7dmFyIHM9W107Zm9yKHQ9MCxpPW4ubGVuZ3RoO3Q8aTt0Kyspe3ZhciByPW5bdF07cy5wdXNoKGRlbGV0ZSBlW3JdKX1yZXR1cm4gc31yZXR1cm4oaT10Lk9EKS5zZXR8fGkuZ2V0fHwoaS52YWx1ZT10Lm9SfHx0LnZhbHVlKSxhKGUsdC5wcixpKX0sUz1mdW5jdGlvbih0KXt2YXIgZSxpPXkoKTtmb3IoZSBpbiB0KWlbZV09dFtlXTtyZXR1cm4gaX0sRT1mdW5jdGlvbih0LGUpe3ZhciBpLHM9T2JqZWN0LmtleXMoZSksbj0wO2ZvcihpPXMubGVuZ3RoO248aTtuKyspe3ZhciByPXNbbl07dFtyXT1lW3JdfX0sUD17Z2V0OmZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiBlP2hbdC5fc2JfSURdOnMmJnRbMF0uX3NiX21hcCYmKGU9aFt0WzBdLl9zYl9tYXBbaV1dKS5nQj9lLmdCOnQuX3NiX21hcCYmdC5fc2JfbWFwW2ldP2hbdC5fc2JfbWFwW2ldXTp2b2lkIDB9LHNldDpmdW5jdGlvbih0LGUpe2lmKGUpYSh0Lm9iamVjdCxcIl9zYl9JRFwiLHtjb25maWd1cmFibGU6ITAsdmFsdWU6dC5JRH0pO2Vsc2V7dmFyIGk9dC5zZTt0Lm9iamVjdC5fc2JfbWFwP3Qub2JqZWN0Ll9zYl9tYXBbaV09dC5JRDooZT17fSxlW2ldPXQuSUQsYSh0Lm9iamVjdCxcIl9zYl9tYXBcIix7Y29uZmlndXJhYmxlOiEwLHZhbHVlOmV9KSl9fX0sVixOPS9bLiorP14ke30oKXxbXFxdXFxcXF0vZyxBPVY9bnVsbCxDPWZ1bmN0aW9uKCl7dmFyIHQ9dS5wbGFjZWhvbGRlclswXS5yZXBsYWNlKE4sXCJcXFxcJCZcIiksZT11LnBsYWNlaG9sZGVyWzFdLnJlcGxhY2UoTixcIlxcXFwkJlwiKSxpPVwiW15cIitlK1wiXStcIjtBPW5ldyBSZWdFeHAodCtcIihcIitpK1wiKVwiK2UsXCJnXCIpLFY9bmV3IFJlZ0V4cChcIlwiK3QraStlLFwiZ1wiKX07QygpO3ZhciB4PWZ1bmN0aW9uKHQsZSxpKXt2YXIgcyxuLHI9XCJcIixoPXM9MDtmb3Iobj10Lmxlbmd0aDtzPG47aD0rK3Mpcis9dFtoXSxpW2hdJiYocis9ZVtpW2hdXSk7cmV0dXJuIHJ9LGs9ZnVuY3Rpb24odCxlLGkpe251bGw9PXRbaV0mJih0W2ldPVtdKSx0W2ldLnB1c2goZSl9LEI9ZnVuY3Rpb24odCxlKXt2YXIgaSxzLG4scj0wO2ZvcihzPSh0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuY2hpbGROb2RlcykpLmxlbmd0aDtyPHM7cisrKXt2YXIgaD10W3JdO2lmKDMhPT1oLm5vZGVUeXBlKUIoaCxlKTtlbHNlIGlmKGgudGV4dENvbnRlbnQubWF0Y2goVikpe3ZhciBvPWgudGV4dENvbnRlbnQuc3BsaXQoQSk7aWYoMz09PW8ubGVuZ3RoJiZcIlwiPT09b1swXStvWzJdKWsoZSxoLG9bMV0pO2Vsc2V7dmFyIHU9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGM9aT0wO2ZvcihuPW8ubGVuZ3RoO2k8bjtjPSsraSl7dmFyIGE9b1tjXSxmPXUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYSkpO2MlMiYmayhlLGYsYSl9aC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh1LGgpfX19fSxGPWZ1bmN0aW9uKHQpe3Rocm93IEVycm9yKFwiU2ltcGx5QmluZDogXCIrKFRbdF18fHQpKX0sRz1mdW5jdGlvbih0LGUpe3Uuc2lsZW50fHwoZT1MKGUpLHQ9VFt0XSxjb25zb2xlLndhcm4oXCJTaW1wbHlCaW5kOiBcIit0K1wiXFxuXFxuXCIrZSkpfSx3PWZ1bmN0aW9uKHQpe0YoXCJJbnZhbGlkIGFyZ3VtZW50L3MgKFwiK3QrXCIpXCIsITApfSxMPWZ1bmN0aW9uKHQpe3JldHVybihFcnJvcigpLnN0YWNrfHxcIlwiKS5zcGxpdChcIlxcblwiKS5zbGljZSh0KzMpLmpvaW4oXCJcXG5cIil9LFQ9e2VySVA6XCJTaW1wbHlCaW5kKCkgYW5kIC50bygpIG9ubHkgYWNjZXB0IGEgZnVuY3Rpb24sIGFuIGFycmF5LCBhIGJvdW5kIG9iamVjdCwgYSBzdHJpbmcsIG9yIGEgbnVtYmVyLlwiLGVyRk46XCJPbmx5IGZ1bmN0aW9ucyBhcmUgYWxsb3dlZCBmb3IgLnRyYW5zZm9ybS8uY29uZGl0aW9uL0FsbCgpXCIsZXJFVjpcIkludmFsaWQgYXJndW1lbnQgbnVtYmVyIGluIC5vZkV2ZW50KClcIixlbXB0eUxpc3Q6XCJFbXB0eSBjb2xsZWN0aW9uIHByb3ZpZGVkXCIsZXJPRDpcIllvdSBjYW4gb25seSBwYXNzIGEgc2luZ2xlIERPTSBlbGVtZW50IHRvIGEgYmluZGluZ1wiLGVyTVg6XCInY2hlY2tlZCcgb2YgTWl4ZWQgbGlzdCBvZiBlbGVtZW50IGNhbm5vdCBiZSBib3VuZFwifSxIPWZ1bmN0aW9uKHQsZSxpLHMsbil7cmV0dXJuKHR8fDA9PT10KSYmKE8uaVModCl8fE8uaU4odCl8fE8uaUYodCl8fHQgaW5zdGFuY2VvZiBBcnJheSl8fE8uaUJJKHQpfHxGKFwiZXJJUFwiKSwhTy5pTyh0KXx8dCBpbnN0YW5jZW9mIEFycmF5PyhlPW5ldyBYKGUpLGUuc289aSxlLklTPXMsZS5jQz1uLHQ9Ty5pRih0KT9lLnNTKHQsITApOmUuc1AodCkpOnQ9bj9uKHQpOnQuc0MoKSx0fTtILnZlcnNpb249XCIxLjE1LjhcIixILnNldHRpbmdzPXUsSC5kZWZhdWx0T3B0aW9ucz1jLEgudW5CaW5kQWxsPWZ1bmN0aW9uKHQsZSl7dmFyIGk7aWYodCYmKE8uaU8odCl8fE8uaUYodCkpKXtPLmlzSSh0KSYmIXQuX3NiX0lEJiZ0WzBdJiZPLkRNKHRbMF0pJiYodD10WzBdKTt2YXIgcz10Ll9zYl9tYXA7aWYodC5fc2JfSUQmJmhbdC5fc2JfSURdLnJBUyhlKSxzKWZvcihpIGluIHMpdD1zW2ldLGhbdF0uckFTKGUpfX07dmFyIFI9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBFKHRoaXMsaSksdGhpcy5vRD10aGlzLnNvP3RoaXMub3B0aW9uczpjLHRoaXMudHlwZT1lLHRoaXMub2JqZWN0PXQsdGhpcy5JRD1nKCksdGhpcy5zdWJzPVtdLHRoaXMuc009eSgpLHRoaXMucE09eSgpLHRoaXMuYXRFVj1bXSxcIlByb3h5XCI9PT10aGlzLnR5cGUmJih0aGlzLnNWPWIpLHRoaXMubUMmJih0aGlzLmNIPXkoKSx0aGlzLm9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgaT10LmNIW2UudmFsdWVdPUgoXCJjaGVja2VkXCIpLm9mKGUpLl87aS5hUyh0KSxpLnNNW3QuSURdLnRGPWZ1bmN0aW9uKCl7cmV0dXJuIGl9LGkuZ0I9dH19KHRoaXMpKSksXCJFdmVudFwiPT09dGhpcy50eXBlfHxcIkZ1bmNcIj09PXRoaXMudHlwZSYmdGhpcy5JU3x8KFwiUGhvbGRlclwiPT09dGhpcy50eXBlPyhlPXRoaXMuZGUmJiFEKHRoaXMuZGUsXCJtdWx0aVwiKT90aGlzLmRlK1wiOlwiK3RoaXMucHI6dGhpcy5wciwodD10aGlzLnBCPUgoZSkub2YodCkuXykuc1BIKCksdGhpcy52YWx1ZT10LnBWTFt0aGlzLlBoXSx0LnR4TiYmKHRoaXMudHhOPXQudHhOW3RoaXMuUGhdKSk6KHRoaXMudmFsdWU9dD10aGlzLmZEVigpLFwiT2JqZWN0UHJvcFwiIT09dGhpcy50eXBlfHxPLmlEKHQpfHxmKHRoaXMub2JqZWN0LHRoaXMucHIpfHwodGhpcy5vYmplY3RbdGhpcy5wcl09dCksSSh0aGlzLHRoaXMub2JqZWN0KSkpLHRoaXMuYUVWKCksaFt0aGlzLklEXT10aGlzfTtSLnByb3RvdHlwZT17YVM6ZnVuY3Rpb24odCxlLGkscyl7dmFyIG47aWYodC5pc011bHRpKXt2YXIgcj10LmJpbmRpbmdzO2Zvcih0PTAsbj1yLmxlbmd0aDt0PG47dCsrKXt2YXIgaD1yW3RdO3RoaXMuYVMoaCxlLGkscyl9fWVsc2UgaWYodGhpcy5zTVt0LklEXSl2YXIgbz0hMDtlbHNlIHQucE1bdGhpcy5JRF09dGhpcyx0aGlzLnN1YnMudW5zaGlmdCh0KSwobj10aGlzLnNNW3QuSURdPXkoKSkudU89aSxuLm9wdHM9UyhlKSwoc3x8XCJFdmVudFwiPT09dGhpcy50eXBlfHxcIlByb3h5XCI9PT10aGlzLnR5cGV8fFwiQXJyYXlcIj09PXRoaXMudHlwZSkmJihuLm9wdHMudXBkYXRlRXZlbklmU2FtZT0hMCksbi5WUj1cIkZ1bmNcIj09PXQudHlwZT9cInBzXCI6XCJ2YWx1ZVwiO3JldHVybiBvfSxyUzpmdW5jdGlvbih0LGUpe3ZhciBpO2lmKHQuaXNNdWx0aSl7dmFyIHM9dC5iaW5kaW5ncztmb3IodD0wLGk9cy5sZW5ndGg7dDxpO3QrKyl7dmFyIG49c1t0XTt0aGlzLnJTKG4sZSl9fWVsc2UgdGhpcy5zTVt0LklEXSYmKHRoaXMuc3Vicy5zcGxpY2UodGhpcy5zdWJzLmluZGV4T2YodCksMSksZGVsZXRlIHRoaXMuc01bdC5JRF0sZGVsZXRlIHQucE1bdGhpcy5JRF0pLGUmJih0LnJTKHRoaXMpLGRlbGV0ZSB0aGlzLnBNW3QuSURdKTswPT09dGhpcy5zdWJzLmxlbmd0aCYmMD09PU9iamVjdC5rZXlzKHRoaXMucE0pLmxlbmd0aCYmdGhpcy5ERVMoKX0sckFTOmZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5zdWJzLnNsaWNlKCkscz0wO2ZvcihlPWkubGVuZ3RoO3M8ZTtzKyspe3ZhciBuPWlbc107dGhpcy5yUyhuLHQpfX0sREVTOmZ1bmN0aW9uKCl7dmFyIHQ7aWYoZGVsZXRlIGhbdGhpcy5JRF0sdGhpcy5yUEkoKSxcIkV2ZW50XCI9PT10aGlzLnR5cGUpe3ZhciBlPXRoaXMuYXRFVixpPTA7Zm9yKHQ9ZS5sZW5ndGg7aTx0O2krKyl7dmFyIHM9ZVtpXTt0aGlzLnVyRVZFKHMpfX1lbHNlXCJGdW5jXCI9PT10aGlzLnR5cGUmJmRlbGV0ZSB0aGlzLm9iamVjdC5fc2JfSUQ7dGhpcy5pc0wmJnRoaXMuT0QmJmoodGhpcyx0aGlzLm9iamVjdCksXCJBcnJheVwiPT09dGhpcy50eXBlJiZqKHRoaXMsdGhpcy52YWx1ZSwhMCksdGhpcy5vYmplY3QuX3NiX21hcCYmKGRlbGV0ZSB0aGlzLm9iamVjdC5fc2JfbWFwW3RoaXMuc2VdLDA9PT1PYmplY3Qua2V5cyh0aGlzLm9iamVjdC5fc2JfbWFwKS5sZW5ndGgmJmRlbGV0ZSB0aGlzLm9iamVjdC5fc2JfbWFwKX0sZkRWOmZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLnR5cGU7c3dpdGNoKCExKXtjYXNlXCJGdW5jXCIhPT1lOnJldHVybiB0aGlzLm9iamVjdCgpO2Nhc2VcIkRPTUF0dHJcIiE9PWU6cmV0dXJuIHRoaXMub2JqZWN0LmdldEF0dHJpYnV0ZSh0aGlzLnByKXx8XCJcIjtjYXNlIXRoaXMubUM6dmFyIGk9W10scz10aGlzLmNIO2Zvcih0IGluIHMpaWYoc1t0XS5vYmplY3QuY2hlY2tlZCl7aWYoXCJET01SYWRpb1wiPT09ZSlyZXR1cm4gdDtpLnB1c2godCl9cmV0dXJuIGk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5vYmplY3RbdGhpcy5wcl19fSxzVjpmdW5jdGlvbih0LGUsaSxzKXtpZihlfHwoZT10aGlzKSx0aGlzLnRmUyYmKHQ9dGhpcy50ZlModCkpLCFpKXN3aXRjaCh0aGlzLnR5cGUpe2Nhc2VcIk9iamVjdFByb3BcIjppZih0aGlzLmlzTClpZih0aGlzLmRJKWlmKHMpe2lmKHQhPT10aGlzLk9HKCkpe3ZhciBuPXRoaXMub2JqZWN0LnNlbGVjdGlvblN0YXJ0O3RoaXMuT1ModCksbiYmdGhpcy5vYmplY3Quc2V0U2VsZWN0aW9uUmFuZ2UobixuKX19ZWxzZSB0aGlzLk9TKHQpLHUuZGlzcGF0Y2hFdmVudHMmJnRoaXMub2JqZWN0LmRpc3BhdGNoRXZlbnQocCgpKTtlbHNlIHRoaXMuT1MmJnRoaXMuT1ModCk7ZWxzZSB0IT09dGhpcy52YWx1ZSYmKHRoaXMub2JqZWN0W3RoaXMucHJdPXQpO2JyZWFrO2Nhc2VcIlBob2xkZXJcIjppZihzPXRoaXMucEIscy5wVkxbdGhpcy5QaF09dCxuPXgocy5wQ1Qscy5wVkwscy5wSU0pLHRoaXMudHhOJiZ0IT09dGhpcy52YWx1ZSl7dmFyIHI9dGhpcy50eE4saD0wO2ZvcihpPXIubGVuZ3RoO2g8aTtoKyspe3ZhciBvPXJbaF07by50ZXh0Q29udGVudD10fX1cInRleHRDb250ZW50XCIhPT10aGlzLnByJiZzLnNWKG4sZSk7YnJlYWs7Y2FzZVwiQXJyYXlcIjp0IT09dGhpcy52YWx1ZSYmKE8uaUEodCl8fCh0PUFycmF5LnByb3RvdHlwZS5jb25jYXQodCkpLGoodGhpcyx0aGlzLnZhbHVlLCEwKSxJKHRoaXMsdD10LnNsaWNlKCksITApLHRoaXMuT1MmJnRoaXMuT1ModCkpO2JyZWFrO2Nhc2VcIkZ1bmNcIjpuPXRoaXMucHMsdGhpcy5wcz10LHQ9dGhpcy5vYmplY3QodCxuKTticmVhaztjYXNlXCJFdmVudFwiOnRoaXMuaUU9ITAsdGhpcy5lRSh0KSx0aGlzLmlFPSExO2JyZWFrO2Nhc2VcIkRPTVJhZGlvXCI6aWYodGhpcy5tQylpZihzPU8uaUIodCk/dDp0aGlzLmNIW3RdKWZvcihoIGluIHQ9cy5vYmplY3QudmFsdWUsbj10aGlzLmNIKShpPW5baF0pLnNWKGkuSUQ9PT1zLklELGUpO2Vsc2UgdD10aGlzLnZhbHVlO2Vsc2V7aWYoKHQ9ISF0KT09PXRoaXMudmFsdWUpcmV0dXJuO3RoaXMub2JqZWN0LmNoZWNrZWQhPT10JiYodGhpcy5vYmplY3QuY2hlY2tlZD10KSx0JiZ1LmRpc3BhdGNoRXZlbnRzJiZ0aGlzLm9iamVjdC5kaXNwYXRjaEV2ZW50KHAoKSl9YnJlYWs7Y2FzZVwiRE9NQ2hlY2tib3hcIjppZih0aGlzLm1DKXtmb3IoaD0hTy5pQih0KSxpPXM9MCxyPSh0PVtdLmNvbmNhdCh0KSkubGVuZ3RoO3M8cjtpPSsrcylvPXRbaV0sdFtpXT1PLmlCKG8pP286dGhpcy5jSFtvXTtyPVtdLG89dGhpcy5jSDtmb3IobiBpbiBvKWk9b1tuXSxzPWg/RCh0LGkpOmkudmFsdWUsaS5zVihzLGUpLHMmJnIucHVzaChuKTt0PXJ9ZWxzZXtpZigodD0hIXQpPT09dGhpcy52YWx1ZSlyZXR1cm47dGhpcy5vYmplY3QuY2hlY2tlZCE9PXQmJih0aGlzLm9iamVjdC5jaGVja2VkPXQsdS5kaXNwYXRjaEV2ZW50cyYmdGhpcy5vYmplY3QuZGlzcGF0Y2hFdmVudChwKCkpKX1icmVhaztjYXNlXCJET01BdHRyXCI6dGhpcy5vYmplY3Quc2V0QXR0cmlidXRlKHRoaXMucHIsdCl9dGhpcy52YWx1ZT10LHRoaXMudUFTKGUpfSx1QVM6ZnVuY3Rpb24odCl7dmFyIGUsaTtpZihpPShlPXRoaXMuc3VicykubGVuZ3RoKWZvcig7aS0tOyl0aGlzLnVTKGVbaV0sdCl9LHVTOmZ1bmN0aW9uKHQsZSxpKXt2YXIgcztpZighKGU9PT10fHxlIT09dGhpcyYmZS5zTVt0LklEXSkpe3ZhciBuPXRoaXMuc01bdC5JRF07aWYoIW4uZEx8fCFuLmRMW2UuSURdKXtpZihuLm9wdHMudGhyb3R0bGUpe3ZhciByPShpPStuZXcgRGF0ZSktbi5sVTtpZihyPG4ub3B0cy50aHJvdHRsZSlyZXR1cm4gY2xlYXJUaW1lb3V0KG4udVQpLG4udVQ9c2V0VGltZW91dChmdW5jdGlvbihpKXtyZXR1cm4gZnVuY3Rpb24oKXtpZihpLnNNW3QuSURdKXJldHVybiBpLnVTKHQsZSl9fSh0aGlzKSxuLm9wdHMudGhyb3R0bGUtcik7bi5sVT1pfWVsc2UgaWYobi5vcHRzLmRlbGF5JiYhaSlyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbihpKXtyZXR1cm4gZnVuY3Rpb24oKXtpZihpLnNNW3QuSURdKXJldHVybiBpLnVTKHQsZSwhMCl9fSh0aGlzKSxuLm9wdHMuZGVsYXkpO2k9XCJBcnJheVwiPT09dGhpcy50eXBlJiZuLm9wdHMuc2VuZEFycmF5Q29waWVzP3RoaXMudmFsdWUuc2xpY2UoKTp0aGlzLnZhbHVlLHI9dFtuLlZSXSwoaT0ocz1uLnRGKT9zKGkscix0Lm9iamVjdCk6aSk9PT1yJiYhbi5vcHRzLnVwZGF0ZUV2ZW5JZlNhbWV8fG4uY04mJiFuLmNOKGkscix0Lm9iamVjdCl8fChuLm9wdHMucHJvbWlzZVRyYW5zZm9ybXMmJmkmJk8uaUYoaS50aGVuKT9pLnRoZW4oZnVuY3Rpb24oaSl7dC5zVihpLGUpfSk6dC5zVihpLGUpLG4udU8mJnRoaXMuclModCkpfX19LGFNOmZ1bmN0aW9uKHQsZSxpLHMpe3ZhciBuLHI7aWYoTy5pRihpKSl7dmFyIGg9MDtmb3Iocj1lLmxlbmd0aDtoPHI7aCsrKXt2YXIgbz1lW2hdLHU9by5ffHxvO3UuaXNNdWx0aT90aGlzLmFNKHQsdS5iaW5kaW5ncyxpLHMpOihvPXRoaXMuc01bdS5JRF0sb1t0XT1pLHM9cyYmIW8udU8sdGhpcy5wTVt1LklEXSYmKChuPXUuc01bdGhpcy5JRF0pW3RdfHwoblt0XT1pKSksIXMmJlwiRnVuY1wiIT09dGhpcy50eXBlfHxcInRGXCIhPT10fHx0aGlzLnVTKHUsdGhpcykpfXJldHVybiEwfXJldHVybiBHKFwiZXJGTlwiLDIpfSxzczpmdW5jdGlvbih0LGUpe3RoaXMudGZTPXQsZSYmdGhpcy5zVih0aGlzLnZhbHVlKX0sYUQ6ZnVuY3Rpb24odCxlKXt2YXIgaTsobnVsbCE9KGk9dGhpcy5zTVt0LklEXSkuZEw/aS5kTDppLmRMPXkoKSlbZS5JRF09MX0sc1BIOmZ1bmN0aW9uKCl7aWYoIXRoaXMucFZMKXtpZih0aGlzLnBWTD15KCksdGhpcy5wSU09eSgpLHRoaXMucENUPVtdLE8uaVModGhpcy52YWx1ZSkpe3RoaXMucENUPXRoaXMudmFsdWUuc3BsaXQoVik7dmFyIHQ9MDt0aGlzLnZhbHVlPXRoaXMudmFsdWUucmVwbGFjZShBLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihpLHMpe3JldHVybiBlLnBJTVt0KytdPXMsZS5wVkxbc109c319KHRoaXMpKX10aGlzLkRNJiZcInRleHRDb250ZW50XCI9PT10aGlzLnByJiZCKHRoaXMub2JqZWN0LHRoaXMudHhOPXkoKSl9fSxhUEk6ZnVuY3Rpb24odCl7aWYoXCJFdmVudFwiIT09dGhpcy50eXBlKXJldHVybiB0aGlzLnJQSSgpLHRoaXMuUEk9c2V0SW50ZXJ2YWwoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dC5mRFYoKTtyZXR1cm4gdC5zVihlLHQsITApfX0odGhpcyksdCl9LHJQSTpmdW5jdGlvbigpe3JldHVybiBjbGVhckludGVydmFsKHRoaXMuUEkpLHRoaXMuUEk9bnVsbH0sYVVWOmZ1bmN0aW9uKHQsZSl7dGhpcy5vYmplY3QuYWRkRXZlbnRMaXN0ZW5lcih0LGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihpKXtpLl9zYnx8KGk9dC50ZlMmJnQuZEksdC5zVih0Lm9iamVjdFtlXSxudWxsLCFpLCEwKSl9fSh0aGlzKSwhMSl9LGFFVjpmdW5jdGlvbigpe3RoaXMuZXZOP3RoaXMuckVWRSh0aGlzLmV2Tik6dGhpcy5kST8odGhpcy5hVVYoXCJpbnB1dFwiLFwidmFsdWVcIiksdGhpcy5hVVYoXCJjaGFuZ2VcIixcInZhbHVlXCIpKTp0aGlzLm1DfHxcIkRPTVJhZGlvXCIhPT10aGlzLnR5cGUmJlwiRE9NQ2hlY2tib3hcIiE9PXRoaXMudHlwZXx8dGhpcy5hVVYoXCJjaGFuZ2VcIixcImNoZWNrZWRcIil9LHJFVkU6ZnVuY3Rpb24odCl7dGhpcy5hdEVWLnB1c2godCksdGhpcy5ldkh8fCh0aGlzLmV2SD1VLmJpbmQodGhpcykpLHRoaXMub2JqZWN0W3RoaXMuZU0ubGlzdGVuXSh0LHRoaXMuZXZIKX0sdXJFVkU6ZnVuY3Rpb24odCl7dGhpcy5hdEVWLnNwbGljZSh0aGlzLmF0RVYuaW5kZXhPZih0KSwxKSx0aGlzLm9iamVjdFt0aGlzLmVNLnJlbW92ZV0odCx0aGlzLmV2SCl9LGVFOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZXZOO1wiZGlzcGF0Y2hFdmVudFwiPT09dGhpcy5lTS5lbWl0JiYodGhpcy5ldk98fCh0aGlzLmV2Tz1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpLHRoaXMuZXZPLmluaXRFdmVudCh0aGlzLmV2TiwhMCwhMCkpLHRoaXMuZXZPLmJpbmRpbmdEYXRhPXQsZT10aGlzLmV2TyksdGhpcy5vYmplY3RbdGhpcy5lTS5lbWl0XShlLHQpfX07dmFyIFU9ZnVuY3Rpb24oKXt0aGlzLmlFfHx0aGlzLnNWKGFyZ3VtZW50c1t0aGlzLnByXSxudWxsLCEwKX0sWD1mdW5jdGlvbih0LGUpe3ZhciBpO2lmKGUpRSh0aGlzLGUpLHRoaXMuc0c9MTtlbHNlIGZvcihpIGluIHRoaXMuc0c9MCx0aGlzLnN1YnM9W10sdGhpcy5vUD10fHwodD17fSksdGhpcy5vcHRpb25zPXt9LGMpdGhpcy5vcHRpb25zW2ldPW51bGwhPXRbaV0/dFtpXTpjW2ldO3JldHVybiB0aGlzfTt0PXtzQzpmdW5jdGlvbigpe3JldHVybiBuZXcgWChudWxsLHRoaXMpfSxkTTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fPXQsT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyx7dmFsdWU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0LnZhbHVlfX0sb3JpZ2luYWw6e2dldDpmdW5jdGlvbigpe3JldHVybiB0Lm9iamVjdHN8fHQub2JqZWN0fX0sc3Vic2NyaWJlcnM6e2dldDpmdW5jdGlvbigpe3JldHVybiB0LnN1YnMuc2xpY2UoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQub2JqZWN0fSl9fX0pfSxjcmVhdGVCUDpmdW5jdGlvbih0LGUsaSxzKXt2YXIgbjtyZXR1cm4gdGhpcy5vYmplY3Q9dCwobj1QLmdldCh0LHMsdGhpcy5zZSx0aGlzLm1DKSk/dGhpcy5wYXRjaENhY2hlZEJQKG4pOih0PW5ldyBSKHQsZSxpKSxQLnNldCh0LHMpLHQpfSxwYXRjaENhY2hlZEJQOmZ1bmN0aW9uKHQpe3ZhciBlO2lmKFwiT2JqZWN0UHJvcFwiIT09dC50eXBlfHx0aGlzLnByIGluIHRoaXMub2JqZWN0fHxJKHQsdGhpcy5vYmplY3QpLHRoaXMuc28pe3ZhciBpPXRoaXMub1A7Zm9yKG4gaW4gaSl7dmFyIHM9aVtuXTt0Lm9EW25dPXN9fXZhciBuPXQub0Q7Zm9yKGUgaW4gbilzPW5bZV0sdGhpcy5vcHRpb25zW2VdPU8uaUQodGhpcy5vUFtlXSk/dGhpcy5vUFtlXTpzO3JldHVybiB0fSxzUDpmdW5jdGlvbih0KXtpZihPLmlOKHQpJiYodD10LnRvU3RyaW5nKCkpLHRoaXMuc2U9dGhpcy5wcj10LCF0aGlzLm9wdGlvbnMuc2ltcGxlU2VsZWN0b3Ipe2lmKEQodCxcIjpcIikpe3ZhciBlPXQuc3BsaXQoXCI6XCIpO3RoaXMuZGU9ZS5zbGljZSgwLC0xKS5qb2luKFwiOlwiKSx0aGlzLnByPWVbZS5sZW5ndGgtMV19RCh0LFwiLlwiKSYmKGU9dGhpcy5wci5zcGxpdChcIi5cIiksdGhpcy5wcj1lWzBdLHRoaXMuUGg9ZS5zbGljZSgxKS5qb2luKFwiLlwiKSksRCh0aGlzLmRlLFwiZXZlbnRcIikmJihEKHQsXCIjXCIpPyhlPXRoaXMucHIuc3BsaXQoXCIjXCIpLHRoaXMuZXZOPWVbMF0sdGhpcy5wcj1lWzFdKToodGhpcy5ldk49dGhpcy5wcix0aGlzLnByPTApLGlzTmFOKHBhcnNlSW50KHRoaXMucHIpKSYmRyhcImVyRVZcIiwxKSl9cmV0dXJuIHRoaXN9LHNTOmZ1bmN0aW9uKHQsZSl7dGhpcy5zRz0xO3ZhciBpLHM9KGk9dCE9PXdpbmRvdyYmTy5pc0kodCkmJiF0Lm5vZGVUeXBlKT90WzBdOnQ7aWYocyl7aWYodGhpcy5ETT1PLkRNKHMpKXtpZihcImNoZWNrZWRcIj09PXRoaXMucHIpdmFyIG49cyYmTy5kUihzKSxyPSFuJiZzJiZPLmRDKHMpO2Vsc2VcInZhbHVlXCI9PT10aGlzLnByJiYodGhpcy5kST1PLmRJKHMpKTtpZihpJiYhRCh0aGlzLmRlLFwibXVsdGlcIikpaWYoMT09PXQubGVuZ3RoKXQ9dFswXTtlbHNle2lmKChufHxyKSYmIU8uZUFTKHQpKXJldHVybiBHKFwiZXJNWFwiLDMpO258fHI/KHRoaXMubUM9ITAsdD1bXS5zbGljZS5jYWxsKHQpKToodD10WzBdLEcoXCJlck9EXCIsMykpfX19ZWxzZSBpJiZPLmVDKHQpJiZGKFwiZW1wdHlMaXN0XCIpO3N3aXRjaCghMSl7Y2FzZSFlOnI9XCJGdW5jXCI7YnJlYWs7Y2FzZSF0aGlzLlBoOnI9XCJQaG9sZGVyXCI7YnJlYWs7Y2FzZSEoRCh0aGlzLmRlLFwiYXJyYXlcIikmJk8uaUEodFt0aGlzLnByXSkpOnI9XCJBcnJheVwiO2JyZWFrO2Nhc2UhRCh0aGlzLmRlLFwiZXZlbnRcIik6cj1cIkV2ZW50XCIsdGhpcy5lTT17bGlzdGVuOnRoaXMub1AubGlzdGVuTWV0aG9kLHJlbW92ZTp0aGlzLm9QLnJlbW92ZU1ldGhvZCxlbWl0OnRoaXMub1AuZW1pdE1ldGhvZH0sdFt0aGlzLmVNLmxpc3Rlbl18fCh0aGlzLmVNLmxpc3Rlbj1PLmROKHQpP1wiYWRkRXZlbnRMaXN0ZW5lclwiOlwib25cIiksdFt0aGlzLmVNLnJlbW92ZV18fCh0aGlzLmVNLnJlbW92ZT1PLmROKHQpP1wicmVtb3ZlRXZlbnRMaXN0ZW5lclwiOlwicmVtb3ZlTGlzdGVuZXJcIiksdFt0aGlzLmVNLmVtaXRdfHwodGhpcy5lTS5lbWl0PU8uZE4odCk/XCJkaXNwYXRjaEV2ZW50XCI6XCJlbWl0XCIpO2JyZWFrO2Nhc2UhRCh0aGlzLmRlLFwiZnVuY1wiKTpyPVwiUHJveHlcIjticmVhaztjYXNlIW46cj1cIkRPTVJhZGlvXCI7YnJlYWs7Y2FzZSFyOnI9XCJET01DaGVja2JveFwiO2JyZWFrO2Nhc2UhRCh0aGlzLmRlLFwiYXR0clwiKTpyPVwiRE9NQXR0clwiO2JyZWFrO2RlZmF1bHQ6cj1cIk9iamVjdFByb3BcIn1yZXR1cm4gRCh0aGlzLmRlLFwibXVsdGlcIik/KHQubGVuZ3RofHxGKFwiZW1wdHlMaXN0XCIpLHRoaXMuZE0obmV3IG50KHRoaXMsdCxyKSkpOnRoaXMuZE0odGhpcy5jcmVhdGVCUCh0LHIsdGhpcyxlKSksRCh0aGlzLl8udHlwZSxcIkV2ZW50XCIpfHxEKHRoaXMuXy50eXBlLFwiUHJveHlcIik/dGhpcy5vcHRpb25zLnVwZGF0ZU9uQmluZD0hMTpEKHRoaXMuXy50eXBlLFwiRnVuY1wiKSYmKHRoaXMub3B0aW9ucy51cGRhdGVPbkJpbmQ9ITApLHRoaXMuY0M/dGhpcy5jQyh0aGlzKTp0aGlzfSxhUDpmdW5jdGlvbih0KXt2YXIgZTt0LnNHPTIsdC5zdWJzLnB1c2godGhpcyk7dmFyIGk9dC5fLmFTKHRoaXMuXyx0Lm9wdGlvbnMsdC51Tyk7aWYodC51TylkZWxldGUgdC51TztlbHNlIGlmKHQub3B0aW9ucy51cGRhdGVPbkJpbmQmJiFpKWlmKHRoaXMuXy5pc011bHRpKXt2YXIgcz10aGlzLl8uYmluZGluZ3Msbj0wO2ZvcihlPXMubGVuZ3RoO248ZTtuKyspaT1zW25dLHQuXy51UyhpLHQuXyl9ZWxzZSB0Ll8udVModGhpcy5fLHQuXyl9fSxYLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQse29mOntnZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy5zRylyZXR1cm4gV319LHNldDp7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5zRylyZXR1cm4gJH19LGNoYWluVG86e2dldDpmdW5jdGlvbigpe2lmKDI9PT10aGlzLnNHKXJldHVybiBZfX0sdHJhbnNmb3JtU2VsZjp7Z2V0OmZ1bmN0aW9uKCl7aWYoMT09PXRoaXMuc0cpcmV0dXJuIFF9fSx0cmFuc2Zvcm06e2dldDpmdW5jdGlvbigpe2lmKDI9PT10aGlzLnNHKXJldHVybiBxfX0sdHJhbnNmb3JtQWxsOntnZXQ6ZnVuY3Rpb24oKXtpZigyPT09dGhpcy5zRylyZXR1cm4gen19LGNvbmRpdGlvbjp7Z2V0OmZ1bmN0aW9uKCl7aWYoMj09PXRoaXMuc0cpcmV0dXJuIEp9fSxjb25kaXRpb25BbGw6e2dldDpmdW5jdGlvbigpe2lmKDI9PT10aGlzLnNHKXJldHVybiBLfX0sYm90aFdheXM6e2dldDpmdW5jdGlvbigpe2lmKDI9PT10aGlzLnNHKXJldHVybiBafX0sdW5CaW5kOntnZXQ6ZnVuY3Rpb24oKXtpZigyPT09dGhpcy5zRylyZXR1cm4gdHR9fSxwb2xsRXZlcnk6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuc0cpcmV0dXJuIGV0fX0sc3RvcFBvbGxpbmc6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuc0cpcmV0dXJuIGl0fX0sc2V0T3B0aW9uOntnZXQ6ZnVuY3Rpb24oKXtpZigyPT09dGhpcy5zRylyZXR1cm4gc3R9fSxkaXNhbGxvd0Zyb206e2dldDpmdW5jdGlvbigpe3ZhciB0O2lmKDI9PT10aGlzLnNHJiYodD10aGlzKSlyZXR1cm4gXyghMSxmdW5jdGlvbihlKXtyZXR1cm4gdC5fLmFEKHQuc3Vic1t0LnN1YnMubGVuZ3RoLTFdLl8sZS5fKSx0fSl9fSx1cGRhdGVPbjp7Z2V0OmZ1bmN0aW9uKCl7dmFyIHQ7aWYodGhpcy5zRyYmKHQ9dGhpcykpcmV0dXJuIF8oITEsZnVuY3Rpb24oZSl7cmV0dXJuIGUuXyE9PXQuXyYmKHQuXy5wTVtlLl8uSURdPWUuXyxlLl8uYVMobSh0Ll8sITApLGUub3B0aW9ucywhMSwhMCkpLHR9KX19LHJlbW92ZVVwZGF0ZXI6e2dldDpmdW5jdGlvbigpe3ZhciB0LGU7aWYodGhpcy5zRyYmKGU9dGhpcykmJih0PXRoaXMuXy5zVSkpcmV0dXJuIF8oITEsZnVuY3Rpb24oaSl7aS5fLnNNW3QuSURdJiYoZGVsZXRlIGUuXy5wTVtpLl8uSURdLGkuXy5yUyh0KSl9KX19LHRvOntnZXQ6ZnVuY3Rpb24oKXt2YXIgdDtpZigxPT09dGhpcy5zRyYmKHQ9dGhpcykpcmV0dXJuIF8oITAsZnVuY3Rpb24oZSl7cmV0dXJuIGUuXyE9PXQuXyYmZS5hUCh0KSx0fSl9fSxhbmQ6e2dldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc0MoKTtpZigyPT09dGhpcy5zRylyZXR1cm4gdDtpZigxPT09dGhpcy5zRyl7aWYoIXQuXy5pc011bHRpKXt2YXIgZT10Ll87dC5fPXQuXz1uZXcgbnQodCksdC5fLmFkZEJQKGUpfXJldHVybiBfKCExLGZ1bmN0aW9uKGUpe3JldHVybiB0Ll8uYWRkQlAoZS5fKSx0fSl9fX0sb25jZTp7Z2V0OmZ1bmN0aW9uKCl7aWYoMT09PXRoaXMuc0cpe3ZhciB0PXRoaXMuc0MoKTtyZXR1cm4gdC51Tz0hMCx0fX19LHVwZGF0ZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0fX0sdHdvV2F5OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib3RoV2F5c319LHBpcGU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoYWluVG99fX0pO3ZhciBXPWZ1bmN0aW9uKHQpe3JldHVybiBPLmlPKHQpfHxPLmlGKHQpfHx3KHQpLE8uaUJJKHQpJiYodD10Lm9iamVjdCksdGhpcy5zRz0xLHRoaXMuc1ModCl9LFk9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBIKHRoaXMuc3Vic1t0aGlzLnN1YnMubGVuZ3RoLTFdKS50byh0LGUsaSl9LCQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuXy5zVih0KSx0aGlzfSxRPWZ1bmN0aW9uKHQpe3JldHVybiBPLmlGKHQpP3RoaXMuXy5zcyh0LHRoaXMub3B0aW9ucy51cGRhdGVPbkJpbmQpOkcoXCJlckZOXCIsMSksdGhpc30scT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fLmFNKFwidEZcIix0aGlzLnN1YnMuc2xpY2UoLTEpLHQsdGhpcy5vcHRpb25zLnVwZGF0ZU9uQmluZCksdGhpc30sej1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fLmFNKFwidEZcIix0aGlzLnN1YnMsdCx0aGlzLm9wdGlvbnMudXBkYXRlT25CaW5kKSx0aGlzfSxKPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl8uYU0oXCJjTlwiLHRoaXMuc3Vicy5zbGljZSgtMSksdCksdGhpc30sSz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fLmFNKFwiY05cIix0aGlzLnN1YnMsdCksdGhpc30sWj1mdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuc3Vic1t0aGlzLnN1YnMubGVuZ3RoLTFdLHM9aS5fLG49dGhpcy5fLmlzTXVsdGk/dGhpcy5fLmJpbmRpbmdzOlt0aGlzLl9dO2ZvcihzLmFTKHRoaXMuXyxpLm9wdGlvbnMpLGk9MCxlPW4ubGVuZ3RoO2k8ZTtpKyspe3ZhciByPW5baV0saD1yLnNNW3MuSURdLnRGO3I9ci5zTVtzLklEXS5jTiwoaHx8dCkmJihoPU8uaUYodCk/dDpoKSYmITEhPT10JiYocy5zTVt0aGlzLl8uSURdLnRGPWgpLHImJihzLnNNW3RoaXMuXy5JRF0uY049cil9cmV0dXJuIHRoaXN9LHR0PWZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5zdWJzLHM9MDtmb3IoZT1pLmxlbmd0aDtzPGU7cysrKXt2YXIgbj1pW3NdO3RoaXMuXy5yUyhuLl8sdCl9cmV0dXJuIHRoaXN9LGV0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl8uYVBJKHQpLHRoaXN9LGl0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuXy5yUEkoKSx0aGlzfSxzdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl8uc01bdGhpcy5zdWJzW3RoaXMuc3Vicy5sZW5ndGgtMV0uXy5JRF0ub3B0c1t0XT1lLHRoaXN9LG50PWZ1bmN0aW9uKHQsZSxpKXt2YXIgcyxuO2lmKHQuc2U9dC5zZS5zbGljZSg2KSxFKHRoaXMsdGhpcy5Jbj10KSx0aGlzLmlzTXVsdGk9ITAsdGhpcy5iaW5kaW5ncz1zPVtdLGUpZm9yKHQ9MCxuPWUubGVuZ3RoO3Q8bjt0Kyspe3ZhciByPWVbdF07dGhpcy5hZGRCUChyLGkpfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHt0eXBlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pfX0sdmFsdWU6e2dldDpmdW5jdGlvbigpe3JldHVybiBzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC52YWx1ZX0pfX19KX0scnQ9bnQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIE9iamVjdC5rZXlzKFIucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBydFt0XT1mdW5jdGlvbihlLGkscyxuKXt2YXIgcixoPXRoaXMuYmluZGluZ3Msbz0wO2ZvcihyPWgubGVuZ3RoO288cjtvKyspe3ZhciB1PWhbb107XCJ1U1wiPT09dCYmKGk9dSksdVt0XShlLGkscyxuKX19fSkscnQuYWRkQlA9ZnVuY3Rpb24odCxlKXt0aGlzLmJpbmRpbmdzLnB1c2goZT90aGlzLmNyZWF0ZUJQKHQsZSx0aGlzLkluKTp0KX0sZS5leHBvcnRzPUgsZS5leHBvcnRzfX0sdGhpcyksXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUudW1kKWRlZmluZShmdW5jdGlvbigpe3JldHVybiB0KDApfSk7ZWxzZXtpZihcIm9iamVjdFwiIT10eXBlb2YgbW9kdWxlfHwhbW9kdWxlLmV4cG9ydHMpcmV0dXJuIHRoaXMuc2ltcGx5YmluZD10KDApO21vZHVsZS5leHBvcnRzPXQoMCl9fSkuY2FsbCh0aGlzLG51bGwpOyIsInZhciBSRUdFWCA9IHtcbiAgYW55OiAvLi8sXG4gIHdoaXRlU3BhY2U6IC9cXHMrLyxcbiAgbnVtZXJpYzogL15cXGQkLyxcbiAgbGV0dGVyOiAvXlthLXpBLVpdJC8sXG4gIC8vIGFscGhhbnVtZXJpYzogL1tcXGRhLXpBLVpdL1xuICB3aWRlbnVtZXJpYzogL15bMC05XFwhI1xcJFxcJVxcKlxcK1xcL1xcPVxcP1xcXlxce1xcfFxcfVxcKFxcKVxcflxcLVxcLl0kLyxcbiAgYWxwaGFudW1lcmljOiAvXlswLTlBLVphLXpcXCEjXFwkXFwlXFwmXFwnXFwqXFwrXFwvXFw9XFw/XFxeXFxfXFxgXFx7XFx8XFx9XFwoXFwpXFx+XFwtXFwgXSQvLFxuICBlbWFpbDogL15bXFx3XFwtXFwuXStAW1xcd1xcLVxcLl0rXFwuW0EtWmEtel17MiwxMH0kL1xufTtleHBvcnQgZGVmYXVsdCBSRUdFWDsiLCJpbXBvcnQnQGRhbmllbGthbGVuL2lzJztpbXBvcnQgSVMgZnJvbScuL2NoZWNrcy5qcyc7aW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQnQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCBSRUdFWCBmcm9tJy4vY29uc3RhbnRzL3JlZ2V4LmpzJzt2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xudmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gKHRhcmdldCwgaXRlbSkge1xuICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn07XG52YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0cmluZywgY291bnQpIHtcbiAgdmFyIGk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGosIHJlZiwgcmVzdWx0czE7XG4gICAgcmVzdWx0czEgPSBbXTtcblxuICAgIGZvciAoaSA9IGogPSAxLCByZWYgPSBjb3VudDsgMSA8PSByZWYgPyBqIDw9IHJlZiA6IGogPj0gcmVmOyBpID0gMSA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgIHJlc3VsdHMxLnB1c2goc3RyaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0czE7XG4gIH0oKS5qb2luKCcnKTtcbn07XG52YXIgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uICh0YXJnZXQsIGl0ZW0pIHtcbiAgdmFyIGl0ZW1JbmRleDtcbiAgaXRlbUluZGV4ID0gdGFyZ2V0LmluZGV4T2YoaXRlbSk7XG5cbiAgaWYgKGl0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICB9XG59O1xudmFyIGluc2VydEFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgaXRlbSwgbmV3SXRlbSkge1xuICB2YXIgaXRlbUluZGV4O1xuICBpdGVtSW5kZXggPSB0YXJnZXQuaW5kZXhPZihpdGVtKTtcblxuICBpZiAoaXRlbUluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiB0YXJnZXQuc3BsaWNlKGl0ZW1JbmRleCwgMCwgbmV3SXRlbSk7XG4gIH1cbn07XG52YXIgZmluZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGZuKSB7XG4gIHZhciByZXN1bHRzO1xuICByZXN1bHRzID0gdGFyZ2V0LmZpbHRlcihmbik7XG4gIHJldHVybiByZXN1bHRzWzBdO1xufTtcbnZhciBkaWZmID0gZnVuY3Rpb24gKHNvdXJjZSwgY29tcGFyZWUpIHtcbiAgdmFyIGNvbXBhcmVlVmFsLCBpLCBtYXhMZW4sIHJlc3VsdCwgc291cmNlVmFsO1xuICByZXN1bHQgPSBbXTtcbiAgbWF4TGVuID0gTWF0aC5tYXgoc291cmNlLmxlbmd0aCwgY29tcGFyZWUubGVuZ3RoKTtcbiAgaSA9IC0xO1xuXG4gIHdoaWxlICgrK2kgPCBtYXhMZW4pIHtcbiAgICBzb3VyY2VWYWwgPSBzb3VyY2VbaV07XG4gICAgY29tcGFyZWVWYWwgPSBjb21wYXJlZVtpXTtcblxuICAgIGlmIChzb3VyY2VWYWwgIT09IGNvbXBhcmVlVmFsKSB7XG4gICAgICBpZiAoSVMuZGVmaW5lZChzb3VyY2VWYWwpICYmICFpbmNsdWRlcyhjb21wYXJlZSwgc291cmNlVmFsKSkge1xuICAgICAgICByZXN1bHQucHVzaChzb3VyY2VWYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoSVMuZGVmaW5lZChjb21wYXJlZVZhbCkgJiYgIWluY2x1ZGVzKHNvdXJjZSwgY29tcGFyZWVWYWwpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvbXBhcmVlVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBoZXhUb1JHQkEgPSBmdW5jdGlvbiAoaGV4LCBhbHBoYSkge1xuICB2YXIgQiwgRywgUjtcblxuICBpZiAoaGV4WzBdID09PSAnIycpIHtcbiAgICBoZXggPSBoZXguc2xpY2UoMSk7XG4gIH1cblxuICBSID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNik7XG4gIEcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KTtcbiAgQiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpO1xuICByZXR1cm4gYHJnYmEoJHtSfSwgJHtHfSwgJHtCfSwgJHthbHBoYX0pYDtcbn07XG52YXIgZGVmYXVsdENvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBkZWZhdWx0Q29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnIHx8ICFjb2xvcikge1xuICAgIHJldHVybiBkZWZhdWx0Q29sb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59O1xudmFyIGNhbGNQYWRkaW5nID0gZnVuY3Rpb24gKGRlc2lyZWRIZWlnaHQsIGZvbnRTaXplKSB7XG4gIHJldHVybiBNYXRoLmNlaWwoKGRlc2lyZWRIZWlnaHQgLSBmb250U2l6ZSAqIDEuMjMxKSAvIDIpO1xufTtcbnZhciB1bmxvY2tTY3JvbGwgPSBmdW5jdGlvbiAoZXhjbHVkZWRFbCkge1xuICB3aW5kb3cuX2lzTG9ja2VkID0gZmFsc2U7XG4gIHJldHVybiBET00od2luZG93KS5vZmYoJ3doZWVsLmxvY2snKTtcbn07XG52YXIgbG9ja1Njcm9sbCA9IGZ1bmN0aW9uIChleGNsdWRlZEVsKSB7XG4gIGlmICghd2luZG93Ll9pc0xvY2tlZCkge1xuICAgIHdpbmRvdy5faXNMb2NrZWQgPSB0cnVlO1xuICAgIHJldHVybiBET00od2luZG93KS5vbignd2hlZWwubG9jaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZXhjbHVkZWRFbC5yYXcgfHwgRE9NKGV2ZW50LnRhcmdldCkucGFyZW50TWF0Y2hpbmcoZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50ID09PSBleGNsdWRlZEVsO1xuICAgICAgfSkpIHtcbiAgICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEgPiAwICYmIGV4Y2x1ZGVkRWwucmF3LnNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEgPCAwICYmIGV4Y2x1ZGVkRWwucmF3LnNjcm9sbEhlaWdodCAtIGV4Y2x1ZGVkRWwucmF3LnNjcm9sbFRvcCA9PT0gZXhjbHVkZWRFbC5yYXcuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIGZ1enp5TWF0Y2ggPSBmdW5jdGlvbiAobmVlZGxlLCBoYXlzdGFjaywgY2FzZVNlbnNpdGl2ZSkge1xuICB2YXIgaEksIGhMZW5ndGgsIG1hdGNoZWRDb3VudCwgbkksIG5MZW5ndGgsIG5lZWRsZUNoYXI7XG4gIG5MZW5ndGggPSBuZWVkbGUubGVuZ3RoO1xuICBoTGVuZ3RoID0gaGF5c3RhY2subGVuZ3RoO1xuXG4gIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgIG5lZWRsZSA9IG5lZWRsZS50b1VwcGVyQ2FzZSgpO1xuICAgIGhheXN0YWNrID0gaGF5c3RhY2sudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIGlmIChuTGVuZ3RoID4gaExlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuTGVuZ3RoID09PSBoTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5lZWRsZSA9PT0gaGF5c3RhY2s7XG4gIH1cblxuICBuSSA9IGhJID0gbWF0Y2hlZENvdW50ID0gMDtcblxuICB3aGlsZSAobkkgPCBuTGVuZ3RoKSB7XG4gICAgbmVlZGxlQ2hhciA9IG5lZWRsZVtuSSsrXTtcblxuICAgIHdoaWxlIChoSSA8IGhMZW5ndGgpIHtcbiAgICAgIGlmIChoYXlzdGFja1toSSsrXSA9PT0gbmVlZGxlQ2hhcikge1xuICAgICAgICBtYXRjaGVkQ291bnQrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRDb3VudCA9PT0gbkxlbmd0aDtcbn07XG52YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChuZWVkbGUsIGhheXN0YWNrLCBjYXNlU2Vuc2l0aXZlKSB7XG4gIHZhciBpO1xuXG4gIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgIG5lZWRsZSA9IG5lZWRsZS50b1VwcGVyQ2FzZSgpO1xuICAgIGhheXN0YWNrID0gaGF5c3RhY2sudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIGlmIChuZWVkbGUubGVuZ3RoID4gaGF5c3RhY2subGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5lZWRsZS5sZW5ndGggPT09IGhheXN0YWNrLmxlbmd0aCkge1xuICAgIHJldHVybiBuZWVkbGUgPT09IGhheXN0YWNrO1xuICB9XG5cbiAgaSA9IC0xO1xuXG4gIHdoaWxlIChuZWVkbGVbKytpXSkge1xuICAgIGlmIChuZWVkbGVbaV0gIT09IGhheXN0YWNrW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGdldEluZGV4T2ZGaXJzdERpZmYgPSBmdW5jdGlvbiAoc291cmNlU3RyaW5nLCBjb21wYXJlU3RyaW5nKSB7XG4gIHZhciBjdXJyZW50UG9zLCBtYXhMZW5ndGg7XG4gIGN1cnJlbnRQb3MgPSAwO1xuICBtYXhMZW5ndGggPSBNYXRoLm1heChzb3VyY2VTdHJpbmcubGVuZ3RoLCBjb21wYXJlU3RyaW5nLmxlbmd0aCk7XG5cbiAgd2hpbGUgKGN1cnJlbnRQb3MgPCBtYXhMZW5ndGgpIHtcbiAgICBpZiAoc291cmNlU3RyaW5nW2N1cnJlbnRQb3NdICE9PSBjb21wYXJlU3RyaW5nW2N1cnJlbnRQb3NdKSB7XG4gICAgICByZXR1cm4gY3VycmVudFBvcztcbiAgICB9XG5cbiAgICBjdXJyZW50UG9zKys7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgcGFyc2VDc3NTaG9ydGhhbmRWYWx1ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCwgdmFsdWVzO1xuICB2YWx1ZXMgPSBzdHJpbmcuc3BsaXQoUkVHRVgud2hpdGVTcGFjZSkubWFwKHBhcnNlRmxvYXQpO1xuICByZXN1bHQgPSB7fTtcblxuICBzd2l0Y2ggKHZhbHVlcy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXN1bHQudG9wID0gcmVzdWx0LnJpZ2h0ID0gcmVzdWx0LmJvdHRvbSA9IHJlc3VsdC5sZWZ0ID0gdmFsdWVzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXN1bHQudG9wID0gcmVzdWx0LmJvdHRvbSA9IHZhbHVlc1swXTtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHJlc3VsdC5sZWZ0ID0gdmFsdWVzWzFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXN1bHQudG9wID0gdmFsdWVzWzBdO1xuICAgICAgcmVzdWx0LnJpZ2h0ID0gcmVzdWx0LmxlZnQgPSB2YWx1ZXNbMV07XG4gICAgICByZXN1bHQuYm90dG9tID0gdmFsdWVzWzJdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDQ6XG4gICAgICByZXN1bHQudG9wID0gdmFsdWVzWzBdO1xuICAgICAgcmVzdWx0LnJpZ2h0ID0gdmFsdWVzWzFdO1xuICAgICAgcmVzdWx0LmJvdHRvbSA9IHZhbHVlc1syXTtcbiAgICAgIHJlc3VsdC5sZWZ0ID0gdmFsdWVzWzNdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgc2hvcnRoYW5kU2lkZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBzaWRlKSB7XG4gIHZhciB2YWx1ZXM7XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhbHVlcyA9IHBhcnNlQ3NzU2hvcnRoYW5kVmFsdWUodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlc1tzaWRlXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciB1cGRhdGVTaG9ydGhhbmRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2lkZSwgbmV3VmFsdWUpIHtcbiAgdmFyIHZhbHVlcztcbiAgdmFsdWVzID0gcGFyc2VDc3NTaG9ydGhhbmRWYWx1ZSgnJyArICh2YWx1ZSB8fCAwKSk7XG5cbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHZhbHVlcy50b3AgKz0gbmV3VmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHZhbHVlcy5yaWdodCArPSBuZXdWYWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHZhbHVlcy5ib3R0b20gKz0gbmV3VmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdmFsdWVzLmxlZnQgKz0gbmV3VmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tzaWRlXSArPSBuZXdWYWx1ZTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGAke3ZhbHVlcy50b3B9cHggJHt2YWx1ZXMucmlnaHR9cHggJHt2YWx1ZXMuYm90dG9tfXB4ICR7dmFsdWVzLmxlZnR9cHhgO1xufTtcbnZhciBpbmhlcml0UHJvdG8gPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCwga2V5cykge1xuICB2YXIgaiwga2V5LCBsZW4sIHJlZjtcbiAgcmVmID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyZW50LnByb3RvdHlwZSk7XG5cbiAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAga2V5ID0gcmVmW2pdO1xuXG4gICAgaWYgKGtleXMgJiYgIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5wcm90b3R5cGVba2V5XSkge1xuICAgICAgY2hpbGQucHJvdG90eXBlW2tleV0gPSBwYXJlbnQucHJvdG90eXBlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufTtleHBvcnR7bm9vcCxpbmNsdWRlcyxyZXBlYXQscmVtb3ZlSXRlbSxpbnNlcnRBZnRlcixmaW5kLGRpZmYsaGV4VG9SR0JBLGRlZmF1bHRDb2xvcixjYWxjUGFkZGluZyx1bmxvY2tTY3JvbGwsbG9ja1Njcm9sbCxmdXp6eU1hdGNoLHN0YXJ0c1dpdGgsZ2V0SW5kZXhPZkZpcnN0RGlmZixwYXJzZUNzc1Nob3J0aGFuZFZhbHVlLHNob3J0aGFuZFNpZGVWYWx1ZSx1cGRhdGVTaG9ydGhhbmRWYWx1ZSxpbmhlcml0UHJvdG99OyIsInZhciBSRVFVSVJFRF9GSUVMRF9NRVRIT0RTID0gWydfZ2V0VmFsdWUnLCAnX3NldFZhbHVlJywgJ192YWxpZGF0ZSddO2V4cG9ydCBkZWZhdWx0IFJFUVVJUkVEX0ZJRUxEX01FVEhPRFM7IiwiIShmdW5jdGlvbih3aW4pIHtcblxuLyoqXG4gKiBGYXN0RG9tXG4gKlxuICogRWxpbWluYXRlcyBsYXlvdXQgdGhyYXNoaW5nXG4gKiBieSBiYXRjaGluZyBET00gcmVhZC93cml0ZVxuICogaW50ZXJhY3Rpb25zLlxuICpcbiAqIEBhdXRob3IgV2lsc29uIFBhZ2UgPHdpbHNvbnBhZ2VAbWUuY29tPlxuICogQGF1dGhvciBLb3JuZWwgTGVzaW5za2kgPGtvcm5lbC5sZXNpbnNraUBmdC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1pbmkgbG9nZ2VyXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciBkZWJ1ZyA9IDAgPyBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUsICdbZmFzdGRvbV0nKSA6IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogTm9ybWFsaXplZCByQUZcbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbnZhciByYWYgPSB3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbi53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luLm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB8fCB3aW4ubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgZnVuY3Rpb24oY2IpIHsgcmV0dXJuIHNldFRpbWVvdXQoY2IsIDE2KTsgfTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgYEZhc3REb21gLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGYXN0RG9tKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucmVhZHMgPSBbXTtcbiAgc2VsZi53cml0ZXMgPSBbXTtcbiAgc2VsZi5yYWYgPSByYWYuYmluZCh3aW4pOyAvLyB0ZXN0IGhvb2tcbiAgZGVidWcoJ2luaXRpYWxpemVkJywgc2VsZik7XG59XG5cbkZhc3REb20ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRmFzdERvbSxcblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcmVhZCBiYXRjaCBhbmRcbiAgICogc2NoZWR1bGVzIGEgbmV3IGZyYW1lIGlmIG5lZWQgYmUuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICAgKiBAcHVibGljXG4gICAqL1xuICBtZWFzdXJlOiBmdW5jdGlvbihmbiwgY3R4KSB7XG4gICAgZGVidWcoJ21lYXN1cmUnKTtcbiAgICB2YXIgdGFzayA9ICFjdHggPyBmbiA6IGZuLmJpbmQoY3R4KTtcbiAgICB0aGlzLnJlYWRzLnB1c2godGFzayk7XG4gICAgc2NoZWR1bGVGbHVzaCh0aGlzKTtcbiAgICByZXR1cm4gdGFzaztcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGVcbiAgICogd3JpdGUgYmF0Y2ggYW5kIHNjaGVkdWxlc1xuICAgKiBhIG5ldyBmcmFtZSBpZiBuZWVkIGJlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbXV0YXRlOiBmdW5jdGlvbihmbiwgY3R4KSB7XG4gICAgZGVidWcoJ211dGF0ZScpO1xuICAgIHZhciB0YXNrID0gIWN0eCA/IGZuIDogZm4uYmluZChjdHgpO1xuICAgIHRoaXMud3JpdGVzLnB1c2godGFzayk7XG4gICAgc2NoZWR1bGVGbHVzaCh0aGlzKTtcbiAgICByZXR1cm4gdGFzaztcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXJzIGEgc2NoZWR1bGVkICdyZWFkJyBvciAnd3JpdGUnIHRhc2suXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHN1Y2Nlc3NcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uKHRhc2spIHtcbiAgICBkZWJ1ZygnY2xlYXInLCB0YXNrKTtcbiAgICByZXR1cm4gcmVtb3ZlKHRoaXMucmVhZHMsIHRhc2spIHx8IHJlbW92ZSh0aGlzLndyaXRlcywgdGFzayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0aGlzIEZhc3REb20gd2l0aCBzb21lXG4gICAqIGN1c3RvbSBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBCZWNhdXNlIGZhc3Rkb20gbXVzdCAqYWx3YXlzKiBiZSBhXG4gICAqIHNpbmdsZXRvbiwgd2UncmUgYWN0dWFsbHkgZXh0ZW5kaW5nXG4gICAqIHRoZSBmYXN0ZG9tIGluc3RhbmNlLiBUaGlzIG1lYW5zIHRhc2tzXG4gICAqIHNjaGVkdWxlZCBieSBhbiBleHRlbnNpb24gc3RpbGwgZW50ZXJcbiAgICogZmFzdGRvbSdzIGdsb2JhbCB0YXNrIHF1ZXVlLlxuICAgKlxuICAgKiBUaGUgJ3N1cGVyJyBpbnN0YW5jZSBjYW4gYmUgYWNjZXNzZWRcbiAgICogZnJvbSBgdGhpcy5mYXN0ZG9tYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG15RmFzdGRvbSA9IGZhc3Rkb20uZXh0ZW5kKHtcbiAgICogICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICogICAgIC8vIHJ1bnMgb24gY3JlYXRpb25cbiAgICogICB9LFxuICAgKlxuICAgKiAgIC8vIG92ZXJyaWRlIGEgbWV0aG9kXG4gICAqICAgbWVhc3VyZTogZnVuY3Rpb24oZm4pIHtcbiAgICogICAgIC8vIGRvIGV4dHJhIHN0dWZmIC4uLlxuICAgKlxuICAgKiAgICAgLy8gdGhlbiBjYWxsIHRoZSBvcmlnaW5hbFxuICAgKiAgICAgcmV0dXJuIHRoaXMuZmFzdGRvbS5tZWFzdXJlKGZuKTtcbiAgICogICB9LFxuICAgKlxuICAgKiAgIC4uLlxuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyAgcHJvcGVydGllcyB0byBtaXhpblxuICAgKiBAcmV0dXJuIHtGYXN0RG9tfVxuICAgKi9cbiAgZXh0ZW5kOiBmdW5jdGlvbihwcm9wcykge1xuICAgIGRlYnVnKCdleHRlbmQnLCBwcm9wcyk7XG4gICAgaWYgKHR5cGVvZiBwcm9wcyAhPSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBvYmplY3QnKTtcblxuICAgIHZhciBjaGlsZCA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgbWl4aW4oY2hpbGQsIHByb3BzKTtcbiAgICBjaGlsZC5mYXN0ZG9tID0gdGhpcztcblxuICAgIC8vIHJ1biBvcHRpb25hbCBjcmVhdGlvbiBob29rXG4gICAgaWYgKGNoaWxkLmluaXRpYWxpemUpIGNoaWxkLmluaXRpYWxpemUoKTtcblxuICAgIHJldHVybiBjaGlsZDtcbiAgfSxcblxuICAvLyBvdmVycmlkZSB0aGlzIHdpdGggYSBmdW5jdGlvblxuICAvLyB0byBwcmV2ZW50IEVycm9ycyBpbiBjb25zb2xlXG4gIC8vIHdoZW4gdGFza3MgdGhyb3dcbiAgY2F0Y2g6IG51bGxcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgbmV3IHJlYWQvd3JpdGVcbiAqIGJhdGNoIGlmIG9uZSBpc24ndCBwZW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlRmx1c2goZmFzdGRvbSkge1xuICBpZiAoIWZhc3Rkb20uc2NoZWR1bGVkKSB7XG4gICAgZmFzdGRvbS5zY2hlZHVsZWQgPSB0cnVlO1xuICAgIGZhc3Rkb20ucmFmKGZsdXNoLmJpbmQobnVsbCwgZmFzdGRvbSkpO1xuICAgIGRlYnVnKCdmbHVzaCBzY2hlZHVsZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgcXVldWVkIGByZWFkYCBhbmQgYHdyaXRlYCB0YXNrcy5cbiAqXG4gKiBFcnJvcnMgYXJlIGNhdWdodCBhbmQgdGhyb3duIGJ5IGRlZmF1bHQuXG4gKiBJZiBhIGAuY2F0Y2hgIGZ1bmN0aW9uIGhhcyBiZWVuIGRlZmluZWRcbiAqIGl0IGlzIGNhbGxlZCBpbnN0ZWFkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZsdXNoKGZhc3Rkb20pIHtcbiAgZGVidWcoJ2ZsdXNoJyk7XG5cbiAgdmFyIHdyaXRlcyA9IGZhc3Rkb20ud3JpdGVzO1xuICB2YXIgcmVhZHMgPSBmYXN0ZG9tLnJlYWRzO1xuICB2YXIgZXJyb3I7XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgcmVhZHMnLCByZWFkcy5sZW5ndGgpO1xuICAgIHJ1blRhc2tzKHJlYWRzKTtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgd3JpdGVzJywgd3JpdGVzLmxlbmd0aCk7XG4gICAgcnVuVGFza3Mod3JpdGVzKTtcbiAgfSBjYXRjaCAoZSkgeyBlcnJvciA9IGU7IH1cblxuICBmYXN0ZG9tLnNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIElmIHRoZSBiYXRjaCBlcnJvcmVkIHdlIG1heSBzdGlsbCBoYXZlIHRhc2tzIHF1ZXVlZFxuICBpZiAocmVhZHMubGVuZ3RoIHx8IHdyaXRlcy5sZW5ndGgpIHNjaGVkdWxlRmx1c2goZmFzdGRvbSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgZGVidWcoJ3Rhc2sgZXJyb3JlZCcsIGVycm9yLm1lc3NhZ2UpO1xuICAgIGlmIChmYXN0ZG9tLmNhdGNoKSBmYXN0ZG9tLmNhdGNoKGVycm9yKTtcbiAgICBlbHNlIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogV2UgcnVuIHRoaXMgaW5zaWRlIGEgdHJ5IGNhdGNoXG4gKiBzbyB0aGF0IGlmIGFueSBqb2JzIGVycm9yLCB3ZVxuICogYXJlIGFibGUgdG8gcmVjb3ZlciBhbmQgY29udGludWVcbiAqIHRvIGZsdXNoIHRoZSBiYXRjaCB1bnRpbCBpdCdzIGVtcHR5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1blRhc2tzKHRhc2tzKSB7XG4gIGRlYnVnKCdydW4gdGFza3MnKTtcbiAgdmFyIHRhc2s7IHdoaWxlICh0YXNrID0gdGFza3Muc2hpZnQoKSkgdGFzaygpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHsqfSBpdGVtXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGl0ZW0pIHtcbiAgdmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgcmV0dXJuICEhfmluZGV4ICYmICEhYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbn1cblxuLyoqXG4gKiBNaXhpbiBvd24gcHJvcGVydGllcyBvZiBzb3VyY2VcbiAqIG9iamVjdCBpbnRvIHRoZSB0YXJnZXQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlXG4gKi9cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbn1cblxuLy8gVGhlcmUgc2hvdWxkIG5ldmVyIGJlIG1vcmUgdGhhblxuLy8gb25lIGluc3RhbmNlIG9mIGBGYXN0RG9tYCBpbiBhbiBhcHBcbnZhciBleHBvcnRzID0gd2luLmZhc3Rkb20gPSAod2luLmZhc3Rkb20gfHwgbmV3IEZhc3REb20oKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vLyBFeHBvc2UgdG8gQ0pTICYgQU1EXG5pZiAoKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicpIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGV4cG9ydHM7IH0pO1xuZWxzZSBpZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnKSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cbn0pKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuIiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vY2hlY2tzLmpzJztpbXBvcnQgU2ltcGx5QmluZCBmcm9tJ0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJzt2YXIgQ29uZGl0aW9uO1xuQ29uZGl0aW9uID0gY2xhc3MgQ29uZGl0aW9uIHtcbiAgY29uc3RydWN0b3IoZmllbGQxLCBzZXR0aW5ncywgY2FsbGJhY2sxKSB7XG4gICAgdmFyIHByb3BlcnR5LCB0YXJnZXQ7XG4gICAgdGhpcy5maWVsZCA9IGZpZWxkMTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrMTtcbiAgICB0aGlzLnNhdGlzZmllZCA9IGZhbHNlO1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnNldHRpbmdzLnZhbHVlO1xuICAgIHRoaXMucHJvcGVydHkgPSB0aGlzLnNldHRpbmdzLnByb3BlcnR5IHx8ICdfdmFsdWUnO1xuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucHJvcGVydHkgPT09ICd2YWx1ZScpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSAnX3ZhbHVlJztcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0aGlzLmZpZWxkLmFsbEZpZWxkc1t0aGlzLnNldHRpbmdzLnRhcmdldF07XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgY29uZGl0aW9uIHRhcmdldCBub3QgZm91bmQgZm9yIHRoZSBwcm92aWRlZCBJRCAnJHt0aGlzLnNldHRpbmdzLnRhcmdldH0nYCwgdGhpcy5maWVsZCk7XG4gICAgfVxuXG4gICAgcHJvcGVydHkgPSBJUy5hcnJheSh0aGlzLnRhcmdldFt0aGlzLnByb3BlcnR5XSkgPyBgYXJyYXk6JHt0aGlzLnByb3BlcnR5fWAgOiB0aGlzLnByb3BlcnR5O1xuICAgIFNpbXBseUJpbmQocHJvcGVydHksIHtcbiAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICB9KS5vZih0aGlzLnRhcmdldCkuYW5kKCd2aXNpYmxlJykub2YodGhpcy50YXJnZXQuc3RhdGUpLnRvKHRoaXMuY2FsbGJhY2spO1xuICAgIFNpbXBseUJpbmQoJ3NhdGlzZmllZCcsIHtcbiAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICB9KS5vZih0aGlzKS50bygobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICB2YXIgYmFzZTtcblxuICAgICAgaWYgKG9sZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiAoYmFzZSA9IHRoaXMuZmllbGQpLmVtaXQgPT09IFwiZnVuY3Rpb25cIiA/IGJhc2UuZW1pdCgnY29uZGl0aW9uQ2hhbmdlJywgdGhpcykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0ZXN0KCkge1xuICAgIHZhciBjb21wYXJpc29uLCBjb21wYXJpc29uT3BlcmF0b3JzLCBwYXNzZWRDb21wYXJpc29ucywgcmVmLCB0YXJnZXRWYWx1ZTtcblxuICAgIGlmICghKChyZWYgPSB0aGlzLnRhcmdldCkgIT0gbnVsbCA/IHJlZi5zdGF0ZS52aXNpYmxlIDogdm9pZCAwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbXBhcmlzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgIUlTLm9iamVjdFBsYWluKHRoaXMudmFsdWUpOlxuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXG4gICAgICAgIGNhc2UgIUlTLnJlZ2V4KHRoaXMudmFsdWUpOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnJHJlZ2V4JzogdGhpcy52YWx1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSAhKHRoaXMudmFsdWUgPT09ICd2YWxpZCcgJiYgIXRoaXMuc2V0dGluZ3MucHJvcGVydHkgfHwgIUlTLmRlZmluZWQodGhpcy52YWx1ZSkpOlxuICAgICAgICAgIHJldHVybiAndmFsaWQnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICckZXEnOiB0aGlzLnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LmNhbGwodGhpcyk7XG5cbiAgICBpZiAoY29tcGFyaXNvbiA9PT0gJ3ZhbGlkJykge1xuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0LnZhbGlkYXRlKCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0VmFsdWUgPSAoKCkgPT4ge1xuICAgICAgdmFyIG5lc3RlZE9iamVjdCwgcHJvcGVydHlDaGFpbjtcblxuICAgICAgaWYgKHRoaXMucHJvcGVydHkgPT09ICdfdmFsdWUnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcGVydHlDaGFpbiA9IHRoaXMucHJvcGVydHkuc3BsaXQoJy4nKTtcblxuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlIHByb3BlcnR5Q2hhaW4ubGVuZ3RoICE9PSAxOlxuICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFt0aGlzLnByb3BlcnR5XTtcblxuICAgICAgICBjYXNlICFJUy5kZWZpbmVkKHRoaXMudGFyZ2V0W3RoaXMucHJvcGVydHldKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRbdGhpcy5wcm9wZXJ0eV07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBuZXN0ZWRPYmplY3QgPSB0aGlzLnRhcmdldDtcblxuICAgICAgICAgIHdoaWxlIChJUy5vYmplY3QobmVzdGVkT2JqZWN0KSkge1xuICAgICAgICAgICAgbmVzdGVkT2JqZWN0ID0gbmVzdGVkT2JqZWN0W3Byb3BlcnR5Q2hhaW4ucG9wKCldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXN0ZWRPYmplY3Q7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIGNvbXBhcmlzb25PcGVyYXRvcnMgPSBPYmplY3Qua2V5cyhjb21wYXJpc29uKTtcbiAgICBwYXNzZWRDb21wYXJpc29ucyA9IGNvbXBhcmlzb25PcGVyYXRvcnMuZmlsdGVyKGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgdmFyIHNlZWtlZFZhbHVlO1xuICAgICAgc2Vla2VkVmFsdWUgPSBjb21wYXJpc29uW29wZXJhdG9yXTtcblxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICckZXEnOlxuICAgICAgICAgIHJldHVybiB0YXJnZXRWYWx1ZSA9PT0gc2Vla2VkVmFsdWU7XG5cbiAgICAgICAgY2FzZSAnJG5lJzpcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0VmFsdWUgIT09IHNlZWtlZFZhbHVlO1xuXG4gICAgICAgIGNhc2UgJyRndCc6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFZhbHVlID4gc2Vla2VkVmFsdWU7XG5cbiAgICAgICAgY2FzZSAnJGd0ZSc6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFZhbHVlID49IHNlZWtlZFZhbHVlO1xuXG4gICAgICAgIGNhc2UgJyRsdCc6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFZhbHVlIDwgc2Vla2VkVmFsdWU7XG5cbiAgICAgICAgY2FzZSAnJGx0ZSc6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFZhbHVlIDw9IHNlZWtlZFZhbHVlO1xuXG4gICAgICAgIGNhc2UgJyRjdCc6XG4gICAgICAgICAgcmV0dXJuIGhlbHBlcnMuaW5jbHVkZXModGFyZ2V0VmFsdWUsIHNlZWtlZFZhbHVlKTtcblxuICAgICAgICBjYXNlICckbmN0JzpcbiAgICAgICAgICByZXR1cm4gIWhlbHBlcnMuaW5jbHVkZXModGFyZ2V0VmFsdWUsIHNlZWtlZFZhbHVlKTtcblxuICAgICAgICBjYXNlICckcmVnZXgnOlxuICAgICAgICAgIHJldHVybiBzZWVrZWRWYWx1ZS50ZXN0KHRhcmdldFZhbHVlKTtcblxuICAgICAgICBjYXNlICckbnJlZ2V4JzpcbiAgICAgICAgICByZXR1cm4gIXNlZWtlZFZhbHVlLnRlc3QodGFyZ2V0VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgJyRtYXNrJzpcbiAgICAgICAgICByZXR1cm4gaGVscGVycy50ZXN0TWFzayh0YXJnZXRWYWx1ZSwgc2Vla2VkVmFsdWUpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXNzZWRDb21wYXJpc29ucy5sZW5ndGggPT09IGNvbXBhcmlzb25PcGVyYXRvcnMubGVuZ3RoO1xuICB9XG5cbiAgc3RhdGljIHZhbGlkYXRlKGNvbmRpdGlvbnMpIHtcbiAgICB2YXIgdmFsaWRDb25kaXRpb25zO1xuXG4gICAgaWYgKGNvbmRpdGlvbnMpIHtcbiAgICAgIHZhbGlkQ29uZGl0aW9ucyA9IGNvbmRpdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbi5zYXRpc2ZpZWQgPSBjb25kaXRpb24udGVzdCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsaWRDb25kaXRpb25zLmxlbmd0aCA9PT0gY29uZGl0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGluaXQoZmllbGQsIGNvbmRpdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkLnZhbGlkYXRlQ29uZGl0aW9ucygpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmaWVsZC5jb25kaXRpb25zID0gY29uZGl0aW9ucy5tYXAoZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbihmaWVsZCwgY29uZGl0aW9uLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cbn07XG52YXIgQ29uZGl0aW9uJDEgPSBDb25kaXRpb247ZXhwb3J0IGRlZmF1bHQgQ29uZGl0aW9uJDE7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vY2hlY2tzLmpzJzt2YXIgdHJhbnNmb3JtU2V0dGluZ3MgPSB7XG4gIGNvbmRpdGlvbnM6IGZ1bmN0aW9uIChjb25kaXRpb25zKSB7XG4gICAgdmFyIHJlc3VsdHMsIHRhcmdldCwgdmFsdWU7XG5cbiAgICBpZiAoSVMub2JqZWN0UGxhaW4oY29uZGl0aW9ucykpIHtcbiAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgICAgZm9yICh0YXJnZXQgaW4gY29uZGl0aW9ucykge1xuICAgICAgICB2YWx1ZSA9IGNvbmRpdGlvbnNbdGFyZ2V0XTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gZWxzZSBpZiAoSVMuYXJyYXkoY29uZGl0aW9ucykpIHtcbiAgICAgIHJldHVybiBjb25kaXRpb25zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoSVMuc3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogaXRlbVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY2hvaWNlczogZnVuY3Rpb24gKGNob2ljZXMpIHtcbiAgICB2YXIgbGFiZWwsIHJlc3VsdHMsIHZhbHVlO1xuXG4gICAgaWYgKElTLm9iamVjdFBsYWluKGNob2ljZXMpKSB7XG4gICAgICByZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAobGFiZWwgaW4gY2hvaWNlcykge1xuICAgICAgICB2YWx1ZSA9IGNob2ljZXNbbGFiZWxdO1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9IGVsc2UgaWYgKElTLmFycmF5KGNob2ljZXMpKSB7XG4gICAgICByZXR1cm4gY2hvaWNlcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJUy5vYmplY3RQbGFpbihpdGVtKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogaXRlbSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICB2YWxpZFdoZW5SZWdleDogZnVuY3Rpb24gKHJlZ2V4KSB7XG4gICAgaWYgKElTLnN0cmluZyhyZWdleCkpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlZ2V4O1xuICAgIH1cbiAgfVxufTtleHBvcnQgZGVmYXVsdCB0cmFuc2Zvcm1TZXR0aW5nczsiLCJ2YXIgZ2xvYmFsRGVmYXVsdHMgPSB7XG4gIGZvbnRGYW1pbHk6ICdzeXN0ZW0tdWksIHNhbnMtc2VyaWYnLFxuICB0ZW1wbGF0ZXM6IHt9LFxuICBldmVudHM6IG51bGwsXG4gIGxhYmVsOiBmYWxzZSxcbiAgZXJyb3I6ICcnLFxuICBoZWxwOiAnJyxcbiAgcmVxdWlyZWQ6IGZhbHNlLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIGRlZmF1bHRWYWx1ZTogbnVsbCxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgbW9iaWxlV2lkdGg6IG51bGwsXG4gIG1vYmlsZVRocmVzaG9sZDogNzM2LFxuICBib3JkZXI6IDEsXG4gIG1hcmdpbjogbnVsbCxcbiAgcGFkZGluZzogbnVsbCxcbiAgZGlzdGFuY2U6IG51bGwsXG4gIGlucHV0UGFkZGluZzogMTIsXG4gIGZvbnRTaXplOiAxNCxcbiAgbGFiZWxTaXplOiBudWxsLFxuICBpY29uOiBudWxsLFxuICBpY29uU2l6ZTogMjIsXG4gIGdldHRlcjogbnVsbCxcbiAgc2V0dGVyOiBudWxsLFxuICB2YWxpZGF0b3I6IG51bGwsXG4gIGNsZWFyRXJyb3JPblZhbGlkOiB0cnVlLFxuICBtYWtlUm9vbUZvckhlbHA6IHRydWVcbn07ZXhwb3J0IGRlZmF1bHQgZ2xvYmFsRGVmYXVsdHM7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7dXBkYXRlU2hvcnRoYW5kVmFsdWV9ZnJvbScuLi9oZWxwZXJzLmpzJztpbXBvcnQgZXh0ZW5kIGZyb20nc21hcnQtZXh0ZW5kJztpbXBvcnQgZmFzdGRvbSBmcm9tJ2Zhc3Rkb20nO2ltcG9ydCBDb25kaXRpb24gZnJvbScuLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0IHRyYW5zZm9ybVNldHRpbmdzIGZyb20nLi90cmFuc2Zvcm1TZXR0aW5ncy5qcyc7aW1wb3J0IGdsb2JhbERlZmF1bHRzIGZyb20nLi9nbG9iYWxEZWZhdWx0cy5qcyc7dmFyIEZpZWxkLCBjdXJyZW50SUQ7XG5jdXJyZW50SUQgPSAwO1xuXG5GaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBidWlsZGVyLCBzZXR0aW5nT3ZlcnJpZGVzLCB0ZW1wbGF0ZU92ZXJyaWRlcykge1xuICAgICAgdmFyIHJlZiwgc2hhbGxvd1NldHRpbmdzLCB0cmFuc2Zvcm1TZXR0aW5nc187XG4gICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuXG4gICAgICBpZiAoc2V0dGluZ092ZXJyaWRlcykge1xuICAgICAgICBpZiAoc2V0dGluZ092ZXJyaWRlcy5nbG9iYWxEZWZhdWx0cykge1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGVmYXVsdHMgPSBzZXR0aW5nT3ZlcnJpZGVzLmdsb2JhbERlZmF1bHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdPdmVycmlkZXNbc2V0dGluZ3MudHlwZV0pIHtcbiAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gc2V0dGluZ092ZXJyaWRlc1tzZXR0aW5ncy50eXBlXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGVtcGxhdGVPdmVycmlkZXMgJiYgdGVtcGxhdGVPdmVycmlkZXNbc2V0dGluZ3MudHlwZV0pIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMgPSB0ZW1wbGF0ZU92ZXJyaWRlc1tzZXR0aW5ncy50eXBlXTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlT3ZlcnJpZGVzW3NldHRpbmdzLnR5cGVdLmRlZmF1bHQ7XG4gICAgICB9XG5cbiAgICAgIHNoYWxsb3dTZXR0aW5ncyA9IHRoaXMuc2hhbGxvd1NldHRpbmdzID8gRmllbGQuc2hhbGxvd1NldHRpbmdzLmNvbmNhdCh0aGlzLnNoYWxsb3dTZXR0aW5ncykgOiBGaWVsZC5zaGFsbG93U2V0dGluZ3M7XG4gICAgICB0cmFuc2Zvcm1TZXR0aW5nc18gPSB0aGlzLnRyYW5zZm9ybVNldHRpbmdzID8gRmllbGQudHJhbnNmb3JtU2V0dGluZ3MuY29uY2F0KHRoaXMudHJhbnNmb3JtU2V0dGluZ3MpIDogRmllbGQudHJhbnNmb3JtU2V0dGluZ3M7XG4gICAgICB0aGlzLnNldHRpbmdzID0gZXh0ZW5kLmRlZXAuY2xvbmUubm90RGVlcChzaGFsbG93U2V0dGluZ3MpLnRyYW5zZm9ybSh0cmFuc2Zvcm1TZXR0aW5nc18pKHRoaXMuZ2xvYmFsRGVmYXVsdHMsIHRoaXMuZGVmYXVsdHMsIHNldHRpbmdzKTtcbiAgICAgIHRoaXMuSUQgPSB0aGlzLnNldHRpbmdzLklEIHx8IGN1cnJlbnRJRCsrICsgJyc7XG4gICAgICB0aGlzLnR5cGUgPSBzZXR0aW5ncy50eXBlO1xuICAgICAgdGhpcy5uYW1lID0gc2V0dGluZ3MubmFtZTtcbiAgICAgIHRoaXMuYWxsRmllbGRzID0gdGhpcy5zZXR0aW5ncy5maWVsZEluc3RhbmNlcyB8fCBGaWVsZC5pbnN0YW5jZXM7XG4gICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICB0aGlzLl9ldmVudENhbGxiYWNrcyA9IHt9O1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICBob3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJhY3RlZDogZmFsc2UsXG4gICAgICAgIGlzTW9iaWxlOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQ6IHRoaXMuc2V0dGluZ3MuZGlzYWJsZWQsXG4gICAgICAgIG1hcmdpbjogdGhpcy5zZXR0aW5ncy5tYXJnaW4sXG4gICAgICAgIHBhZGRpbmc6IHRoaXMuc2V0dGluZ3MucGFkZGluZyxcbiAgICAgICAgd2lkdGg6IHRoaXMuc2V0dGluZ3Mud2lkdGgsXG4gICAgICAgIHNob3dMYWJlbDogdGhpcy5zZXR0aW5ncy5sYWJlbCxcbiAgICAgICAgbGFiZWw6IHRoaXMuc2V0dGluZ3MubGFiZWwsXG4gICAgICAgIHNob3dIZWxwOiB0aGlzLnNldHRpbmdzLmhlbHAsXG4gICAgICAgIGhlbHA6IHRoaXMuc2V0dGluZ3MuaGVscCxcbiAgICAgICAgc2hvd0Vycm9yOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHRoaXMuc2V0dGluZ3MuZXJyb3JcbiAgICAgIH07XG5cbiAgICAgIGlmIChJUy5kZWZpbmVkKHRoaXMuc2V0dGluZ3MucGxhY2Vob2xkZXIpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucGxhY2Vob2xkZXIgPSB0aGlzLnNldHRpbmdzLnBsYWNlaG9sZGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoSVMubnVtYmVyKHRoaXMuc2V0dGluZ3Mud2lkdGgpICYmIHRoaXMuc2V0dGluZ3Mud2lkdGggPD0gMSkge1xuICAgICAgICB0aGlzLnN0YXRlLndpZHRoID0gYCR7dGhpcy5zZXR0aW5ncy53aWR0aCAqIDEwMH0lYDtcbiAgICAgIH1cblxuICAgICAgaWYgKChyZWYgPSB0aGlzLnNldHRpbmdzLmNvbmRpdGlvbnMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBDb25kaXRpb24uaW5pdCh0aGlzLCB0aGlzLnNldHRpbmdzLmNvbmRpdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hbGxGaWVsZHNbdGhpcy5JRF0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBmaWVsZCBJRHMgZm91bmQ6ICcke3RoaXMuSUR9J2ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsRmllbGRzW3RoaXMuSURdID0gdGhpcztcbiAgICB9XG5cbiAgICBfY29uc3RydWN0b3JFbmQoKSB7XG4gICAgICB2YXIgYmFzZSwgaGFuZGxlciwgcmVmLCB0YXJnZXQ7XG4gICAgICB0aGlzLmVsLmNoaWxkZjsgLy8uZmllbGQub24gJ2luc2VydGVkJywgKCk9PiBAZW1pdCgnaW5zZXJ0ZWQnKVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5JRCkge1xuICAgICAgICB0aGlzLmVsLnJhdy5pZCA9IHRoaXMuSUQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKChiYXNlID0gdGhpcy5zZXR0aW5ncykuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBiYXNlLmRlZmF1bHRWYWx1ZSA9IHRoaXMuc2V0dGluZ3MudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc2V0dGluZ3MubXVsdGlwbGUgPyBbXS5jb25jYXQodGhpcy5zZXR0aW5ncy5kZWZhdWx0VmFsdWUpIDogdGhpcy5zZXR0aW5ncy5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dFcnJvcicsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgfSkub2YodGhpcy5zdGF0ZSkudG8oJ2hlbHAnKS5vZih0aGlzLnN0YXRlKS50cmFuc2Zvcm0oc2hvdyA9PiB7XG4gICAgICAgIGlmIChzaG93ICYmIHRoaXMuc3RhdGUuZXJyb3IgJiYgSVMuc3RyaW5nKHRoaXMuc3RhdGUuZXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuaGVscCB8fCB0aGlzLnN0YXRlLmhlbHA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXJyb3InLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMuc3RhdGUpLnRvKCdoZWxwJykub2YodGhpcy5zdGF0ZSkuY29uZGl0aW9uKGVycm9yID0+IHtcbiAgICAgICAgcmV0dXJuIGVycm9yICYmIHRoaXMuc3RhdGUuc2hvd0Vycm9yO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdoZWxwJykub2YodGhpcy5zdGF0ZSkudG8oJ2h0bWwnKS5vZih0aGlzLmVsLmNoaWxkLmhlbHApLmFuZC50bygnc2hvd0hlbHAnKS5vZih0aGlzLnN0YXRlKTtcbiAgICAgIFNpbXBseUJpbmQoJ2xhYmVsJykub2YodGhpcy5zdGF0ZSkudG8oJ3RleHQnKS5vZih0aGlzLmVsLmNoaWxkLmxhYmVsKS5hbmQudG8oJ3Nob3dMYWJlbCcpLm9mKHRoaXMuc3RhdGUpO1xuICAgICAgU2ltcGx5QmluZCgnbWFyZ2luJykub2YodGhpcy5zdGF0ZSkudG8odGhpcy5lbC5zdHlsZS5iaW5kKHRoaXMuZWwsICdtYXJnaW4nKSk7XG4gICAgICBTaW1wbHlCaW5kKCdwYWRkaW5nJykub2YodGhpcy5zdGF0ZSkudG8odGhpcy5lbC5zdHlsZS5iaW5kKHRoaXMuZWwsICdwYWRkaW5nJykpO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0hlbHAnKS5vZih0aGlzLnN0YXRlKS50bygoc2hvdywgcHJldlNob3cpID0+IHtcbiAgICAgICAgdmFyIGNoYW5nZUFtb3VudDtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tYWtlUm9vbUZvckhlbHApIHtcbiAgICAgICAgICBjaGFuZ2VBbW91bnQgPSAhIXNob3cgPT09ICEhcHJldlNob3cgPyAwIDogc2hvdyA/IDI1IDogcHJldlNob3cgPyAtMjUgOiB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlQW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5tYXJnaW4gPSB1cGRhdGVTaG9ydGhhbmRWYWx1ZSh0aGlzLnN0YXRlLm1hcmdpbiwgJ2JvdHRvbScsIGNoYW5nZUFtb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2ZvY3VzZWQnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMuc3RhdGUpLnRvKGZvY3VzZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGZvY3VzZWQgPyAnZm9jdXMnIDogJ2JsdXInKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2JpbGVXaWR0aCkge1xuICAgICAgICBTaW1wbHlCaW5kKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZmFzdGRvbS5tZWFzdXJlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzTW9iaWxlID0gd2luZG93LmlubmVyV2lkdGggPD0gdGhpcy5zZXR0aW5ncy5tb2JpbGVUaHJlc2hvbGQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLnVwZGF0ZU9uKCdldmVudDpyZXNpemUnKS5vZih3aW5kb3cpO1xuICAgICAgfVxuXG4gICAgICBpZiAoSVMub2JqZWN0KHRoaXMuc2V0dGluZ3MuZXZlbnRzKSkge1xuICAgICAgICByZWYgPSB0aGlzLnNldHRpbmdzLmV2ZW50cztcblxuICAgICAgICBmb3IgKHRhcmdldCBpbiByZWYpIHtcbiAgICAgICAgICBoYW5kbGVyID0gcmVmW3RhcmdldF07XG4gICAgICAgICAgdGhpcy5vbih0YXJnZXQsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdCgnY3JlYXRlZCcsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuZWwucmF3Ll9xdWlja0ZpZWxkID0gdGhpcztcbiAgICB9XG5cbiAgICBfZm9ybWF0V2lkdGgod2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5zdGF0ZS5pc01vYmlsZSA/IHRoaXMuc2V0dGluZ3MubW9iaWxlV2lkdGggfHwgd2lkdGggOiB3aWR0aDtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGlzdGFuY2UgJiYgd2lkdGggIT09ICcxMDAlJykge1xuICAgICAgICB3aWR0aCA9IGBjYWxjKCR7d2lkdGh9IC0gJHt0aGlzLnNldHRpbmdzLmRpc3RhbmNlfXB4KWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG5cbiAgICBhcHBlbmRUbyh0YXJnZXQpIHtcbiAgICAgIHRoaXMuZWwuYXBwZW5kVG8odGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHByZXBlbmRUbyh0YXJnZXQpIHtcbiAgICAgIHRoaXMuZWwucHJlcGVuZFRvKHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnNlcnRBZnRlcih0YXJnZXQpIHtcbiAgICAgIHRoaXMuZWwuaW5zZXJ0QWZ0ZXIodGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGluc2VydEJlZm9yZSh0YXJnZXQpIHtcbiAgICAgIHRoaXMuZWwuaW5zZXJ0QmVmb3JlKHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkZXRhY2godGFyZ2V0KSB7XG4gICAgICB0aGlzLmVsLmRldGFjaCh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVtb3ZlKCkge1xuICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZmFsc2UpO1xuICAgIH1cblxuICAgIGRlc3Ryb3kocmVtb3ZlRnJvbURPTSA9IHRydWUpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByZWY7XG4gICAgICBTaW1wbHlCaW5kLnVuQmluZEFsbCh0aGlzKTtcbiAgICAgIFNpbXBseUJpbmQudW5CaW5kQWxsKHRoaXMuc3RhdGUpO1xuICAgICAgU2ltcGx5QmluZC51bkJpbmRBbGwodGhpcy5lbCk7XG4gICAgICByZWYgPSB0aGlzLmVsLmNoaWxkO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgIFNpbXBseUJpbmQudW5CaW5kQWxsKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZUZyb21ET00pIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgdGhpcy5hbGxGaWVsZHNbdGhpcy5JRF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvbihldmVudE5hbWVzLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgICAgdGhpcy5lbC5vbi5jYWxsKHRoaXMuZWwsIGV2ZW50TmFtZXMsIGNhbGxiYWNrLCB1c2VDYXB0dXJlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG9uY2UoZXZlbnROYW1lcywgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lcywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcy5lbCwgYXJndW1lbnRzKTtcbiAgICAgIH0sIHVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIG9mZigpIHtcbiAgICAgIHRoaXMuZWwub2ZmLmFwcGx5KHRoaXMuZWwsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbWl0KCkge1xuICAgICAgdGhpcy5lbC5lbWl0UHJpdmF0ZS5hcHBseSh0aGlzLmVsLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFsaWRhdGUocHJvdmlkZWRWYWx1ZSA9IHRoaXNbdGhpcy5jb3JlVmFsdWVQcm9wXSwgdGVzdFVucmVxdWlyZWQsIHJlcG9ydCkge1xuICAgICAgdmFyIGlzVmFsaWQ7XG5cbiAgICAgIGlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICBjYXNlICF0aGlzLnNldHRpbmdzLnZhbGlkYXRvcjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnZhbGlkYXRvcihwcm92aWRlZFZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgISghdGhpcy5zZXR0aW5ncy5yZXF1aXJlZCAmJiAhdGVzdFVucmVxdWlyZWQpOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBjYXNlIHRoaXMuX3ZhbGlkYXRlKHByb3ZpZGVkVmFsdWUsIHRlc3RVbnJlcXVpcmVkLCByZXBvcnQpICE9PSBmYWxzZTpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgIGNhc2UgIXRoaXMuc2V0dGluZ3MucmVxdWlyZWQ6XG4gICAgICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgIXRoaXMuc2V0dGluZ3MubXVsdGlwbGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHByb3ZpZGVkVmFsdWUgIT0gbnVsbCA/IHByb3ZpZGVkVmFsdWUubGVuZ3RoIDogdm9pZCAwKTtcblxuICAgICAgICAgICAgICBjYXNlIHR5cGVvZiBwcm92aWRlZFZhbHVlICE9PSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gISFwcm92aWRlZFZhbHVlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgIT0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0uY2FsbCh0aGlzKTtcblxuICAgICAgaWYgKGlzVmFsaWQgJiYgdGhpcy5zZXR0aW5ncy5jbGVhckVycm9yT25WYWxpZCkge1xuICAgICAgICB0aGlzLnN0YXRlLnNob3dFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUNvbmRpdGlvbnMoY29uZGl0aW9ucykge1xuICAgICAgdmFyIHBhc3NlZENvbmRpdGlvbnMsIHRvZ2dsZVZpc2liaWxpdHk7XG5cbiAgICAgIGlmIChjb25kaXRpb25zKSB7XG4gICAgICAgIHRvZ2dsZVZpc2liaWxpdHkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmRpdGlvbnMgPSB0aGlzLmNvbmRpdGlvbnM7XG4gICAgICAgIHRvZ2dsZVZpc2liaWxpdHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXNzZWRDb25kaXRpb25zID0gQ29uZGl0aW9uLnZhbGlkYXRlKGNvbmRpdGlvbnMpO1xuXG4gICAgICBpZiAodG9nZ2xlVmlzaWJpbGl0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS52aXNpYmxlID0gcGFzc2VkQ29uZGl0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXNzZWRDb25kaXRpb25zO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlQW5kUmVwb3J0KHByb3ZpZGVkVmFsdWUsIHRlc3RVbnJlcXVpcmVkKSB7XG4gICAgICB2YXIgaXNWYWxpZDtcbiAgICAgIGlzVmFsaWQgPSB0aGlzLnZhbGlkYXRlKHByb3ZpZGVkVmFsdWUsIHRlc3RVbnJlcXVpcmVkLCB0cnVlKTtcbiAgICAgIHRoaXMuc3RhdGUuc2hvd0Vycm9yID0gIWlzVmFsaWQ7XG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9XG5cbiAgfVxuICBGaWVsZC5pbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBGaWVsZC5zaGFsbG93U2V0dGluZ3MgPSBbJ3RlbXBsYXRlcycsICdmaWVsZEluc3RhbmNlcycsICd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcbiAgRmllbGQudHJhbnNmb3JtU2V0dGluZ3MgPSB0cmFuc2Zvcm1TZXR0aW5ncztcbiAgRmllbGQucHJvdG90eXBlLmdsb2JhbERlZmF1bHRzID0gZ2xvYmFsRGVmYXVsdHM7XG4gIEZpZWxkLnByb3RvdHlwZS5jb3JlVmFsdWVQcm9wID0gJ192YWx1ZSc7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpZWxkLnByb3RvdHlwZSwge1xuICAgICdyZW1vdmVMaXN0ZW5lcic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmY7XG4gICAgICB9XG4gICAgfSxcbiAgICAnZWxzJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ZhbHVlUmF3Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICd2YWx1ZSc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5nZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5nZXR0ZXIodGhpcy5fZ2V0VmFsdWUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5zZXR0ZXIgPyB0aGlzLnNldHRpbmdzLnNldHRlcih2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEZpZWxkO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbnZhciBGaWVsZCQxID0gRmllbGQ7ZXhwb3J0IGRlZmF1bHQgRmllbGQkMTsiLCJ2YXIga2V5Q29kZXM7XG52YXIgS0VZQ09ERVMgPSBrZXlDb2RlcyA9IHtcbiAgZGVsZXRlOiA4LFxuICBlbnRlcjogMTMsXG4gIGVzYzogMjcsXG4gIGN0cmw6IDE3LFxuICBhbHQ6IDE4LFxuICBzaGlmdDogMTYsXG4gIHN1cGVyOiA5MSxcbiAgc3VwZXIyOiA5MyxcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgaHlwaGVuOiA0NSxcbiAgdW5kZXJzY29yZTogOTUsXG4gIHF1ZXN0aW9uOiA2MyxcbiAgZXhjbGFtYXRpb246IDMzLFxuICBmcm9udHNsYXNoOiA0NyxcbiAgYmFja3NsYXNoOiA5MixcbiAgY29tbWE6IDQ0LFxuICBwZXJpb2Q6IDQ2LFxuICBzcGFjZTogMzIsXG4gIGFueUFycm93OiBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBrZXlDb2Rlcy51cCB8fCBjb2RlID09PSBrZXlDb2Rlcy5kb3duIHx8IGNvZGUgPT09IGtleUNvZGVzLmxlZnQgfHwgY29kZSA9PT0ga2V5Q29kZXMucmlnaHQ7XG4gIH0sXG4gIGFueU1vZGlmaWVyOiBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBrZXlDb2Rlcy5jdHJsIHx8IGNvZGUgPT09IGtleUNvZGVzLmFsdCB8fCBjb2RlID09PSBrZXlDb2Rlcy5zaGlmdCB8fCBjb2RlID09PSBrZXlDb2Rlcy5zdXBlciB8fCBjb2RlID09PSBrZXlDb2Rlcy5zdXBlcjI7XG4gIH0sXG4gIGFueUFscGhhOiBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiA5NyA8PSBjb2RlICYmIGNvZGUgPD0gMTIyIHx8IDY1IDw9IGNvZGUgJiYgY29kZSA8PSA5MDtcbiAgfSxcbiAgYW55TnVtZXJpYzogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gNDggPD0gY29kZSAmJiBjb2RlIDw9IDU3O1xuICB9LFxuICBhbnlBbHBoYU51bWVyaWM6IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmFueUFscGhhKGNvZGUpIHx8IGtleUNvZGVzLmFueU51bWVyaWMoY29kZSk7XG4gIH0sXG4gIGFueVByaW50YWJsZTogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuYW55QWxwaGEoY29kZSkgfHwga2V5Q29kZXMuYW55TnVtZXJpYyhjb2RlKSB8fCBjb2RlID09PSBrZXlDb2Rlcy5oeXBoZW4gfHwgY29kZSA9PT0ga2V5Q29kZXMudW5kZXJzY29yZSB8fCBjb2RlID09PSBrZXlDb2Rlcy5xdWVzdGlvbiB8fCBjb2RlID09PSBrZXlDb2Rlcy5leGNsYW1hdGlvbiB8fCBjb2RlID09PSBrZXlDb2Rlcy5mcm9udHNsYXNoIHx8IGNvZGUgPT09IGtleUNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBrZXlDb2Rlcy5jb21tYSB8fCBjb2RlID09PSBrZXlDb2Rlcy5wZXJpb2QgfHwgY29kZSA9PT0ga2V5Q29kZXMuc3BhY2U7XG4gIH1cbn07ZXhwb3J0IGRlZmF1bHQgS0VZQ09ERVM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJzt2YXIgY2hlY2ttYXJrID0gRE9NLnRlbXBsYXRlKFsnKnN2ZycsIHtcbiAgYXR0cnM6IHtcbiAgICB3aWR0aDogJzEycHgnLFxuICAgIGhlaWdodDogJzEycHgnLFxuICAgIHZpZXdCb3g6ICc1IDcgMTIgMTInLFxuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6ICc5cHgnLFxuICAgIGhlaWdodDogJzlweCdcbiAgfVxufSwgWycqcG9seWxpbmUnLCB7XG4gIGF0dHJzOiB7XG4gICAgJ3N0cm9rZS13aWR0aCc6ICcyJyxcbiAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLFxuICAgICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnLFxuICAgIGZpbGw6ICdub25lJyxcbiAgICBwb2ludHM6ICc3IDEzLjg4ODg4ODkgOS42NjY2NjY2NyAxNyAxNSA5JyxcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZVxuICB9XG59XV0pO2V4cG9ydCBkZWZhdWx0IGNoZWNrbWFyazsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO3ZhciBhbmdsZURvd24gPSBET00udGVtcGxhdGUoWycqc3ZnJywge1xuICBhdHRyczoge1xuICAgIHdpZHRoOiAnMTc5MnB4JyxcbiAgICBoZWlnaHQ6ICcxNzkycHgnLFxuICAgIHZpZXdCb3g6ICcwIDAgMTc5MiAxNzkyJyxcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZVxuICB9LFxuICBzdHlsZToge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3V0bGluZTogJ25vbmUnXG4gIH1cbn0sIFsnKnBhdGgnLCB7XG4gIGF0dHJzOiB7XG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2UsXG4gICAgZDogJ00xMzk1IDczNnEwIDEzLTEwIDIzbC00NjYgNDY2cS0xMCAxMC0yMyAxMHQtMjMtMTBsLTQ2Ni00NjZxLTEwLTEwLTEwLTIzdDEwLTIzbDUwLTUwcTEwLTEwIDIzLTEwdDIzIDEwbDM5MyAzOTMgMzkzLTM5M3ExMC0xMCAyMy0xMHQyMyAxMGw1MCA1MHExMCAxMCAxMCAyM3onXG4gIH1cbn1dXSk7ZXhwb3J0IGRlZmF1bHQgYW5nbGVEb3duOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7dmFyIGNhcmV0VXAgPSBET00udGVtcGxhdGUoWycqc3ZnJywge1xuICBhdHRyczoge1xuICAgIHZpZXdCb3g6ICcwIDAgNTEyIDUxMicsXG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2VcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIG91dGxpbmU6ICdub25lJ1xuICB9XG59LCBbJypwYXRoJywge1xuICBhdHRyczoge1xuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlLFxuICAgIGQ6ICdNNDAyIDM0N2MwIDUtMiAxMC01IDEzLTQgNC04IDYtMTMgNmgtMjU2Yy01IDAtOS0yLTEzLTYtMy0zLTUtOC01LTEzczItOSA1LTEybDEyOC0xMjhjNC00IDgtNiAxMy02czkgMiAxMyA2bDEyOCAxMjhjMyAzIDUgNyA1IDEyeidcbiAgfVxufV1dKTtleHBvcnQgZGVmYXVsdCBjYXJldFVwOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7dmFyIGNhcmV0RG93biA9IERPTS50ZW1wbGF0ZShbJypzdmcnLCB7XG4gIGF0dHJzOiB7XG4gICAgdmlld0JveDogJzAgMCA1MTIgNTEyJyxcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZVxuICB9LFxuICBzdHlsZToge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3V0bGluZTogJ25vbmUnXG4gIH1cbn0sIFsnKnBhdGgnLCB7XG4gIGF0dHJzOiB7XG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2UsXG4gICAgZDogJ000MDIgMjAxYzAgNS0yIDktNSAxM2wtMTI4IDEyOGMtNCA0LTggNS0xMyA1cy05LTEtMTMtNWwtMTI4LTEyOGMtMy00LTUtOC01LTEzczItOSA1LTEzYzQtMyA4LTUgMTMtNWgyNTZjNSAwIDkgMiAxMyA1IDMgNCA1IDggNSAxM3onXG4gIH1cbn1dXSk7ZXhwb3J0IGRlZmF1bHQgY2FyZXREb3duOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7dmFyIHBsdXMgPSBET00udGVtcGxhdGUoWycqc3ZnJywge1xuICBhdHRyczoge1xuICAgIHZpZXdCb3g6ICcwIDAgMTUgMTUnLFxuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBvdXRsaW5lOiAnbm9uZSdcbiAgfVxufSwgWycqcG9seWdvbicsIHtcbiAgYXR0cnM6IHtcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICBwb2ludHM6ICc5IDAgNiAwIDYgNiAwIDYgMCA5IDYgOSA2IDE1IDkgMTUgOSA5IDE1IDkgMTUgNiA5IDYnXG4gIH1cbn1dXSk7ZXhwb3J0IGRlZmF1bHQgcGx1czsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO3ZhciBjbG9uZSA9IERPTS50ZW1wbGF0ZShbJypzdmcnLCB7XG4gIGF0dHJzOiB7XG4gICAgdmlld0JveDogJzAgMCAxOCAyMCcsXG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2VcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIG91dGxpbmU6ICdub25lJ1xuICB9XG59LCBbJypwYXRoJywge1xuICBhdHRyczoge1xuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlLFxuICAgIGQ6ICdNMTMuNDE0LDAgTDYsMCBDNC44OTcsMCA0LDAuODk4IDQsMiBMNCwxNCBDNCwxNS4xMDMgNC44OTcsMTYgNiwxNiBMMTYsMTYgQzE3LjEwMywxNiAxOCwxNS4xMDMgMTgsMTQgTDE4LDQuNTg2IEwxMy40MTQsMCBaIE0xNi4wMDEsMTQgTDYsMTQgTDYsMiBMMTIsMiBMMTIsNiBMMTYsNiBMMTYuMDAxLDE0IFonXG4gIH1cbn1dLCBbJypwYXRoJywge1xuICBhdHRyczoge1xuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlLFxuICAgIGQ6ICdNMiw2LjQyMzc5MjgyIEwwLDYuNDIzNzkyODIgTDAsMTggQzAsMTkuMTAzIDAuODk3LDIwIDIsMjAgTDE0LDIwIEwxNCwxOCBMMiwxOCBMMiw2LjQyMzc5MjgyIFonXG4gIH1cbn1dXSk7ZXhwb3J0IGRlZmF1bHQgY2xvbmU7IiwiaW1wb3J0J3F1aWNrZG9tJztpbXBvcnQgcGx1cyBmcm9tJy4vcGx1cy5qcyc7dmFyIHJlbW92ZSA9IHBsdXMuZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIHN0eWxlOiB7XG4gICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoNDVkZWcpJ1xuICAgIH1cbiAgfVxufSk7ZXhwb3J0IGRlZmF1bHQgcmVtb3ZlOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IHtoZXhUb1JHQkF9ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQgY2hlY2ttYXJrIGZyb20nLi4vLi4vc3ZnL2NoZWNrbWFyay5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9hbmdsZURvd24uanMnO2ltcG9ydCBjYXJldFVwIGZyb20nLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCBjYXJldERvd24gZnJvbScuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJzt2YXIgdGVtcGxhdGUgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2Ryb3Bkb3duJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6IDEwLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICB0b3A6IGZ1bmN0aW9uIChkcm9wZG93bikge1xuICAgICAgaWYgKGRyb3Bkb3duLmZpZWxkLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucmF3LnN0eWxlLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnLTdweCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBsZWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQucmVjdC5sZWZ0IC0gNSA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTU7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgLy8gYmFja2dyb3VuZENvbG9yOiBoZXhUb1JHQkEoJ2Y2ZjZmNicsIDAuOSlcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjZmNmY2JyxcbiAgICBib3hTaGFkb3c6IGAwcHggNnB4IDEwcHggJHtoZXhUb1JHQkEoJzAwMDAwMCcsIDAuMzIpfWAsXG4gICAgYm9yZGVyV2lkdGg6ICcxcHgnLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgIGJvcmRlckNvbG9yOiAnI2QxZDFkMScsXG4gICAgYm9yZGVyUmFkaXVzOiAnNXB4JyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBwYWRkaW5nOiAnNHB4IDAnLFxuICAgICRpc09wZW46IHtcbiAgICAgICRoYXNWaXNpYmxlQ2hvaWNlczoge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICB9XG4gICAgfVxuICB9XG59XSk7XG52YXIgbGlzdCA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnbGlzdCcsXG4gIHBhc3NTdGF0ZVRvQ2hpbGRyZW46IGZhbHNlLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICBvdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJyxcbiAgICBvdmVyZmxvd1N0eWxlOiAnLW1zLWF1dG9oaWRpbmctc2Nyb2xsYmFyJ1xuICB9XG59XSk7XG52YXIgY2hvaWNlID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICBzdHlsZToge1xuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICBmb250U2l6ZTogJzAnLFxuICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgIGxpbmVIZWlnaHQ6ICcxZW0nLFxuICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICR2aXNpYmxlOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfSxcbiAgICAkdW5hdmFpbGFibGU6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0sXG4gICAgJGhvdmVyOiB7XG4gICAgICBjb2xvcjogJyNmZmZmZmYnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzRDOTZGRidcbiAgICB9XG4gIH1cbn0sIFsnZGl2JywgLy8gQ2hlY2ttYXJrXG57XG4gIHN0eWxlOiB7XG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgd2lkdGg6ICcyMHB4JyxcbiAgICAvLyBoZWlnaHQ6ICgpLT4gQHBhcmVudC5yYXcuc3R5bGUuaGVpZ2h0XG4gICAgLy8gbGluZUhlaWdodDogKCktPiBAcGFyZW50LnN0eWxlKCdoZWlnaHQnKVxuICAgIC8vIGZvbnRTaXplOiAoKS0+IEBwYXJlbnQuc3R5bGUoJ2hlaWdodCcpXG4gICAgbGluZUhlaWdodDogJzIwcHgnLFxuICAgIGZvbnRTaXplOiAnMTNweCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgJHNlbGVjdGVkOiB7XG4gICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICB9XG4gIH1cbn0sIGNoZWNrbWFya10sIFsnZGl2JywgLy8gVGV4dFxue1xuICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICBzdHlsZToge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgd29yZFdyYXA6ICdub3JtYWwnLFxuICAgIG1heFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYGNhbGMoMTAwJSAtICR7dGhpcy5wcmV2LnN0eWxlU2FmZSgnd2lkdGgnLCB0cnVlKX0pYDtcbiAgICB9LFxuICAgIHBhZGRpbmdSaWdodDogJzEwcHgnLFxuICAgIGxpbmVIZWlnaHQ6ICcyMHB4JyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIGZvbnRGYW1pbHk6IGZ1bmN0aW9uIChkcm9wZG93bikge1xuICAgICAgcmV0dXJuIGRyb3Bkb3duLnNldHRpbmdzLmZvbnRGYW1pbHk7XG4gICAgfSxcbiAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gIH1cbn1dXSk7XG52YXIgc2Nyb2xsSW5kaWNhdG9yVXAgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ3Njcm9sbEluZGljYXRvclVwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjZmNmY2JyxcbiAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgJHZpc2libGU6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzUwJScsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB3aWR0aDogJzE1cHgnLFxuICAgIGhlaWdodDogJzE1cHgnLFxuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgbWFyZ2luOiAnMCBhdXRvJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJ1xuICB9XG59LCBjYXJldFVwXV0pO1xudmFyIHNjcm9sbEluZGljYXRvckRvd24gPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ3Njcm9sbEluZGljYXRvckRvd24nLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzIwcHgnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJyNmNmY2ZjYnLFxuICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAkdmlzaWJsZToge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAnNTAlJyxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHdpZHRoOiAnMTVweCcsXG4gICAgaGVpZ2h0OiAnMTVweCcsXG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICBtYXJnaW46ICcwIGF1dG8nLFxuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTUwJSknXG4gIH1cbn0sIGNhcmV0RG93bl1dKTtcbnZhciBoZWxwID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdoZWxwJyxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgYm9yZGVyVG9wOiAnMnB4IHNvbGlkIHJnYmEoMCwwLDAsMC4wNSknLFxuICAgIHBhZGRpbmc6ICc0cHggMTJweCAxcHgnLFxuICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICBmb250V2VpZ2h0OiAnNTAwJyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAkc2hvd0hlbHA6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH1cbn1dKTt2YXIgdGVtcGxhdGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZhdWx0OiB0ZW1wbGF0ZSxsaXN0OiBsaXN0LGNob2ljZTogY2hvaWNlLHNjcm9sbEluZGljYXRvclVwOiBzY3JvbGxJbmRpY2F0b3JVcCxzY3JvbGxJbmRpY2F0b3JEb3duOiBzY3JvbGxJbmRpY2F0b3JEb3duLGhlbHA6IGhlbHB9KTtleHBvcnR7dGVtcGxhdGUkMSBhcyBhLHRlbXBsYXRlIGFzIGIsbGlzdCBhcyBjLGNob2ljZSBhcyBkLHNjcm9sbEluZGljYXRvclVwIGFzIGUsc2Nyb2xsSW5kaWNhdG9yRG93biBhcyBmLGhlbHAgYXMgZ307IiwidmFyIGRlZmF1bHRzID0ge1xuICBtYXhIZWlnaHQ6IDMwMCxcbiAgbXVsdGlwbGU6IGZhbHNlLFxuICBsb2NrU2Nyb2xsOiB0cnVlLFxuICB0eXBlQnVmZmVyOiBmYWxzZSxcbiAgaGVscDogJycsXG4gIHRlbXBsYXRlczoge31cbn07ZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vLi4vY2hlY2tzLmpzJztpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7cmVtb3ZlSXRlbSxub29wLGxvY2tTY3JvbGwsdW5sb2NrU2Nyb2xsLHN0YXJ0c1dpdGh9ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQgZXh0ZW5kIGZyb20nc21hcnQtZXh0ZW5kJztpbXBvcnQgQ29uZGl0aW9uIGZyb20nLi4vY29uZGl0aW9uLmpzJztpbXBvcnQgZ2xvYmFsRGVmYXVsdHMgZnJvbScuLi8uLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEtFWUNPREVTIGZyb20nLi4vLi4vY29uc3RhbnRzL2tleUNvZGVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NoZWNrbWFyay5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9hbmdsZURvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXRVcC5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldERvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvcGx1cy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jbG9uZS5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9yZW1vdmUuanMnO2ltcG9ydCB7YSBhcyB0ZW1wbGF0ZX1mcm9tJy4vdGVtcGxhdGUtYjk2MWY4MWYuanMnO2ltcG9ydCBkZWZhdWx0cyBmcm9tJy4vZGVmYXVsdHMuanMnO3ZhciBDaG9pY2UsIERyb3Bkb3duLCBMaXN0O1xuXG5Ecm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgRHJvcGRvd24ge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxDaG9pY2VzLCBmaWVsZCkge1xuICAgICAgdGhpcy5pbml0aWFsQ2hvaWNlcyA9IGluaXRpYWxDaG9pY2VzO1xuICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMudHlwZUJ1ZmZlciA9ICcnO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IGV4dGVuZC5kZWVwLmNsb25lLmZpbHRlcih0aGlzLl9zZXR0aW5nRmlsdGVycykoZ2xvYmFsRGVmYXVsdHMsIHRoaXMuZGVmYXVsdHMsIHRoaXMuZmllbGQuc2V0dGluZ3MuZHJvcGRvd24pO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2V0dGluZ3MubXVsdGlwbGUgPyBbXSA6IG51bGw7XG4gICAgICB0aGlzLmxhc3RTZWxlY3RlZCA9IG51bGw7XG4gICAgICB0aGlzLmNob2ljZXMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudEhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgIHRoaXMudmlzaWJsZUNob2ljZXNDb3VudCA9IDA7XG4gICAgICB0aGlzLnZpc2libGVDaG9pY2VzID0gW107XG4gICAgICB0aGlzLmVscyA9IHt9O1xuICAgICAgdGhpcy5fc2VsZWN0ZWRDYWxsYmFjayA9IG5vb3A7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBjaG9pY2UsIGdsb2JhbE9wdHMsIGksIGxlbiwgcmVmO1xuICAgICAgZ2xvYmFsT3B0cyA9IHtcbiAgICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzXG4gICAgICB9O1xuICAgICAgdGhpcy5lbHMuY29udGFpbmVyID0gdGhpcy50ZW1wbGF0ZS5kZWZhdWx0LnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmRlZmF1bHQsIGV4dGVuZCh7XG4gICAgICAgIHBhc3NTdGF0ZVRvQ2hpbGRyZW46IGZhbHNlXG4gICAgICB9LCBnbG9iYWxPcHRzKSk7XG4gICAgICB0aGlzLmVscy5saXN0ID0gdGhpcy50ZW1wbGF0ZS5saXN0LnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmxpc3QsIGdsb2JhbE9wdHMpLmFwcGVuZFRvKHRoaXMuZWxzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVscy5oZWxwID0gdGhpcy50ZW1wbGF0ZS5oZWxwLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmhlbHAsIGdsb2JhbE9wdHMpLmFwcGVuZFRvKHRoaXMuZWxzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JVcCA9IHRoaXMudGVtcGxhdGUuc2Nyb2xsSW5kaWNhdG9yVXAuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuc2Nyb2xsSW5kaWNhdG9yVXAsIGdsb2JhbE9wdHMpLmFwcGVuZFRvKHRoaXMuZWxzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duID0gdGhpcy50ZW1wbGF0ZS5zY3JvbGxJbmRpY2F0b3JEb3duLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLnNjcm9sbEluZGljYXRvckRvd24sIGdsb2JhbE9wdHMpLmFwcGVuZFRvKHRoaXMuZWxzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmxpc3QgPSBuZXcgTGlzdCh0aGlzKTtcbiAgICAgIHJlZiA9IHRoaXMuaW5pdGlhbENob2ljZXM7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjaG9pY2UgPSByZWZbaV07XG4gICAgICAgIHRoaXMuYWRkQ2hvaWNlKGNob2ljZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hCaW5kaW5nc19zY3JvbGxJbmRpY2F0b3JzKCk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdoZWxwJykub2YodGhpcy5zZXR0aW5ncykudG8oJ3RleHQnKS5vZih0aGlzLmVscy5oZWxwKS5hbmQudG8oc2hvd0hlbHAgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHMuaGVscC5zdGF0ZSgnc2hvd0hlbHAnLCBzaG93SGVscCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Zpc2libGVDaG9pY2VzQ291bnQnKS5vZih0aGlzKS50byhjb3VudCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVscy5jb250YWluZXIuc3RhdGUoJ2hhc1Zpc2libGVDaG9pY2VzJywgISFjb3VudCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaW1wbHlCaW5kKCdjdXJyZW50SGlnaGxpZ2h0ZWQnKS5vZih0aGlzKS50bygoY3VycmVudCwgcHJldikgPT4ge1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIHByZXYuZWwuc3RhdGUoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudC5lbC5zdGF0ZSgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdpc09wZW4nLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMpLnRvKGlzT3BlbiA9PiB7XG4gICAgICAgIHRoaXMuZWxzLmNvbnRhaW5lci5zdGF0ZSgnaXNPcGVuJywgaXNPcGVuKTtcblxuICAgICAgICBpZiAoIWlzT3Blbikge1xuICAgICAgICAgIHRoaXMuY3VycmVudEhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmxvY2tTY3JvbGwpIHtcbiAgICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICBsb2NrU2Nyb2xsKHRoaXMuZWxzLmxpc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmxvY2tTY3JvbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgdGhpcy5saXN0LmFwcGVuZENob2ljZXMoKTtcbiAgICAgICAgICB0aGlzLmxpc3QuY2FsY0Rpc3BsYXkoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkICYmICF0aGlzLnNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0LnNjcm9sbFRvQ2hvaWNlKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0LnNldFRyYW5zbGF0ZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdsYXN0U2VsZWN0ZWQnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2UsXG4gICAgICAgIHVwZGF0ZUV2ZW5JZlNhbWU6IHRydWVcbiAgICAgIH0pLm9mKHRoaXMpLnRvKChuZXdDaG9pY2UsIHByZXZDaG9pY2UpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2FsbGJhY2sobmV3Q2hvaWNlLCBwcmV2Q2hvaWNlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZm9jdXNlZCcsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgfSkub2YodGhpcy5maWVsZC5zdGF0ZSkudG8oZm9jdXNlZCA9PiB7XG4gICAgICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLmVsLmNoaWxkLmlucHV0Lm9mZigna2V5ZG93bi5kcm9wZG93bk5hdicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLmVsLmNoaWxkLmlucHV0Lm9uKCdrZXlkb3duLmRyb3Bkb3duTmF2JywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZQ09ERVMudXA6XG4gICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0UHJldigpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBLRVlDT0RFUy5kb3duOlxuICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodE5leHQoKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgS0VZQ09ERVMuZW50ZXI6XG4gICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlbGVjdGVkID0gdGhpcy5jdXJyZW50SGlnaGxpZ2h0ZWQ7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBLRVlDT0RFUy5lc2M6XG4gICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy50eXBlQnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgU2ltcGx5QmluZCgnZm9jdXNlZCcsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgfSkub2YodGhpcy5maWVsZC5zdGF0ZSkudG8oZm9jdXNlZCA9PiB7XG4gICAgICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgICAgIHJldHVybiBET00oZG9jdW1lbnQpLm9mZigna2V5cHJlc3MuZHJvcGRvd25UeXBlQnVmZmVyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIERPTShkb2N1bWVudCkub24oJ2tleXByZXNzLmRyb3Bkb3duVHlwZUJ1ZmZlcicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgIGlmICghS0VZQ09ERVMuYW55UHJpbnRhYmxlKGV2ZW50LmtleUNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZUJ1ZmZlciArPSBldmVudC5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFNpbXBseUJpbmQoJ3R5cGVCdWZmZXInLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMpLnRvKCgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHlwZUJ1ZmZlclRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlQnVmZmVyVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnR5cGVCdWZmZXIgPSAnJztcbiAgICAgICAgfSwgMTUwMCk7XG4gICAgICB9KS5hbmQudG8oYnVmZmVyID0+IHtcbiAgICAgICAgdmFyIGNob2ljZSwgaSwgbGVuLCByZWY7XG5cbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgIHJlZiA9IHRoaXMudmlzaWJsZUNob2ljZXM7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNob2ljZSA9IHJlZltpXTtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgoYnVmZmVyLCBjaG9pY2UubGFiZWwpKSB7XG4gICAgICAgICAgICAgIHRoaXMuY3VycmVudEhpZ2hsaWdodGVkID0gY2hvaWNlO1xuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5saXN0LmNob2ljZUluVmlldyhjaG9pY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvQ2hvaWNlKGNob2ljZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3Nfc2Nyb2xsSW5kaWNhdG9ycygpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3Njcm9sbFRvcCcsIHtcbiAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZVxuICAgICAgfSkub2YodGhpcy5lbHMubGlzdC5yYXcpLnRvKHNjcm9sbFRvcCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVTY3JvbGxJbmRpY2F0b3JWaXNpYmlsaXR5KCk7XG4gICAgICB9KS5jb25kaXRpb24oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09wZW4gJiYgIXRoaXMuc2V0dGluZ3MuaGVscCAmJiB0aGlzLmVscy5saXN0LnJhdy5zY3JvbGxIZWlnaHQgIT09IHRoaXMuZWxzLmxpc3QucmF3LmNsaWVudEhlaWdodCAmJiB0aGlzLmVscy5saXN0LnJhdy5jbGllbnRIZWlnaHQgPj0gMTAwO1xuICAgICAgfSkudXBkYXRlT24oJ2V2ZW50OnNjcm9sbCcpLm9mKHRoaXMuZWxzLmxpc3QucmF3KS51cGRhdGVPbignaXNPcGVuJykub2YodGhpcyk7XG4gICAgICB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JVcC5vbignbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5zdGFydFNjcm9sbGluZygndXAnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbHMuc2Nyb2xsSW5kaWNhdG9yVXAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3Quc3RvcFNjcm9sbGluZygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLm9uKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LnN0YXJ0U2Nyb2xsaW5nKCdkb3duJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LnN0b3BTY3JvbGxpbmcoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF91cGRhdGVTY3JvbGxJbmRpY2F0b3JWaXNpYmlsaXR5KCkge1xuICAgICAgdmFyIHNjcm9sbFRvcCwgc2hvd0JvdHRvbUluZGljYXRvciwgc2hvd1RvcEluZGljYXRvcjtcbiAgICAgIHNjcm9sbFRvcCA9IHRoaXMuZWxzLmxpc3QucmF3O1xuICAgICAgc2hvd1RvcEluZGljYXRvciA9IHNjcm9sbFRvcCA+IDA7XG4gICAgICBzaG93Qm90dG9tSW5kaWNhdG9yID0gdGhpcy5lbHMubGlzdC5yYXcuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5lbHMubGlzdC5yYXcuY2xpZW50SGVpZ2h0ID4gc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5lbHMuc2Nyb2xsSW5kaWNhdG9yVXAuc3RhdGUoJ3Zpc2libGUnLCBzaG93VG9wSW5kaWNhdG9yKTtcbiAgICAgIHJldHVybiB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLnN0YXRlKCd2aXNpYmxlJywgc2hvd0JvdHRvbUluZGljYXRvcik7XG4gICAgfVxuXG4gICAgYWRkQ2hvaWNlKGNvbmZpZykge1xuICAgICAgdmFyIGksIGl0ZW0sIGxlbiwgbmV3Q2hvaWNlO1xuXG4gICAgICBpZiAoSVMuYXJyYXkoY29uZmlnKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gY29uZmlnW2ldO1xuICAgICAgICAgIHRoaXMuYWRkQ2hvaWNlKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChJUy5zdHJpbmcoY29uZmlnKSkge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgbGFiZWw6IGNvbmZpZyxcbiAgICAgICAgICB2YWx1ZTogY29uZmlnXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKElTLm9iamVjdFBsYWluKGNvbmZpZykpIHtcbiAgICAgICAgaWYgKGNvbmZpZy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgY29uZmlnLnZhbHVlID0gY29uZmlnLmxhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5sYWJlbCA9PSBudWxsKSB7XG4gICAgICAgICAgY29uZmlnLmxhYmVsID0gY29uZmlnLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5ld0Nob2ljZSA9IG5ldyBDaG9pY2UodGhpcywgY29uZmlnLCB0aGlzLmxpc3QsIHRoaXMuY2hvaWNlcy5sZW5ndGgpO1xuXG4gICAgICBpZiAodGhpcy5saXN0LmFwcGVuZGVkQ2hvaWNlcykge1xuICAgICAgICBuZXdDaG9pY2UuaW5pdCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNob2ljZXMucHVzaChuZXdDaG9pY2UpO1xuICAgICAgcmV0dXJuIG5ld0Nob2ljZTtcbiAgICB9XG5cbiAgICByZW1vdmVDaG9pY2UoY2hvaWNlKSB7XG4gICAgICB2YXIgaSwgaXRlbSwgbGVuO1xuXG4gICAgICBpZiAoSVMuYXJyYXkoY2hvaWNlKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaG9pY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gY2hvaWNlW2ldO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2hvaWNlKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hvaWNlID0gdGhpcy5maW5kQ2hvaWNlQW55KGNob2ljZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2hvaWNlLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuY2hvaWNlcy5zcGxpY2UodGhpcy5jaG9pY2VzLmluZGV4T2YoY2hvaWNlKSwgMSk7XG4gICAgfVxuXG4gICAgcmVwbGFjZUNob2ljZXMobmV3Q2hvaWNlcykge1xuICAgICAgdGhpcy5yZW1vdmVDaG9pY2UodGhpcy5jaG9pY2VzLnNsaWNlKCkpO1xuICAgICAgdGhpcy5hZGRDaG9pY2UobmV3Q2hvaWNlcyk7XG4gICAgfVxuXG4gICAgYXBwZW5kVG8odGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbHMuY29udGFpbmVyLmFwcGVuZFRvKHRhcmdldCk7XG4gICAgfVxuXG4gICAgb25TZWxlY3RlZChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmaW5kQ2hvaWNlKHByb3ZpZGVkVmFsdWUsIGJ5TGFiZWwpIHtcbiAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgbWF0Y2hlcyA9IHRoaXMuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhSVMub2JqZWN0KHByb3ZpZGVkVmFsdWUpOlxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPT09IGNob2ljZTtcblxuICAgICAgICAgIGNhc2UgIWJ5TGFiZWw6XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZWRWYWx1ZSA9PT0gY2hvaWNlLmxhYmVsO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlZFZhbHVlID09PSBjaG9pY2UudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgZmluZENob2ljZUFueShwcm92aWRlZFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kQ2hvaWNlKHByb3ZpZGVkVmFsdWUpIHx8IHRoaXMuZmluZENob2ljZShwcm92aWRlZFZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBoaWdobGlnaHRQcmV2KCkge1xuICAgICAgdmFyIGNob2ljZSwgY3VycmVudEluZGV4O1xuICAgICAgY3VycmVudEluZGV4ID0gdGhpcy52aXNpYmxlQ2hvaWNlcy5pbmRleE9mKHRoaXMuY3VycmVudEhpZ2hsaWdodGVkKTtcblxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SGlnaGxpZ2h0ZWQgPSBjaG9pY2UgPSB0aGlzLnZpc2libGVDaG9pY2VzW2N1cnJlbnRJbmRleCAtIDFdO1xuXG4gICAgICAgIGlmICghdGhpcy5saXN0LmNob2ljZUluVmlldyhjaG9pY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5zY3JvbGxVcChjaG9pY2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRIaWdobGlnaHRlZCA9IGNob2ljZSA9IHRoaXMudmlzaWJsZUNob2ljZXNbdGhpcy52aXNpYmxlQ2hvaWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoIXRoaXMubGlzdC5jaG9pY2VJblZpZXcoY2hvaWNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Quc2Nyb2xsVG9DaG9pY2UoY2hvaWNlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGhpZ2hsaWdodE5leHQoKSB7XG4gICAgICB2YXIgY2hvaWNlLCBjdXJyZW50SW5kZXg7XG4gICAgICBjdXJyZW50SW5kZXggPSB0aGlzLnZpc2libGVDaG9pY2VzLmluZGV4T2YodGhpcy5jdXJyZW50SGlnaGxpZ2h0ZWQpO1xuXG4gICAgICBpZiAoY3VycmVudEluZGV4IDwgdGhpcy52aXNpYmxlQ2hvaWNlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEhpZ2hsaWdodGVkID0gY2hvaWNlID0gdGhpcy52aXNpYmxlQ2hvaWNlc1tjdXJyZW50SW5kZXggKyAxXTtcblxuICAgICAgICBpZiAoIXRoaXMubGlzdC5jaG9pY2VJblZpZXcoY2hvaWNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Quc2Nyb2xsRG93bihjaG9pY2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRIaWdobGlnaHRlZCA9IGNob2ljZSA9IHRoaXMudmlzaWJsZUNob2ljZXNbMF07XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3QuY2hvaWNlSW5WaWV3KGNob2ljZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0LnNjcm9sbFRvQ2hvaWNlKGNob2ljZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuICBEcm9wZG93bi5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgRHJvcGRvd24ucHJvdG90eXBlLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIERyb3Bkb3duLnByb3RvdHlwZS5fc2V0dGluZ0ZpbHRlcnMgPSB7XG4gICAgbWF4SGVpZ2h0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBJUy5udW1iZXIodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIERyb3Bkb3duO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbkxpc3QgPSBjbGFzcyBMaXN0IHtcbiAgY29uc3RydWN0b3IoZHJvcGRvd24pIHtcbiAgICB0aGlzLmNob2ljZUluVmlldyA9IHRoaXMuY2hvaWNlSW5WaWV3LmJpbmQodGhpcyk7XG4gICAgdGhpcy5kcm9wZG93biA9IGRyb3Bkb3duO1xuICAgICh7XG4gICAgICBlbHM6IHRoaXMuZWxzLFxuICAgICAgZmllbGQ6IHRoaXMuZmllbGQsXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5nc1xuICAgIH0gPSB0aGlzLmRyb3Bkb3duKTtcbiAgICB0aGlzLmVsID0gdGhpcy5lbHMubGlzdDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWxzLmNvbnRhaW5lcjtcbiAgICB0aGlzLmFwcGVuZGVkQ2hvaWNlcyA9IGZhbHNlO1xuICB9XG5cbiAgYXBwZW5kQ2hvaWNlcygpIHtcbiAgICB2YXIgY2hvaWNlLCBpLCBsZW4sIHJlZjtcblxuICAgIGlmICh0aGlzLmFwcGVuZGVkQ2hvaWNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZiA9IHRoaXMuZHJvcGRvd24uY2hvaWNlcztcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2hvaWNlID0gcmVmW2ldO1xuICAgICAgY2hvaWNlLmluaXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBlbmRlZENob2ljZXMgPSB0cnVlO1xuICB9XG5cbiAgY2FsY0Rpc3BsYXkoKSB7XG4gICAgdmFyIGJvdHRvbUN1dG9mZiwgY2xpcHBpbmdQYXJlbnQsIGNsaXBwaW5nUmVjdCwgY3V0b2ZmLCBoZWlnaHQsIGlzQm90dG9tQ3V0b2ZmLCBpc1RvcEN1dG9mZiwgbmVlZHNOZXdIZWlnaHQsIHBhZGRpbmcsIHNjcm9sbEhlaWdodCwgc2VsZlJlY3QsIHRvcEN1dG9mZiwgdHJhbnNsYXRpb24sIHdpbmRvd0N1dG9mZiwgd2luZG93SGVpZ2h0O1xuICAgIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB0cmFuc2xhdGlvbiA9IHRoaXMudHJhbnNsYXRpb24gfHwgMDtcbiAgICBjbGlwcGluZ1BhcmVudCA9IHRoaXMuY29udGFpbmVyLnBhcmVudE1hdGNoaW5nKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgIG92ZXJmbG93ID0gcGFyZW50LnN0eWxlKCdvdmVyZmxvd1knKTtcbiAgICAgIHJldHVybiBvdmVyZmxvdyA9PT0gJ2hpZGRlbicgfHwgb3ZlcmZsb3cgPT09ICdzY3JvbGwnO1xuICAgIH0pO1xuICAgIHNjcm9sbEhlaWdodCA9IHRoaXMuZWwucmF3LnNjcm9sbEhlaWdodCB8fCAyZTMwODtcbiAgICBzZWxmUmVjdCA9IGV4dGVuZC5jbG9uZSh0aGlzLmNvbnRhaW5lci5yZWN0KTtcbiAgICBwYWRkaW5nID0gc2VsZlJlY3QuaGVpZ2h0IC0gdGhpcy5lbC5oZWlnaHQ7XG4gICAgaGVpZ2h0ID0gTWF0aC5taW4oc2Nyb2xsSGVpZ2h0LCB0aGlzLnNldHRpbmdzLm1heEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IC0gNDApO1xuICAgIHNlbGZSZWN0LmJvdHRvbSA9IHNlbGZSZWN0LnRvcCArIGhlaWdodDtcblxuICAgIGlmIChjbGlwcGluZ1BhcmVudCkge1xuICAgICAgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnQucmVjdDtcbiAgICAgIGJvdHRvbUN1dG9mZiA9IHNlbGZSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC5ib3R0b207XG4gICAgICB0b3BDdXRvZmYgPSBjbGlwcGluZ1JlY3QudG9wIC0gc2VsZlJlY3QudG9wO1xuICAgICAgaXNCb3R0b21DdXRvZmYgPSBib3R0b21DdXRvZmYgPiAwO1xuICAgICAgaXNUb3BDdXRvZmYgPSB0b3BDdXRvZmYgPiAwO1xuXG4gICAgICBpZiAoc2VsZlJlY3QudG9wID49IGNsaXBwaW5nUmVjdC5ib3R0b20gfHwgY2xpcHBpbmdSZWN0LnRvcCA+PSBzZWxmUmVjdC5ib3R0b20pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBUaGUgZHJvcGRvd24gZm9yIGVsZW1lbnQgJyR7dGhpcy5maWVsZC5JRH0nIGNhbm5vdCBiZSBkaXNwbGF5ZWQgYXMgaXQncyBoaWRkZW4gYnkgdGhlIHBhcmVudCBvdmVyZmxvd2ApO1xuICAgICAgfSBlbHNlIGlmIChpc0JvdHRvbUN1dG9mZiB8fCBpc1RvcEN1dG9mZikge1xuICAgICAgICBuZWVkc05ld0hlaWdodCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHNlbGZSZWN0LnRvcCAtIGJvdHRvbUN1dG9mZiA+IGNsaXBwaW5nUmVjdC50b3AgJiYgIWlzVG9wQ3V0b2ZmKSB7XG4gICAgICAgICAgdHJhbnNsYXRpb24gPSBib3R0b21DdXRvZmY7XG4gICAgICAgICAgc2VsZlJlY3QudG9wIC09IHRyYW5zbGF0aW9uO1xuICAgICAgICAgIHNlbGZSZWN0LmJvdHRvbSAtPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgICBjdXRvZmYgPSBjbGlwcGluZ1JlY3QudG9wIC0gc2VsZlJlY3QudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGZSZWN0LmJvdHRvbSAtIHRvcEN1dG9mZiA8IGNsaXBwaW5nUmVjdC5ib3R0b20pIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbiA9IHRvcEN1dG9mZiAqIC0xO1xuICAgICAgICAgIHNlbGZSZWN0LnRvcCArPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgICBzZWxmUmVjdC5ib3R0b20gKz0gdHJhbnNsYXRpb247XG4gICAgICAgICAgY3V0b2ZmID0gc2VsZlJlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc05ld0hlaWdodCA9IGN1dG9mZiA+IDApIHtcbiAgICAgICAgICBoZWlnaHQgPSBjdXRvZmYgLSBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93Q3V0b2ZmID0gc2VsZlJlY3QudG9wICsgaGVpZ2h0IC0gd2luZG93SGVpZ2h0O1xuXG4gICAgaWYgKHdpbmRvd0N1dG9mZiA+IDAgJiYgaGVpZ2h0IDwgd2luZG93SGVpZ2h0KSB7XG4gICAgICB0cmFuc2xhdGlvbiArPSB3aW5kb3dDdXRvZmYgKyAxMDtcbiAgICB9XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoaGVpZ2h0LCB0aGlzLmZpZWxkLmVsLmNoaWxkLmlubmVyd3JhcC53aWR0aCArIDEwKTtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFuc2xhdGUodHJhbnNsYXRpb24pO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucyhoZWlnaHQsIHdpZHRoKSB7XG4gICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmVsLnN0eWxlKCdtYXhIZWlnaHQnLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbC5zdHlsZSgnbWluV2lkdGgnLCB3aWR0aCk7XG4gICAgfVxuICB9XG5cbiAgc2V0VHJhbnNsYXRlKHRyYW5zbGF0aW9uKSB7XG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xuICAgIHRyYW5zbGF0aW9uICo9IC0xO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5zdHlsZSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVkoJHt0cmFuc2xhdGlvbn1weClgKTtcbiAgfVxuXG4gIHNjcm9sbFRvQ2hvaWNlKGNob2ljZSwgb2Zmc2V0ID0gMykge1xuICAgIHZhciBkaXN0YW5lRnJvbVRvcCwgc2VsZWN0ZWRIZWlnaHQ7XG4gICAgZGlzdGFuZUZyb21Ub3AgPSBjaG9pY2UuZWwucmF3Lm9mZnNldFRvcDtcbiAgICBzZWxlY3RlZEhlaWdodCA9IGNob2ljZS5lbC5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZWwucmF3LnNjcm9sbFRvcCA9IGRpc3RhbmVGcm9tVG9wIC0gc2VsZWN0ZWRIZWlnaHQgKiBvZmZzZXQ7XG4gIH1cblxuICBzY3JvbGxEb3duKGNob2ljZSkge1xuICAgIHJldHVybiB0aGlzLmVsLnJhdy5zY3JvbGxUb3AgKz0gY2hvaWNlLmVsLmhlaWdodDtcbiAgfVxuXG4gIHNjcm9sbFVwKGNob2ljZSkge1xuICAgIHJldHVybiB0aGlzLmVsLnJhdy5zY3JvbGxUb3AgLT0gY2hvaWNlLmVsLmhlaWdodDtcbiAgfVxuXG4gIGNob2ljZUluVmlldyhjaG9pY2UpIHtcbiAgICB2YXIgY2hvaWNlUmVjdCwgZG93blBhZGRpbmcsIGxpc3RSZWN0LCB1cFBhZGRpbmc7XG4gICAgY2hvaWNlUmVjdCA9IGNob2ljZS5lbC5yZWN0O1xuICAgIGxpc3RSZWN0ID0gdGhpcy5lbC5yZWN0O1xuICAgIHVwUGFkZGluZyA9IHRoaXMuZWxzLnNjcm9sbEluZGljYXRvclVwLnN0YXRlKCd2aXNpYmxlJykgPyBwYXJzZUZsb2F0KHRoaXMuZWxzLnNjcm9sbEluZGljYXRvclVwLnN0eWxlU2FmZSgnaGVpZ2h0JywgdHJ1ZSkpIDogdm9pZCAwO1xuICAgIGRvd25QYWRkaW5nID0gdGhpcy5lbHMuc2Nyb2xsSW5kaWNhdG9yRG93bi5zdGF0ZSgndmlzaWJsZScpID8gcGFyc2VGbG9hdCh0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLnN0eWxlU2FmZSgnaGVpZ2h0JywgdHJ1ZSkpIDogdm9pZCAwO1xuICAgIHJldHVybiBjaG9pY2VSZWN0LmJvdHRvbSA8PSBsaXN0UmVjdC5ib3R0b20gLSBkb3duUGFkZGluZyAmJiBjaG9pY2VSZWN0LnRvcCA+PSBsaXN0UmVjdC50b3AgKyB1cFBhZGRpbmc7XG4gIH1cblxuICBzdGFydFNjcm9sbGluZyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZWwucmF3LnNjcm9sbFRvcCArPSBkaXJlY3Rpb24gPT09ICd1cCcgPyAtMjAgOiAyMDtcbiAgICB9LCA1MCk7XG4gIH1cblxuICBzdG9wU2Nyb2xsaW5nKCkge1xuICAgIHJldHVybiBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJRCk7XG4gIH1cblxufTtcbkNob2ljZSA9IGNsYXNzIENob2ljZSB7XG4gIGNvbnN0cnVjdG9yKGRyb3Bkb3duLCBzZXR0aW5ncywgbGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgcmVmO1xuICAgIHRoaXMuZHJvcGRvd24gPSBkcm9wZG93bjtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgKHtcbiAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICBjb25kaXRpb25zOiB0aGlzLmNvbmRpdGlvbnNcbiAgICB9ID0gdGhpcy5zZXR0aW5ncyk7XG5cbiAgICBpZiAodGhpcy5sYWJlbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmxhYmVsID0gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5sYWJlbDtcbiAgICB9XG5cbiAgICB0aGlzLmZpZWxkID0gdGhpcy5kcm9wZG93bi5maWVsZDtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgaWYgKChyZWYgPSB0aGlzLmNvbmRpdGlvbnMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICB0aGlzLnVuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWxsRmllbGRzID0gdGhpcy5maWVsZC5hbGxGaWVsZHM7XG4gICAgICBDb25kaXRpb24uaW5pdCh0aGlzLCB0aGlzLmNvbmRpdGlvbnMsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hdmFpbGFibGUgPSAhQ29uZGl0aW9uLnZhbGlkYXRlKHRoaXMuY29uZGl0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5lbCA9IHRoaXMuZHJvcGRvd24udGVtcGxhdGUuY2hvaWNlLnNwYXduKG51bGwsIHtcbiAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpcy5kcm9wZG93blxuICAgIH0pO1xuICAgIHRoaXMuZWwuY2hpbGRyZW5bMV0udGV4dCA9IHRoaXMubGFiZWw7XG4gICAgdGhpcy5lbC5hcHBlbmRUbyh0aGlzLmxpc3QuZWwpO1xuICAgIHJldHVybiB0aGlzLl9hdHRhY2hCaW5kaW5ncygpO1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsLnJlbW92ZSgpO1xuICB9XG5cbiAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgIHJldHVybiAoKCkgPT4ge1xuICAgICAgU2ltcGx5QmluZCgndmlzaWJsZScpLm9mKHRoaXMpLnRvKCh2aXNpYmxlLCBwcmV2KSA9PiB7XG4gICAgICAgIHRoaXMuZHJvcGRvd24udmlzaWJsZUNob2ljZXNDb3VudCArPSB2aXNpYmxlID8gMSA6IC0xO1xuICAgICAgICB0aGlzLmVsLnN0YXRlKCd2aXNpYmxlJywgdmlzaWJsZSk7XG5cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICB0aGlzLmRyb3Bkb3duLnZpc2libGVDaG9pY2VzLnB1c2godGhpcyk7XG5cbiAgICAgICAgICBpZiAoSVMuZGVmaW5lZChwcmV2KSkge1xuICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHN0YXRlIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi52aXNpYmxlQ2hvaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbSh0aGlzLmRyb3Bkb3duLnZpc2libGVDaG9pY2VzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzZWxlY3RlZCcpLm9mKHRoaXMpLnRvKHNlbGVjdGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCd1bmF2YWlsYWJsZScpLm9mKHRoaXMpLnRvKHVuYXZhaWxhYmxlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3VuYXZhaWxhYmxlJywgdW5hdmFpbGFibGUpO1xuICAgICAgfSkuYW5kLnRvKHVuYXZhaWxhYmxlID0+IHtcbiAgICAgICAgaWYgKHVuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24ubGFzdFNlbGVjdGVkID0gdGhpcztcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6bW91c2Vkb3duJykub2YodGhpcy5lbCkudG8oZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaW1wbHlCaW5kKCdldmVudDptb3VzZWVudGVyJykub2YodGhpcy5lbCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQgPSB0aGlzO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHRvZ2dsZShuZXdWYWx1ZSwgdW5hdmFpbGFibGUpIHtcbiAgICB2YXIgbmV3U3RhdGUsIHByZXZTdGF0ZSwgcmVmLCB3YXNTZWxlY3RlZDtcbiAgICBwcmV2U3RhdGUgPSB0aGlzLnNlbGVjdGVkO1xuICAgIG5ld1N0YXRlID0gSVMuZGVmaW5lZChuZXdWYWx1ZSkgPyBuZXdWYWx1ZSA6ICF0aGlzLnNlbGVjdGVkO1xuXG4gICAgaWYgKCFuZXdTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuZHJvcGRvd24uc2V0dGluZ3MubXVsdGlwbGUgJiYgcHJldlN0YXRlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW0odGhpcy5maWVsZC5fdmFsdWUsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FzU2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuXG4gICAgICAgIGlmIChJUy5kZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXdTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmF2YWlsYWJsZSAmJiB3YXNTZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1N0YXRlO1xuXG4gICAgICBpZiAodGhpcy5maWVsZC5zZXR0aW5ncy5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLmZpZWxkLl92YWx1ZS5wdXNoKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmZpZWxkLl92YWx1ZSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJlZi50b2dnbGUoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWVsZC5fdmFsdWUgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5maWVsZC5sYXN0U2VsZWN0ZWQgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG59O1xudmFyIERyb3Bkb3duJDEgPSBEcm9wZG93bjtleHBvcnQgZGVmYXVsdCBEcm9wZG93biQxO2V4cG9ydHtDaG9pY2V9OyIsIiFmdW5jdGlvbihlLHIpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXIoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHIpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMudGV4dE1hc2tDb3JlPXIoKTplLnRleHRNYXNrQ29yZT1yKCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIG89dFtuXT17ZXhwb3J0czp7fSxpZDpuLGxvYWRlZDohMX07cmV0dXJuIGVbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsciksby5sb2FkZWQ9ITAsby5leHBvcnRzfXZhciB0PXt9O3JldHVybiByLm09ZSxyLmM9dCxyLnA9XCJcIixyKDApfShbZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPXQoMyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJjb25mb3JtVG9NYXNrXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4obykuZGVmYXVsdH19KTt2YXIgaT10KDIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiYWRqdXN0Q2FyZXRQb3NpdGlvblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuKGkpLmRlZmF1bHR9fSk7dmFyIGE9dCg1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImNyZWF0ZVRleHRNYXNrSW5wdXRFbGVtZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4oYSkuZGVmYXVsdH19KX0sZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLnBsYWNlaG9sZGVyQ2hhcj1cIl9cIn0sZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUpe3ZhciByPWUucHJldmlvdXNDb25mb3JtZWRWYWx1ZSx0PXZvaWQgMD09PXI/bzpyLGk9ZS5wcmV2aW91c1BsYWNlaG9sZGVyLGE9dm9pZCAwPT09aT9vOmksdT1lLmN1cnJlbnRDYXJldFBvc2l0aW9uLGw9dm9pZCAwPT09dT8wOnUscz1lLmNvbmZvcm1lZFZhbHVlLGY9ZS5yYXdWYWx1ZSxkPWUucGxhY2Vob2xkZXJDaGFyLGM9ZS5wbGFjZWhvbGRlcix2PWUuaW5kZXhlc09mUGlwZWRDaGFycyxwPXZvaWQgMD09PXY/bjp2LGg9ZS5jYXJldFRyYXBJbmRleGVzLGc9dm9pZCAwPT09aD9uOmg7aWYoMD09PWwpcmV0dXJuIDA7dmFyIG09Zi5sZW5ndGgseT10Lmxlbmd0aCxiPWMubGVuZ3RoLEM9cy5sZW5ndGgsUD1tLXkseD1QPjAsTz0wPT09eSxrPVA+MSYmIXgmJiFPO2lmKGspcmV0dXJuIGw7dmFyIGo9eCYmKHQ9PT1zfHxzPT09YyksTT0wLFQ9dm9pZCAwLHc9dm9pZCAwO2lmKGopTT1sLVA7ZWxzZXt2YXIgXz1zLnRvTG93ZXJDYXNlKCksVj1mLnRvTG93ZXJDYXNlKCksUz1WLnN1YnN0cigwLGwpLnNwbGl0KG8pLE49Uy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIF8uaW5kZXhPZihlKSE9PS0xfSk7dz1OW04ubGVuZ3RoLTFdO3ZhciBFPWEuc3Vic3RyKDAsTi5sZW5ndGgpLnNwbGl0KG8pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSE9PWR9KS5sZW5ndGgsQT1jLnN1YnN0cigwLE4ubGVuZ3RoKS5zcGxpdChvKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT1kfSkubGVuZ3RoLFI9QSE9PUUsST12b2lkIDAhPT1hW04ubGVuZ3RoLTFdJiZ2b2lkIDAhPT1jW04ubGVuZ3RoLTJdJiZhW04ubGVuZ3RoLTFdIT09ZCYmYVtOLmxlbmd0aC0xXSE9PWNbTi5sZW5ndGgtMV0mJmFbTi5sZW5ndGgtMV09PT1jW04ubGVuZ3RoLTJdOyF4JiYoUnx8SSkmJkU+MCYmYy5pbmRleE9mKHcpPi0xJiZ2b2lkIDAhPT1mW2xdJiYoVD0hMCx3PWZbbF0pO2Zvcih2YXIgSj1wLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gX1tlXX0pLHE9Si5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT13fSkubGVuZ3RoLEY9Ti5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT13fSkubGVuZ3RoLEw9Yy5zdWJzdHIoMCxjLmluZGV4T2YoZCkpLnNwbGl0KG8pLmZpbHRlcihmdW5jdGlvbihlLHIpe3JldHVybiBlPT09dyYmZltyXSE9PWV9KS5sZW5ndGgsVz1MK0YrcSsoVD8xOjApLHo9MCxCPTA7QjxDO0IrKyl7dmFyIEQ9X1tCXTtpZihNPUIrMSxEPT09dyYmeisrLHo+PVcpYnJlYWt9fWlmKHgpe2Zvcih2YXIgRz1NLEg9TTtIPD1iO0grKylpZihjW0hdPT09ZCYmKEc9SCksY1tIXT09PWR8fGcuaW5kZXhPZihIKSE9PS0xfHxIPT09YilyZXR1cm4gR31lbHNlIGlmKFQpe2Zvcih2YXIgSz1NLTE7Sz49MDtLLS0paWYoc1tLXT09PXd8fGcuaW5kZXhPZihLKSE9PS0xfHwwPT09SylyZXR1cm4gS31lbHNlIGZvcih2YXIgUT1NO1E+PTA7US0tKWlmKGNbUS0xXT09PWR8fGcuaW5kZXhPZihRKSE9PS0xfHwwPT09USlyZXR1cm4gUX1PYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmRlZmF1bHQ9dDt2YXIgbj1bXSxvPVwiXCJ9LGZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOmEscj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06YSx0PWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxuPXQuZ3VpZGUsdT12b2lkIDA9PT1ufHxuLGw9dC5wcmV2aW91c0NvbmZvcm1lZFZhbHVlLHM9dm9pZCAwPT09bD9hOmwsZj10LnBsYWNlaG9sZGVyQ2hhcixkPXZvaWQgMD09PWY/aS5wbGFjZWhvbGRlckNoYXI6ZixjPXQucGxhY2Vob2xkZXIsdj12b2lkIDA9PT1jPygwLG8uY29udmVydE1hc2tUb1BsYWNlaG9sZGVyKShyLGQpOmMscD10LmN1cnJlbnRDYXJldFBvc2l0aW9uLGg9dC5rZWVwQ2hhclBvc2l0aW9ucyxnPXU9PT0hMSYmdm9pZCAwIT09cyxtPWUubGVuZ3RoLHk9cy5sZW5ndGgsYj12Lmxlbmd0aCxDPXIubGVuZ3RoLFA9bS15LHg9UD4wLE89cCsoeD8tUDowKSxrPU8rTWF0aC5hYnMoUCk7aWYoaD09PSEwJiYheCl7Zm9yKHZhciBqPWEsTT1PO008aztNKyspdltNXT09PWQmJihqKz1kKTtlPWUuc2xpY2UoMCxPKStqK2Uuc2xpY2UoTyxtKX1mb3IodmFyIFQ9ZS5zcGxpdChhKS5tYXAoZnVuY3Rpb24oZSxyKXtyZXR1cm57Y2hhcjplLGlzTmV3OnI+PU8mJnI8a319KSx3PW0tMTt3Pj0wO3ctLSl7dmFyIF89VFt3XS5jaGFyO2lmKF8hPT1kKXt2YXIgVj13Pj1PJiZ5PT09QztfPT09dltWP3ctUDp3XSYmVC5zcGxpY2UodywxKX19dmFyIFM9YSxOPSExO2U6Zm9yKHZhciBFPTA7RTxiO0UrKyl7dmFyIEE9dltFXTtpZihBPT09ZCl7aWYoVC5sZW5ndGg+MClmb3IoO1QubGVuZ3RoPjA7KXt2YXIgUj1ULnNoaWZ0KCksST1SLmNoYXIsSj1SLmlzTmV3O2lmKEk9PT1kJiZnIT09ITApe1MrPWQ7Y29udGludWUgZX1pZihyW0VdLnRlc3QoSSkpe2lmKGg9PT0hMCYmSiE9PSExJiZzIT09YSYmdSE9PSExJiZ4KXtmb3IodmFyIHE9VC5sZW5ndGgsRj1udWxsLEw9MDtMPHE7TCsrKXt2YXIgVz1UW0xdO2lmKFcuY2hhciE9PWQmJlcuaXNOZXc9PT0hMSlicmVhaztpZihXLmNoYXI9PT1kKXtGPUw7YnJlYWt9fW51bGwhPT1GPyhTKz1JLFQuc3BsaWNlKEYsMSkpOkUtLX1lbHNlIFMrPUk7Y29udGludWUgZX1OPSEwfWc9PT0hMSYmKFMrPXYuc3Vic3RyKEUsYikpO2JyZWFrfVMrPUF9aWYoZyYmeD09PSExKXtmb3IodmFyIHo9bnVsbCxCPTA7QjxTLmxlbmd0aDtCKyspdltCXT09PWQmJih6PUIpO1M9bnVsbCE9PXo/Uy5zdWJzdHIoMCx6KzEpOmF9cmV0dXJue2NvbmZvcm1lZFZhbHVlOlMsbWV0YTp7c29tZUNoYXJzUmVqZWN0ZWQ6Tn19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuZGVmYXVsdD1uO3ZhciBvPXQoNCksaT10KDEpLGE9XCJcIn0sZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bCxyPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp1LnBsYWNlaG9sZGVyQ2hhcjtpZihlLmluZGV4T2YocikhPT0tMSl0aHJvdyBuZXcgRXJyb3IoXCJQbGFjZWhvbGRlciBjaGFyYWN0ZXIgbXVzdCBub3QgYmUgdXNlZCBhcyBwYXJ0IG9mIHRoZSBtYXNrLiBQbGVhc2Ugc3BlY2lmeSBhIGNoYXJhY3RlciB0aGF0IGlzIG5vdCBwcmVzZW50IGluIHlvdXIgbWFzayBhcyB5b3VyIHBsYWNlaG9sZGVyIGNoYXJhY3Rlci5cXG5cXG5cIisoXCJUaGUgcGxhY2Vob2xkZXIgY2hhcmFjdGVyIHRoYXQgd2FzIHJlY2VpdmVkIGlzOiBcIitKU09OLnN0cmluZ2lmeShyKStcIlxcblxcblwiKSsoXCJUaGUgbWFzayB0aGF0IHdhcyByZWNlaXZlZCBpczogXCIrSlNPTi5zdHJpbmdpZnkoZSkpKTtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBSZWdFeHA/cjplfSkuam9pbihcIlwiKX1mdW5jdGlvbiBvKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgU3RyaW5nfWZ1bmN0aW9uIGkoZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGUmJnZvaWQgMD09PWUubGVuZ3RoJiYhaXNOYU4oZSl9ZnVuY3Rpb24gYShlKXtmb3IodmFyIHI9W10sdD12b2lkIDA7dD1lLmluZGV4T2YocyksdCE9PS0xOylyLnB1c2godCksZS5zcGxpY2UodCwxKTtyZXR1cm57bWFza1dpdGhvdXRDYXJldFRyYXBzOmUsaW5kZXhlczpyfX1PYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmNvbnZlcnRNYXNrVG9QbGFjZWhvbGRlcj1uLHIuaXNTdHJpbmc9byxyLmlzTnVtYmVyPWksci5wcm9jZXNzQ2FyZXRUcmFwcz1hO3ZhciB1PXQoMSksbD1bXSxzPVwiW11cIn0sZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIG8oZSl7dmFyIHI9e3ByZXZpb3VzQ29uZm9ybWVkVmFsdWU6dm9pZCAwLHByZXZpb3VzUGxhY2Vob2xkZXI6dm9pZCAwfTtyZXR1cm57c3RhdGU6cix1cGRhdGU6ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmUsbz1uLmlucHV0RWxlbWVudCxzPW4ubWFzayxkPW4uZ3VpZGUsbT1uLnBpcGUsYj1uLnBsYWNlaG9sZGVyQ2hhcixDPXZvaWQgMD09PWI/cC5wbGFjZWhvbGRlckNoYXI6YixQPW4ua2VlcENoYXJQb3NpdGlvbnMseD12b2lkIDAhPT1QJiZQLE89bi5zaG93TWFzayxrPXZvaWQgMCE9PU8mJk87aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHQmJih0PW8udmFsdWUpLHQhPT1yLnByZXZpb3VzQ29uZm9ybWVkVmFsdWUpeyhcInVuZGVmaW5lZFwiPT10eXBlb2Ygcz9cInVuZGVmaW5lZFwiOmwocykpPT09eSYmdm9pZCAwIT09cy5waXBlJiZ2b2lkIDAhPT1zLm1hc2smJihtPXMucGlwZSxzPXMubWFzayk7dmFyIGo9dm9pZCAwLE09dm9pZCAwO2lmKHMgaW5zdGFuY2VvZiBBcnJheSYmKGo9KDAsdi5jb252ZXJ0TWFza1RvUGxhY2Vob2xkZXIpKHMsQykpLHMhPT0hMSl7dmFyIFQ9YSh0KSx3PW8uc2VsZWN0aW9uRW5kLF89ci5wcmV2aW91c0NvbmZvcm1lZFZhbHVlLFY9ci5wcmV2aW91c1BsYWNlaG9sZGVyLFM9dm9pZCAwO2lmKChcInVuZGVmaW5lZFwiPT10eXBlb2Ygcz9cInVuZGVmaW5lZFwiOmwocykpPT09aCl7aWYoTT1zKFQse2N1cnJlbnRDYXJldFBvc2l0aW9uOncscHJldmlvdXNDb25mb3JtZWRWYWx1ZTpfLHBsYWNlaG9sZGVyQ2hhcjpDfSksTT09PSExKXJldHVybjt2YXIgTj0oMCx2LnByb2Nlc3NDYXJldFRyYXBzKShNKSxFPU4ubWFza1dpdGhvdXRDYXJldFRyYXBzLEE9Ti5pbmRleGVzO009RSxTPUEsaj0oMCx2LmNvbnZlcnRNYXNrVG9QbGFjZWhvbGRlcikoTSxDKX1lbHNlIE09czt2YXIgUj17cHJldmlvdXNDb25mb3JtZWRWYWx1ZTpfLGd1aWRlOmQscGxhY2Vob2xkZXJDaGFyOkMscGlwZTptLHBsYWNlaG9sZGVyOmosY3VycmVudENhcmV0UG9zaXRpb246dyxrZWVwQ2hhclBvc2l0aW9uczp4fSxJPSgwLGMuZGVmYXVsdCkoVCxNLFIpLEo9SS5jb25mb3JtZWRWYWx1ZSxxPShcInVuZGVmaW5lZFwiPT10eXBlb2YgbT9cInVuZGVmaW5lZFwiOmwobSkpPT09aCxGPXt9O3EmJihGPW0oSix1KHtyYXdWYWx1ZTpUfSxSKSksRj09PSExP0Y9e3ZhbHVlOl8scmVqZWN0ZWQ6ITB9OigwLHYuaXNTdHJpbmcpKEYpJiYoRj17dmFsdWU6Rn0pKTt2YXIgTD1xP0YudmFsdWU6SixXPSgwLGYuZGVmYXVsdCkoe3ByZXZpb3VzQ29uZm9ybWVkVmFsdWU6XyxwcmV2aW91c1BsYWNlaG9sZGVyOlYsY29uZm9ybWVkVmFsdWU6TCxwbGFjZWhvbGRlcjpqLHJhd1ZhbHVlOlQsY3VycmVudENhcmV0UG9zaXRpb246dyxwbGFjZWhvbGRlckNoYXI6QyxpbmRleGVzT2ZQaXBlZENoYXJzOkYuaW5kZXhlc09mUGlwZWRDaGFycyxjYXJldFRyYXBJbmRleGVzOlN9KSx6PUw9PT1qJiYwPT09VyxCPWs/ajpnLEQ9ej9COkw7ci5wcmV2aW91c0NvbmZvcm1lZFZhbHVlPUQsci5wcmV2aW91c1BsYWNlaG9sZGVyPWosby52YWx1ZSE9PUQmJihvLnZhbHVlPUQsaShvLFcpKX19fX19ZnVuY3Rpb24gaShlLHIpe2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PT1lJiYoYj9DKGZ1bmN0aW9uKCl7cmV0dXJuIGUuc2V0U2VsZWN0aW9uUmFuZ2UocixyLG0pfSwwKTplLnNldFNlbGVjdGlvblJhbmdlKHIscixtKSl9ZnVuY3Rpb24gYShlKXtpZigoMCx2LmlzU3RyaW5nKShlKSlyZXR1cm4gZTtpZigoMCx2LmlzTnVtYmVyKShlKSlyZXR1cm4gU3RyaW5nKGUpO2lmKHZvaWQgMD09PWV8fG51bGw9PT1lKXJldHVybiBnO3Rocm93IG5ldyBFcnJvcihcIlRoZSAndmFsdWUnIHByb3ZpZGVkIHRvIFRleHQgTWFzayBuZWVkcyB0byBiZSBhIHN0cmluZyBvciBhIG51bWJlci4gVGhlIHZhbHVlIHJlY2VpdmVkIHdhczpcXG5cXG4gXCIrSlNPTi5zdHJpbmdpZnkoZSkpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciB0PWFyZ3VtZW50c1tyXTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSl9cmV0dXJuIGV9LGw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07ci5kZWZhdWx0PW87dmFyIHM9dCgyKSxmPW4ocyksZD10KDMpLGM9bihkKSx2PXQoNCkscD10KDEpLGg9XCJmdW5jdGlvblwiLGc9XCJcIixtPVwibm9uZVwiLHk9XCJvYmplY3RcIixiPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJi9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxDPVwidW5kZWZpbmVkXCIhPXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOnNldFRpbWVvdXR9XSl9KTsiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnRleHRNYXNrQWRkb25zPXQoKTplLnRleHRNYXNrQWRkb25zPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiB0KHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgbz1uW3JdPXtleHBvcnRzOnt9LGlkOnIsbG9hZGVkOiExfTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyx0KSxvLmxvYWRlZD0hMCxvLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQucD1cIlwiLHQoMCl9KFtmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigxKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNyZWF0ZUF1dG9Db3JyZWN0ZWREYXRlUGlwZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByKG8pLmRlZmF1bHR9fSk7dmFyIGk9bigyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNyZWF0ZU51bWJlck1hc2tcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcihpKS5kZWZhdWx0fX0pO3ZhciB1PW4oMyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJlbWFpbE1hc2tcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcih1KS5kZWZhdWx0fX0pfSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06XCJtbSBkZCB5eXl5XCI7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPVtdLHI9ZS5zcGxpdCgvW15kbXldKy8pLG89e2RkOjMxLG1tOjEyLHl5Ojk5LHl5eXk6OTk5OX0saT17ZGQ6MSxtbToxLHl5OjAseXl5eToxfSx1PXQuc3BsaXQoXCJcIik7ci5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWUuaW5kZXhPZih0KSxpPXBhcnNlSW50KG9bdF0udG9TdHJpbmcoKS5zdWJzdHIoMCwxKSwxMCk7cGFyc2VJbnQodVtyXSwxMCk+aSYmKHVbcisxXT11W3JdLHVbcl09MCxuLnB1c2gocikpfSk7dmFyIGM9ci5zb21lKGZ1bmN0aW9uKG4pe3ZhciByPWUuaW5kZXhPZihuKSx1PW4ubGVuZ3RoLGM9dC5zdWJzdHIocix1KS5yZXBsYWNlKC9cXEQvZyxcIlwiKSxsPXBhcnNlSW50KGMsMTApO3JldHVybiBsPm9bbl18fGMubGVuZ3RoPT09dSYmbDxpW25dfSk7cmV0dXJuIWMmJnt2YWx1ZTp1LmpvaW4oXCJcIiksaW5kZXhlc09mUGlwZWRDaGFyczpufX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PW59LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06Yyx0PWUubGVuZ3RoO2lmKGU9PT1jfHxlWzBdPT09aFswXSYmMT09PXQpcmV0dXJuIGguc3BsaXQoYykuY29uY2F0KFt2XSkuY29uY2F0KG0uc3BsaXQoYykpO2lmKGU9PT1TJiZNKXJldHVybiBoLnNwbGl0KGMpLmNvbmNhdChbXCIwXCIsUyx2XSkuY29uY2F0KG0uc3BsaXQoYykpO3ZhciBuPWUubGFzdEluZGV4T2YoUyksdT1uIT09LTEsbD1lWzBdPT09cyYmSSxhPXZvaWQgMCxnPXZvaWQgMCxiPXZvaWQgMDtpZihlLnNsaWNlKFYqLTEpPT09bSYmKGU9ZS5zbGljZSgwLFYqLTEpKSx1JiYoTXx8RCk/KGE9ZS5zbGljZShlLnNsaWNlKDAsJCk9PT1oPyQ6MCxuKSxnPWUuc2xpY2UobisxLHQpLGc9cihnLnJlcGxhY2UoZixjKSkpOmE9ZS5zbGljZSgwLCQpPT09aD9lLnNsaWNlKCQpOmUsTiYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBOP1widW5kZWZpbmVkXCI6aShOKSk9PT1wKXt2YXIgTz1cIi5cIj09PV8/XCJbLl1cIjpcIlwiK18saj0oYS5tYXRjaChuZXcgUmVnRXhwKE8sXCJnXCIpKXx8W10pLmxlbmd0aDthPWEuc2xpY2UoMCxOK2oqcSl9cmV0dXJuIGE9YS5yZXBsYWNlKGYsYyksQXx8KGE9YS5yZXBsYWNlKC9eMCsoMCR8W14wXSkvLFwiJDFcIikpLGE9eD9vKGEsXyk6YSxiPXIoYSksKHUmJk18fEQ9PT0hMCkmJihlW24tMV0hPT1TJiZiLnB1c2goeSksYi5wdXNoKFMseSksZyYmKChcInVuZGVmaW5lZFwiPT10eXBlb2YgQz9cInVuZGVmaW5lZFwiOmkoQykpPT09cCYmKGc9Zy5zbGljZSgwLEMpKSxiPWIuY29uY2F0KGcpKSxEPT09ITAmJmVbbi0xXT09PVMmJmIucHVzaCh2KSksJD4wJiYoYj1oLnNwbGl0KGMpLmNvbmNhdChiKSksbCYmKGIubGVuZ3RoPT09JCYmYi5wdXNoKHYpLGI9W2RdLmNvbmNhdChiKSksbS5sZW5ndGg+MCYmKGI9Yi5jb25jYXQobS5zcGxpdChjKSkpLGJ9dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LG49dC5wcmVmaXgsaD12b2lkIDA9PT1uP3U6bixnPXQuc3VmZml4LG09dm9pZCAwPT09Zz9jOmcsYj10LmluY2x1ZGVUaG91c2FuZHNTZXBhcmF0b3IseD12b2lkIDA9PT1ifHxiLE89dC50aG91c2FuZHNTZXBhcmF0b3JTeW1ib2wsXz12b2lkIDA9PT1PP2w6TyxqPXQuYWxsb3dEZWNpbWFsLE09dm9pZCAwIT09aiYmaixQPXQuZGVjaW1hbFN5bWJvbCxTPXZvaWQgMD09PVA/YTpQLHc9dC5kZWNpbWFsTGltaXQsQz12b2lkIDA9PT13PzI6dyxrPXQucmVxdWlyZURlY2ltYWwsRD12b2lkIDAhPT1rJiZrLEU9dC5hbGxvd05lZ2F0aXZlLEk9dm9pZCAwIT09RSYmRSxSPXQuYWxsb3dMZWFkaW5nWmVyb2VzLEE9dm9pZCAwIT09UiYmUixMPXQuaW50ZWdlckxpbWl0LE49dm9pZCAwPT09TD9udWxsOkwsJD1oJiZoLmxlbmd0aHx8MCxWPW0mJm0ubGVuZ3RofHwwLHE9XyYmXy5sZW5ndGh8fDA7cmV0dXJuIGUuaW5zdGFuY2VPZj1cImNyZWF0ZU51bWJlck1hc2tcIixlfWZ1bmN0aW9uIHIoZSl7cmV0dXJuIGUuc3BsaXQoYykubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB2LnRlc3QoZSk/djplfSl9ZnVuY3Rpb24gbyhlLHQpe3JldHVybiBlLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csdCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07dC5kZWZhdWx0PW47dmFyIHU9XCIkXCIsYz1cIlwiLGw9XCIsXCIsYT1cIi5cIixzPVwiLVwiLGQ9Ly0vLGY9L1xcRCsvZyxwPVwibnVtYmVyXCIsdj0vXFxkLyx5PVwiW11cIn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIG8oZSx0KXtlPWUucmVwbGFjZShPLHYpO3ZhciBuPXQucGxhY2Vob2xkZXJDaGFyLHI9dC5jdXJyZW50Q2FyZXRQb3NpdGlvbixvPWUuaW5kZXhPZih5KSxzPWUubGFzdEluZGV4T2YocCksZD1zPG8/LTE6cyxmPWkoZSxvKzEseSksaD1pKGUsZC0xLHApLGc9dShlLG8sbiksbT1jKGUsbyxkLG4pLGI9bChlLGQsbixyKTtnPWEoZyksbT1hKG0pLGI9YShiLCEwKTt2YXIgeD1nLmNvbmNhdChmKS5jb25jYXQobSkuY29uY2F0KGgpLmNvbmNhdChiKTtyZXR1cm4geH1mdW5jdGlvbiBpKGUsdCxuKXt2YXIgcj1bXTtyZXR1cm4gZVt0XT09PW4/ci5wdXNoKG4pOnIucHVzaChoLG4pLHIucHVzaChoKSxyfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4gdD09PS0xP2U6ZS5zbGljZSgwLHQpfWZ1bmN0aW9uIGMoZSx0LG4scil7dmFyIG89djtyZXR1cm4gdCE9PS0xJiYobz1uPT09LTE/ZS5zbGljZSh0KzEsZS5sZW5ndGgpOmUuc2xpY2UodCsxLG4pKSxvPW8ucmVwbGFjZShuZXcgUmVnRXhwKFwiW1xcXFxzXCIrcitcIl1cIixtKSx2KSxvPT09eT9mOm8ubGVuZ3RoPDE/ZzpvW28ubGVuZ3RoLTFdPT09cD9vLnNsaWNlKDAsby5sZW5ndGgtMSk6b31mdW5jdGlvbiBsKGUsdCxuLHIpe3ZhciBvPXY7cmV0dXJuIHQhPT0tMSYmKG89ZS5zbGljZSh0KzEsZS5sZW5ndGgpKSxvPW8ucmVwbGFjZShuZXcgUmVnRXhwKFwiW1xcXFxzXCIrbitcIi5dXCIsbSksdiksMD09PW8ubGVuZ3RoP2VbdC0xXT09PXAmJnIhPT1lLmxlbmd0aD9mOnY6b31mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIGUuc3BsaXQodikubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlPT09Zz9lOnQ/eDpifSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9big0KSxkPXIocyksZj1cIipcIixwPVwiLlwiLHY9XCJcIix5PVwiQFwiLGg9XCJbXVwiLGc9XCIgXCIsbT1cImdcIixiPS9bXlxcc10vLHg9L1teLlxcc10vLE89L1xccy9nO3QuZGVmYXVsdD17bWFzazpvLHBpcGU6ZC5kZWZhdWx0fX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUsdCl7dmFyIG49dC5jdXJyZW50Q2FyZXRQb3NpdGlvbixpPXQucmF3VmFsdWUsZj10LnByZXZpb3VzQ29uZm9ybWVkVmFsdWUscD10LnBsYWNlaG9sZGVyQ2hhcix2PWU7dj1yKHYpO3ZhciB5PXYuaW5kZXhPZihjKSxoPW51bGw9PT1pLm1hdGNoKG5ldyBSZWdFeHAoXCJbXkBcXFxccy5cIitwK1wiXVwiKSk7aWYoaClyZXR1cm4gdTtpZih2LmluZGV4T2YoYSkhPT0tMXx8eSE9PS0xJiZuIT09eSsxfHxpLmluZGV4T2Yobyk9PT0tMSYmZiE9PXUmJmkuaW5kZXhPZihsKSE9PS0xKXJldHVybiExO3ZhciBnPXYuaW5kZXhPZihvKSxtPXYuc2xpY2UoZysxLHYubGVuZ3RoKTtyZXR1cm4obS5tYXRjaChkKXx8cykubGVuZ3RoPjEmJnYuc3Vic3RyKC0xKT09PWwmJm4hPT1pLmxlbmd0aCYmKHY9di5zbGljZSgwLHYubGVuZ3RoLTEpKSx2fWZ1bmN0aW9uIHIoZSl7dmFyIHQ9MDtyZXR1cm4gZS5yZXBsYWNlKGksZnVuY3Rpb24oKXtyZXR1cm4gdCsrLDE9PT10P286dX0pfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1uO3ZhciBvPVwiQFwiLGk9L0AvZyx1PVwiXCIsYz1cIkAuXCIsbD1cIi5cIixhPVwiLi5cIixzPVtdLGQ9L1xcLi9nfV0pfSk7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0IFJFR0VYIGZyb20nLi4vY29uc3RhbnRzL3JlZ2V4LmpzJztpbXBvcnQge3JlcGVhdH1mcm9tJy4uL2hlbHBlcnMuanMnO2ltcG9ydCBleHRlbmQgZnJvbSdzbWFydC1leHRlbmQnO2ltcG9ydCBtYXNrQ29yZSBmcm9tJ3RleHQtbWFzay1jb3JlJztpbXBvcnQgbWFza0FkZG9ucyBmcm9tJ3RleHQtbWFzay1hZGRvbnMnO3ZhciBNYXNrLCBkZWZhdWx0UGF0dGVybkNoYXJzO1xuZGVmYXVsdFBhdHRlcm5DaGFycyA9IHtcbiAgJzEnOiBSRUdFWC5udW1lcmljLFxuICAnIyc6IFJFR0VYLndpZGVudW1lcmljLFxuICAnYSc6IFJFR0VYLmxldHRlcixcbiAgJyonOiBSRUdFWC5hbnlcbn07XG5NYXNrID0gY2xhc3MgTWFzayB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBjb25maWcpIHtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgIHRoaXMucHJldlZhbHVlID0gJyc7XG4gICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgIHRoaXMucHJldkN1cnNvciA9IDA7XG4gICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXR0ZXJuUmF3ID0gdGhpcy5jb25maWcucGF0dGVybjtcbiAgICB0aGlzLnBhdHRlcm5TZXR0ZXIgPSB0aGlzLmNvbmZpZy5zZXR0ZXI7XG4gICAgdGhpcy5wbGFjZWhvbGRlckNoYXIgPSB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICB0aGlzLnBsYWNlaG9sZGVyUmVnZXggPSBuZXcgUmVnRXhwKCdcXFxcJyArICh0aGlzLnBsYWNlaG9sZGVyQ2hhciB8fCAnXycpLCAnZycpO1xuICAgIHRoaXMuZ3VpZGUgPSB0aGlzLmNvbmZpZy5ndWlkZTtcbiAgICB0aGlzLmtlZXBDaGFyUG9zaXRpb25zID0gdGhpcy5jb25maWcua2VlcENoYXJQb3NpdGlvbnM7XG4gICAgdGhpcy5jaGFycyA9IGV4dGVuZC5jbG9uZShkZWZhdWx0UGF0dGVybkNoYXJzLCB0aGlzLmNvbmZpZy5jdXN0b21QYXR0ZXJucyk7XG4gICAgdGhpcy5zZXRQYXR0ZXJuKHRoaXMucGF0dGVybik7XG4gIH1cblxuICBnZXRTdGF0ZShwYXR0ZXJuLCByYXdWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICByYXdWYWx1ZSxcbiAgICAgIGd1aWRlOiB0aGlzLmd1aWRlLFxuICAgICAgcGxhY2Vob2xkZXJDaGFyOiB0aGlzLnBsYWNlaG9sZGVyQ2hhcixcbiAgICAgIGtlZXBDaGFyUG9zaXRpb25zOiB0aGlzLmtlZXBDaGFyUG9zaXRpb25zLFxuICAgICAgY3VycmVudENhcmV0UG9zaXRpb246IHRoaXMuZmllbGQuZWwgPyB0aGlzLmZpZWxkLnNlbGVjdGlvbigpLmVuZCA6IHRoaXMuY3Vyc29yLFxuICAgICAgcHJldmlvdXNDb25mb3JtZWRWYWx1ZTogdGhpcy5wcmV2VmFsdWUsXG4gICAgICBwbGFjZWhvbGRlcjogdGhpcy5nZXRQbGFjZWhvbGRlcihwYXR0ZXJuKVxuICAgIH07XG4gIH1cblxuICBnZXRQbGFjZWhvbGRlcihwYXR0ZXJuKSB7XG4gICAgdmFyIGNoYXIsIGosIGxlbiwgcGxhY2Vob2xkZXI7XG5cbiAgICBpZiAoSVMuZnVuY3Rpb24ocGF0dGVybikpIDsgZWxzZSB7XG4gICAgICBwbGFjZWhvbGRlciA9ICcnO1xuXG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGNoYXIgPSBwYXR0ZXJuW2pdO1xuXG4gICAgICAgIGlmIChJUy5yZWdleChjaGFyKSkge1xuICAgICAgICAgIHBsYWNlaG9sZGVyICs9IHRoaXMucGxhY2Vob2xkZXJDaGFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBsYWNlaG9sZGVyICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH1cbiAgfVxuXG4gIHJlc29sdmVQYXR0ZXJuKHBhdHRlcm4sIGlucHV0LCBzdGF0ZSkge1xuICAgIHZhciBjaGFyLCBjb3B5LCBpLCBqLCBsZW4sIG9mZnNldCwgdHJhcEluZGV4ZXM7XG4gICAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAnZnVuY3Rpb24nID8gcGF0dGVybihpbnB1dCwgdGhpcy5nZXRTdGF0ZShwYXR0ZXJuLCBpbnB1dCkpIDogcGF0dGVybjtcbiAgICBvZmZzZXQgPSAwO1xuICAgIHRyYXBJbmRleGVzID0gW107XG4gICAgY29weSA9IHBhdHRlcm4uc2xpY2UoKTtcblxuICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSBjb3B5Lmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgICAgY2hhciA9IGNvcHlbaV07XG5cbiAgICAgIGlmICghKGNoYXIgPT09ICdbXScpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0cmFwSW5kZXhlcy5wdXNoKGkgLSBvZmZzZXQpO1xuICAgICAgcGF0dGVybi5zcGxpY2UoaSAtIG9mZnNldCwgMSk7XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICB0aGlzLnByZXZQYXR0ZXJuID0gdGhpcy5yZXNvbHZlZFBhdHRlcm47XG4gICAgdGhpcy5yZXNvbHZlZFBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuLFxuICAgICAgY2FyZXRUcmFwSW5kZXhlczogdHJhcEluZGV4ZXNcbiAgICB9O1xuICB9XG5cbiAgc2V0UGF0dGVybihzdHJpbmcsIHVwZGF0ZVZhbHVlID0gdHJ1ZSwgdXBkYXRlRmllbGQpIHtcbiAgICB0aGlzLnBhdHRlcm5SYXcgPSBzdHJpbmc7XG4gICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXJzZVBhdHRlcm4oc3RyaW5nKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMucGFyc2VUcmFuc2Zvcm0oc3RyaW5nKTtcblxuICAgIGlmICh1cGRhdGVWYWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZSk7XG5cbiAgICAgIGlmICh1cGRhdGVGaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGFyc2VQYXR0ZXJuKHN0cmluZykge1xuICAgIHZhciBjaGFyLCBlc2NhcGVkLCBpLCBqLCBsZW4sIHBhdHRlcm47XG5cbiAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICBjYXNlIHN0cmluZyAhPT0gJ0VNQUlMJzpcbiAgICAgICAgcmV0dXJuIG1hc2tBZGRvbnMuZW1haWxNYXNrLm1hc2s7XG5cbiAgICAgIGNhc2Ugc3RyaW5nICE9PSAnUEhPTkUnOlxuICAgICAgICB0aGlzLnBhdHRlcm5TZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gcmVwZWF0KCcjJywgTWF0aC5tYXgoNywgdmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ndWlkZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gJyMnO1xuXG4gICAgICBjYXNlIHN0cmluZyAhPT0gJ05BTUUnOlxuICAgICAgICB0aGlzLnBhdHRlcm5TZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UodGhpcy5wbGFjZWhvbGRlclJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgIHJldHVybiByZXBlYXQoJ2EnLCBNYXRoLm1heCgyLCB2YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJ2EnO1xuXG4gICAgICBjYXNlIHN0cmluZyAhPT0gJ0ZVTExOQU1FJzpcbiAgICAgICAgdGhpcy5wYXR0ZXJuU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNwbGl0O1xuXG4gICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgIHZhbHVlICs9ICd4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGxpdCA9IHZhbHVlLnJlcGxhY2UodGhpcy5wbGFjZWhvbGRlclJlZ2V4LCAnJykudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNwbGl0Lm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCgnYScsIE1hdGgubWF4KDIsIHBhcnQubGVuZ3RoKSk7XG4gICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAnYSc7XG5cbiAgICAgIGNhc2Ugc3RyaW5nICE9PSAnREFURSc6XG4gICAgICAgIHJldHVybiBbL1xcZC8sIC9cXGQvLCAnLycsIC9cXGQvLCAvXFxkLywgJy8nLCAvXFxkLywgL1xcZC8sIC9cXGQvLCAvXFxkL107XG5cbiAgICAgIGNhc2UgIShzdHJpbmdbMF0gPT09ICdEQVRFJyAmJiBJUy5zdHJpbmcoc3RyaW5nWzFdKSk6XG4gICAgICAgIHJldHVybiBzdHJpbmdbMV0uc3BsaXQoJycpLm1hcChjaGFyID0+IHtcbiAgICAgICAgICBpZiAoUkVHRVgubGV0dGVyLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgIHJldHVybiAvXFxkLztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSBzdHJpbmcgIT09ICdOVU1CRVInOlxuICAgICAgICByZXR1cm4gbWFza0FkZG9ucy5jcmVhdGVOdW1iZXJNYXNrKHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMuY29uZmlnLnByZWZpeCB8fCAnJyxcbiAgICAgICAgICBzdWZmaXg6IHRoaXMuY29uZmlnLnN1ZmZpeCB8fCAnJyxcbiAgICAgICAgICBpbmNsdWRlVGhvdXNhbmRzU2VwYXJhdG9yOiB0aGlzLmNvbmZpZy5zZXAgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgdGhvdXNhbmRzU2VwYXJhdG9yU3ltYm9sOiBJUy5zdHJpbmcodGhpcy5jb25maWcuc2VwKSA/IHRoaXMuY29uZmlnLnNlcCA6IHZvaWQgMCxcbiAgICAgICAgICBhbGxvd0RlY2ltYWw6IHRoaXMuY29uZmlnLmRlY2ltYWwsXG4gICAgICAgICAgZGVjaW1hbExpbWl0OiBJUy5udW1iZXIodGhpcy5jb25maWcuZGVjaW1hbCkgPyB0aGlzLmNvbmZpZy5kZWNpbWFsIDogdm9pZCAwLFxuICAgICAgICAgIGludGVnZXJMaW1pdDogSVMubnVtYmVyKHRoaXMuY29uZmlnLmxpbWl0KSA/IHRoaXMuY29uZmlnLmxpbWl0IDogdm9pZCAwXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICFJUy5hcnJheShzdHJpbmcpOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXR0ZXJuID0gW107XG5cbiAgICAgICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgICBjaGFyID0gc3RyaW5nW2ldO1xuXG4gICAgICAgICAgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXR0ZXJuLnB1c2goZXNjYXBlZCA/IGNoYXIgOiB0aGlzLmNoYXJzW2NoYXJdIHx8IGNoYXIpO1xuICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlVHJhbnNmb3JtKHN0cmluZykge1xuICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgIGNhc2Ugc3RyaW5nICE9PSAnRU1BSUwnOlxuICAgICAgICByZXR1cm4gbWFza0FkZG9ucy5lbWFpbE1hc2sucGlwZTtcblxuICAgICAgY2FzZSBzdHJpbmcgIT09ICdEQVRFJzpcbiAgICAgICAgcmV0dXJuIG1hc2tBZGRvbnMuY3JlYXRlQXV0b0NvcnJlY3RlZERhdGVQaXBlKCdtbS9kZC95eXl5Jyk7XG5cbiAgICAgIGNhc2UgIShzdHJpbmdbMF0gPT09ICdEQVRFJyAmJiBJUy5zdHJpbmcoc3RyaW5nWzFdKSk6XG4gICAgICAgIHJldHVybiBtYXNrQWRkb25zLmNyZWF0ZUF1dG9Db3JyZWN0ZWREYXRlUGlwZShzdHJpbmdbMV0pO1xuXG4gICAgICBjYXNlICF0aGlzLmNvbmZpZy50cmFuc2Zvcm06XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50cmFuc2Zvcm07XG4gICAgfVxuICB9XG5cbiAgc2V0VmFsdWUoaW5wdXQpIHtcbiAgICB2YXIgY2FyZXRUcmFwSW5kZXhlcywgY29uZm9ybWVkVmFsdWUsIGluZGV4ZXNPZlBpcGVkQ2hhcnMsIG5ld1BhdHRlcm4sIHBhdHRlcm4sIHN0YXRlLCB0cmFuc2Zvcm1lZDtcblxuICAgIGlmICh0aGlzLnBhdHRlcm5TZXR0ZXIpIHtcbiAgICAgIG5ld1BhdHRlcm4gPSB0aGlzLnBhdHRlcm5TZXR0ZXIoaW5wdXQpIHx8IHRoaXMucGF0dGVybjtcblxuICAgICAgaWYgKG5ld1BhdHRlcm4gIT09IHRoaXMucGF0dGVyblJhdyAmJiBuZXdQYXR0ZXJuICE9PSB0aGlzLnBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5zZXRQYXR0ZXJuKG5ld1BhdHRlcm4sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAoe1xuICAgICAgY2FyZXRUcmFwSW5kZXhlcyxcbiAgICAgIHBhdHRlcm5cbiAgICB9ID0gdGhpcy5yZXNvbHZlUGF0dGVybih0aGlzLnBhdHRlcm4sIGlucHV0KSk7XG5cbiAgICBpZiAocGF0dGVybiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMucHJldlZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnByZXZDdXJzb3IgPSB0aGlzLmN1cnNvcjtcbiAgICBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUocGF0dGVybiwgaW5wdXQpO1xuICAgICh7XG4gICAgICBjb25mb3JtZWRWYWx1ZVxuICAgIH0gPSBtYXNrQ29yZS5jb25mb3JtVG9NYXNrKGlucHV0LCBwYXR0ZXJuLCBzdGF0ZSkpO1xuXG4gICAgaWYgKHRoaXMudHJhbnNmb3JtKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHRoaXMudHJhbnNmb3JtKGNvbmZvcm1lZFZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybWVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKElTLnN0cmluZyh0cmFuc2Zvcm1lZCkpIHtcbiAgICAgIGNvbmZvcm1lZFZhbHVlID0gdHJhbnNmb3JtZWQ7XG4gICAgfSBlbHNlIGlmIChJUy5vYmplY3QodHJhbnNmb3JtZWQpKSB7XG4gICAgICBpbmRleGVzT2ZQaXBlZENoYXJzID0gdHJhbnNmb3JtZWQuaW5kZXhlc09mUGlwZWRDaGFycztcbiAgICAgIGNvbmZvcm1lZFZhbHVlID0gdHJhbnNmb3JtZWQudmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJzb3IgPSBtYXNrQ29yZS5hZGp1c3RDYXJldFBvc2l0aW9uKGV4dGVuZChzdGF0ZSwge1xuICAgICAgaW5kZXhlc09mUGlwZWRDaGFycyxcbiAgICAgIGNhcmV0VHJhcEluZGV4ZXMsXG4gICAgICBjb25mb3JtZWRWYWx1ZVxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9IGNvbmZvcm1lZFZhbHVlO1xuICB9XG5cbiAgdmFsaWRhdGUoaW5wdXQpIHtcbiAgICB2YXIgY2hhciwgaSwgaiwgbGVuLCBwYXR0ZXJuO1xuXG4gICAgaWYgKGlucHV0ICE9PSB0aGlzLnZhbHVlICYmIHRoaXMucGF0dGVyblNldHRlcikge1xuICAgICAgcGF0dGVybiA9IHRoaXMucGF0dGVyblNldHRlcihpbnB1dCkgfHwgdGhpcy5wYXR0ZXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5yZXNvbHZlZFBhdHRlcm47XG5cbiAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAoe1xuICAgICAgICAgIHBhdHRlcm5cbiAgICAgICAgfSA9IHRoaXMucmVzb2x2ZVBhdHRlcm4odGhpcy5wYXR0ZXJuLCBpbnB1dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICBjaGFyID0gcGF0dGVybltpXTtcblxuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICEhaW5wdXRbaV06XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgIShJUy5yZWdleChjaGFyKSAmJiAhY2hhci50ZXN0KGlucHV0W2ldKSk6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgIShJUy5zdHJpbmcoY2hhcikgJiYgaW5wdXRbaV0gIT09IGNoYXIpOlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgdmFyIGNoYXIsIGksIGlucHV0LCBqLCBsZW4sIHBhdHRlcm47XG4gICAgaW5wdXQgPSB0aGlzLnZhbHVlO1xuICAgIHBhdHRlcm4gPSB0aGlzLnJlc29sdmVkUGF0dGVybjtcblxuICAgIGlmICghcGF0dGVybikge1xuICAgICAgaWYgKHRoaXMucGF0dGVyblNldHRlcikge1xuICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuU2V0dGVyKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgKHtcbiAgICAgICAgcGF0dGVyblxuICAgICAgfSA9IHRoaXMucmVzb2x2ZVBhdHRlcm4ocGF0dGVybiB8fCB0aGlzLnBhdHRlcm4sIGlucHV0KSk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0ID09PSB0aGlzLmNvbmZpZy5wcmVmaXggfHwgaW5wdXQgPT09IHRoaXMuY29uZmlnLnN1ZmZpeCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICBjaGFyID0gcGF0dGVybltpXTtcblxuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICEhaW5wdXRbaV06XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSAhSVMucmVnZXgoY2hhcik6XG4gICAgICAgICAgcmV0dXJuICFjaGFyLnRlc3QoaW5wdXRbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59O1xudmFyIE1hc2skMSA9IE1hc2s7ZXhwb3J0IGRlZmF1bHQgTWFzayQxOyIsInZhciBDT0xPUlMgPSB7XG4gIHJlZDogJyNjYzQ4MjAnLFxuICBncmVlbjogJyM3MmMzMjInLFxuICBvcmFuZ2U6ICcjZmY5YzAwJyxcbiAgYmxhY2s6ICcjMTgxODE4JyxcbiAgZ3JleV9kYXJrOiAnIzVlNWU1ZScsXG4gIGdyZXk6ICcjOTA5MDkwJyxcbiAgZ3JleV9zZW1pX2xpZ2h0OiAnI2JlYmViZScsXG4gIGdyZXlfbGlnaHQ6ICcjZDNkM2QzJyxcbiAgZ3JleV9saWdodDI6ICcjZGRkZGRkJyxcbiAgZ3JleV9saWdodDM6ICcjZjJmNWY3JyxcbiAgZ3JleV9saWdodDQ6ICcjZTVlNWU1J1xufTtleHBvcnQgZGVmYXVsdCBDT0xPUlM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQge3Nob3J0aGFuZFNpZGVWYWx1ZSxjYWxjUGFkZGluZyxkZWZhdWx0Q29sb3IsaGV4VG9SR0JBfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0IENPTE9SUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO3ZhciB0ZXh0RmllbGRUZW1wbGF0ZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnZmllbGQnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5mb250RmFtaWx5O1xuICAgIH0sXG4gICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgJHZpc2libGU6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBhbmltYXRpb246ICcwLjJzIGZpZWxkRXJyb3JTaGFrZSdcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAxLFxuICAgIHRvcDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZVBhcnNlZCgnZm9udFNpemUnLCB0cnVlKSAqIDAuNztcbiAgICB9LFxuICAgIGxlZnQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiBzaG9ydGhhbmRTaWRlVmFsdWUoZmllbGQuc2V0dGluZ3MucGFkZGluZywgJ2xlZnQnKSArICgoKHJlZiA9IGZpZWxkLmVsLmNoaWxkLmljb24pICE9IG51bGwgPyByZWYud2lkdGggOiB2b2lkIDApIHx8IDApO1xuICAgIH0sXG4gICAgcGFkZGluZzogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gYDAgJHtmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmd9cHhgO1xuICAgIH0sXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5sYWJlbFNpemUgfHwgZmllbGQuc2V0dGluZ3MuZm9udFNpemUgKiAoMTEgLyAxNCk7XG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgbGluZUhlaWdodDogMSxcbiAgICBjb2xvcjogQ09MT1JTLmdyZXksXG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzLCBjb2xvciAwLjJzJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICRmaWxsZWQ6IHtcbiAgICAgICRzaG93TGFiZWw6IHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfVxuICAgIH0sXG4gICAgJGZvY3VzOiB7XG4gICAgICBjb2xvcjogQ09MT1JTLm9yYW5nZVxuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaW5uZXJ3cmFwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmhlaWdodDtcbiAgICB9LFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICBib3JkZXJXaWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MuYm9yZGVyO1xuICAgIH0sXG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyQ29sb3I6IENPTE9SUy5ncmV5X2xpZ2h0LFxuICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIHRyYW5zaXRpb246ICdib3JkZXItY29sb3IgMC4ycycsXG4gICAgJGZvY3VzOiB7XG4gICAgICBib3JkZXJDb2xvcjogQ09MT1JTLm9yYW5nZVxuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgYm9yZGVyQ29sb3I6IENPTE9SUy5yZWRcbiAgICB9LFxuICAgICRkaXNhYmxlZDoge1xuICAgICAgYm9yZGVyQ29sb3I6IENPTE9SUy5ncmV5X2xpZ2h0LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBDT0xPUlMuZ3JleV9saWdodFxuICAgIH1cbiAgfVxufSwgWydpbnB1dCcsIHtcbiAgcmVmOiAnaW5wdXQnLFxuICB0eXBlOiAndGV4dCcsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiAzLFxuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIGhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnN0eWxlU2FmZSgnaGVpZ2h0JywgMSkgfHwgdGhpcy5wYXJlbnQuc3R5bGVTYWZlKCdoZWlnaHQnKTtcbiAgICB9LFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHZhciBpY29uU2libGluZywgaW5wdXRTaWJsaW5nLCBwYWRkaW5nLCBwYWRkaW5nTGVmdCwgcGFkZGluZ1JpZ2h0LCBzdWJ0cmFjdCwgd2lkdGg7XG5cbiAgICAgIGlmICghZmllbGQuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG4gICAgICAgIHN1YnRyYWN0ID0gMDtcblxuICAgICAgICBpZiAoaWNvblNpYmxpbmcgPSBmaWVsZC5lbC5jaGlsZC5pY29uKSB7XG4gICAgICAgICAgc3VidHJhY3QgKz0gaWNvblNpYmxpbmcud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXRTaWJsaW5nID0gZmllbGQuZWwuY2hpbGRbZmllbGQuc2V0dGluZ3MuaW5wdXRTaWJsaW5nXSkge1xuICAgICAgICAgIHdpZHRoID0gaW5wdXRTaWJsaW5nLnN0eWxlUGFyc2VkKCd3aWR0aCcsIDEpIHx8IDA7XG4gICAgICAgICAgcGFkZGluZyA9IGlucHV0U2libGluZy5zdHlsZVBhcnNlZCgncGFkZGluZycsIDEpIHx8IDA7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBpbnB1dFNpYmxpbmcuc3R5bGVQYXJzZWQoJ3BhZGRpbmdMZWZ0JywgMSkgfHwgcGFkZGluZyB8fCAwO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGlucHV0U2libGluZy5zdHlsZVBhcnNlZCgncGFkZGluZ1JpZ2h0JywgMSkgfHwgcGFkZGluZyB8fCAwO1xuICAgICAgICAgIHN1YnRyYWN0ICs9IHdpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYGNhbGMoMTAwJSAtICR7c3VidHJhY3R9cHgpYDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhZGRpbmc6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgaWYgKHRoaXMucGFkZGluZyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGgubWF4KDAsIGNhbGNQYWRkaW5nKGZpZWxkLnNldHRpbmdzLmhlaWdodCwgMTQpIC0gMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLnBhZGRpbmd9cHggJHtmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmd9cHhgO1xuICAgIH0sXG4gICAgbWFyZ2luOiAnMCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIGFwcGVhcmFuY2U6ICdub25lJyxcbiAgICBib3JkZXI6ICdub25lJyxcbiAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5mb250U2l6ZTtcbiAgICB9LFxuICAgIGNvbG9yOiBDT0xPUlMuYmxhY2ssXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgYm94U2hhZG93OiAnbm9uZScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgYmFja2dyb3VuZENsaXA6ICdjb250ZW50LWJveCcsXG4gICAgLy8gc2VtaS1maXggZm9yIHllbGxvdyBhdXRvZmlsbCBiYWNrZ3JvdW5kXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKScsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzLCAtd2Via2l0LXRyYW5zZm9ybSAwLjJzJyxcbiAgICAkZGlzYWJsZWQ6IHtcbiAgICAgIGN1cnNvcjogJ25vdC1hbGxvd2VkJ1xuICAgIH0sXG4gICAgJGZpbGxlZDoge1xuICAgICAgJHNob3dMYWJlbDoge1xuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIHZhciBsYWJlbCwgdG90YWxIZWlnaHQsIHRyYW5zbGF0aW9uLCB3b3JrYWJsZUhlaWdodDtcblxuICAgICAgICAgIGlmICh0aGlzLnRyYW5zbGF0aW9uICE9IG51bGwgfHwgIShsYWJlbCA9IGZpZWxkLmVsLmNoaWxkLmxhYmVsKSB8fCBsYWJlbC5zdHlsZVNhZmUoJ3Bvc2l0aW9uJywgMSkgIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvdGFsSGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3R5bGVQYXJzZWQoJ2hlaWdodCcsIDEpO1xuICAgICAgICAgIHdvcmthYmxlSGVpZ2h0ID0gdG90YWxIZWlnaHQgLSAobGFiZWwuc3R5bGVQYXJzZWQoJ2ZvbnRTaXplJywgMSkgKyBsYWJlbC5zdHlsZVBhcnNlZCgndG9wJywgMSkgKiAyKTtcbiAgICAgICAgICB0cmFuc2xhdGlvbiA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKHRvdGFsSGVpZ2h0IC0gd29ya2FibGVIZWlnaHQpIC8gNCkpO1xuICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlWSgke3RyYW5zbGF0aW9ufXB4KWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAncGxhY2Vob2xkZXInLFxuICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICB0b3A6ICcwcHgnLFxuICAgIGxlZnQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAoKHJlZiA9IGZpZWxkLmVsLmNoaWxkLmljb24pICE9IG51bGwgPyByZWYud2lkdGggOiB2b2lkIDApIHx8IDA7XG4gICAgfSxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ2ZvbnRGYW1pbHknLCAxKTtcbiAgICB9LFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ2ZvbnRTaXplJywgMSk7XG4gICAgfSxcbiAgICBwYWRkaW5nOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHZhciBob3JpeiwgdmVydGk7XG4gICAgICB2ZXJ0aSA9IGZpZWxkLmVsLmNoaWxkLmlucHV0LnN0eWxlUGFyc2VkKCdwYWRkaW5nVG9wJywgMSkgfHwgZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ3BhZGRpbmdUb3AnKTtcbiAgICAgIGhvcml6ID0gZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ3BhZGRpbmdMZWZ0JywgMSkgfHwgZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ3BhZGRpbmdMZWZ0Jyk7XG4gICAgICByZXR1cm4gYCR7dmVydGkgKyAzfXB4ICR7aG9yaXp9cHhgO1xuICAgIH0sXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBvcGFjaXR5OiAwLjUsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJyxcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDAuMnMsIC13ZWJraXQtdHJhbnNmb3JtIDAuMnMnLFxuICAgICRmaWxsZWQ6IHtcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgJHNob3dMYWJlbDoge1xuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmaWVsZC5lbC5jaGlsZC5pbnB1dC5yYXcuc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XV0sIFsnZGl2Jywge1xuICByZWY6ICdoZWxwJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICcxMTAlJyxcbiAgICBsZWZ0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBzaG9ydGhhbmRTaWRlVmFsdWUoZmllbGQuc2V0dGluZ3MucGFkZGluZywgJ2xlZnQnKTtcbiAgICB9LFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIGNvbG9yOiBDT0xPUlMuZ3JleSxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9LFxuICAgICRzaG93SGVscDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufV1dKTtcbnZhciBpY29uID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdpY29uJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDIsXG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmljb25TaXplO1xuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pY29uU2l6ZTtcbiAgICB9LFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pY29uU2l6ZTtcbiAgICB9LFxuICAgIHBhZGRpbmdMZWZ0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmc7XG4gICAgfSxcbiAgICBwYWRkaW5nVG9wOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5zdHlsZVBhcnNlZCgnaGVpZ2h0JywgMSkgLyAyIC0gZmllbGQuc2V0dGluZ3MuaWNvblNpemUgLyAyO1xuICAgIH0sXG4gICAgbGluZUhlaWdodDogJzFlbScsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB3aWR0aDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnNlcnRlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhdy5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZVBhcnNlZCgnd2lkdGgnLCAxKSB8fCB0aGlzLnJlbGF0ZWQuc2V0dGluZ3MuaWNvblNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dKTsgLy8gQHN0eWxlUGFyc2VkKCd3aWR0aCcsMSkgb3IgQHJhdy5vZmZzZXRXaWR0aCBvciBAcmVsYXRlZC5zZXR0aW5ncy5pY29uU2l6ZSBvciAwXG5cbnZhciBjaGVja21hcmsgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFyaycsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiA0LFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICB3aWR0aDogMjYsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgcGFkZGluZ1RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnN0eWxlUGFyc2VkKCdoZWlnaHQnLCAxKSAvIDIgLSAxMztcbiAgICB9LFxuICAgIHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MuaW5wdXRQYWRkaW5nO1xuICAgIH0sXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgJGZpbGxlZDoge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdjaGVja21hcmtfaW5uZXJ3cmFwJyxcbiAgc3R5bGU6IHtcbiAgICB3aWR0aDogJzIwcHgnLFxuICAgIGhlaWdodDogJzIwcHgnLFxuICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgYm9yZGVyV2lkdGg6ICczcHgnLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgIGJvcmRlckNvbG9yOiBDT0xPUlMuZ3JlZW4sXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMC44KScsXG4gICAgLy8gdHJhbnNmb3JtT3JpZ2luOiAnMTAwJSAwJ1xuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGJvcmRlckNvbG9yOiBDT0xPUlMucmVkXG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnY2hlY2ttYXJrX21hc2sxJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICctNHB4JyxcbiAgICBsZWZ0OiAnLTEwcHgnLFxuICAgIHdpZHRoOiAnMTVweCcsXG4gICAgaGVpZ2h0OiAnMzBweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMzBweCAwIDAgMzBweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Q29sb3IoZmllbGQuZWxzLmlubmVyd3JhcC5zdHlsZVNhZmUoJ2JhY2tncm91bmRDb2xvcicsIDEpLCAnd2hpdGUnKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtNDVkZWcpJyxcbiAgICB0cmFuc2Zvcm1PcmlnaW46ICcxNXB4IDE1cHggMCdcbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdjaGVja21hcmtfbWFzazInLFxuICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJy01cHgnLFxuICAgIGxlZnQ6ICc4cHgnLFxuICAgIHdpZHRoOiAnMTVweCcsXG4gICAgaGVpZ2h0OiAnMzBweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMCAzMHB4IDMwcHggMCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Q29sb3IoZmllbGQuZWxzLmlubmVyd3JhcC5zdHlsZVNhZmUoJ2JhY2tncm91bmRDb2xvcicsIDEpLCAnd2hpdGUnKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtNDVkZWcpJyxcbiAgICB0cmFuc2Zvcm1PcmlnaW46ICcwIDE1cHggMCcsXG4gICAgJGZpbGxlZDoge1xuICAgICAgYW5pbWF0aW9uOiAnNC4yNXMgZWFzZS1pbiBjaGVja21hcmtSb3RhdGVQbGFjZWhvbGRlcicsXG4gICAgICAkaW52YWxpZDoge1xuICAgICAgICBhbmltYXRpb246ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFya19saW5lV3JhcHBlcicsXG4gIHN0eWxlOiB7XG4gICAgJGZpbGxlZDoge1xuICAgICAgJGludmFsaWQ6IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHpJbmRleDogMixcbiAgICAgICAgYW5pbWF0aW9uOiAnMC41NXMgY2hlY2ttYXJrQW5pbWF0ZUVycm9yJyxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnNTAlIDEwcHgnXG4gICAgICB9XG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnY2hlY2ttYXJrX2xpbmVTaG9ydCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAyLFxuICAgIHRvcDogJzEwcHgnLFxuICAgIGxlZnQ6ICczcHgnLFxuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgd2lkdGg6ICc4cHgnLFxuICAgIGhlaWdodDogJzNweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IENPTE9SUy5ncmVlbixcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoNDVkZWcpJyxcbiAgICAkZmlsbGVkOiB7XG4gICAgICBhbmltYXRpb246ICcwLjc1cyBjaGVja21hcmtBbmltYXRlU3VjY2Vzc1RpcCdcbiAgICB9LFxuICAgICRpbnZhbGlkOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IENPTE9SUy5yZWQsXG4gICAgICBsZWZ0OiAnNHB4JyxcbiAgICAgIHRvcDogJzhweCcsXG4gICAgICB3aWR0aDogJzEycHgnLFxuICAgICAgJGZpbGxlZDoge1xuICAgICAgICBhbmltYXRpb246ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFya19saW5lTG9uZycsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAyLFxuICAgIHRvcDogJzhweCcsXG4gICAgcmlnaHQ6ICcycHgnLFxuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgd2lkdGg6ICcxMnB4JyxcbiAgICBoZWlnaHQ6ICczcHgnLFxuICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBDT0xPUlMuZ3JlZW4sXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC00NWRlZyknLFxuICAgICRmaWxsZWQ6IHtcbiAgICAgIGFuaW1hdGlvbjogJzAuNzVzIGNoZWNrbWFya0FuaW1hdGVTdWNjZXNzTG9uZydcbiAgICB9LFxuICAgICRpbnZhbGlkOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IENPTE9SUy5yZWQsXG4gICAgICB0b3A6ICc4cHgnLFxuICAgICAgbGVmdDogJzRweCcsXG4gICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgJGZpbGxlZDoge1xuICAgICAgICBhbmltYXRpb246ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG59XV0sIFsnZGl2Jywge1xuICByZWY6ICdjaGVja21hcmtfcGxhY2Vob2xkZXInLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICB0b3A6ICctNHB4JyxcbiAgICBsZWZ0OiAnLTNweCcsXG4gICAgd2lkdGg6ICcyMHB4JyxcbiAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgIGJvcmRlcldpZHRoOiAnM3B4JyxcbiAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICBib3JkZXJDb2xvcjogaGV4VG9SR0JBKENPTE9SUy5ncmVlbiwgMC40KSxcbiAgICAkaW52YWxpZDoge1xuICAgICAgYm9yZGVyQ29sb3I6IGhleFRvUkdCQShDT0xPUlMucmVkLCAwLjQpXG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFya19wYXRjaCcsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAxLFxuICAgIHRvcDogJy0ycHgnLFxuICAgIGxlZnQ6ICc2cHgnLFxuICAgIHdpZHRoOiAnNHB4JyxcbiAgICBoZWlnaHQ6ICcyOHB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRDb2xvcihmaWVsZC5lbHMuaW5uZXJ3cmFwLnN0eWxlU2FmZSgnYmFja2dyb3VuZENvbG9yJywgMSksICd3aGl0ZScpO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC00NWRlZyknXG4gIH1cbn1dXV0pO3ZhciB0ZW1wbGF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDogdGV4dEZpZWxkVGVtcGxhdGUsaWNvbjogaWNvbixjaGVja21hcms6IGNoZWNrbWFya30pO2V4cG9ydHt0ZXh0RmllbGRUZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBiLGljb24gYXMgYyxjaGVja21hcmsgYXMgZH07IiwidmFyIGRlZmF1bHRzID0ge1xuICBwbGFjZWhvbGRlcjogdHJ1ZSxcbiAgdmFsaWRXaGVuSXNDaG9pY2U6IGZhbHNlLFxuICB2YWxpZFdoZW5SZWdleDogZmFsc2UsXG4gIGF1dG9XaWR0aDogZmFsc2UsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIG1pbldpZHRoOiAyLFxuICBoZWlnaHQ6IDQ2LFxuICBjaGVja21hcms6IHRydWUsXG4gIGtleWJvYXJkOiAndGV4dCcsXG4gIGRyb3Bkb3duOiB7XG4gICAgbG9ja1Njcm9sbDogZmFsc2VcbiAgfSxcbiAgY2hvaWNlczogbnVsbCxcbiAgbWluTGVuZ3RoOiBudWxsLFxuICBtYXhMZW5ndGg6IG51bGwsXG4gIGlucHV0U2libGluZzogJ2NoZWNrbWFyaycsXG4gIG1hc2s6IHtcbiAgICBwYXR0ZXJuOiBmYWxzZSxcbiAgICBwbGFjZWhvbGRlcjogJ18nLFxuICAgIGd1aWRlOiB0cnVlLFxuICAgIGN1c3RvbVBhdHRlcm5zOiBmYWxzZVxuICB9XG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uLy4uL2NoZWNrcy5qcyc7aW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQgU2ltcGx5QmluZCBmcm9tJ0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQgUkVHRVggZnJvbScuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7ZnV6enlNYXRjaCxnZXRJbmRleE9mRmlyc3REaWZmLGluY2x1ZGVzfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQgS0VZQ09ERVMgZnJvbScuLi8uLi9jb25zdGFudHMva2V5Q29kZXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2FuZ2xlRG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vdGVtcGxhdGUtYjk2MWY4MWYuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2RlZmF1bHRzLmpzJztpbXBvcnQgRHJvcGRvd24gZnJvbScuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzJztpbXBvcnQndGV4dC1tYXNrLWNvcmUnO2ltcG9ydCd0ZXh0LW1hc2stYWRkb25zJztpbXBvcnQgTWFzayBmcm9tJy4uLy4uL2NvbXBvbmVudHMvbWFzay5qcyc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCB7YSBhcyB0ZXh0RmllbGRUZW1wbGF0ZSxiIGFzIHRlbXBsYXRlc31mcm9tJy4vdGVtcGxhdGUtMjMzZTk0MTMuanMnO2ltcG9ydCBkZWZhdWx0cyBmcm9tJy4vZGVmYXVsdHMuanMnO3ZhciBUZXh0RmllbGQ7XG5cblRleHRGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgVGV4dEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZS50eXBpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3Vyc29yID0ge1xuICAgICAgICBwcmV2OiAwLFxuICAgICAgICBjdXJyZW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mua2V5Ym9hcmQgPT09ICdlbWFpbCcgJiYgdGhpcy5zZXR0aW5ncy5yZXF1aXJlZCkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXggPSBSRUdFWC5lbWFpbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLm1hc2sgPT09ICdOQU1FJyB8fCB0aGlzLnNldHRpbmdzLm1hc2sucGF0dGVybiA9PT0gJ05BTUUnKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleCA9IC9eW2EtekEtWl17Mn0vO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MubWFzayA9PT0gJ0ZVTExOQU1FJyB8fCB0aGlzLnNldHRpbmdzLm1hc2sucGF0dGVybiA9PT0gJ0ZVTExOQU1FJykge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXggPSAvXlthLXpBLVpdK1xccytbYS16QS1aXSsvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5tYXNrLnBhdHRlcm4pIHtcbiAgICAgICAgaWYgKElTLnN0cmluZyh0aGlzLnNldHRpbmdzLm1hc2spKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy5tYXNrID0gZXh0ZW5kLmRlZXAuY2xvbmUodGhpcy5kZWZhdWx0cy5tYXNrLCB7XG4gICAgICAgICAgICBwYXR0ZXJuOiB0aGlzLnNldHRpbmdzLm1hc2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChJUy5vYmplY3QodGhpcy5zZXR0aW5ncy5tYXNrKSkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MubWFzay5wYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmtleWJvYXJkKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnREFURSc7XG5cbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05VTUJFUic7XG5cbiAgICAgICAgICAgICAgY2FzZSAncGhvbmUnOlxuICAgICAgICAgICAgICBjYXNlICd0ZWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnUEhPTkUnO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0VNQUlMJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWFzay5wYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMubWFzayA9IG5ldyBNYXNrKHRoaXMsIHRoaXMuc2V0dGluZ3MubWFzayk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMuZHJvcGRvd24gJiYgdGhpcy5zZWxlY3RlZCAmJiB0aGlzLl92YWx1ZSA9PT0gdGhpcy5zZWxlY3RlZC5sYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIGlmIChJUy5zdHJpbmcobmV3VmFsdWUpIHx8IElTLm51bWJlcihuZXdWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBTdHJpbmcobmV3VmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLm1hc2sgPyB0aGlzLm1hc2suc2V0VmFsdWUobmV3VmFsdWUpIDogbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlY2FsY0Rpc3BsYXkoKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGdsb2JhbE9wdHM7XG4gICAgICBnbG9iYWxPcHRzID0ge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH07XG4gICAgICB0aGlzLmVsID0gdGhpcy50ZW1wbGF0ZS5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5kZWZhdWx0LCBnbG9iYWxPcHRzKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hvaWNlcykge1xuICAgICAgICB0aGlzLmRyb3Bkb3duID0gbmV3IERyb3Bkb3duKHRoaXMuc2V0dGluZ3MuY2hvaWNlcywgdGhpcyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uYXBwZW5kVG8odGhpcy5lbC5jaGlsZC5pbm5lcndyYXApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5pY29uKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzLmljb24uc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuaWNvbiwgZ2xvYmFsT3B0cykuYXBwZW5kKHRoaXMuc2V0dGluZ3MuaWNvbikuaW5zZXJ0QmVmb3JlKHRoaXMuZWwuY2hpbGQuaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja21hcmspIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuY2hlY2ttYXJrLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmNoZWNrbWFyaywgZ2xvYmFsT3B0cykuaW5zZXJ0QWZ0ZXIodGhpcy5lbC5jaGlsZC5pbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuY2hpbGQuaW5wdXQucHJvcCgndHlwZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmtleWJvYXJkKSB7XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBjYXNlICd0ZWwnOlxuICAgICAgICAgIGNhc2UgJ3Bob25lJzpcbiAgICAgICAgICAgIHJldHVybiAndGVsJztcblxuICAgICAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgICAgICAgIHJldHVybiAncGFzc3dvcmQnO1xuXG4gICAgICAgICAgY2FzZSAndXJsJzpcbiAgICAgICAgICAgIHJldHVybiAndXJsJztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyB3aGVuICdlbWFpbCcgdGhlbiAnZW1haWwnXG4gICAgICAgICAgICByZXR1cm4gJ3RleHQnO1xuICAgICAgICB9XG4gICAgICB9LmNhbGwodGhpcykpO1xuICAgICAgdGhpcy5lbC5zdGF0ZSgnaGFzTGFiZWwnLCB0aGlzLnNldHRpbmdzLmxhYmVsKTtcbiAgICAgIHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3Ll9xdWlja0ZpZWxkID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkZjtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3MoKSB7XG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvV2lkdGgoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfdmFsdWUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfYXV0b2NvbXBsZXRlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3Zpc2libGUnKS5vZih0aGlzLnN0YXRlKS50byh2aXNpYmxlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Zpc2libGUnLCB2aXNpYmxlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnaG92ZXJlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGhvdmVyZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnaG92ZXInLCBob3ZlcmVkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZm9jdXNlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGZvY3VzZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZm9jdXMnLCBmb2N1c2VkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZmlsbGVkJykub2YodGhpcy5zdGF0ZSkudG8oZmlsbGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2ZpbGxlZCcsIGZpbGxlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2Rpc2FibGVkJykub2YodGhpcy5zdGF0ZSkudG8oZGlzYWJsZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZGlzYWJsZWQnLCBkaXNhYmxlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dMYWJlbCcpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dMYWJlbCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93TGFiZWwnLCBzaG93TGFiZWwpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93RXJyb3InKS5vZih0aGlzLnN0YXRlKS50byhzaG93RXJyb3IgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0Vycm9yJywgc2hvd0Vycm9yKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0hlbHAnKS5vZih0aGlzLnN0YXRlKS50byhzaG93SGVscCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93SGVscCcsIHNob3dIZWxwKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgndmFsaWQnKS5vZih0aGlzLnN0YXRlKS50byh2YWxpZCA9PiB7XG4gICAgICAgIHRoaXMuZWwuc3RhdGUoJ3ZhbGlkJywgdmFsaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnaW52YWxpZCcsICF2YWxpZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3BsYWNlaG9sZGVyJykub2YodGhpcy5zdGF0ZSkudG8oJ3RleHQnKS5vZih0aGlzLmVsLmNoaWxkLnBsYWNlaG9sZGVyKS50cmFuc2Zvcm0ocGxhY2Vob2xkZXIgPT4ge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhKHBsYWNlaG9sZGVyID09PSB0cnVlICYmIHRoaXMuc2V0dGluZ3MubGFiZWwpOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MubGFiZWw7XG5cbiAgICAgICAgICBjYXNlICFJUy5zdHJpbmcocGxhY2Vob2xkZXIpOlxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdkaXNhYmxlZCcsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiB0aGlzLnN0YXRlLmRpc2FibGVkXG4gICAgICB9KS5vZih0aGlzLnN0YXRlKS50bygoZGlzYWJsZWQsIHByZXYpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2ttYXJrKSB7XG4gICAgICAgICAgaWYgKGRpc2FibGVkIHx8ICFkaXNhYmxlZCAmJiBwcmV2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbC5jaGlsZC5jaGVja21hcmtfbWFzazEucmVjYWxjU3R5bGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5lbC5jaGlsZC5jaGVja21hcmtfbWFzazIucmVjYWxjU3R5bGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuY2hlY2ttYXJrX3BhdGNoLnJlY2FsY1N0eWxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gQGVsLmNoaWxkLmNoZWNrbWFyay5yZWNhbGNTdHlsZSh0cnVlKVxuXG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvV2lkdGgoKSB7XG4gICAgICBTaW1wbHlCaW5kKCd3aWR0aCcsIHtcbiAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZVxuICAgICAgfSkub2YodGhpcy5zdGF0ZSkudG8od2lkdGggPT4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoID8gdGhpcy5lbC5jaGlsZC5pbnB1dCA6IHRoaXMuZWwpLnN0eWxlKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgIH0pLnRyYW5zZm9ybSh0aGlzLl9mb3JtYXRXaWR0aC5iaW5kKHRoaXMpKS51cGRhdGVPbignaXNNb2JpbGUnKS5vZih0aGlzLnN0YXRlKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG4gICAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScsIHtcbiAgICAgICAgICB1cGRhdGVFdmVuSWZTYW1lOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgICAgfSkub2YodGhpcykudG8oJ3dpZHRoJykub2YodGhpcy5zdGF0ZSkudHJhbnNmb3JtKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYCR7dGhpcy5fZ2V0SW5wdXRBdXRvV2lkdGgoKX1weGA7XG4gICAgICAgIH0pLnVwZGF0ZU9uKCdldmVudDppbnNlcnRlZCcpLm9mKHRoaXMuZWwpLnVwZGF0ZU9uKCd2aXNpYmxlJykub2YodGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCkge1xuICAgICAgdmFyIGlucHV0LCByZXNldElucHV0O1xuICAgICAgaW5wdXQgPSB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdztcblxuICAgICAgcmVzZXRJbnB1dCA9ICgpID0+IHtcbiAgICAgICAgdmFyIGZpbGxlZDtcbiAgICAgICAgZmlsbGVkID0gIXRoaXMubWFzay5pc0VtcHR5KCk7XG5cbiAgICAgICAgaWYgKCFmaWxsZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbih0aGlzLm1hc2suY3Vyc29yID0gMCk7XG4gICAgICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgICAgICB0aGlzLnN0YXRlLmZpbGxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbGxlZDtcbiAgICAgIH07XG5cbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmlucHV0Jykub2YoaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGlucHV0LnZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbih0aGlzLm1hc2suY3Vyc29yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScsIHtcbiAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogISF0aGlzLm1hc2tcbiAgICAgIH0pLm9mKHRoaXMpLnRvKCd2YWx1ZScpLm9mKGlucHV0KS5hbmQudG8odmFsdWUgPT4ge1xuICAgICAgICB2YXIgZmlsbGVkO1xuICAgICAgICBmaWxsZWQgPSAhIXZhbHVlO1xuXG4gICAgICAgIGlmIChmaWxsZWQgJiYgdGhpcy5tYXNrICYmIHRoaXMubWFzay5ndWlkZSAmJiAoIXRoaXMuc3RhdGUuZm9jdXNlZCB8fCB0aGlzLm1hc2suY3Vyc29yID09PSAwKSkge1xuICAgICAgICAgIGZpbGxlZCA9IHJlc2V0SW5wdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbGVkID0gZmlsbGVkO1xuXG4gICAgICAgIGlmIChmaWxsZWQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmludGVyYWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6a2V5ZG93bicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWUNPREVTLmVudGVyKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdzdWJtaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoYGtleS0ke2V2ZW50LmtleUNvZGV9YCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubWFzayAmJiB0aGlzLm1hc2suZ3VpZGUpIHtcbiAgICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Ymx1cicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKHJlc2V0SW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19hdXRvY29tcGxldGUoKSB7XG4gICAgICBpZiAodGhpcy5kcm9wZG93bikge1xuICAgICAgICBTaW1wbHlCaW5kLmRlZmF1bHRPcHRpb25zLnVwZGF0ZU9uQmluZCA9IGZhbHNlO1xuICAgICAgICBTaW1wbHlCaW5kKCd0eXBpbmcnLCB7XG4gICAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZVxuICAgICAgICB9KS5vZih0aGlzLnN0YXRlKS50byhpc1R5cGluZyA9PiB7XG4gICAgICAgICAgaWYgKGlzVHlwaW5nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24uaXNPcGVuKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duLmxpc3QuY2FsY0Rpc3BsYXkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YoZG9jdW1lbnQpLm9uY2UudG8oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICB9KS5jb25kaXRpb24oZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhRE9NKGV2ZW50LnRhcmdldCkucGFyZW50TWF0Y2hpbmcocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPT09IHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJykub2YodGhpcykudG8odmFsdWUgPT4ge1xuICAgICAgICAgIHZhciBjaG9pY2UsIGksIGxlbiwgcmVmLCBzaG91bGRCZVZpc2libGU7XG4gICAgICAgICAgcmVmID0gdGhpcy5kcm9wZG93bi5jaG9pY2VzO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaG9pY2UgPSByZWZbaV07XG4gICAgICAgICAgICBzaG91bGRCZVZpc2libGUgPSAhdmFsdWUgPyB0cnVlIDogZnV6enlNYXRjaCh2YWx1ZSwgY2hvaWNlLmxhYmVsKTtcblxuICAgICAgICAgICAgaWYgKGNob2ljZS52aXNpYmxlICE9PSBzaG91bGRCZVZpc2libGUpIHtcbiAgICAgICAgICAgICAgY2hvaWNlLnZpc2libGUgPSBzaG91bGRCZVZpc2libGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24uaXNPcGVuICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRyb3Bkb3duLm9uU2VsZWN0ZWQoc2VsZWN0ZWRDaG9pY2UgPT4ge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZENob2ljZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWRDaG9pY2UubGFiZWw7XG4gICAgICAgICAgdGhpcy5kcm9wZG93bi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24odGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFNpbXBseUJpbmQuZGVmYXVsdE9wdGlvbnMudXBkYXRlT25CaW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpIHtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50Om1vdXNlZW50ZXInKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhvdmVyZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDptb3VzZWxlYXZlJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ob3ZlcmVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmZvY3VzJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmJsdXInKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGluZyA9IHRoaXMuc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDppbnB1dCcpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6a2V5ZG93bicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLnByZXYgPSB0aGlzLnNlbGVjdGlvbigpLmVuZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9zY2hlZHVsZUN1cnNvclJlc2V0KCkge1xuICAgICAgdmFyIGN1cnJlbnRDdXJzb3IsIGRpZmZJbmRleCwgbmV3Q3Vyc29yO1xuICAgICAgZGlmZkluZGV4ID0gZ2V0SW5kZXhPZkZpcnN0RGlmZih0aGlzLm1hc2sudmFsdWUsIHRoaXMubWFzay5wcmV2LnZhbHVlKTtcbiAgICAgIGN1cnJlbnRDdXJzb3IgPSB0aGlzLmN1cnNvci5jdXJyZW50O1xuICAgICAgbmV3Q3Vyc29yID0gdGhpcy5tYXNrLm5vcm1hbGl6ZUN1cnNvclBvcyhjdXJyZW50Q3Vyc29yLCB0aGlzLmN1cnNvci5wcmV2KTtcblxuICAgICAgaWYgKG5ld0N1cnNvciAhPT0gY3VycmVudEN1cnNvcikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbihuZXdDdXJzb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRWYWx1ZUlmTm90U2V0KCkge1xuICAgICAgaWYgKHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRJbnB1dEF1dG9XaWR0aCgpIHtcbiAgICAgIHZhciBpbnB1dFdpZHRoLCBsYWJlbFdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2V0VmFsdWVJZk5vdFNldCgpO1xuXG4gICAgICAgIHRoaXMuZWwuY2hpbGQuaW5wdXQuc3R5bGUoJ3dpZHRoJywgMCk7XG4gICAgICAgIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNjcm9sbExlZnQgPSAxZSsxMDtcbiAgICAgICAgaW5wdXRXaWR0aCA9IE1hdGgubWF4KHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNjcm9sbExlZnQgKyB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5vZmZzZXRXaWR0aCwgdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcuc2Nyb2xsV2lkdGgpICsgMjtcbiAgICAgICAgbGFiZWxXaWR0aCA9IHRoaXMuc2V0dGluZ3MubGFiZWwgJiYgdGhpcy5lbC5jaGlsZC5sYWJlbC5zdHlsZVNhZmUoJ3Bvc2l0aW9uJykgPT09ICdhYnNvbHV0ZScgPyB0aGlzLmVsLmNoaWxkLmxhYmVsLnJlY3Qud2lkdGggOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRXaWR0aCA9IHRoaXMuZWwuY2hpbGQucGxhY2Vob2xkZXIucmVjdC53aWR0aDtcbiAgICAgICAgbGFiZWxXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21heCcpLCBNYXRoLm1heCh0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21pbicpLCBpbnB1dFdpZHRoLCBsYWJlbFdpZHRoKSk7XG4gICAgfVxuXG4gICAgX2dldFdpZHRoU2V0dGluZyh0YXJnZXQpIHtcbiAgICAgIHZhciBwYXJlbnQsIHBhcmVudFdpZHRoLCByZXN1bHQ7XG5cbiAgICAgIGlmICh0YXJnZXQgPT09ICdtaW4nIHx8IHRhcmdldCA9PT0gJ21heCcpIHtcbiAgICAgICAgdGFyZ2V0ICs9ICdXaWR0aCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXR0aW5nc1t0YXJnZXRdID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnNldHRpbmdzW3RhcmdldF07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNldHRpbmdzW3RhcmdldF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQodGhpcy5zZXR0aW5nc1t0YXJnZXRdKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5zZXR0aW5nc1t0YXJnZXRdLCAnJScpKSB7XG4gICAgICAgICAgaWYgKChwYXJlbnQgPSB0aGlzLmVsLnBhcmVudCkgJiYgcGFyZW50LnN0eWxlKCdkaXNwbGF5JykgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgIHBhcmVudFdpZHRoID0gcGFyZW50LnN0eWxlUGFyc2VkKCd3aWR0aCcpIC0gcGFyZW50LnN0eWxlUGFyc2VkKCdwYWRkaW5nTGVmdCcpIC0gcGFyZW50LnN0eWxlUGFyc2VkKCdwYWRkaW5nUmlnaHQnKSAtIDI7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRXaWR0aCAqIChyZXN1bHQgLyAxMDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8ICh0YXJnZXQgPT09ICdtaW5XaWR0aCcgPyAwIDogMmUzMDgpO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZShwcm92aWRlZFZhbHVlKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdDaG9pY2UsIHJlZjtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXggJiYgSVMucmVnZXgodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnZhbGlkV2hlblJlZ2V4LnRlc3QocHJvdmlkZWRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuSXNDaG9pY2UgJiYgKChyZWYgPSB0aGlzLnNldHRpbmdzLmNob2ljZXMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSkge1xuICAgICAgICBtYXRjaGluZ0Nob2ljZSA9IHRoaXMuc2V0dGluZ3MuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICAgIHJldHVybiBjaG9pY2UudmFsdWUgPT09IHByb3ZpZGVkVmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWF0Y2hpbmdDaG9pY2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1pbkxlbmd0aCkge1xuICAgICAgICBpZiAocHJvdmlkZWRWYWx1ZS5sZW5ndGggPCB0aGlzLnNldHRpbmdzLm1pbkxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tYXhMZW5ndGgpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVkVmFsdWUubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc2sudmFsaWRhdGUocHJvdmlkZWRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uKGFyZykge1xuICAgICAgdmFyIGVuZCwgc3RhcnQ7XG5cbiAgICAgIGlmIChJUy5vYmplY3QoYXJnKSkge1xuICAgICAgICBzdGFydCA9IGFyZy5zdGFydDtcbiAgICAgICAgZW5kID0gYXJnLmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gYXJnO1xuICAgICAgICBlbmQgPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghZW5kIHx8IGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ3N0YXJ0JzogdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgJ2VuZCc6IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNlbGVjdGlvbkVuZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgYmx1cigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5ibHVyKCk7XG4gICAgfVxuXG4gIH1cbiAgVGV4dEZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRleHRGaWVsZFRlbXBsYXRlO1xuICBUZXh0RmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgVGV4dEZpZWxkLnByb3RvdHlwZS5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICByZXR1cm4gVGV4dEZpZWxkO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbnZhciBUZXh0RmllbGQkMSA9IFRleHRGaWVsZDtleHBvcnQgZGVmYXVsdCBUZXh0RmllbGQkMTsiLCJpbXBvcnQncXVpY2tjc3MnO2ltcG9ydCByZWdpc3RlckFuaW1hdGlvbnMgZnJvbScuL2FuaW1hdGlvbnMuanMnO2ltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4vY2hlY2tzLmpzJztpbXBvcnQnLi9jb25zb2xlUGF0Y2guanMnO2ltcG9ydCdxdWlja2RvbSc7aW1wb3J0J0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQnLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCcuL2hlbHBlcnMuanMnO2ltcG9ydCBleHRlbmQgZnJvbSdzbWFydC1leHRlbmQnO2ltcG9ydCBSRVFVSVJFRF9GSUVMRF9NRVRIT0RTIGZyb20nLi9jb25zdGFudHMvcmVxRmllbGRNZXRob2RzLmpzJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4vY29tcG9uZW50cy9jb25kaXRpb24uanMnO2ltcG9ydCcuL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi9maWVsZC9pbmRleC5qcyc7aW1wb3J0Jy4vY29uc3RhbnRzL2tleUNvZGVzLmpzJztpbXBvcnQnLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi9zdmcvY2FyZXRVcC5qcyc7aW1wb3J0Jy4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuL3N2Zy9jbG9uZS5qcyc7aW1wb3J0Jy4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4vY29tcG9uZW50cy9kcm9wZG93bi90ZW1wbGF0ZS1iOTYxZjgxZi5qcyc7aW1wb3J0Jy4vY29tcG9uZW50cy9kcm9wZG93bi9kZWZhdWx0cy5qcyc7aW1wb3J0Jy4vY29tcG9uZW50cy9kcm9wZG93bi9pbmRleC5qcyc7aW1wb3J0J3RleHQtbWFzay1jb3JlJztpbXBvcnQndGV4dC1tYXNrLWFkZG9ucyc7aW1wb3J0Jy4vY29tcG9uZW50cy9tYXNrLmpzJztpbXBvcnQnLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQnLi9maWVsZHMvdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyc7aW1wb3J0Jy4vZmllbGRzL3RleHQvZGVmYXVsdHMuanMnO2ltcG9ydCBUZXh0RmllbGQgZnJvbScuL2ZpZWxkcy90ZXh0L2luZGV4LmpzJzt2YXIgdmVyc2lvbiA9IFwiMS4wLjk3XCI7dmFyIGNyZWF0ZUJ1aWxkZXIsIHF1aWNrZmllbGQ7XG5cbmNyZWF0ZUJ1aWxkZXIgPSBmdW5jdGlvbiAoc2V0dGluZ092ZXJyaWRlcywgdGVtcGxhdGVPdmVycmlkZXMpIHtcbiAgdmFyIGJ1aWxkZXI7XG5cbiAgYnVpbGRlciA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgc2V0dGluZ3MgPSBleHRlbmQuY2xvbmUoLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIUlTLm9iamVjdChzZXR0aW5ncykpIHtcbiAgICAgIHNldHRpbmdzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLnR5cGUgPT0gbnVsbCkge1xuICAgICAgc2V0dGluZ3MudHlwZSA9ICd0ZXh0JztcbiAgICB9XG5cbiAgICBpZiAoIUZpZWxkW3NldHRpbmdzLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1aWNrRmllbGQ6ICcke3NldHRpbmdzLnR5cGV9JyBpcyBub3QgYSB2YWxpZC9yZWdpc3RlcmVkIGZpZWxkIHR5cGVgKTtcbiAgICB9XG5cbiAgICByZWdpc3RlckFuaW1hdGlvbnMoKTtcbiAgICByZXR1cm4gbmV3IEZpZWxkW3NldHRpbmdzLnR5cGVdKHNldHRpbmdzLCBidWlsZGVyLCBzZXR0aW5nT3ZlcnJpZGVzLCB0ZW1wbGF0ZU92ZXJyaWRlcyk7XG4gIH07XG5cbiAgYnVpbGRlci5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlLCB0YXJnZXRGaWVsZCkge1xuICAgIHZhciBpLCBsZW4sIHJlcXVpcmVkTWV0aG9kO1xuXG4gICAgaWYgKCFJUy5zdHJpbmcodHlwZSkgfHwgIUlTLmZ1bmN0aW9uKHRhcmdldEZpZWxkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVpY2tGaWVsZCBSZWdpc3RyYXRpb246IGludmFsaWQgYXJndW1lbnRzXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IFJFUVVJUkVEX0ZJRUxEX01FVEhPRFMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlcXVpcmVkTWV0aG9kID0gUkVRVUlSRURfRklFTERfTUVUSE9EU1tpXTtcblxuICAgICAgaWYgKCF0YXJnZXRGaWVsZC5wcm90b3R5cGVbcmVxdWlyZWRNZXRob2RdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVpY2tGaWVsZCBSZWdpc3RyYXRpb246ICcke3JlcXVpcmVkTWV0aG9kfScgbWV0aG9kIGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIHJlZ2lzdGVyIHRoZSBmaWVsZGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIEZpZWxkW3R5cGVdID0gdGFyZ2V0RmllbGQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgYnVpbGRlci5jb25maWcgPSBmdW5jdGlvbiAobmV3U2V0dGluZ3MsIG5ld1RlbXBsYXRlcykge1xuICAgIHZhciBjb25maWcsIGdsb2JhbENvbmZpZywgbmFtZSQkMSwgb3JpZ2luYWxUZW1wbGF0ZXMsIG91dHB1dFNldHRpbmdzLCBvdXRwdXRUZW1wbGF0ZXMsIHJlZiwgdGVtcGxhdGVzLCB0eXBlO1xuXG4gICAgaWYgKCFJUy5vYmplY3QobmV3U2V0dGluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1aWNrRmllbGQgQ29uZmlnOiBpbnZhbGlkIGNvbmZpZyBvYmplY3QgcHJvdmlkZWQgJHtTdHJpbmcobmV3U2V0dGluZ3MpfWApO1xuICAgIH1cblxuICAgIG91dHB1dFNldHRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAodHlwZSBpbiBuZXdTZXR0aW5ncykge1xuICAgICAgY29uZmlnID0gbmV3U2V0dGluZ3NbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlID09PSAnZ2xvYmFsJykge1xuICAgICAgICBvdXRwdXRTZXR0aW5ncy5nbG9iYWxEZWZhdWx0cyA9IGV4dGVuZC5kZWVwLm5vdERlZXAoRmllbGQuc2hhbGxvd1NldHRpbmdzKS5jbG9uZShGaWVsZC5wcm90b3R5cGUuZ2xvYmFsRGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgICB9IGVsc2UgaWYgKEZpZWxkW3R5cGVdKSB7XG4gICAgICAgIG91dHB1dFNldHRpbmdzW3R5cGVdID0gZXh0ZW5kLmNsb25lLmRlZXAubm90RGVlcChGaWVsZC5zaGFsbG93U2V0dGluZ3MpKEZpZWxkW3R5cGVdLnByb3RvdHlwZS5kZWZhdWx0cywgY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSVMub2JqZWN0KG5ld1RlbXBsYXRlcykpIHtcbiAgICAgIG91dHB1dFRlbXBsYXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBnbG9iYWxDb25maWcgPSBuZXdUZW1wbGF0ZXMuZ2xvYmFsO1xuXG4gICAgICBpZiAoZ2xvYmFsQ29uZmlnICYmIGdsb2JhbENvbmZpZy5maWVsZCAmJiAhZ2xvYmFsQ29uZmlnLmRlZmF1bHQpIHtcbiAgICAgICAgZ2xvYmFsQ29uZmlnLmRlZmF1bHQgPSBnbG9iYWxDb25maWcuZmllbGQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodHlwZSBpbiBGaWVsZCkge1xuICAgICAgICBvcmlnaW5hbFRlbXBsYXRlcyA9IChyZWYgPSBGaWVsZFt0eXBlXS5wcm90b3R5cGUpICE9IG51bGwgPyByZWYudGVtcGxhdGVzIDogdm9pZCAwO1xuICAgICAgICB0ZW1wbGF0ZXMgPSBuZXdUZW1wbGF0ZXNbdHlwZV0gfHwgZ2xvYmFsQ29uZmlnO1xuXG4gICAgICAgIGlmICghb3JpZ2luYWxUZW1wbGF0ZXMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVtcGxhdGVzKSB7XG4gICAgICAgICAgb3V0cHV0VGVtcGxhdGVzW3R5cGVdID0gb3JpZ2luYWxUZW1wbGF0ZXM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGVtcGxhdGVzLmZpZWxkICYmICF0ZW1wbGF0ZXMuZGVmYXVsdCkge1xuICAgICAgICAgIHRlbXBsYXRlcy5kZWZhdWx0ID0gdGVtcGxhdGVzLmZpZWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0VGVtcGxhdGVzW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBmb3IgKG5hbWUkJDEgaW4gdGVtcGxhdGVzKSB7XG4gICAgICAgICAgY29uZmlnID0gdGVtcGxhdGVzW25hbWUkJDFdO1xuXG4gICAgICAgICAgaWYgKG5hbWUkJDEgPT09ICdmaWVsZCcgfHwgIW9yaWdpbmFsVGVtcGxhdGVzW25hbWUkJDFdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2xvYmFsQ29uZmlnICYmIGdsb2JhbENvbmZpZ1tuYW1lJCQxXSkge1xuICAgICAgICAgICAgY29uZmlnID0gZXh0ZW5kLmNsb25lLmRlZXAuY29uY2F0KGdsb2JhbENvbmZpZ1tuYW1lJCQxXSwgY29uZmlnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdXRwdXRUZW1wbGF0ZXNbdHlwZV1bbmFtZSQkMV0gPSBvcmlnaW5hbFRlbXBsYXRlc1tuYW1lJCQxXS5leHRlbmQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobmFtZSQkMSBpbiBvcmlnaW5hbFRlbXBsYXRlcykge1xuICAgICAgICAgIGNvbmZpZyA9IG9yaWdpbmFsVGVtcGxhdGVzW25hbWUkJDFdO1xuXG4gICAgICAgICAgaWYgKCFvdXRwdXRUZW1wbGF0ZXNbdHlwZV1bbmFtZSQkMV0pIHtcbiAgICAgICAgICAgIG91dHB1dFRlbXBsYXRlc1t0eXBlXVtuYW1lJCQxXSA9IGNvbmZpZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQnVpbGRlcihvdXRwdXRTZXR0aW5ncywgb3V0cHV0VGVtcGxhdGVzKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVpbGRlciwgJ2ZpZWxkcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleHRlbmQuY2xvbmUub3duLm5vdEtleXMoJ2luc3RhbmNlcycpKEZpZWxkKTtcbiAgICB9XG4gIH0pO1xuICBidWlsZGVyLnNldHRpbmdPdmVycmlkZXMgPSBzZXR0aW5nT3ZlcnJpZGVzO1xuICBidWlsZGVyLnRlbXBsYXRlT3ZlcnJpZGVzID0gdGVtcGxhdGVPdmVycmlkZXM7XG4gIGJ1aWxkZXIudmVyc2lvbiA9IHZlcnNpb247XG4gIGJ1aWxkZXIuRmllbGQgPSBGaWVsZDtcbiAgcmV0dXJuIGJ1aWxkZXI7XG59O1xuLy8gaW1wb3J0IE51bWJlckZpZWxkIGZyb20gJy4vZmllbGRzL251bWJlcidcbi8vIGltcG9ydCBTZWxlY3RGaWVsZCBmcm9tICcuL2ZpZWxkcy9zZWxlY3QnXG4vLyBpbXBvcnQgQ2hvaWNlRmllbGQgZnJvbSAnLi9maWVsZHMvY2hvaWNlJ1xuLy8gaW1wb3J0IFRydWVmYWxzZUZpZWxkIGZyb20gJy4vZmllbGRzL3RydWVmYWxzZSdcbi8vIGltcG9ydCBUb2dnbGVGaWVsZCBmcm9tICcuL2ZpZWxkcy90b2dnbGUnXG4vLyBpbXBvcnQgR3JvdXBGaWVsZCBmcm9tICcuL2ZpZWxkcy9ncm91cCdcbi8vIGltcG9ydCBSZXBlYXRlckZpZWxkIGZyb20gJy4vZmllbGRzL3JlcGVhdGVyJ1xuLy8gaW1wb3J0IEZpbGVGaWVsZCBmcm9tICcuL2ZpZWxkcy9maWxlJ1xuLy8gaW1wb3J0IENoZWNrYm94RmllbGQgZnJvbSAnLi9maWVsZHMvY2hlY2tib3gnXG5cbnF1aWNrZmllbGQgPSBjcmVhdGVCdWlsZGVyKCk7XG5xdWlja2ZpZWxkLnJlZ2lzdGVyKCd0ZXh0JywgVGV4dEZpZWxkKTsgLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAndGV4dGFyZWEnLCBUZXh0YXJlYUZpZWxkXG4vLyBxdWlja2ZpZWxkLnJlZ2lzdGVyICdudW1iZXInLCBOdW1iZXJGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAnc2VsZWN0JywgU2VsZWN0RmllbGRcbi8vIHF1aWNrZmllbGQucmVnaXN0ZXIgJ2Nob2ljZScsIENob2ljZUZpZWxkXG4vLyBxdWlja2ZpZWxkLnJlZ2lzdGVyICd0cnVlZmFsc2UnLCBUcnVlZmFsc2VGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAndG9nZ2xlJywgVG9nZ2xlRmllbGRcbi8vIHF1aWNrZmllbGQucmVnaXN0ZXIgJ2dyb3VwJywgR3JvdXBGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAncmVwZWF0ZXInLCBSZXBlYXRlckZpZWxkXG4vLyBxdWlja2ZpZWxkLnJlZ2lzdGVyICdjaGVja2JveCcsIEZpbGVGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAnZmlsZScsIENoZWNrYm94RmllbGRcblxudmFyIHF1aWNrZmllbGQkMSA9IHF1aWNrZmllbGQ7ZXhwb3J0IGRlZmF1bHQgcXVpY2tmaWVsZCQxOyIsInZhciBkZWZhdWx0cyA9IHtcbiAgcGxhY2Vob2xkZXI6IHRydWUsXG4gIHZhbGlkV2hlblJlZ2V4OiBmYWxzZSxcbiAgYXV0b1dpZHRoOiBmYWxzZSxcbiAgYXV0b0hlaWdodDogdHJ1ZSxcbiAgbWluSGVpZ2h0OiA0NixcbiAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgbWF4SGVpZ2h0OiAyZTMwOCxcbiAgbWluV2lkdGg6IDIsXG4gIG1pbkxlbmd0aDogbnVsbCxcbiAgbWF4TGVuZ3RoOiBudWxsLFxuICBjb3VudGVyOiBmYWxzZVxufTsgLy8gZHJvcGRvd246IHtzdG9yZVNlbGVjdGVkOmZhbHNlLCBsb2NrU2Nyb2xsOmZhbHNlfVxuLy8gY2hvaWNlczogbnVsbFxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQge3Nob3J0aGFuZFNpZGVWYWx1ZX1mcm9tJy4uLy4uL2hlbHBlcnMuanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQge2EgYXMgdGV4dEZpZWxkVGVtcGxhdGV9ZnJvbScuLi90ZXh0L3RlbXBsYXRlLTIzM2U5NDEzLmpzJzt2YXIgdGVtcGxhdGUgPSB0ZXh0RmllbGRUZW1wbGF0ZS5leHRlbmQoe1xuICBjaGlsZHJlbjoge1xuICAgICdpbm5lcndyYXAnOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgIGhlaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MubWluSGVpZ2h0IHx8IDQ2O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2lkdGg6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZC5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcxMDAlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdsYWJlbCc6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBsZWZ0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGhhbmRTaWRlVmFsdWUoZmllbGQuc2V0dGluZ3MucGFkZGluZywgJ2xlZnQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvcDogJzcuNnB4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnaW5wdXQnOiB7XG4gICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHJlc2l6ZTogJ25vbmUnLFxuICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgaGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYGNhbGMoMTAwJSAtICR7dGhpcy5zdHlsZVNhZmUoJ21hcmdpblRvcCcsIHRydWUpfSAtICR7dGhpcy5zdHlsZVNhZmUoJ21hcmdpbkJvdHRvbScsIHRydWUpfSlgO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFyZ2luOiAnMCcsXG4gICAgICAgICAgbWFyZ2luVG9wOiAnMTVweCcsXG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAnMTJweCcsXG4gICAgICAgICAgcGFkZGluZzogJzAgMTJweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3BsYWNlaG9sZGVyJzoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcGFkZGluZzogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgaG9yaXosIHZlcnRpO1xuICAgICAgICAgICAgaG9yaXogPSBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ3BhZGRpbmdMZWZ0JywgdHJ1ZSkgfHwgZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVTYWZlKCdwYWRkaW5nTGVmdCcpO1xuICAgICAgICAgICAgdmVydGkgPSBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ21hcmdpblRvcCcsIHRydWUpIHx8IGZpZWxkLmVsLmNoaWxkLmlucHV0LnN0eWxlU2FmZSgnbWFyZ2luVG9wJyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dmVydGl9ICR7aG9yaXp9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xudmFyIGNvdW50ZXIgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2NvdW50ZXInLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGJvdHRvbTogLTEwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGZvbnRTaXplOiAxMCxcbiAgICBmb250V2VpZ2h0OiA1MDBcbiAgfVxufV0pO3ZhciB0ZW1wbGF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDogdGVtcGxhdGUsY291bnRlcjogY291bnRlcn0pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBiLGNvdW50ZXIgYXMgY307IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7aW5oZXJpdFByb3RvfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0J3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2tleUNvZGVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NoZWNrbWFyay5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9hbmdsZURvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXRVcC5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldERvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvcGx1cy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jbG9uZS5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9yZW1vdmUuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL3RlbXBsYXRlLWI5NjFmODFmLmpzJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9kcm9wZG93bi9kZWZhdWx0cy5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vaW5kZXguanMnO2ltcG9ydCd0ZXh0LW1hc2stY29yZSc7aW1wb3J0J3RleHQtbWFzay1hZGRvbnMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL21hc2suanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQnLi4vdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyc7aW1wb3J0Jy4uL3RleHQvZGVmYXVsdHMuanMnO2ltcG9ydCBUZXh0RmllbGQgZnJvbScuLi90ZXh0L2luZGV4LmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYiBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLTY1ZmVkYTA1LmpzJzt2YXIgVGV4dGFyZWFGaWVsZDtcblxuVGV4dGFyZWFGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgVGV4dGFyZWFGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUuaGVpZ2h0ID0gdGhpcy5zZXR0aW5ncy5hdXRvSGVpZ2h0ID8gJ2F1dG8nIDogdGhpcy5zZXR0aW5ncy5oZWlnaHQ7XG4gICAgICB0aGlzLnN0YXRlLnR5cGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJzb3IgPSB7XG4gICAgICAgIHByZXY6IDAsXG4gICAgICAgIGN1cnJlbnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIF9zZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgaWYgKElTLnN0cmluZyhuZXdWYWx1ZSkgfHwgSVMubnVtYmVyKG5ld1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSBTdHJpbmcobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWNhbGNEaXNwbGF5KCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b0hlaWdodCB8fCB0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgZm9yY2VPcHRzO1xuICAgICAgZm9yY2VPcHRzID0ge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH07XG4gICAgICB0aGlzLmVsID0gdGhpcy50ZW1wbGF0ZS5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5kZWZhdWx0cywgZm9yY2VPcHRzKTtcbiAgICAgIHRoaXMuZWwuc3RhdGUoJ2hhc0xhYmVsJywgdGhpcy5zZXR0aW5ncy5sYWJlbCk7XG4gICAgICB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5fcXVpY2tGaWVsZCA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXlfYXV0b1dpZHRoKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXlfYXV0b0hlaWdodCgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc192YWx1ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19hdXRvY29tcGxldGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9IZWlnaHQoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdoZWlnaHQnLCB7XG4gICAgICAgIHVwZGF0ZUV2ZW5JZlNhbWU6IHRydWVcbiAgICAgIH0pLm9mKHRoaXMuc3RhdGUpLnRyYW5zZm9ybVNlbGYoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgJiYgaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuICdhdXRvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pLnRvKGhlaWdodCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5zdHlsZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgIH0pLnVwZGF0ZU9uKCdldmVudDppbnNlcnRlZCcpLm9mKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScsIHtcbiAgICAgICAgICB1cGRhdGVFdmVuSWZTYW1lOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgICAgfSkub2YodGhpcykudG8oJ2hlaWdodCcpLm9mKHRoaXMuc3RhdGUpLnRyYW5zZm9ybSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldElucHV0QXV0b0hlaWdodCgpO1xuICAgICAgICB9KS51cGRhdGVPbignZXZlbnQ6aW5zZXJ0ZWQnKS5vZih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvV2lkdGgoKSB7XG4gICAgICBTaW1wbHlCaW5kKCd3aWR0aCcsIHtcbiAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZVxuICAgICAgfSkub2YodGhpcy5zdGF0ZSkudG8od2lkdGggPT4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoID8gdGhpcy5lbC5jaGlsZC5pbm5lcndyYXAgOiB0aGlzLmVsKS5zdHlsZSgnd2lkdGgnLCB3aWR0aCk7XG4gICAgICB9KS50cmFuc2Zvcm0odGhpcy5fZm9ybWF0V2lkdGguYmluZCh0aGlzKSkudXBkYXRlT24oJ2lzTW9iaWxlJykub2YodGhpcy5zdGF0ZSk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xuICAgICAgICBTaW1wbHlCaW5kKCdfdmFsdWUnLCB7XG4gICAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZSxcbiAgICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICAgIH0pLm9mKHRoaXMpLnRvKCd3aWR0aCcpLm9mKHRoaXMuc3RhdGUpLnRyYW5zZm9ybSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldElucHV0QXV0b1dpZHRoKCk7XG4gICAgICAgIH0pLnVwZGF0ZU9uKCdldmVudDppbnNlcnRlZCcpLm9mKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc192YWx1ZSgpIHtcbiAgICAgIHZhciBpbnB1dDtcbiAgICAgIGlucHV0ID0gdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXc7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDppbnB1dCcpLm9mKGlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScpLm9mKHRoaXMpLnRvKCd2YWx1ZScpLm9mKGlucHV0KS5hbmQudG8odmFsdWUgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGxlZCA9ICEhdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbnRlcmFjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUudmFsaWQgPSB0aGlzLnZhbGlkYXRlKHZvaWQgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2F1dG9jb21wbGV0ZSgpIHt9XG5cbiAgICBfZ2V0SW5wdXRBdXRvSGVpZ2h0KCkge1xuICAgICAgdmFyIGlucHV0SGVpZ2h0LCBwcmV2SGVpZ2h0O1xuICAgICAgcHJldkhlaWdodCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnN0eWxlLmhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldFZhbHVlSWZOb3RTZXQoKTtcblxuICAgICAgICB0aGlzLmVsLmNoaWxkLmlucHV0LnN0eWxlKCdoZWlnaHQnLCAwKTtcbiAgICAgICAgaW5wdXRIZWlnaHQgPSB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5zY3JvbGxIZWlnaHQgKyAyO1xuICAgICAgICBpbnB1dEhlaWdodCArPSB0aGlzLmVsLmNoaWxkLmlucHV0LnN0eWxlUGFyc2VkKCdtYXJnaW5Ub3AnKSArIHRoaXMuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ21hcmdpbkJvdHRvbScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRIZWlnaHQgPSB0aGlzLmVsLmNoaWxkLnBsYWNlaG9sZGVyLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZSgnaGVpZ2h0JywgcHJldkhlaWdodCk7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5zZXR0aW5ncy5tYXhIZWlnaHQsIE1hdGgubWF4KGlucHV0SGVpZ2h0LCB0aGlzLnNldHRpbmdzLm1pbkhlaWdodCkpO1xuICAgIH1cblxuICAgIF9nZXRJbnB1dEF1dG9XaWR0aCgpIHtcbiAgICAgIHZhciBpbnB1dFBhZGRpbmcsIGlucHV0V2lkdGgsIGxhYmVsV2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgICB0aGlzLl9zZXRWYWx1ZUlmTm90U2V0KCk7XG5cbiAgICAgICAgdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZSh7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgICAgICAgfSkucmF3LnNjcm9sbExlZnQgPSAxZSsxMDtcbiAgICAgICAgaW5wdXRQYWRkaW5nID0gdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZVBhcnNlZCgncGFkZGluZ0xlZnQnKSB8fCB0aGlzLmVsLmNoaWxkLmlucHV0LnN0eWxlUGFyc2VkKCdwYWRkaW5nJyk7XG4gICAgICAgIGlucHV0V2lkdGggPSBNYXRoLm1heCh0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5zY3JvbGxMZWZ0ICsgdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcub2Zmc2V0V2lkdGgsIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNjcm9sbFdpZHRoKSArIDIgKyBpbnB1dFBhZGRpbmcgKyAxO1xuICAgICAgICBsYWJlbFdpZHRoID0gdGhpcy5zZXR0aW5ncy5sYWJlbCAmJiB0aGlzLmVsLmNoaWxkLmxhYmVsLnN0eWxlU2FmZSgncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJyA/IHRoaXMuZWwuY2hpbGQubGFiZWwucmVjdC53aWR0aCA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dFdpZHRoID0gdGhpcy5lbC5jaGlsZC5wbGFjZWhvbGRlci5yZWN0LndpZHRoO1xuICAgICAgICBsYWJlbFdpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZSh7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21heCcpLCBNYXRoLm1heCh0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21pbicpLCBpbnB1dFdpZHRoLCBsYWJlbFdpZHRoKSk7XG4gICAgfVxuXG4gIH1cbiAgVGV4dGFyZWFGaWVsZC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgVGV4dGFyZWFGaWVsZC5wcm90b3R5cGUudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICBUZXh0YXJlYUZpZWxkLnByb3RvdHlwZS5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICBpbmhlcml0UHJvdG8oVGV4dGFyZWFGaWVsZCwgVGV4dEZpZWxkKTtcbiAgcmV0dXJuIFRleHRhcmVhRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxudmFyIFRleHRhcmVhRmllbGQkMSA9IFRleHRhcmVhRmllbGQ7ZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWFGaWVsZCQxOyIsInZhciBkZWZhdWx0cyA9IHtcbiAgcGxhY2Vob2xkZXI6IHRydWUsXG4gIHZhbGlkV2hlbk1pbjogZmFsc2UsXG4gIHZhbGlkV2hlbk1heDogZmFsc2UsXG4gIGF1dG9XaWR0aDogZmFsc2UsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogNDYsXG4gIGJ1dHRvbnM6IHRydWUsXG4gIG1pblZhbHVlOiAtMmUzMDgsXG4gIG1heFZhbHVlOiAyZTMwOCxcbiAgc3RlcDogMSxcbiAgZW5mb3JjZTogZmFsc2UsXG4gIGlucHV0U2libGluZzogJ2J1dHRvbnMnXG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQgY2FyZXRVcCBmcm9tJy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQgY2FyZXREb3duIGZyb20nLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0IENPTE9SUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCB7YSBhcyB0ZXh0RmllbGRUZW1wbGF0ZX1mcm9tJy4uL3RleHQvdGVtcGxhdGUtMjMzZTk0MTMuanMnO3ZhciB0ZW1wbGF0ZSA9IHRleHRGaWVsZFRlbXBsYXRlLmV4dGVuZCgpO1xudmFyIHN0ZXBCdXR0b24gPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHN0YXRlVHJpZ2dlcnM6IHtcbiAgICAnYWN0aXZlJzoge1xuICAgICAgb246ICdtb3VzZWRvd24nLFxuICAgICAgb2ZmOiAnbW91c2V1cCcsXG4gICAgICBidWJibGVzOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgYXR0cnM6IHtcbiAgICB0YWJpbmRleDogLTFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogMTcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgb3V0bGluZTogJ25vbmUnLFxuICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgIGZpbGw6IENPTE9SUy5ncmV5LFxuICAgICRhY3RpdmU6IHtcbiAgICAgIGZpbGw6IENPTE9SUy5ncmV5X2RhcmtcbiAgICB9XG4gIH1cbn1dKTtcbnZhciBidXR0b25zID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdidXR0b25zJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDMsXG4gICAgdG9wOiAnNTAlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICB3aWR0aDogMTcsXG4gICAgcGFkZGluZ1JpZ2h0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmc7XG4gICAgfSxcbiAgICBvdXRsaW5lOiAnbm9uZSdcbiAgfVxufSwgc3RlcEJ1dHRvbi5leHRlbmQoe1xuICBjaGlsZHJlbjogW2NhcmV0VXBdLFxuICBvcHRpb25zOiB7XG4gICAgcmVmOiAnc3RlcFVwJ1xuICB9XG59KSwgc3RlcEJ1dHRvbi5leHRlbmQoe1xuICBjaGlsZHJlbjogW2NhcmV0RG93bl0sXG4gIG9wdGlvbnM6IHtcbiAgICByZWY6ICdzdGVwRG93bidcbiAgfVxufSldKTt2YXIgdGVtcGxhdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RlZmF1bHQ6IHRlbXBsYXRlLHN0ZXBCdXR0b246IHN0ZXBCdXR0b24sYnV0dG9uczogYnV0dG9uc30pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBiLGJ1dHRvbnMgYXMgYyxzdGVwQnV0dG9uIGFzIGR9OyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCcuLi8uLi9jaGVja3MuanMnO2ltcG9ydCdxdWlja2RvbSc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9yZWdleC5qcyc7aW1wb3J0IHtpbmhlcml0UHJvdG99ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQgZXh0ZW5kIGZyb20nc21hcnQtZXh0ZW5kJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvY29uZGl0aW9uLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvdHJhbnNmb3JtU2V0dGluZ3MuanMnO2ltcG9ydCcuLi8uLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi4vLi4vZmllbGQvaW5kZXguanMnO2ltcG9ydCBLRVlDT0RFUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9rZXlDb2Rlcy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9kcm9wZG93bi90ZW1wbGF0ZS1iOTYxZjgxZi5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vZGVmYXVsdHMuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzJztpbXBvcnQndGV4dC1tYXNrLWNvcmUnO2ltcG9ydCd0ZXh0LW1hc2stYWRkb25zJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9tYXNrLmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0Jy4uL3RleHQvdGVtcGxhdGUtMjMzZTk0MTMuanMnO2ltcG9ydCcuLi90ZXh0L2RlZmF1bHRzLmpzJztpbXBvcnQgVGV4dEZpZWxkIGZyb20nLi4vdGV4dC9pbmRleC5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7aW1wb3J0IHthIGFzIHRlbXBsYXRlLGIgYXMgdGVtcGxhdGVzLGMgYXMgYnV0dG9uc31mcm9tJy4vdGVtcGxhdGUtYzkyMmUxNjMuanMnO3ZhciBOdW1iZXJGaWVsZDtcblxuTnVtYmVyRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIE51bWJlckZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVuZm9yY2UgJiYgdGhpcy5zZXR0aW5ncy5taW5WYWx1ZSAmJiB0aGlzLnNldHRpbmdzLm1pblZhbHVlICE9PSAtMmUzMDgpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgfHwgKHRoaXMuX3ZhbHVlID0gdGhpcy5zZXR0aW5ncy5taW5WYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc3RlcCA9IE51bWJlcih0aGlzLnNldHRpbmdzLnN0ZXApIHx8IDE7XG4gICAgICB0aGlzLnN0YXRlLnR5cGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJzb3IgPSB7XG4gICAgICAgIHByZXY6IDAsXG4gICAgICAgIGN1cnJlbnQ6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLnByZWNpc2lvbiA9ICgocmVmID0gdGhpcy5zZXR0aW5ncy5zdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXSkgIT0gbnVsbCA/IHJlZi5sZW5ndGggOiB2b2lkIDApIHx8IDA7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIE51bWJlcih0aGlzLl92YWx1ZSkgfHwgMDtcbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA9IHRoaXMuX25vcm1hbGl6ZVZhbHVlKG5ld1ZhbHVlLCB0aGlzLnNldHRpbmdzLmVuZm9yY2UpO1xuICAgIH1cblxuICAgIF9jcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBnbG9iYWxPcHRzO1xuICAgICAgZ2xvYmFsT3B0cyA9IHtcbiAgICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzXG4gICAgICB9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMudGVtcGxhdGUuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuZGVmYXVsdHMsIGdsb2JhbE9wdHMpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5idXR0b25zKSB7XG4gICAgICAgIGJ1dHRvbnMuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuYnV0dG9ucywgZ2xvYmFsT3B0cykuaW5zZXJ0QWZ0ZXIodGhpcy5lbC5jaGlsZC5pbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuc3RhdGUoJ2hhc0xhYmVsJywgdGhpcy5zZXR0aW5ncy5sYWJlbCk7XG4gICAgICB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzLmVsLmNoaWxkZi5pbnB1dC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9XaWR0aCgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc192YWx1ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3N0ZXBFdmVudHMoKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfdmFsdWUoKSB7XG4gICAgICB2YXIgaW5wdXQ7XG4gICAgICBpbnB1dCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3O1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6aW5wdXQnKS5vZihpbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICB2YXIgbmV3VmFsdWUsIHNlbGVjdE51bWJlclBhcnQ7XG4gICAgICAgIHRoaXMuY3Vyc29yLnByZXYgPSB0aGlzLmN1cnNvci5jdXJyZW50O1xuICAgICAgICB0aGlzLmN1cnNvci5jdXJyZW50ID0gdGhpcy5zZWxlY3Rpb24oKS5lbmQ7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlW25ld1ZhbHVlLmxlbmd0aCAtIDFdID09PSAnLScpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5taW5WYWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IC0xO1xuICAgICAgICAgICAgc2VsZWN0TnVtYmVyUGFydCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgICBpZiAoc2VsZWN0TnVtYmVyUGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uKDEsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24odGhpcy5jdXJzb3IuY3VycmVudCwgdGhpcy5jdXJzb3IuY3VycmVudCArIChTdHJpbmcodGhpcy5fdmFsdWUpLmxlbmd0aCAtIG5ld1ZhbHVlLmxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdfdmFsdWUnKS5vZih0aGlzKS50bygndmFsdWUnKS5vZihpbnB1dCkuYW5kLnRvKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsZWQgPSAhIVN0cmluZyh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmludGVyYWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmJsdXInKS5vZihpbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmVuZm9yY2UpIHtcbiAgICAgICAgICB2YWx1ZSA9IE51bWJlcih0aGlzLl92YWx1ZSkgfHwgMDtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCAhdGhpcy5zdGF0ZS5pbnRlcmFjdGVkICYmIHZhbHVlID09PSB0aGlzLnNldHRpbmdzLm1pblZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6a2V5ZG93bicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWUNPREVTLmVudGVyKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdzdWJtaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoYGtleS0ke2V2ZW50LmtleUNvZGV9YCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3Nfc3RlcEV2ZW50cygpIHtcbiAgICAgIHZhciBzdG9wUHJvcGFnYXRpb247XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDprZXlkb3duJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oZXZlbnQgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIEtFWUNPREVTLnVwOlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBVcCgpO1xuXG4gICAgICAgICAgY2FzZSBLRVlDT0RFUy5kb3duOlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBEb3duKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5idXR0b25zKSB7XG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YodGhpcy5lbC5jaGlsZC5zdGVwVXApLnRvKHRoaXMuc3RlcFVwLmJpbmQodGhpcykpLmFuZC50byhzdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQuc3RlcERvd24pLnRvKHRoaXMuc3RlcERvd24uYmluZCh0aGlzKSkuYW5kLnRvKHN0b3BQcm9wYWdhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldFZhbHVlSWZOb3RTZXQoKSB7XG4gICAgICBpZiAoTnVtYmVyKHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX25vcm1hbGl6ZVZhbHVlKHZhbHVlLCBlbmZvcmNlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCA6IDA7XG5cbiAgICAgIGlmICh2YWx1ZSAlIHRoaXMuc2V0dGluZ3Muc3RlcCAmJiBlbmZvcmNlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IHRoaXMuc2V0dGluZ3Muc3RlcCkge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5zZXR0aW5ncy5zdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5fcm91bmRUb05lYXJlc3QodmFsdWUsIHRoaXMuc2V0dGluZ3Muc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlIDwgdGhpcy5zZXR0aW5ncy5taW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuc2V0dGluZ3MubWluVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA+IHRoaXMuc2V0dGluZ3MubWF4VmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNldHRpbmdzLm1heFZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgX3JvdW5kVG9OZWFyZXN0KHZhbHVlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyO1xuICAgICAgdmFsdWUgPSAodmFsdWUgfHwgMCkudG9GaXhlZCh0aGlzLnByZWNpc2lvbikgKiAxO1xuICAgICAgbXVsdGlwbGllciA9IHRhcmdldCA8IDEgPyAxIC8gdGFyZ2V0IDogMTtcbiAgICAgIHRhcmdldCAqPSBtdWx0aXBsaWVyO1xuICAgICAgdmFsdWUgKj0gbXVsdGlwbGllcjtcbiAgICAgIHZhbHVlID0gTWF0aC5jZWlsKHZhbHVlIC8gdGFyZ2V0KSAqIHRhcmdldCAvIG11bHRpcGxpZXI7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RlcFVwKCkge1xuICAgICAgdmFyIG5ld1ZhbHVlLCByb3VuZGVkO1xuICAgICAgcm91bmRlZCA9IHRoaXMuX3JvdW5kVG9OZWFyZXN0KHRoaXMuX3ZhbHVlLCB0aGlzLnNldHRpbmdzLnN0ZXApO1xuICAgICAgbmV3VmFsdWUgPSBNYXRoLm1pbihyb3VuZGVkICsgdGhpcy5zZXR0aW5ncy5zdGVwLCB0aGlzLl92YWx1ZSArIHRoaXMuc2V0dGluZ3Muc3RlcCk7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0VmFsdWUodGhpcy5fcm91bmRUb05lYXJlc3QobmV3VmFsdWUsIHRoaXMuc2V0dGluZ3Muc3RlcCkpO1xuICAgIH1cblxuICAgIHN0ZXBEb3duKCkge1xuICAgICAgdmFyIG5ld1ZhbHVlLCByb3VuZGVkO1xuICAgICAgcm91bmRlZCA9IHRoaXMuX3JvdW5kVG9OZWFyZXN0KHRoaXMuX3ZhbHVlLCB0aGlzLnNldHRpbmdzLnN0ZXApO1xuICAgICAgbmV3VmFsdWUgPSBNYXRoLm1heChyb3VuZGVkIC0gdGhpcy5zZXR0aW5ncy5zdGVwLCB0aGlzLl92YWx1ZSAtIHRoaXMuc2V0dGluZ3Muc3RlcCk7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0VmFsdWUodGhpcy5fcm91bmRUb05lYXJlc3QobmV3VmFsdWUsIHRoaXMuc2V0dGluZ3Muc3RlcCkpO1xuICAgIH1cblxuICB9XG4gIE51bWJlckZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBOdW1iZXJGaWVsZC5wcm90b3R5cGUudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICBOdW1iZXJGaWVsZC5wcm90b3R5cGUuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgaW5oZXJpdFByb3RvKE51bWJlckZpZWxkLCBUZXh0RmllbGQpO1xuICByZXR1cm4gTnVtYmVyRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxuZXh0ZW5kLm5vdEtleXMoTnVtYmVyRmllbGQucHJvdG90eXBlKShOdW1iZXJGaWVsZC5wcm90b3R5cGUsIFRleHRGaWVsZC5wcm90b3R5cGUpO1xudmFyIE51bWJlckZpZWxkJDEgPSBOdW1iZXJGaWVsZDtleHBvcnQgZGVmYXVsdCBOdW1iZXJGaWVsZCQxOyIsInZhciBkZWZhdWx0cyA9IHtcbiAgcGxhY2Vob2xkZXI6IHRydWUsXG4gIHZhbGlkV2hlbklzQ2hvaWNlOiBmYWxzZSxcbiAgdmFsaWRXaGVuUmVnZXg6IGZhbHNlLFxuICB2YWxpZFdoZW5DaG9zZU1pbjogMmUzMDgsXG4gIGF1dG9XaWR0aDogZmFsc2UsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogNDYsXG4gIGxhYmVsRmlsdGVyOiBudWxsLFxuICBjaG9pY2VzOiBbXSxcbiAgbXVsdGlwbGU6IGZhbHNlLFxuICBkcm9wZG93bjoge1xuICAgIHR5cGVCdWZmZXI6IHRydWVcbiAgfSxcbiAgaW5wdXRTaWJsaW5nOiAnY2FyZXQnXG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCdxdWlja2RvbSc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCBjYXJldERvd24gZnJvbScuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0IHthIGFzIHRleHRGaWVsZFRlbXBsYXRlfWZyb20nLi4vdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyc7dmFyIHRlbXBsYXRlID0gdGV4dEZpZWxkVGVtcGxhdGUuZXh0ZW5kKHtcbiAgY2hpbGRyZW46IHtcbiAgICBpbm5lcndyYXA6IHtcbiAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICdpbnB1dCc6IFsnZGl2Jywge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0YWJJbmRleDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG1hcmdpblRvcDogMyxcbiAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgICAvLyBvdmVyZmxvdzogJ3Njcm9sbCdcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgICdjYXJldCc6IFsnZGl2Jywge1xuICAgICAgICAgIHJlZjogJ2NhcmV0JyxcbiAgICAgICAgICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIHpJbmRleDogMyxcbiAgICAgICAgICAgIHRvcDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5zdHlsZVBhcnNlZCgnaGVpZ2h0JywgdHJ1ZSkgLyAyIC0gdGhpcy5zdHlsZVBhcnNlZCgnaGVpZ2h0JykgLyAyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgd2lkdGg6IDE3LFxuICAgICAgICAgICAgaGVpZ2h0OiAxNyxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICBmaWxsOiBDT0xPUlMuZ3JleVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgY2FyZXREb3duXVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7dmFyIHRlbXBsYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZhdWx0OiB0ZW1wbGF0ZX0pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBifTsiLCJpbXBvcnQnQGRhbmllbGthbGVuL2lzJztpbXBvcnQgSVMgZnJvbScuLi8uLi9jaGVja3MuanMnO2ltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9yZWdleC5qcyc7aW1wb3J0IHtpbmhlcml0UHJvdG8saW5jbHVkZXN9ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQnc21hcnQtZXh0ZW5kJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvY29uZGl0aW9uLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvdHJhbnNmb3JtU2V0dGluZ3MuanMnO2ltcG9ydCcuLi8uLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi4vLi4vZmllbGQvaW5kZXguanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMva2V5Q29kZXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2FuZ2xlRG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vdGVtcGxhdGUtYjk2MWY4MWYuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2RlZmF1bHRzLmpzJztpbXBvcnQgRHJvcGRvd24se0Nob2ljZX1mcm9tJy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vaW5kZXguanMnO2ltcG9ydCd0ZXh0LW1hc2stY29yZSc7aW1wb3J0J3RleHQtbWFzay1hZGRvbnMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL21hc2suanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQnLi4vdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyc7aW1wb3J0Jy4uL3RleHQvZGVmYXVsdHMuanMnO2ltcG9ydCBUZXh0RmllbGQgZnJvbScuLi90ZXh0L2luZGV4LmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYiBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLTZiYmNkZGQwLmpzJzt2YXIgU2VsZWN0RmllbGQ7XG5cblNlbGVjdEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBjbGFzcyBTZWxlY3RGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHZhciBiYXNlO1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuZHJvcGRvd24ubXVsdGlwbGUgPSB0aGlzLnNldHRpbmdzLm11bHRpcGxlO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tdWx0aXBsZSkge1xuICAgICAgICBpZiAoKGJhc2UgPSB0aGlzLnNldHRpbmdzLmRyb3Bkb3duKS5oZWxwID09IG51bGwpIHtcbiAgICAgICAgICBiYXNlLmhlbHAgPSAnVGlwOiBwcmVzcyBFU0MgdG8gY2xvc2UgdGhpcyBtZW51JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuc2V0dGluZ3MubXVsdGlwbGUgPyBbXSA6IG51bGw7XG4gICAgICB0aGlzLmRyb3Bkb3duID0gbmV3IERyb3Bkb3duKHRoaXMuc2V0dGluZ3MuY2hvaWNlcywgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgdmFyIHJlZjtcblxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiAocmVmID0gdGhpcy5fdmFsdWUpICE9IG51bGwgPyByZWYudmFsdWUgOiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUubWFwKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgICByZXR1cm4gY2hvaWNlLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHZhciBpLCBsZW4sIHZhbHVlO1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubXVsdGlwbGUgfHwgIUlTLmFycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgICB0aGlzLnNldENob2ljZShuZXdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBuZXdWYWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWVbaV07XG4gICAgICAgICAgdGhpcy5zZXRDaG9pY2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlY2FsY0Rpc3BsYXkoKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVMYWJlbCA9IHRoaXMudmFsdWVMYWJlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgZm9yY2VPcHRzO1xuICAgICAgZm9yY2VPcHRzID0ge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH07XG4gICAgICB0aGlzLmVsID0gdGhpcy50ZW1wbGF0ZS5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5kZWZhdWx0LCBmb3JjZU9wdHMpO1xuICAgICAgdGhpcy5kcm9wZG93bi5hcHBlbmRUbyh0aGlzLmVsLmNoaWxkLmlubmVyd3JhcCk7XG4gICAgICB0aGlzLmVsLmNoaWxkLnBsYWNlaG9sZGVyLmluc2VydEJlZm9yZSh0aGlzLmVsLmNoaWxkLmlucHV0KTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubGFiZWwpIHtcbiAgICAgICAgdGhpcy5lbC5jaGlsZC5sYWJlbC50ZXh0ID0gdGhpcy5zZXR0aW5ncy5sYWJlbDtcbiAgICAgICAgdGhpcy5lbC5zdGF0ZSgnaGFzTGFiZWwnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbC5jaGlsZC5pbm5lcndyYXAucmF3Ll9xdWlja0ZpZWxkID0gdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfdmFsdWUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9XaWR0aCgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kcm9wZG93bigpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXlfYXV0b1dpZHRoKCkge1xuICAgICAgU2ltcGx5QmluZCgnd2lkdGgnLCB7XG4gICAgICAgIHVwZGF0ZUV2ZW5JZlNhbWU6IHRydWVcbiAgICAgIH0pLm9mKHRoaXMuc3RhdGUpLnRvKHdpZHRoID0+IHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCA/IHRoaXMuZWwuY2hpbGQuaW5wdXQgOiB0aGlzLmVsKS5zdHlsZSh7XG4gICAgICAgICAgd2lkdGhcbiAgICAgICAgfSk7XG4gICAgICB9KS50cmFuc2Zvcm0odGhpcy5fZm9ybWF0V2lkdGguYmluZCh0aGlzKSkudXBkYXRlT24oJ2lzTW9iaWxlJykub2YodGhpcy5zdGF0ZSk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xuICAgICAgICBTaW1wbHlCaW5kKCd2YWx1ZUxhYmVsJywge1xuICAgICAgICAgIHVwZGF0ZUV2ZW5JZlNhbWU6IHRydWUsXG4gICAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgICB9KS5vZih0aGlzKS50bygnd2lkdGgnKS5vZih0aGlzLnN0YXRlKS50cmFuc2Zvcm0oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnB1dEF1dG9XaWR0aCgpO1xuICAgICAgICB9KS51cGRhdGVPbignZXZlbnQ6aW5zZXJ0ZWQnKS5vZih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0SW5wdXRBdXRvV2lkdGgoKSB7XG4gICAgICB2YXIgaW5wdXRXaWR0aCwgbGFiZWxXaWR0aDtcblxuICAgICAgaWYgKHRoaXMudmFsdWVMYWJlbCkge1xuICAgICAgICB0aGlzLmVsLmNoaWxkLmlucHV0LnN0eWxlKCd3aWR0aCcsIDApO1xuICAgICAgICBpbnB1dFdpZHRoID0gdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcuc2Nyb2xsV2lkdGggKyAyO1xuICAgICAgICBsYWJlbFdpZHRoID0gdGhpcy5lbC5jaGlsZC5sYWJlbC5zdHlsZVNhZmUoJ3Bvc2l0aW9uJykgPT09ICdhYnNvbHV0ZScgPyB0aGlzLmVsLmNoaWxkLmxhYmVsLnJlY3Qud2lkdGggOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRXaWR0aCA9IHRoaXMuZWwuY2hpbGQucGxhY2Vob2xkZXIucmVjdC53aWR0aDtcbiAgICAgICAgbGFiZWxXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLm1heChpbnB1dFdpZHRoLCBsYWJlbFdpZHRoKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfdmFsdWUoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdhcnJheTpfdmFsdWUnKS5vZih0aGlzKS50byhzZWxlY3RlZCA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbGVkID0gdGhpcy5zZXR0aW5ncy5tdWx0aXBsZSA/ICEhKHNlbGVjdGVkICE9IG51bGwgPyBzZWxlY3RlZC5sZW5ndGggOiB2b2lkIDApIDogISFzZWxlY3RlZDtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5maWxsZWQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmludGVyYWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnaW5wdXQnLCB0aGlzLnZhbHVlKTtcbiAgICAgIH0pLmFuZC50bygndmFsdWVMYWJlbCcpLm9mKHRoaXMpLnRyYW5zZm9ybShzZWxlY3RlZCA9PiB7XG4gICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZC5tYXAoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlLmxhYmVsO1xuICAgICAgICAgICAgfSkuam9pbignLCAnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkLmxhYmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCd2YWx1ZUxhYmVsJykub2YodGhpcykudG8oJ3RleHQnKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50cmFuc2Zvcm0obGFiZWwgPT4ge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sYWJlbEZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmxhYmVsRm9ybWF0KGxhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kcm9wZG93bigpIHtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oZXZlbnQgPT4ge1xuICAgICAgICB2YXIgZXNjTGlzdGVuZXI7XG5cbiAgICAgICAgaWYgKCEodGhpcy5zdGF0ZS5kaXNhYmxlZCB8fCB0aGlzLmRyb3Bkb3duLmNob2ljZXMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgIHRoaXMuZHJvcGRvd24uaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgRE9NKGRvY3VtZW50KS5vbignY2xpY2suZHJvcGRvd24nLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoRE9NKGV2ZW50LnRhcmdldCkucGFyZW50TWF0Y2hpbmcocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCA9PT0gdGhpcy5lbC5jaGlsZC5pbm5lcndyYXA7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgIGVzY0xpc3RlbmVyID0gU2ltcGx5QmluZCgnZXZlbnQ6a2V5ZG93bicpLm9mKGRvY3VtZW50KS5vbmNlLnRvKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgIH0pLmNvbmRpdGlvbihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5rZXlDb2RlID09PSAyNztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gU2ltcGx5QmluZCgnaXNPcGVuJywge1xuICAgICAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgICAgIH0pLm9mKHRoaXMuZHJvcGRvd24pLm9uY2UudG8oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXNjTGlzdGVuZXIudW5CaW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gRE9NKGRvY3VtZW50KS5vZmYoJ2NsaWNrLmRyb3Bkb3duJyk7XG4gICAgICAgICAgfSkuY29uZGl0aW9uKGZ1bmN0aW9uIChpc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNPcGVuO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YodGhpcy5lbC5jaGlsZC5pbm5lcndyYXApLnRvKGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmlucHV0LmVtaXRQcml2YXRlKCdjbGljaycpO1xuICAgICAgfSkuY29uZGl0aW9uKGV2ZW50ID0+IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5lbC5jaGlsZC5pbm5lcndyYXAucmF3O1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdmb2N1c2VkJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzLnN0YXRlKS50byhmb2N1c2VkID0+IHtcbiAgICAgICAgdmFyIHRyaWdnZXJpbmdLZXljb2RlcztcblxuICAgICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5pbnB1dC5vZmYoJ2tleWRvd24uZHJvcGRvd25UcmlnZ2VyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJpZ2dlcmluZ0tleWNvZGVzID0gWzMyLCAzNywgMzgsIDM5LCA0MF07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuaW5wdXQub24oJ2tleWRvd24uZHJvcGRvd25UcmlnZ2VyJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdmFyIHJlZjtcblxuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKHRyaWdnZXJpbmdLZXljb2RlcywgZXZlbnQua2V5Q29kZSkgJiYgIXRoaXMuZHJvcGRvd24uaXNPcGVuKSB7XG4gICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoKHJlZiA9IHRoaXMuZHJvcGRvd24ubGFzdFNlbGVjdGVkKSAhPSBudWxsID8gcmVmLnNlbGVjdGVkIDogdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQgPSB0aGlzLmRyb3Bkb3duLmxhc3RTZWxlY3RlZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA5ICYmIHRoaXMuZHJvcGRvd24uaXNPcGVuKSB7XG4gICAgICAgICAgICAgIC8vIFByZXZlbnQgdGFiIGtleVxuICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRyb3Bkb3duLm9uU2VsZWN0ZWQoY2hvaWNlID0+IHtcbiAgICAgICAgaWYgKCEoY2hvaWNlLnNlbGVjdGVkICYmICF0aGlzLnNldHRpbmdzLm11bHRpcGxlKSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBjaG9pY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKSB7XG4gICAgICAvLyMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIyBTdGF0ZSBldmVudCB0cmlnZ2Vyc1xuICAgICAgLy8jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IFxuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6bW91c2VlbnRlcicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50Om1vdXNlbGVhdmUnKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhvdmVyZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Zm9jdXMnKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUuZm9jdXNlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Ymx1cicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlKHByb3ZpZGVkVmFsdWUpIHtcbiAgICAgIHZhciBtYXRjaGluZ0Nob2ljZSwgcmVmLCByZWYxO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleCAmJiBJUy5yZWdleCh0aGlzLnNldHRpbmdzLnZhbGlkV2hlblJlZ2V4KSkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhdGhpcy5zZXR0aW5ncy5tdWx0aXBsZTpcbiAgICAgICAgICAgIGlmICghKCgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkQ2hvaWNlcztcblxuICAgICAgICAgICAgICBpZiAocHJvdmlkZWRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWxpZENob2ljZXMgPSBwcm92aWRlZFZhbHVlLmZpbHRlcihjaG9pY2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnZhbGlkV2hlblJlZ2V4LnRlc3QoY2hvaWNlKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuQ2hvc2VNaW4gPT09IDJlMzA4IHx8ICFJUy5udW1iZXIodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5DaG9zZU1pbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRDaG9pY2VzLmxlbmd0aCA9PT0gcHJvdmlkZWRWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkQ2hvaWNlcy5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5DaG9zZU1pbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleC50ZXN0KHByb3ZpZGVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkV2hlbklzQ2hvaWNlICYmICgocmVmID0gdGhpcy5kcm9wZG93bi5jaG9pY2VzKSAhPSBudWxsID8gcmVmLmxlbmd0aCA6IHZvaWQgMCkpIHtcbiAgICAgICAgbWF0Y2hpbmdDaG9pY2UgPSB0aGlzLmRyb3Bkb3duLmNob2ljZXMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlID09PSBwcm92aWRlZFZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoISEhbWF0Y2hpbmdDaG9pY2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm11bHRpcGxlICYmIC0xID4gKHJlZjEgPSB0aGlzLnNldHRpbmdzLnZhbGlkV2hlbkNob3NlTWluKSAmJiByZWYxIDwgMmUzMDgpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlZFZhbHVlLmxlbmd0aCA+PSB0aGlzLnNldHRpbmdzLnZhbGlkV2hlbkNob3NlTWluKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm11bHRpcGxlICYmIHRoaXMuc2V0dGluZ3MucmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhZGRDaG9pY2UoY2hvaWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi5hZGRDaG9pY2UoY2hvaWNlKTtcbiAgICB9XG5cbiAgICBzZXRDaG9pY2UoY2hvaWNlKSB7XG4gICAgICB2YXIgbWF0Y2gsIHJlZjtcblxuICAgICAgaWYgKElTLm9iamVjdChjaG9pY2UpICYmIGNob2ljZSBpbnN0YW5jZW9mIENob2ljZSkge1xuICAgICAgICByZXR1cm4gY2hvaWNlLnRvZ2dsZSgpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHRoaXMuZHJvcGRvd24uZmluZENob2ljZUFueShjaG9pY2UpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaC50b2dnbGUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMuYWRkQ2hvaWNlKGNob2ljZSkpICE9IG51bGwgPyByZWYudG9nZ2xlKHRydWUpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICB9XG4gIFNlbGVjdEZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBTZWxlY3RGaWVsZC5wcm90b3R5cGUudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICBTZWxlY3RGaWVsZC5wcm90b3R5cGUuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgU2VsZWN0RmllbGQucHJvdG90eXBlLmNvcmVWYWx1ZVByb3AgPSAndmFsdWUnO1xuICByZXR1cm4gU2VsZWN0RmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxuaW5oZXJpdFByb3RvKFNlbGVjdEZpZWxkLCBUZXh0RmllbGQsIFsnX2dldE1heFdpZHRoJywgJ19hdHRhY2hCaW5kaW5nc19lbFN0YXRlJywgJ19hdHRhY2hCaW5kaW5nc19kaXNwbGF5JywgJ2ZvY3VzJywgJ2JsdXInXSk7XG52YXIgU2VsZWN0RmllbGQkMSA9IFNlbGVjdEZpZWxkO2V4cG9ydCBkZWZhdWx0IFNlbGVjdEZpZWxkJDE7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7dmFyIHRlbXBsYXRlID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdmaWVsZCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zdGF0ZS53aWR0aDtcbiAgICB9LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGZvbnRGYW1pbHk6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmZvbnRGYW1pbHk7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAkdmlzaWJsZToge1xuICAgICAgJGhhc1Zpc2libGVDaG9pY2VzOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICB9XG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBhbmltYXRpb246ICcwLjJzIGZpZWxkRXJyb3JTaGFrZSdcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlOiB7XG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIG1hcmdpbkJvdHRvbTogJzEycHgnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzEzcHgnLFxuICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICBjb2xvcjogQ09MT1JTLmJsYWNrLFxuICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHNob3dMYWJlbDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaW5uZXJ3cmFwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCdcbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdoZWxwJyxcbiAgc3R5bGU6IHtcbiAgICBtYXJnaW5Ub3A6ICcxMHB4JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICBjb2xvcjogQ09MT1JTLmdyZXksXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMucmVkLFxuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dIZWxwOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9XG59XV0pO1xudmFyIGNob2ljZUdyb3VwID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdjaG9pY2VHcm91cCcsXG4gIHN0eWxlOiB7XG4gICAgbWFyZ2luQm90dG9tOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zcGFjaW5nO1xuICAgIH0sXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgIGZvbnRTaXplOiAnMCcsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfVxufV0pO1xudmFyIGNob2ljZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnY2hvaWNlJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICB3aWR0aDogJ2F1dG8nLFxuICAgIG1hcmdpbkxlZnQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgaWYgKHRoaXMuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGBjYWxjKDEwMCUgLSAoMTAwJSAtICR7ZmllbGQuc2V0dGluZ3Muc3BhY2luZ31weCkpYDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIG1pbkhlaWdodDogJzQ2cHgnXG4gICAgcGFkZGluZzogJzAgMTJweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAkZGVmaW5lZFdpZHRoOiB7XG4gICAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBgY2FsYygoMTAwJSAtICR7ZmllbGQuc2V0dGluZ3Muc3BhY2luZyAqIChmaWVsZC5zZXR0aW5ncy5wZXJHcm91cCAtIDEpfXB4KSAvICR7ZmllbGQuc2V0dGluZ3MucGVyR3JvdXB9KWA7XG4gICAgICB9XG4gICAgfSxcbiAgICAkc2VsZWN0ZWQ6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMub3JhbmdlXG4gICAgfSxcbiAgICAkdW5hdmFpbGFibGU6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0sXG4gICAgJGRpc2FibGVkOiB7XG4gICAgICBjdXJzb3I6ICdub3QtYWxsb3dlZCcsXG4gICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICBjb2xvcjogQ09MT1JTLmdyZXlcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdib3JkZXInLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICB0b3A6ICcwJyxcbiAgICBsZWZ0OiAnMCcsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBib3JkZXJXaWR0aDogJzFweCcsXG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyQ29sb3I6IENPTE9SUy5ncmV5X2xpZ2h0LFxuICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgJHNlbGVjdGVkOiB7XG4gICAgICBib3JkZXJDb2xvcjogJ2luaGVyaXQnLFxuICAgICAgYm9yZGVyV2lkdGg6ICcycHgnXG4gICAgfSxcbiAgICAkZGlzYWJsZWQ6IHtcbiAgICAgIGJvcmRlckNvbG9yOiBDT0xPUlMuZ3JleV9saWdodFxuICAgIH1cbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICBwYWRkaW5nOiAnMTVweCAwcHgnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MuZm9udFNpemU7XG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiAnNTAwJ1xuICB9XG59XV0pO1xudmFyIGNob2ljZUljb24gPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2ljb24nLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzUwJScsXG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICBmb250U2l6ZTogJzIwcHgnLFxuICAgIG9wYWNpdHk6IDAuMTYsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKSdcbiAgfVxufV0pO3ZhciB0ZW1wbGF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDogdGVtcGxhdGUsY2hvaWNlR3JvdXA6IGNob2ljZUdyb3VwLGNob2ljZTogY2hvaWNlLGNob2ljZUljb246IGNob2ljZUljb259KTtleHBvcnR7dGVtcGxhdGUgYXMgYSx0ZW1wbGF0ZXMgYXMgYixjaG9pY2UgYXMgYyxjaG9pY2VJY29uIGFzIGQsY2hvaWNlR3JvdXAgYXMgZX07IiwidmFyIGRlZmF1bHRzID0ge1xuICB2YWxpZFdoZW5TZWxlY3RlZDogZmFsc2UsXG4gIHZhbGlkV2hlbklzQ2hvaWNlOiBmYWxzZSxcbiAgc2hvd1NlbGVjdEFsbDogZmFsc2UsXG4gIHBlckdyb3VwOiA3LFxuICBzcGFjaW5nOiA4LFxuICBjaG9pY2VzOiBbXVxufTtleHBvcnQgZGVmYXVsdCBkZWZhdWx0czsiLCJpbXBvcnQnQGRhbmllbGthbGVuL2lzJztpbXBvcnQgSVMgZnJvbScuLi8uLi9jaGVja3MuanMnO2ltcG9ydCdxdWlja2RvbSc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9yZWdleC5qcyc7aW1wb3J0IHtyZW1vdmVJdGVtLGluY2x1ZGVzfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0J3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCBDb25kaXRpb24gZnJvbScuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0IHthIGFzIHRlbXBsYXRlLGIgYXMgdGVtcGxhdGVzfWZyb20nLi90ZW1wbGF0ZS1jODhmYTk1Yi5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7dmFyIENob2ljZSwgQ2hvaWNlRmllbGQ7XG5cbkNob2ljZUZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBjbGFzcyBDaG9pY2VGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuXG4gICAgICBpZiAoISgocmVmID0gdGhpcy5zZXR0aW5ncy5jaG9pY2VzKSAhPSBudWxsID8gcmVmLmxlbmd0aCA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaG9pY2VzIHdlcmUgbm90IHByb3ZpZGVkIGZvciBjaG9pY2UgZmllbGQgJyR7dGhpcy5zZXR0aW5ncy5sYWJlbCB8fCB0aGlzLklEfSdgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLnNldHRpbmdzLm11bHRpcGxlID8gW10gOiBudWxsO1xuICAgICAgdGhpcy5sYXN0U2VsZWN0ZWQgPSBudWxsO1xuICAgICAgdGhpcy52aXNpYmxlQ2hvaWNlc0NvdW50ID0gMDtcbiAgICAgIHRoaXMuY2hvaWNlcyA9IHRoaXMuc2V0dGluZ3MuY2hvaWNlcztcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuU2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5TZWxlY3RlZCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0dGluZ3MucGVyR3JvdXAgPSBNYXRoLm1pbih0aGlzLnNldHRpbmdzLnBlckdyb3VwLCB0aGlzLmNob2ljZXMubGVuZ3RoICsgKHRoaXMuc2V0dGluZ3MubXVsdGlwbGUgJiYgdGhpcy5zZXR0aW5ncy5zaG93U2VsZWN0QWxsID8gMSA6IDApKTtcblxuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3MoKTtcblxuICAgICAgdGhpcy5fY29uc3RydWN0b3JFbmQoKTtcbiAgICB9XG5cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICB2YXIgcmVmO1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLl92YWx1ZSkgIT0gbnVsbCA/IHJlZi52YWx1ZSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZS5tYXAoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICAgIHJldHVybiBjaG9pY2UudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgdmFyIGksIGxlbiwgdmFsdWU7XG5cbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5tdWx0aXBsZSB8fCAhSVMuYXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2V0Q2hvaWNlKG5ld1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5ld1ZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZVtpXTtcbiAgICAgICAgICB0aGlzLnNldENob2ljZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgY2hvaWNlR3JvdXBzLCBjaG9pY2VzLCBnbG9iYWxPcHRzLCBwZXJHcm91cDtcbiAgICAgIGdsb2JhbE9wdHMgPSB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLnRlbXBsYXRlLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmRlZmF1bHQsIGdsb2JhbE9wdHMpO1xuICAgICAgdGhpcy5jaG9pY2VzID0gW107XG4gICAgICBjaG9pY2VzID0gdGhpcy5zZXR0aW5ncy5jaG9pY2VzO1xuICAgICAgcGVyR3JvdXAgPSB0aGlzLnNldHRpbmdzLnBlckdyb3VwO1xuICAgICAgY2hvaWNlR3JvdXBzID0gQXJyYXkoTWF0aC5jZWlsKGNob2ljZXMubGVuZ3RoIC8gcGVyR3JvdXApKS5maWxsKCkubWFwKGZ1bmN0aW9uIChzLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gY2hvaWNlcy5zbGljZShpbmRleCAqIHBlckdyb3VwLCBpbmRleCAqIHBlckdyb3VwICsgcGVyR3JvdXApO1xuICAgICAgfSk7XG4gICAgICBjaG9pY2VHcm91cHMuZm9yRWFjaCgoY2hvaWNlcywgZ3JvdXBJbmRleCkgPT4ge1xuICAgICAgICB2YXIgZ3JvdXBFbDtcbiAgICAgICAgZ3JvdXBFbCA9IHRoaXMudGVtcGxhdGVzLmNob2ljZUdyb3VwLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmNob2ljZUdyb3VwLCBnbG9iYWxPcHRzKS5hcHBlbmRUbyh0aGlzLmVsLmNoaWxkLmlubmVyd3JhcCk7XG4gICAgICAgIHJldHVybiBjaG9pY2VzLmZvckVhY2goKGNob2ljZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaG9pY2VzLnB1c2gobmV3IENob2ljZSh0aGlzLCBjaG9pY2UsIGluZGV4LCBncm91cEluZGV4LCBncm91cEVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHZhciBjaG9pY2UsIGksIGxlbiwgcmVmO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc192YWx1ZSgpO1xuXG4gICAgICByZWYgPSB0aGlzLmNob2ljZXM7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjaG9pY2UgPSByZWZbaV07XG5cbiAgICAgICAgY2hvaWNlLl9hdHRhY2hCaW5kaW5ncygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCkge1xuICAgICAgU2ltcGx5QmluZCgndmlzaWJsZScpLm9mKHRoaXMuc3RhdGUpLnRvKHZpc2libGUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgndmlzaWJsZScsIHZpc2libGUpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdob3ZlcmVkJykub2YodGhpcy5zdGF0ZSkudG8oaG92ZXJlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdob3ZlcmVkJywgaG92ZXJlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2ZpbGxlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGZpbGxlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdmaWxsZWQnLCBmaWxsZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdkaXNhYmxlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGRpc2FibGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93TGFiZWwnKS5vZih0aGlzLnN0YXRlKS50byhzaG93TGFiZWwgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0xhYmVsJywgc2hvd0xhYmVsKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0Vycm9yJykub2YodGhpcy5zdGF0ZSkudG8oc2hvd0Vycm9yID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Nob3dFcnJvcicsIHNob3dFcnJvcik7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dIZWxwJykub2YodGhpcy5zdGF0ZSkudG8oc2hvd0hlbHAgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0hlbHAnLCBzaG93SGVscCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3ZhbGlkJykub2YodGhpcy5zdGF0ZSkudG8odmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmVsLnN0YXRlKCd2YWxpZCcsIHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2ludmFsaWQnLCAhdmFsaWQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDptb3VzZWVudGVyJykub2YodGhpcy5lbCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6bW91c2VsZWF2ZScpLm9mKHRoaXMuZWwpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaG92ZXJlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKSB7XG4gICAgICBTaW1wbHlCaW5kKCd3aWR0aCcpLm9mKHRoaXMuc3RhdGUpLnRvKHdpZHRoID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUoJ3dpZHRoJywgd2lkdGgpLnN0YXRlKCdkZWZpbmVkV2lkdGgnLCB3aWR0aCAhPT0gJ2F1dG8nKTtcbiAgICAgIH0pLnRyYW5zZm9ybSh0aGlzLl9mb3JtYXRXaWR0aC5iaW5kKHRoaXMpKS51cGRhdGVPbignaXNNb2JpbGUnKS5vZih0aGlzLnN0YXRlKTtcbiAgICAgIFNpbXBseUJpbmQoJ3Zpc2libGVDaG9pY2VzQ291bnQnKS5vZih0aGlzKS50byhjb3VudCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdoYXNWaXNpYmxlQ2hvaWNlcycsICEhY291bnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCkge1xuICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJykub2YodGhpcykudG8oc2VsZWN0ZWQgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGxlZCA9ICEhKHNlbGVjdGVkICE9IG51bGwgPyBzZWxlY3RlZC5sZW5ndGggOiB2b2lkIDApO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmZpbGxlZCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUuaW50ZXJhY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnYXJyYXk6X3ZhbHVlJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzKS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfdmFsaWRhdGUocHJvdmlkZWRWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgaWYgKCFJUy5hcnJheShwcm92aWRlZFZhbHVlKSkge1xuICAgICAgICAgIHByb3ZpZGVkVmFsdWUgPSBbcHJvdmlkZWRWYWx1ZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvdmlkZWRWYWx1ZS5sZW5ndGggJiYgIUlTLm9iamVjdChwcm92aWRlZFZhbHVlWzBdKSkge1xuICAgICAgICAgIHByb3ZpZGVkVmFsdWUgPSBwcm92aWRlZFZhbHVlLm1hcChmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hvaWNlLnZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoSVMub2JqZWN0KHByb3ZpZGVkVmFsdWUpKSB7XG4gICAgICAgICAgcHJvdmlkZWRWYWx1ZSA9IHByb3ZpZGVkVmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKElTLm51bWJlcih0aGlzLnNldHRpbmdzLnZhbGlkV2hlblNlbGVjdGVkKSkge1xuICAgICAgICBpZiAoISgocHJvdmlkZWRWYWx1ZSAhPSBudWxsID8gcHJvdmlkZWRWYWx1ZS5sZW5ndGggOiB2b2lkIDApID49IHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuU2VsZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkV2hlbklzQ2hvaWNlKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgICAgaWYgKCFpbmNsdWRlcyhwcm92aWRlZFZhbHVlLCB0aGlzLnNldHRpbmdzLnZhbGlkV2hlbklzQ2hvaWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJvdmlkZWRWYWx1ZSAhPT0gdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5Jc0Nob2ljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmaW5kQ2hvaWNlKHByb3ZpZGVkVmFsdWUsIGJ5TGFiZWwpIHtcbiAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgbWF0Y2hlcyA9IHRoaXMuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhSVMub2JqZWN0KHByb3ZpZGVkVmFsdWUpOlxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPT09IGNob2ljZTtcblxuICAgICAgICAgIGNhc2UgIWJ5TGFiZWw6XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZWRWYWx1ZSA9PT0gY2hvaWNlLmxhYmVsO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlZFZhbHVlID09PSBjaG9pY2UudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgZmluZENob2ljZUFueShwcm92aWRlZFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kQ2hvaWNlKHByb3ZpZGVkVmFsdWUpIHx8IHRoaXMuZmluZENob2ljZShwcm92aWRlZFZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBzZXRDaG9pY2UoY2hvaWNlKSB7XG4gICAgICBpZiAoSVMub2JqZWN0KGNob2ljZSkgJiYgY2hvaWNlIGluc3RhbmNlb2YgQ2hvaWNlKSB7XG4gICAgICAgIHJldHVybiBjaG9pY2UudG9nZ2xlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNob2ljZSA9IHRoaXMuZmluZENob2ljZUFueShjaG9pY2UpKSB7XG4gICAgICAgIHJldHVybiBjaG9pY2UudG9nZ2xlKHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG4gIENob2ljZUZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBDaG9pY2VGaWVsZC5wcm90b3R5cGUudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICBDaG9pY2VGaWVsZC5wcm90b3R5cGUuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgcmV0dXJuIENob2ljZUZpZWxkO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbkNob2ljZSA9IGNsYXNzIENob2ljZSB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBzZXR0aW5ncywgaW5kZXgxLCBncm91cEluZGV4LCBncm91cEVsKSB7XG4gICAgdmFyIGdsb2JhbE9wdHMsIGljb25FbCwgcmVmO1xuICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4MTtcbiAgICBnbG9iYWxPcHRzID0ge1xuICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzLmZpZWxkXG4gICAgfTtcbiAgICAoe1xuICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIGNvbmRpdGlvbnM6IHRoaXMuY29uZGl0aW9uc1xuICAgIH0gPSB0aGlzLnNldHRpbmdzKTtcblxuICAgIGlmICh0aGlzLmxhYmVsID09IG51bGwpIHtcbiAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZhbHVlID09IG51bGwpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhYmVsO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSB0aGlzLmZpZWxkLnRlbXBsYXRlcy5jaG9pY2Uuc3Bhd24odGhpcy5maWVsZC5zZXR0aW5ncy50ZW1wbGF0ZXMuY2hvaWNlLCBnbG9iYWxPcHRzKS5hcHBlbmRUbyhncm91cEVsKTtcblxuICAgIGlmICh0aGlzLmljb24pIHtcbiAgICAgIGljb25FbCA9IHRoaXMudGVtcGxhdGVzLmNob2ljZUljb24uc3Bhd24odGhpcy5maWVsZC5zZXR0aW5ncy50ZW1wbGF0ZXMuY2hvaWNlSWNvbiwgZ2xvYmFsT3B0cykuaW5zZXJ0QmVmb3JlKHRoaXMuZWwuY2hpbGQubGFiZWwpO1xuICAgICAgaWNvbkVsLnRleHQgPSB0aGlzLmljb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWwuaW5kZXggPT0gbnVsbCkge1xuICAgICAgdGhpcy5lbC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgdGhpcy5lbC50b3RhbEluZGV4ID0gdGhpcy5pbmRleCAqIGdyb3VwSW5kZXg7XG4gICAgdGhpcy5lbC5wcm9wKCd0aXRsZScsIHRoaXMubGFiZWwpO1xuICAgIHRoaXMuZWwuY2hpbGQubGFiZWwudGV4dCA9IHRoaXMubGFiZWw7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuc2V0dGluZ3MuZGlzYWJsZWQgfHwgZmFsc2U7XG4gICAgdGhpcy51bmF2YWlsYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKChyZWYgPSB0aGlzLmNvbmRpdGlvbnMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICB0aGlzLnVuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWxsRmllbGRzID0gdGhpcy5maWVsZC5hbGxGaWVsZHM7XG4gICAgICBDb25kaXRpb24uaW5pdCh0aGlzLCB0aGlzLmNvbmRpdGlvbnMsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hdmFpbGFibGUgPSAhQ29uZGl0aW9uLnZhbGlkYXRlKHRoaXMuY29uZGl0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfYXR0YWNoQmluZGluZ3MoKSB7XG4gICAgcmV0dXJuICgoKSA9PiB7XG4gICAgICBTaW1wbHlCaW5kKCd2aXNpYmxlJykub2YodGhpcykudG8odmlzaWJsZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgICB9KS5hbmQudG8odmlzaWJsZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkLnZpc2libGVDaG9pY2VzQ291bnQgKz0gdmlzaWJsZSA/IDEgOiAtMTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2VsZWN0ZWQnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMpLnRvKHNlbGVjdGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdkaXNhYmxlZCcsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgfSkub2YodGhpcykudG8oZGlzYWJsZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZGlzYWJsZWQnLCBkaXNhYmxlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3VuYXZhaWxhYmxlJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzKS50byh1bmF2YWlsYWJsZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCd1bmF2YWlsYWJsZScsIHVuYXZhaWxhYmxlKTtcbiAgICAgIH0pLmFuZC50byh1bmF2YWlsYWJsZSA9PiB7XG4gICAgICAgIGlmICh1bmF2YWlsYWJsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YodGhpcy5lbCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC52YWx1ZSA9IHRoaXM7XG4gICAgICB9KS5jb25kaXRpb24oKCkgPT4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9XG5cbiAgdG9nZ2xlKG5ld1ZhbHVlLCB1bmF2YWlsYWJsZSkge1xuICAgIHZhciBuZXdTdGF0ZSwgcHJldlN0YXRlLCByZWY7XG4gICAgcHJldlN0YXRlID0gdGhpcy5zZWxlY3RlZDtcbiAgICBuZXdTdGF0ZSA9IElTLmRlZmluZWQobmV3VmFsdWUpID8gbmV3VmFsdWUgOiAhdGhpcy5zZWxlY3RlZDtcblxuICAgIGlmICghbmV3U3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmZpZWxkLnNldHRpbmdzLm11bHRpcGxlICYmIHByZXZTdGF0ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiByZW1vdmVJdGVtKHRoaXMuZmllbGQuX3ZhbHVlLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChJUy5kZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXdTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmF2YWlsYWJsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1N0YXRlO1xuXG4gICAgICBpZiAodGhpcy5maWVsZC5zZXR0aW5ncy5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLmZpZWxkLl92YWx1ZS5wdXNoKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmllbGQuX3ZhbHVlICE9PSB0aGlzKSB7XG4gICAgICAgICAgaWYgKChyZWYgPSB0aGlzLmZpZWxkLl92YWx1ZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmLnRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWVsZC5fdmFsdWUgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5maWVsZC5sYXN0U2VsZWN0ZWQgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG59O1xudmFyIENob2ljZUZpZWxkJDEgPSBDaG9pY2VGaWVsZDtleHBvcnQgZGVmYXVsdCBDaG9pY2VGaWVsZCQxO2V4cG9ydHtDaG9pY2V9OyIsImltcG9ydCdzbWFydC1leHRlbmQnO2ltcG9ydCB7YSBhcyB0ZW1wbGF0ZSxjIGFzIGNob2ljZSxkIGFzIGNob2ljZUljb24sZSBhcyBjaG9pY2VHcm91cH1mcm9tJy4uL2Nob2ljZS90ZW1wbGF0ZS1jODhmYTk1Yi5qcyc7dmFyIHRlbXBsYXRlJDEgPSB0ZW1wbGF0ZS5leHRlbmQoKTtcbnZhciBjaG9pY2UkMSA9IGNob2ljZS5leHRlbmQoKTtcbnZhciBjaG9pY2VJY29uJDEgPSBjaG9pY2VJY29uLmV4dGVuZCgpO1xudmFyIGNob2ljZUdyb3VwJDEgPSBjaG9pY2VHcm91cC5leHRlbmQoKTt2YXIgdGVtcGxhdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RlZmF1bHQ6IHRlbXBsYXRlJDEsY2hvaWNlOiBjaG9pY2UkMSxjaG9pY2VJY29uOiBjaG9pY2VJY29uJDEsY2hvaWNlR3JvdXA6IGNob2ljZUdyb3VwJDF9KTtleHBvcnR7dGVtcGxhdGUkMSBhcyBhLHRlbXBsYXRlcyBhcyBiLGNob2ljZSQxIGFzIGMsY2hvaWNlSWNvbiQxIGFzIGQsY2hvaWNlR3JvdXAkMSBhcyBlfTsiLCJ2YXIgZGVmYXVsdHMgPSB7XG4gIHZhbGlkV2hlblNlbGVjdGVkOiBmYWxzZSxcbiAgdmFsaWRXaGVuSXNDaG9pY2U6IGZhbHNlLFxuICB2YWxpZFdoZW5UcnVlOiB0cnVlLFxuICBjaG9pY2VMYWJlbHM6IFsnVHJ1ZScsICdGYWxzZSddLFxuICBjaG9pY2VzOiBbe1xuICAgIHZhbHVlOiB0cnVlXG4gIH0sIHtcbiAgICB2YWx1ZTogZmFsc2VcbiAgfV0sXG4gIHNwYWNpbmc6IDhcbn07ZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0Jy4uLy4uL2NoZWNrcy5qcyc7aW1wb3J0J3F1aWNrZG9tJztpbXBvcnQnQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7aW5oZXJpdFByb3RvfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0J3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0Jy4uL2Nob2ljZS90ZW1wbGF0ZS1jODhmYTk1Yi5qcyc7aW1wb3J0Jy4uL2Nob2ljZS9kZWZhdWx0cy5qcyc7aW1wb3J0IENob2ljZUZpZWxkIGZyb20nLi4vY2hvaWNlL2luZGV4LmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYiBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLTNkNmM1NGEwLmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJzt2YXIgVHJ1ZUZhbHNlRmllbGQ7XG5cblRydWVGYWxzZUZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBjbGFzcyBUcnVlRmFsc2VGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmxhc3RTZWxlY3RlZCA9IG51bGw7XG4gICAgICB0aGlzLnZpc2libGVDaG9pY2VzQ291bnQgPSAyO1xuICAgICAgdGhpcy5jaG9pY2VzID0gdGhpcy5zZXR0aW5ncy5jaG9pY2VzO1xuICAgICAgdGhpcy5jaG9pY2VzWzBdLmxhYmVsID0gdGhpcy5zZXR0aW5ncy5jaG9pY2VMYWJlbHNbMF07XG4gICAgICB0aGlzLmNob2ljZXNbMV0ubGFiZWwgPSB0aGlzLnNldHRpbmdzLmNob2ljZUxhYmVsc1sxXTtcbiAgICAgIHRoaXMuc2V0dGluZ3MucGVyR3JvdXAgPSAyO1xuXG4gICAgICB0aGlzLl9jcmVhdGVFbGVtZW50cygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5ncygpO1xuXG4gICAgICB0aGlzLl9jb25zdHJ1Y3RvckVuZCgpO1xuICAgIH1cblxuICAgIF9nZXRWYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZS5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgdmFyIHJlZjtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB0aGlzLmNob2ljZXNbMF0pIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLmNob2ljZXNbMF0udmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdGhpcy5jaG9pY2VzWzFdKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdGhpcy5jaG9pY2VzWzFdLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmICgocmVmID0gdGhpcy5sYXN0U2VsZWN0ZWQpICE9IG51bGwpIHtcbiAgICAgICAgICByZWYudG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIG5ld1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChuZXdWYWx1ZSA/IHRoaXMuY2hvaWNlc1swXSA6IHRoaXMuY2hvaWNlc1sxXSkudG9nZ2xlKCk7XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlKHByb3ZpZGVkVmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdmlkZWRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJvdmlkZWRWYWx1ZSA9IHRoaXMuZmluZENob2ljZShwcm92aWRlZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuSXNDaG9pY2UpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVkVmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5Jc0Nob2ljZSAhPT0gcHJvdmlkZWRWYWx1ZS52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuU2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlZFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkV2hlblRydWUpIHtcbiAgICAgICAgaWYgKChwcm92aWRlZFZhbHVlICE9IG51bGwgPyBwcm92aWRlZFZhbHVlLmluZGV4IDogdm9pZCAwKSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgfVxuICBUcnVlRmFsc2VGaWVsZC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgVHJ1ZUZhbHNlRmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgVHJ1ZUZhbHNlRmllbGQucHJvdG90eXBlLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHJldHVybiBUcnVlRmFsc2VGaWVsZDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuXG5pbmhlcml0UHJvdG8oVHJ1ZUZhbHNlRmllbGQsIENob2ljZUZpZWxkLCBbJ19jcmVhdGVFbGVtZW50cycsICdfYXR0YWNoQmluZGluZ3MnLCAnX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUnLCAnX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMnLCAnX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXknLCAnX2F0dGFjaEJpbmRpbmdzX3ZhbHVlJ10pO1xudmFyIFRydWVGYWxzZUZpZWxkJDEgPSBUcnVlRmFsc2VGaWVsZDtleHBvcnQgZGVmYXVsdCBUcnVlRmFsc2VGaWVsZCQxOyIsImltcG9ydCBDT0xPUlMgZnJvbScuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJzt2YXIgZGVmYXVsdHMgPSB7XG4gIHZhbGlkV2hlblRydWU6IHRydWUsXG4gIHNpemU6IDUwLFxuICBzdHlsZTogJ2NlbnRlcmVkJyxcbiAgY29sb3I6IENPTE9SUy5ncmVlbixcbiAgYmFja2dyb3VuZDogQ09MT1JTLmdyZXlfbGlnaHQsXG4gIHRyaWdnZXJFdmVudDogJ21vdXNldXAnXG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IENPTE9SUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO3ZhciB0ZW1wbGF0ZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnZmllbGQnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc3RhdGUud2lkdGg7XG4gICAgfSxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5mb250RmFtaWx5O1xuICAgIH0sXG4gICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgJHZpc2libGU6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBhbmltYXRpb246ICcwLjJzIGZpZWxkRXJyb3JTaGFrZSdcbiAgICB9LFxuICAgICRhbGlnbmVkU3R5bGU6IHtcbiAgICAgIHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplICsgMjA7XG4gICAgICB9XG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnbGFiZWwnLFxuICBzdHlsZToge1xuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICBtYXJnaW5Cb3R0b206ICcxMnB4JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6ICcxM3B4JyxcbiAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBjb2xvcjogQ09MT1JTLmJsYWNrLFxuICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHNob3dMYWJlbDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9LFxuICAgICRhbGlnbmVkU3R5bGU6IHtcbiAgICAgIG1hcmdpbkJvdHRvbTogJzAnLFxuICAgICAgdGV4dEFsaWduOiAnbGVmdCdcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaW5uZXJ3cmFwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgJGFsaWduZWRTdHlsZToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogJzUwJScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJ1xuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHJlZjogJ2lucHV0JyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDIsXG4gICAgd2lkdGg6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnNpemU7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnNpemUgLyAyO1xuICAgIH0sXG4gICAgbWFyZ2luOiAnMCBhdXRvJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmJhY2tncm91bmQ7XG4gICAgfSxcbiAgICBib3JkZXI6IGAxcHggc29saWQgJHtDT0xPUlMuZ3JleV9zZW1pX2xpZ2h0fWAsXG4gICAgYm9yZGVyUmFkaXVzOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplO1xuICAgIH0sXG4gICAgY3Vyc29yOiAncG9pbnRlcidcbiAgfVxufSwgWydkaXYnLCB7XG4gIHJlZjogJ2JhY2tncm91bmQnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMSxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplIC8gMjtcbiAgICB9LFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIGJvcmRlclJhZGl1czogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIHNpemUgPSBmaWVsZC5zZXR0aW5ncy5zaXplO1xuICAgICAgcmV0dXJuIGAke3NpemV9cHggMCAwICR7c2l6ZX1weGA7XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmNvbG9yO1xuICAgIH0sXG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzLCB3aWR0aCAwLjJzJyxcbiAgICAkdG9nZ2xlZDoge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnNpemUgKiAwLjc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2JhbGwnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplIC8gMjtcbiAgICB9LFxuICAgIGhlaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3Muc2l6ZSAvIDI7XG4gICAgfSxcbiAgICBtYXJnaW46ICcwIGF1dG8nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgIGJvcmRlcjogYDFweCBzb2xpZCAke0NPTE9SUy5ncmV5X2xpZ2h0fWAsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTUlKScsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHRvZ2dsZWQ6IHtcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoNTAlKScsXG4gICAgICBib3JkZXI6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gYDFweCBzb2xpZCAke2ZpZWxkLnNldHRpbmdzLmNvbG9yfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XV1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaGVscCcsXG4gIHN0eWxlOiB7XG4gICAgbWFyZ2luVG9wOiAnMTBweCcsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgY29sb3I6IENPTE9SUy5ncmV5LFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBjb2xvcjogQ09MT1JTLnJlZCxcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9LFxuICAgICRzaG93SGVscDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufV1dKTt2YXIgdGVtcGxhdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RlZmF1bHQ6IHRlbXBsYXRlfSk7ZXhwb3J0e3RlbXBsYXRlIGFzIGEsdGVtcGxhdGVzIGFzIGJ9OyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCcuLi8uLi9jaGVja3MuanMnO2ltcG9ydCdxdWlja2RvbSc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9yZWdleC5qcyc7aW1wb3J0IHtpbmhlcml0UHJvdG99ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQnc21hcnQtZXh0ZW5kJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvY29uZGl0aW9uLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvdHJhbnNmb3JtU2V0dGluZ3MuanMnO2ltcG9ydCcuLi8uLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi4vLi4vZmllbGQvaW5kZXguanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQnLi4vY2hvaWNlL3RlbXBsYXRlLWM4OGZhOTViLmpzJztpbXBvcnQnLi4vY2hvaWNlL2RlZmF1bHRzLmpzJztpbXBvcnQnLi4vY2hvaWNlL2luZGV4LmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJztpbXBvcnQnLi4vdHJ1ZWZhbHNlL3RlbXBsYXRlLTNkNmM1NGEwLmpzJztpbXBvcnQnLi4vdHJ1ZWZhbHNlL2RlZmF1bHRzLmpzJztpbXBvcnQgVHJ1ZUZhbHNlRmllbGQgZnJvbScuLi90cnVlZmFsc2UvaW5kZXguanMnO2ltcG9ydCB7YSBhcyB0ZW1wbGF0ZSxiIGFzIHRlbXBsYXRlc31mcm9tJy4vdGVtcGxhdGUtYmY3Yjk5YzEuanMnO3ZhciBUb2dnbGVGaWVsZDtcblxuVG9nZ2xlRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIFRvZ2dsZUZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gISF0aGlzLl92YWx1ZTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2l6ZSA9IHBhcnNlRmxvYXQodGhpcy5zZXR0aW5ncy5zaXplKSB8fCBkZWZhdWx0cy5zaXplO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHlsZSAhPT0gJ2NlbnRlcmVkJyAmJiB0aGlzLnNldHRpbmdzLnN0eWxlICE9PSAnYWxpZ25lZCcpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHlsZSA9IGRlZmF1bHRzLnN0eWxlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jcmVhdGVFbGVtZW50cygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5ncygpO1xuXG4gICAgICB0aGlzLl9jb25zdHJ1Y3RvckVuZCgpO1xuICAgIH1cblxuICAgIF9nZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA9ICEhbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGZvcmNlT3B0cztcbiAgICAgIGZvcmNlT3B0cyA9IHtcbiAgICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzXG4gICAgICB9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMudGVtcGxhdGUuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuZGVmYXVsdCwgZm9yY2VPcHRzKTtcbiAgICAgIHRoaXMuZWwuc3RhdGUoJ2FsaWduZWRTdHlsZScsIHRoaXMuc2V0dGluZ3Muc3R5bGUgPT09ICdhbGlnbmVkJykuY2hpbGQuaW5uZXJ3cmFwLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfdmFsdWUoKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfdmFsdWUoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdfdmFsdWUnKS5vZih0aGlzKS50byh2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCd0b2dnbGVkJywgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdfdmFsdWUnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMpLnRvKHZhbHVlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoYGV2ZW50OiR7dGhpcy5zZXR0aW5ncy50cmlnZ2VyRXZlbnR9YCkub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9ICF0aGlzLl92YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZShwcm92aWRlZFZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5UcnVlKSB7XG4gICAgICAgIGlmICghcHJvdmlkZWRWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgfVxuICBUb2dnbGVGaWVsZC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgVG9nZ2xlRmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgVG9nZ2xlRmllbGQucHJvdG90eXBlLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHJldHVybiBUb2dnbGVGaWVsZDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuXG5pbmhlcml0UHJvdG8oVG9nZ2xlRmllbGQsIFRydWVGYWxzZUZpZWxkLCBbJ19hdHRhY2hCaW5kaW5nc19lbFN0YXRlJywgJ19hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzJywgJ19hdHRhY2hCaW5kaW5nc19kaXNwbGF5J10pO1xudmFyIFRvZ2dsZUZpZWxkJDEgPSBUb2dnbGVGaWVsZDtleHBvcnQgZGVmYXVsdCBUb2dnbGVGaWVsZCQxOyIsImltcG9ydCBDT0xPUlMgZnJvbScuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJzt2YXIgZGVmYXVsdHMgPSB7XG4gIGZpZWxkczoge30sXG4gIGNvbGxhcHNhYmxlOiB0cnVlLFxuICBzdGFydENvbGxhcHNlZDogZmFsc2UsXG4gIHBhZGRpbmc6IDIwLFxuICBmaWVsZE1hcmdpbjogMCxcbiAgZmllbGRBbGlnbjogJ3RvcCcsXG4gIGxhYmVsU2l6ZTogMTYsXG4gIGNvbG9yOiBDT0xPUlMuZ3JleV9saWdodDRcbn07ZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQnLi4vLi4vc3ZnL2NoZWNrbWFyay5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9hbmdsZURvd24uanMnO2ltcG9ydCBjYXJldFVwIGZyb20nLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCBjYXJldERvd24gZnJvbScuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7dmFyIGFjdGlvbiA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgZXZlbnRzOiB7XG4gICAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdtYXJnaW5MZWZ0JywgNSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzdHlsZToge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gIH1cbn0sIFsvLyB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuJ2RpdicsIHtcbiAgcmVmOiAnaWNvbicsXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6IDE3LFxuICAgIGhlaWdodDogMTcsXG4gICAgY29sb3I6IENPTE9SUy5ncmV5LFxuICAgIGZpbGw6IENPTE9SUy5ncmV5LFxuICAgICRob3Zlcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5ncmV5X2RhcmssXG4gICAgICBmaWxsOiBDT0xPUlMuZ3JleV9kYXJrXG4gICAgfVxuICB9XG59XV0pO1xudmFyIGNvbGxhcHNlSWNvbnMgPSBbY2FyZXRVcC5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAtMixcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICRjb2xsYXBzZWQ6IHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSksIGNhcmV0RG93bi5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAkY29sbGFwc2VkOiB7XG4gICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSldO1xudmFyIHRlbXBsYXRlID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdmaWVsZCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zdGF0ZS53aWR0aDtcbiAgICB9LFxuICAgIGZvbnRGYW1pbHk6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmZvbnRGYW1pbHk7XG4gICAgfSxcbiAgICAvLyBiYWNrZ3JvdW5kQ29sb3I6IChmaWVsZCktPiBmaWVsZC5zZXR0aW5ncy5jb2xvclxuICAgIGJvcmRlcjogYDFweCBzb2xpZCAke0NPTE9SUy5ncmV5X2xpZ2h0fWAsXG4gICAgYm9yZGVyUmFkaXVzOiAzLFxuICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgIC8vIGxpbmVIZWlnaHQ6ICcxZW0nXG4gICAgJHZpc2libGU6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICAkY29sbGFwc2VkOiB7XG4gICAgICAgIGFuaW1hdGlvbjogJzAuMnMgZmllbGRFcnJvclNoYWtlJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHJlZjogJ2xhYmVsJyxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5sYWJlbFNpemU7XG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHNob3dMYWJlbDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnYWN0aW9ucycsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5wYWRkaW5nICogKDEyIC8gMjApO1xuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnBhZGRpbmcgKiAoMTIgLyAyMCk7XG4gICAgfSxcbiAgICBsaW5lSGVpZ2h0OiAwLFxuICAgIGZvbnRTaXplOiAwLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgJHNob3dMYWJlbDoge1xuICAgICAgdG9wOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnBhZGRpbmcgKiAoMjEgLyAyMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2hlbHAnLFxuICBzdHlsZToge1xuICAgIG1hcmdpblRvcDogJzEwcHgnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIGNvbG9yOiBDT0xPUlMuZ3JleSxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgd2hpdGVTcGFjZTogJ3ByZS1saW5lJyxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBjb2xvcjogQ09MT1JTLnJlZCxcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9LFxuICAgICRzaG93SGVscDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdpbm5lcndyYXAnLFxuICB1bnBhc3NhYmxlU3RhdGVzOiBbJ3Zpc2libGUnLCAnaG92ZXInLCAnZm9jdXMnLCAnZGlzYWJsZWQnLCAnc2hvd0xhYmVsJywgJ3Nob3dFcnJvcicsICdzaG93SGVscCcsICdjb2xsYXBzZWQnLCAndmFsaWQnLCAnaW52YWxpZCddLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIG1hcmdpblRvcDogMTUsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIHRleHRBbGlnbjogJ2p1c3RpZnknLFxuICAgIHRleHRKdXN0aWZ5OiAnZGlzdHJpYnV0ZS1hbGwtbGluZXMnLFxuICAgIGZvbnRTaXplOiAwLFxuICAgICRjb2xsYXBzZWQ6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH1cbiAgfVxufV1dKTt2YXIgdGVtcGxhdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2FjdGlvbjogYWN0aW9uLGNvbGxhcHNlSWNvbnM6IGNvbGxhcHNlSWNvbnMsZGVmYXVsdDogdGVtcGxhdGV9KTtleHBvcnR7dGVtcGxhdGUgYXMgYSx0ZW1wbGF0ZXMgYXMgYixjb2xsYXBzZUljb25zIGFzIGMsYWN0aW9uIGFzIGR9OyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uLy4uL2NoZWNrcy5qcyc7aW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQgU2ltcGx5QmluZCBmcm9tJ0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL3JlZ2V4LmpzJztpbXBvcnQnLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NoZWNrbWFyay5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9hbmdsZURvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXRVcC5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldERvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvcGx1cy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jbG9uZS5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9yZW1vdmUuanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYiBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLTA4NmE4MmUyLmpzJzt2YXIgR3JvdXBGaWVsZDtcblxuR3JvdXBGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgR3JvdXBGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLl9jYWxjRm9jdXNTdGF0ZSA9IHRoaXMuX2NhbGNGb2N1c1N0YXRlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9jYWxjQmx1clN0YXRlID0gdGhpcy5fY2FsY0JsdXJTdGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fZW1pdFN1Ym1pdCA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdzdWJtaXQnKTtcbiAgICAgIHRoaXMuc3RhdGUuY29sbGFwc2VkID0gdGhpcy5zZXR0aW5ncy5zdGFydENvbGxhcHNlZCAmJiB0aGlzLnNldHRpbmdzLmNvbGxhcHNhYmxlO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmllbGRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuZmllbGRzQXJyYXkgPSBbXTtcblxuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3MoKTtcblxuICAgICAgdGhpcy5fY29uc3RydWN0b3JFbmQoKTtcbiAgICB9XG5cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICB2YXIgZmllbGQsIG5hbWUsIHJlZiwgdmFsdWVzO1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlZiA9IHRoaXMuZmllbGRzO1xuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIGZpZWxkID0gcmVmW25hbWVdO1xuICAgICAgICB2YWx1ZXNbbmFtZV0gPSBmaWVsZC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHZhciBuYW1lLCB2YWx1ZTtcblxuICAgICAgaWYgKElTLm9iamVjdChuZXdWYWx1ZSkpIHtcbiAgICAgICAgZm9yIChuYW1lIGluIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZVtuYW1lXTtcblxuICAgICAgICAgIGlmICh0aGlzLmZpZWxkc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5maWVsZHNbbmFtZV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlY2FsY0Rpc3BsYXkoKSB7XG4gICAgICB2YXIgZmllbGQsIGksIGxlbiwgcmVmO1xuICAgICAgcmVmID0gdGhpcy5maWVsZHNBcnJheTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gcmVmW2ldO1xuXG4gICAgICAgIGlmIChmaWVsZC5fcmVjYWxjRGlzcGxheSkge1xuICAgICAgICAgIGZpZWxkLl9yZWNhbGNEaXNwbGF5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgY29uZmlnLCBmaWVsZCwgZmllbGRzLCBmb3JjZU9wdHMsIGksIGxlbiwgbWFyZ2luLCBuYW1lLCByZWYsIHJlZjE7XG4gICAgICBmb3JjZU9wdHMgPSB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfTtcbiAgICAgIG1hcmdpbiA9IGAwIDAgJHt0aGlzLnNldHRpbmdzLmZpZWxkTWFyZ2lufXB4IDBgO1xuICAgICAgdGhpcy5lbCA9IHRoaXMudGVtcGxhdGUuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuZGVmYXVsdCwgZm9yY2VPcHRzKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29sbGFwc2FibGUpIHtcbiAgICAgICAgdGhpcy5hZGRBY3Rpb24oJ2NvbGxhcHNlJywgdGhpcy50ZW1wbGF0ZXMuY29sbGFwc2VJY29ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChJUy5hcnJheSh0aGlzLnNldHRpbmdzLmZpZWxkcykpIHtcbiAgICAgICAgZmllbGRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcmVmID0gdGhpcy5zZXR0aW5ncy5maWVsZHM7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZmllbGQgPSByZWZbaV07XG5cbiAgICAgICAgICBpZiAoIWZpZWxkLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmllbGQgJHt0aGlzLm5hbWUgfHwgdGhpcy5JRH06Z3JvdXAgZmllbGRzIHByb3ZpZGVkIGluIGFycmF5IGZvcm1hdCBtdXN0IGhhdmUgYSBuYW1lYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmllbGRzW2ZpZWxkLm5hbWVdID0gZmllbGQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldHRpbmdzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgIH1cblxuICAgICAgcmVmMSA9IHRoaXMuc2V0dGluZ3MuZmllbGRzO1xuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVmMSkge1xuICAgICAgICBmaWVsZCA9IHJlZjFbbmFtZV07XG4gICAgICAgIGNvbmZpZyA9IGV4dGVuZCh7XG4gICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgIGZpZWxkSW5zdGFuY2VzOiB0aGlzLmZpZWxkc1xuICAgICAgICB9LCBmaWVsZCwge1xuICAgICAgICAgIElEOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpZWxkc0FycmF5LnB1c2godGhpcy5maWVsZHNbbmFtZV0gPSB0aGlzLmJ1aWxkZXIoY29uZmlnKS5hcHBlbmRUbyh0aGlzLmVsLmNoaWxkLmlubmVyd3JhcCkpO1xuICAgICAgICB0aGlzLmZpZWxkc1tuYW1lXS5vbignZm9jdXMnLCB0aGlzLl9jYWxjRm9jdXNTdGF0ZSkub24oJ2JsdXInLCB0aGlzLl9jYWxjQmx1clN0YXRlKS5vbignc3VibWl0JywgdGhpcy5fZW1pdFN1Ym1pdCkuZWwuc3R5bGUoJ3ZlcnRpY2FsQWxpZ24nLCB0aGlzLnNldHRpbmdzLmZpZWxkQWxpZ24pLmFmdGVyKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwLmFwcGVuZChET00uZGl2KHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuZWwuc3RhdGUoJ2NvbGxhcHNhYmxlJywgdGhpcy5zZXR0aW5ncy5jb2xsYXBzYWJsZSk7XG4gICAgICB0aGlzLmVsLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXMuZWwuY2hpbGRmLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKSB7XG4gICAgICBTaW1wbHlCaW5kKCd2aXNpYmxlJykub2YodGhpcy5zdGF0ZSkudG8odmlzaWJsZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2hvdmVyZWQnKS5vZih0aGlzLnN0YXRlKS50byhob3ZlcmVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2hvdmVyJywgaG92ZXJlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2ZvY3VzZWQnKS5vZih0aGlzLnN0YXRlKS50byhmb2N1c2VkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2ZvY3VzJywgZm9jdXNlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2Rpc2FibGVkJykub2YodGhpcy5zdGF0ZSkudG8oZGlzYWJsZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZGlzYWJsZWQnLCBkaXNhYmxlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dMYWJlbCcpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dMYWJlbCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93TGFiZWwnLCBzaG93TGFiZWwpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93RXJyb3InKS5vZih0aGlzLnN0YXRlKS50byhzaG93RXJyb3IgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0Vycm9yJywgc2hvd0Vycm9yKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0hlbHAnKS5vZih0aGlzLnN0YXRlKS50byhzaG93SGVscCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93SGVscCcsIHNob3dIZWxwKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnY29sbGFwc2VkJykub2YodGhpcy5zdGF0ZSkudG8oY29sbGFwc2VkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2NvbGxhcHNlZCcsIGNvbGxhcHNlZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaW1wbHlCaW5kKCd2YWxpZCcpLm9mKHRoaXMuc3RhdGUpLnRvKHZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5lbC5zdGF0ZSgndmFsaWQnLCB2YWxpZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdpbnZhbGlkJywgIXZhbGlkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCkge1xuICAgICAgdmFyIGZpZWxkLCBpLCBsZW4sIHJlZjtcbiAgICAgIFNpbXBseUJpbmQoJ3dpZHRoJykub2YodGhpcy5zdGF0ZSkudG8od2lkdGggPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdHlsZSgnd2lkdGgnLCB3aWR0aCkuc3RhdGUoJ2RlZmluZWRXaWR0aCcsIHdpZHRoICE9PSAnYXV0bycpO1xuICAgICAgfSkudHJhbnNmb3JtKHRoaXMuX2Zvcm1hdFdpZHRoLmJpbmQodGhpcykpLnVwZGF0ZU9uKCdpc01vYmlsZScpLm9mKHRoaXMuc3RhdGUpO1xuICAgICAgcmVmID0gdGhpcy5maWVsZHNBcnJheTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gcmVmW2ldO1xuICAgICAgICBTaW1wbHlCaW5kKCdkaXNhYmxlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKCdkaXNhYmxlZCcpLm9mKGZpZWxkLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpIHtcbiAgICAgIHZhciB0b2dnbGVDb2xsYXBzZTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29sbGFwc2FibGUpIHtcbiAgICAgICAgdG9nZ2xlQ29sbGFwc2UgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5jb2xsYXBzZWQgPSAhdGhpcy5zdGF0ZS5jb2xsYXBzZWQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnY29sbGFwc2VkJywgdGhpcy5zdGF0ZS5jb2xsYXBzZWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YodGhpcy5lbC5jaGlsZC5jb2xsYXBzZSkudG8odG9nZ2xlQ29sbGFwc2UpO1xuICAgICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQubGFiZWwpLnRvKHRvZ2dsZUNvbGxhcHNlKTtcbiAgICAgICAgU2ltcGx5QmluZCgnY29sbGFwc2VkJykub2YodGhpcy5zdGF0ZSkub25jZS50bygoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY2FsY0Rpc3BsYXkoKTtcbiAgICAgICAgfSkuY29uZGl0aW9uKGZ1bmN0aW9uIChjb2xsYXBzZWQpIHtcbiAgICAgICAgICByZXR1cm4gIWNvbGxhcHNlZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCkge1xuICAgICAgdmFyIGZpZWxkLCBmaWVsZE5hbWUsIHJlZjtcbiAgICAgIHJlZiA9IHRoaXMuZmllbGRzO1xuXG4gICAgICBmb3IgKGZpZWxkTmFtZSBpbiByZWYpIHtcbiAgICAgICAgZmllbGQgPSByZWZbZmllbGROYW1lXTtcbiAgICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJykub2YoZmllbGQpLnRvKGZpZWxkTmFtZSkub2YodGhpcy5fdmFsdWUpO1xuICAgICAgICBTaW1wbHlCaW5kKCdfdmFsdWUnLCB7XG4gICAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgICB9KS5vZihmaWVsZCkudG8odmFsdWUgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnRlcmFjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXRlLnZhbGlkID0gdGhpcy52YWxpZGF0ZSh2b2lkIDAsIHRydWUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdmFsaWRhdGUocHJvdmlkZWRWYWx1ZSwgdGVzdFVucmVxdWlyZWQsIHJlcG9ydCkge1xuICAgICAgdmFyIGZpZWxkLCBpLCBpc1ZhbGlkLCBsZW4sIHJlZiwgc29tZUludmFsaWQ7XG4gICAgICBzb21lSW52YWxpZCA9IGZhbHNlO1xuICAgICAgcmVmID0gdGhpcy5maWVsZHNBcnJheTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gcmVmW2ldO1xuXG4gICAgICAgIGlmICghZmllbGQuc3RhdGUudmlzaWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcG9ydCkge1xuICAgICAgICAgIGlzVmFsaWQgPSBmaWVsZC52YWxpZGF0ZUFuZFJlcG9ydChwcm92aWRlZFZhbHVlW2ZpZWxkLm5hbWVdLCB0ZXN0VW5yZXF1aXJlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNWYWxpZCA9IGZpZWxkLnZhbGlkYXRlKHByb3ZpZGVkVmFsdWVbZmllbGQubmFtZV0sIHRlc3RVbnJlcXVpcmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIHNvbWVJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gIXNvbWVJbnZhbGlkO1xuICAgIH1cblxuICAgIF9jYWxjRm9jdXNTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZvY3VzZWQgPSB0aGlzLmZpZWxkc0FycmF5LnNvbWUoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5zdGF0ZS5mb2N1c2VkO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NhbGNCbHVyU3RhdGUoKSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dCh0aGlzLl9jYWxjRm9jdXNTdGF0ZSk7XG4gICAgfVxuXG4gICAgZm9jdXMoKSB7XG4gICAgICB2YXIgZmllbGQsIGksIGxlbiwgcmVmO1xuICAgICAgdGhpcy5zdGF0ZS5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgIHJlZiA9IHRoaXMuZmllbGRzQXJyYXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IHJlZltpXTtcblxuICAgICAgICBpZiAoZmllbGQuZm9jdXMpIHtcbiAgICAgICAgICByZXR1cm4gZmllbGQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJsdXIoKSB7XG4gICAgICB2YXIgZmllbGQsIGksIGxlbiwgcmVmO1xuICAgICAgcmVmID0gdGhpcy5maWVsZHNBcnJheTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gcmVmW2ldO1xuXG4gICAgICAgIGlmIChmaWVsZC5ibHVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkLmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFkZEFjdGlvbihuYW1lLCBpY29ucywgY2FsbGJhY2ssIHByZXBlbmQpIHtcbiAgICAgIHZhciBhY3Rpb24sIGksIGljb24sIGxlbjtcblxuICAgICAgaWYgKGljb25zICYmICFJUy5hcnJheShpY29ucykpIHtcbiAgICAgICAgaWNvbnMgPSBbaWNvbnNdO1xuICAgICAgfVxuXG4gICAgICBhY3Rpb24gPSB0aGlzLnRlbXBsYXRlcy5hY3Rpb24uc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuYWN0aW9uLCB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfSk7XG4gICAgICBhY3Rpb24ucmVmID0gYWN0aW9uLm9wdGlvbnMucmVmID0gbmFtZTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaWNvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWNvbiA9IGljb25zW2ldO1xuICAgICAgICBhY3Rpb24uY2hpbGQuaWNvbi5hcHBlbmQoaWNvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuY2hpbGQuYWN0aW9uc1twcmVwZW5kID8gJ3ByZXBlbmQnIDogJ2FwcGVuZCddKGFjdGlvbik7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKGFjdGlvbikudG8oY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICB9XG4gIEdyb3VwRmllbGQucHJvdG90eXBlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIEdyb3VwRmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgR3JvdXBGaWVsZC5wcm90b3R5cGUuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgR3JvdXBGaWVsZC5wcm90b3R5cGUuc2hhbGxvd1NldHRpbmdzID0gWydmaWVsZHMnXTtcbiAgcmV0dXJuIEdyb3VwRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxudmFyIEdyb3VwRmllbGQkMSA9IEdyb3VwRmllbGQ7ZXhwb3J0IGRlZmF1bHQgR3JvdXBGaWVsZCQxOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQgcGx1cyBmcm9tJy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQgY2xvbmUgZnJvbScuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCByZW1vdmUgZnJvbScuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0IHtjIGFzIGNvbGxhcHNlSWNvbnN9ZnJvbScuLi9ncm91cC90ZW1wbGF0ZS0wODZhODJlMi5qcyc7dmFyIHRlbXBsYXRlID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdmaWVsZCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zdGF0ZS53aWR0aDtcbiAgICB9LFxuICAgIGZvbnRGYW1pbHk6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmZvbnRGYW1pbHk7XG4gICAgfSxcbiAgICBib3JkZXJSYWRpdXM6IDMsXG4gICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgJHZpc2libGU6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBhbmltYXRpb246ICcwLjJzIGZpZWxkRXJyb3JTaGFrZSdcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlOiB7XG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICBjb2xvcjogQ09MT1JTLmJsYWNrLFxuICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAkc2hvd0xhYmVsOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBjb2xvcjogQ09MT1JTLnJlZFxuICAgIH1cbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdjb2xsYXBzZScsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiA1LFxuICAgIHJpZ2h0OiAwLFxuICAgIGxpbmVIZWlnaHQ6IDAsXG4gICAgZm9udFNpemU6IDAsXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgICRzaG93TGFiZWw6IHtcbiAgICAgICRjb2xsYXBzYWJsZToge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICB9XG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnaWNvbicsXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6IDE3LFxuICAgIGhlaWdodDogMTcsXG4gICAgY29sb3I6IENPTE9SUy5ncmV5LFxuICAgIGZpbGw6IENPTE9SUy5ncmV5LFxuICAgICRob3Zlcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5ncmV5X2RhcmssXG4gICAgICBmaWxsOiBDT0xPUlMuZ3JleV9kYXJrXG4gICAgfVxuICB9XG59LCAuLi5jb2xsYXBzZUljb25zXV0sIFsnZGl2Jywge1xuICByZWY6ICdoZWxwJyxcbiAgc3R5bGU6IHtcbiAgICBtYXJnaW5Ub3A6ICcxMHB4JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICBjb2xvcjogQ09MT1JTLmdyZXksXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMucmVkLFxuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dIZWxwOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2lubmVyd3JhcCcsXG4gIHVucGFzc2FibGVTdGF0ZXM6IFsndmlzaWJsZScsICdob3ZlcicsICdmb2N1cycsICdkaXNhYmxlZCcsICdzaG93TGFiZWwnLCAnc2hvd0Vycm9yJywgJ3Nob3dIZWxwJywgJ2NvbGxhcHNlZCcsICd2YWxpZCcsICdpbnZhbGlkJ10sXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgbWFyZ2luVG9wOiAxNSxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgdGV4dEFsaWduOiAnanVzdGlmeScsXG4gICAgdGV4dEp1c3RpZnk6ICdkaXN0cmlidXRlLWFsbC1saW5lcycsXG4gICAgZm9udFNpemU6IDAsXG4gICAgJGNvbGxhcHNlZDoge1xuICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnYWRkQnV0dG9uJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBwYWRkaW5nOiAxMixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IENPTE9SUy5ncmV5X3NlbWlfbGlnaHQsXG4gICAgYm9yZGVyUmFkaXVzOiAzLFxuICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICBsaW5lSGVpZ2h0OiAnMWVtJyxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICRkaXNhYmxlZDoge1xuICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgfSxcbiAgICAkaW5saW5lU3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgdG9wOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmdyb3VwTWFyZ2luIC8gMiAqIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHN0eWxlOiB7XG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgd2lkdGg6IDE1LFxuICAgIGhlaWdodDogMTUsXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBmaWxsOiBDT0xPUlMuYmxhY2tcbiAgfVxufSwgcGx1c11dXV0pO1xudmFyIGNsb25lSWNvbiA9IGNsb25lLmV4dGVuZCh7XG4gIG9wdGlvbnM6IHtcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IDExXG4gICAgfVxuICB9XG59KTtcbnZhciByZW1vdmVJY29uID0gcmVtb3ZlLmV4dGVuZCh7XG4gIG9wdGlvbnM6IHtcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IDExXG4gICAgfVxuICB9XG59KTtcbnZhciBibG9ja0dyb3VwID0ge307XG52YXIgaW5saW5lR3JvdXAgPSB7XG4gIGRlZmF1bHQ6IHtcbiAgICAvLyBvcHRpb25zOiBzdHlsZTpcbiAgICAvLyBcdHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIGlubmVyd3JhcDoge1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIGluc2VydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2VydEFmdGVyKHRoaXMucGFyZW50LmNoaWxkLmlubmVyd3JhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgcG9zaXRpb246ICdzdGF0aWMnLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLXRhYmxlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWN0aW9uOiBbJ2RpdicsIHtcbiAgICBldmVudHM6IHtcbiAgICAgIGluc2VydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2JvcmRlclRvcCcsIGAxcHggc29saWQgJHtDT0xPUlMuZ3JleX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgZGlzcGxheTogJ3RhYmxlLXJvdycsXG4gICAgICBwYWRkaW5nOiA0XG4gICAgfVxuICB9LCBbJ2RpdicsIHtcbiAgICByZWY6ICdpY29uJyxcbiAgICBzdHlsZToge1xuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICBkaXNwbGF5OiAndGFibGUtY2VsbCcsXG4gICAgICBjb2xvcjogQ09MT1JTLmJsYWNrLFxuICAgICAgZmlsbDogQ09MT1JTLmJsYWNrLFxuICAgICAgb3BhY2l0eTogMC42LFxuICAgICAgJGhvdmVyOiB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH1cbiAgICB9XG4gIH1dXVxufTt2YXIgdGVtcGxhdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RlZmF1bHQ6IHRlbXBsYXRlLGNsb25lSWNvbjogY2xvbmVJY29uLHJlbW92ZUljb246IHJlbW92ZUljb24sYmxvY2tHcm91cDogYmxvY2tHcm91cCxpbmxpbmVHcm91cDogaW5saW5lR3JvdXB9KTtleHBvcnR7aW5saW5lR3JvdXAgYXMgYSxibG9ja0dyb3VwIGFzIGIsdGVtcGxhdGUgYXMgYyx0ZW1wbGF0ZXMgYXMgZCxjbG9uZUljb24gYXMgZSxyZW1vdmVJY29uIGFzIGZ9OyIsImltcG9ydCdxdWlja2RvbSc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0Jy4uL2dyb3VwL3RlbXBsYXRlLTA4NmE4MmUyLmpzJztpbXBvcnQge2EgYXMgaW5saW5lR3JvdXAsYiBhcyBibG9ja0dyb3VwfWZyb20nLi90ZW1wbGF0ZS03YzI4NGU2MS5qcyc7dmFyIGRlZmF1bHRzID0ge1xuICBmaWVsZHM6IG51bGwsXG4gIHN0eWxlOiAnYmxvY2snLFxuICBjb2xsYXBzYWJsZTogdHJ1ZSxcbiAgc3RhcnRDb2xsYXBzZWQ6IGZhbHNlLFxuICBncm91cE1hcmdpbjogMTAsXG4gIGdyb3VwV2lkdGg6ICcxMDAlJyxcbiAgYXV0b1dpZHRoOiB0cnVlLFxuICBhdXRvUmVtb3ZlRW1wdHk6IGZhbHNlLFxuICBkeW5hbWljTGFiZWw6IGZhbHNlLFxuICBtaW5JdGVtczogbnVsbCxcbiAgbWF4SXRlbXM6IG51bGwsXG4gIGRyYWdnYWJsZTogZmFsc2UsXG4gIGNsb25lYWJsZTogZmFsc2UsXG4gIHJlbW92ZWFibGU6IHRydWUsXG4gIHNpbmdsZU1vZGU6IGZhbHNlLFxuICBudW1iZXJpbmc6IGZhbHNlLFxuICBtdWx0aXBsZTogdHJ1ZSxcbiAgZHJhZ2Ryb3A6IHRydWUsXG4gIGdyb3VwU2V0dGluZ3M6IHtcbiAgICBsYWJlbFNpemU6IDE0LFxuICAgIGlubGluZToge1xuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGZpZWxkTWFyZ2luOiAwLFxuICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgIGNvbGxhcHNhYmxlOiBmYWxzZSxcbiAgICAgIHN0YXJ0Q29sbGFwc2VkOiBmYWxzZSxcbiAgICAgIHRlbXBsYXRlczogaW5saW5lR3JvdXBcbiAgICB9LFxuICAgIGJsb2NrOiB7XG4gICAgICBzdGFydENvbGxhcHNlZDogZmFsc2UsXG4gICAgICB0ZW1wbGF0ZXM6IGJsb2NrR3JvdXBcbiAgICB9XG4gIH1cbn07ZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdG9hIChhLCBuKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCBuKTsgfVxuIiwidmFyIHNpID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJywgdGljaztcbmlmIChzaSkge1xuICB0aWNrID0gZnVuY3Rpb24gKGZuKSB7IHNldEltbWVkaWF0ZShmbik7IH07XG59IGVsc2Uge1xuICB0aWNrID0gZnVuY3Rpb24gKGZuKSB7IHNldFRpbWVvdXQoZm4sIDApOyB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpY2s7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGlja3kgPSByZXF1aXJlKCd0aWNreScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlYm91bmNlIChmbiwgYXJncywgY3R4KSB7XG4gIGlmICghZm4pIHsgcmV0dXJuOyB9XG4gIHRpY2t5KGZ1bmN0aW9uIHJ1biAoKSB7XG4gICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIGFyZ3MgfHwgW10pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhdG9hID0gcmVxdWlyZSgnYXRvYScpO1xudmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVtaXR0ZXIgKHRoaW5nLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGV2dCA9IHt9O1xuICBpZiAodGhpbmcgPT09IHVuZGVmaW5lZCkgeyB0aGluZyA9IHt9OyB9XG4gIHRoaW5nLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgaWYgKCFldnRbdHlwZV0pIHtcbiAgICAgIGV2dFt0eXBlXSA9IFtmbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dFt0eXBlXS5wdXNoKGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaW5nO1xuICB9O1xuICB0aGluZy5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgZm4uX29uY2UgPSB0cnVlOyAvLyB0aGluZy5vZmYoZm4pIHN0aWxsIHdvcmtzIVxuICAgIHRoaW5nLm9uKHR5cGUsIGZuKTtcbiAgICByZXR1cm4gdGhpbmc7XG4gIH07XG4gIHRoaW5nLm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoYyA9PT0gMSkge1xuICAgICAgZGVsZXRlIGV2dFt0eXBlXTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDApIHtcbiAgICAgIGV2dCA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXQgPSBldnRbdHlwZV07XG4gICAgICBpZiAoIWV0KSB7IHJldHVybiB0aGluZzsgfVxuICAgICAgZXQuc3BsaWNlKGV0LmluZGV4T2YoZm4pLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaW5nO1xuICB9O1xuICB0aGluZy5lbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXRvYShhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGluZy5lbWl0dGVyU25hcHNob3QoYXJncy5zaGlmdCgpKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbiAgdGhpbmcuZW1pdHRlclNuYXBzaG90ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgZXQgPSAoZXZ0W3R5cGVdIHx8IFtdKS5zbGljZSgwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhdG9hKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgY3R4ID0gdGhpcyB8fCB0aGluZztcbiAgICAgIGlmICh0eXBlID09PSAnZXJyb3InICYmIG9wdHMudGhyb3dzICE9PSBmYWxzZSAmJiAhZXQubGVuZ3RoKSB7IHRocm93IGFyZ3MubGVuZ3RoID09PSAxID8gYXJnc1swXSA6IGFyZ3M7IH1cbiAgICAgIGV0LmZvckVhY2goZnVuY3Rpb24gZW1pdHRlciAobGlzdGVuKSB7XG4gICAgICAgIGlmIChvcHRzLmFzeW5jKSB7IGRlYm91bmNlKGxpc3RlbiwgYXJncywgY3R4KTsgfSBlbHNlIHsgbGlzdGVuLmFwcGx5KGN0eCwgYXJncyk7IH1cbiAgICAgICAgaWYgKGxpc3Rlbi5fb25jZSkgeyB0aGluZy5vZmYodHlwZSwgbGlzdGVuKTsgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHRoaW5nO1xufTtcbiIsIlxudmFyIE5hdGl2ZUN1c3RvbUV2ZW50ID0gZ2xvYmFsLkN1c3RvbUV2ZW50O1xuXG5mdW5jdGlvbiB1c2VOYXRpdmUgKCkge1xuICB0cnkge1xuICAgIHZhciBwID0gbmV3IE5hdGl2ZUN1c3RvbUV2ZW50KCdjYXQnLCB7IGRldGFpbDogeyBmb286ICdiYXInIH0gfSk7XG4gICAgcmV0dXJuICAnY2F0JyA9PT0gcC50eXBlICYmICdiYXInID09PSBwLmRldGFpbC5mb287XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ3Jvc3MtYnJvd3NlciBgQ3VzdG9tRXZlbnRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC5DdXN0b21FdmVudFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZU5hdGl2ZSgpID8gTmF0aXZlQ3VzdG9tRXZlbnQgOlxuXG4vLyBJRSA+PSA5XG4nZnVuY3Rpb24nID09PSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPyBmdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICB9IGVsc2Uge1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSwgdm9pZCAwKTtcbiAgfVxuICByZXR1cm4gZTtcbn0gOlxuXG4vLyBJRSA8PSA4XG5mdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgZS50eXBlID0gdHlwZTtcbiAgaWYgKHBhcmFtcykge1xuICAgIGUuYnViYmxlcyA9IEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpO1xuICAgIGUuY2FuY2VsYWJsZSA9IEJvb2xlYW4ocGFyYW1zLmNhbmNlbGFibGUpO1xuICAgIGUuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgfSBlbHNlIHtcbiAgICBlLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICBlLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICBlLmRldGFpbCA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50bWFwID0gW107XG52YXIgZXZlbnRuYW1lID0gJyc7XG52YXIgcm9uID0gL15vbi87XG5cbmZvciAoZXZlbnRuYW1lIGluIGdsb2JhbCkge1xuICBpZiAocm9uLnRlc3QoZXZlbnRuYW1lKSkge1xuICAgIGV2ZW50bWFwLnB1c2goZXZlbnRuYW1lLnNsaWNlKDIpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZW50bWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VzdG9tRXZlbnQgPSByZXF1aXJlKCdjdXN0b20tZXZlbnQnKTtcbnZhciBldmVudG1hcCA9IHJlcXVpcmUoJy4vZXZlbnRtYXAnKTtcbnZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgYWRkRXZlbnQgPSBhZGRFdmVudEVhc3k7XG52YXIgcmVtb3ZlRXZlbnQgPSByZW1vdmVFdmVudEVhc3k7XG52YXIgaGFyZENhY2hlID0gW107XG5cbmlmICghZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgYWRkRXZlbnQgPSBhZGRFdmVudEhhcmQ7XG4gIHJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnRIYXJkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkOiBhZGRFdmVudCxcbiAgcmVtb3ZlOiByZW1vdmVFdmVudCxcbiAgZmFicmljYXRlOiBmYWJyaWNhdGVFdmVudFxufTtcblxuZnVuY3Rpb24gYWRkRXZlbnRFYXN5IChlbCwgdHlwZSwgZm4sIGNhcHR1cmluZykge1xuICByZXR1cm4gZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgY2FwdHVyaW5nKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRIYXJkIChlbCwgdHlwZSwgZm4pIHtcbiAgcmV0dXJuIGVsLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCB3cmFwKGVsLCB0eXBlLCBmbikpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudEVhc3kgKGVsLCB0eXBlLCBmbiwgY2FwdHVyaW5nKSB7XG4gIHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJpbmcpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudEhhcmQgKGVsLCB0eXBlLCBmbikge1xuICB2YXIgbGlzdGVuZXIgPSB1bndyYXAoZWwsIHR5cGUsIGZuKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIGVsLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmFicmljYXRlRXZlbnQgKGVsLCB0eXBlLCBtb2RlbCkge1xuICB2YXIgZSA9IGV2ZW50bWFwLmluZGV4T2YodHlwZSkgPT09IC0xID8gbWFrZUN1c3RvbUV2ZW50KCkgOiBtYWtlQ2xhc3NpY0V2ZW50KCk7XG4gIGlmIChlbC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5maXJlRXZlbnQoJ29uJyArIHR5cGUsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIG1ha2VDbGFzc2ljRXZlbnQgKCkge1xuICAgIHZhciBlO1xuICAgIGlmIChkb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgIGUgPSBkb2MuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGRvYy5jcmVhdGVFdmVudE9iamVjdCkge1xuICAgICAgZSA9IGRvYy5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlQ3VzdG9tRXZlbnQgKCkge1xuICAgIHJldHVybiBuZXcgY3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWw6IG1vZGVsIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBwZXJGYWN0b3J5IChlbCwgdHlwZSwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXBwZXIgKG9yaWdpbmFsRXZlbnQpIHtcbiAgICB2YXIgZSA9IG9yaWdpbmFsRXZlbnQgfHwgZ2xvYmFsLmV2ZW50O1xuICAgIGUudGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGUucHJldmVudERlZmF1bHQgPSBlLnByZXZlbnREZWZhdWx0IHx8IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0ICgpIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9O1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gZS5zdG9wUHJvcGFnYXRpb24gfHwgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICgpIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9O1xuICAgIGUud2hpY2ggPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICBmbi5jYWxsKGVsLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gd3JhcCAoZWwsIHR5cGUsIGZuKSB7XG4gIHZhciB3cmFwcGVyID0gdW53cmFwKGVsLCB0eXBlLCBmbikgfHwgd3JhcHBlckZhY3RvcnkoZWwsIHR5cGUsIGZuKTtcbiAgaGFyZENhY2hlLnB1c2goe1xuICAgIHdyYXBwZXI6IHdyYXBwZXIsXG4gICAgZWxlbWVudDogZWwsXG4gICAgdHlwZTogdHlwZSxcbiAgICBmbjogZm5cbiAgfSk7XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5mdW5jdGlvbiB1bndyYXAgKGVsLCB0eXBlLCBmbikge1xuICB2YXIgaSA9IGZpbmQoZWwsIHR5cGUsIGZuKTtcbiAgaWYgKGkpIHtcbiAgICB2YXIgd3JhcHBlciA9IGhhcmRDYWNoZVtpXS53cmFwcGVyO1xuICAgIGhhcmRDYWNoZS5zcGxpY2UoaSwgMSk7IC8vIGZyZWUgdXAgYSB0YWQgb2YgbWVtb3J5XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZCAoZWwsIHR5cGUsIGZuKSB7XG4gIHZhciBpLCBpdGVtO1xuICBmb3IgKGkgPSAwOyBpIDwgaGFyZENhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgaXRlbSA9IGhhcmRDYWNoZVtpXTtcbiAgICBpZiAoaXRlbS5lbGVtZW50ID09PSBlbCAmJiBpdGVtLnR5cGUgPT09IHR5cGUgJiYgaXRlbS5mbiA9PT0gZm4pIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FjaGUgPSB7fTtcbnZhciBzdGFydCA9ICcoPzpefFxcXFxzKSc7XG52YXIgZW5kID0gJyg/OlxcXFxzfCQpJztcblxuZnVuY3Rpb24gbG9va3VwQ2xhc3MgKGNsYXNzTmFtZSkge1xuICB2YXIgY2FjaGVkID0gY2FjaGVbY2xhc3NOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIGNhY2hlZC5sYXN0SW5kZXggPSAwO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlW2NsYXNzTmFtZV0gPSBjYWNoZWQgPSBuZXcgUmVnRXhwKHN0YXJ0ICsgY2xhc3NOYW1lICsgZW5kLCAnZycpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xhc3NOYW1lKSB7XG4gIHZhciBjdXJyZW50ID0gZWwuY2xhc3NOYW1lO1xuICBpZiAoIWN1cnJlbnQubGVuZ3RoKSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9IGVsc2UgaWYgKCFsb29rdXBDbGFzcyhjbGFzc05hbWUpLnRlc3QoY3VycmVudCkpIHtcbiAgICBlbC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJtQ2xhc3MgKGVsLCBjbGFzc05hbWUpIHtcbiAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobG9va3VwQ2xhc3MoY2xhc3NOYW1lKSwgJyAnKS50cmltKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGQ6IGFkZENsYXNzLFxuICBybTogcm1DbGFzc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCdjb250cmEvZW1pdHRlcicpO1xudmFyIGNyb3NzdmVudCA9IHJlcXVpcmUoJ2Nyb3NzdmVudCcpO1xudmFyIGNsYXNzZXMgPSByZXF1aXJlKCcuL2NsYXNzZXMnKTtcbnZhciBkb2MgPSBkb2N1bWVudDtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5mdW5jdGlvbiBkcmFndWxhIChpbml0aWFsQ29udGFpbmVycywgb3B0aW9ucykge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGluaXRpYWxDb250YWluZXJzKSA9PT0gZmFsc2UpIHtcbiAgICBvcHRpb25zID0gaW5pdGlhbENvbnRhaW5lcnM7XG4gICAgaW5pdGlhbENvbnRhaW5lcnMgPSBbXTtcbiAgfVxuICB2YXIgX21pcnJvcjsgLy8gbWlycm9yIGltYWdlXG4gIHZhciBfc291cmNlOyAvLyBzb3VyY2UgY29udGFpbmVyXG4gIHZhciBfaXRlbTsgLy8gaXRlbSBiZWluZyBkcmFnZ2VkXG4gIHZhciBfb2Zmc2V0WDsgLy8gcmVmZXJlbmNlIHhcbiAgdmFyIF9vZmZzZXRZOyAvLyByZWZlcmVuY2UgeVxuICB2YXIgX21vdmVYOyAvLyByZWZlcmVuY2UgbW92ZSB4XG4gIHZhciBfbW92ZVk7IC8vIHJlZmVyZW5jZSBtb3ZlIHlcbiAgdmFyIF9pbml0aWFsU2libGluZzsgLy8gcmVmZXJlbmNlIHNpYmxpbmcgd2hlbiBncmFiYmVkXG4gIHZhciBfY3VycmVudFNpYmxpbmc7IC8vIHJlZmVyZW5jZSBzaWJsaW5nIG5vd1xuICB2YXIgX2NvcHk7IC8vIGl0ZW0gdXNlZCBmb3IgY29weWluZ1xuICB2YXIgX3JlbmRlclRpbWVyOyAvLyB0aW1lciBmb3Igc2V0VGltZW91dCByZW5kZXJNaXJyb3JJbWFnZVxuICB2YXIgX2xhc3REcm9wVGFyZ2V0ID0gbnVsbDsgLy8gbGFzdCBjb250YWluZXIgaXRlbSB3YXMgb3ZlclxuICB2YXIgX2dyYWJiZWQ7IC8vIGhvbGRzIG1vdXNlZG93biBjb250ZXh0IHVudGlsIGZpcnN0IG1vdXNlbW92ZVxuXG4gIHZhciBvID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG8ubW92ZXMgPT09IHZvaWQgMCkgeyBvLm1vdmVzID0gYWx3YXlzOyB9XG4gIGlmIChvLmFjY2VwdHMgPT09IHZvaWQgMCkgeyBvLmFjY2VwdHMgPSBhbHdheXM7IH1cbiAgaWYgKG8uaW52YWxpZCA9PT0gdm9pZCAwKSB7IG8uaW52YWxpZCA9IGludmFsaWRUYXJnZXQ7IH1cbiAgaWYgKG8uY29udGFpbmVycyA9PT0gdm9pZCAwKSB7IG8uY29udGFpbmVycyA9IGluaXRpYWxDb250YWluZXJzIHx8IFtdOyB9XG4gIGlmIChvLmlzQ29udGFpbmVyID09PSB2b2lkIDApIHsgby5pc0NvbnRhaW5lciA9IG5ldmVyOyB9XG4gIGlmIChvLmNvcHkgPT09IHZvaWQgMCkgeyBvLmNvcHkgPSBmYWxzZTsgfVxuICBpZiAoby5jb3B5U29ydFNvdXJjZSA9PT0gdm9pZCAwKSB7IG8uY29weVNvcnRTb3VyY2UgPSBmYWxzZTsgfVxuICBpZiAoby5yZXZlcnRPblNwaWxsID09PSB2b2lkIDApIHsgby5yZXZlcnRPblNwaWxsID0gZmFsc2U7IH1cbiAgaWYgKG8ucmVtb3ZlT25TcGlsbCA9PT0gdm9pZCAwKSB7IG8ucmVtb3ZlT25TcGlsbCA9IGZhbHNlOyB9XG4gIGlmIChvLmRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IG8uZGlyZWN0aW9uID0gJ3ZlcnRpY2FsJzsgfVxuICBpZiAoby5pZ25vcmVJbnB1dFRleHRTZWxlY3Rpb24gPT09IHZvaWQgMCkgeyBvLmlnbm9yZUlucHV0VGV4dFNlbGVjdGlvbiA9IHRydWU7IH1cbiAgaWYgKG8ubWlycm9yQ29udGFpbmVyID09PSB2b2lkIDApIHsgby5taXJyb3JDb250YWluZXIgPSBkb2MuYm9keTsgfVxuXG4gIHZhciBkcmFrZSA9IGVtaXR0ZXIoe1xuICAgIGNvbnRhaW5lcnM6IG8uY29udGFpbmVycyxcbiAgICBzdGFydDogbWFudWFsU3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gICAgY2FuY2VsOiBjYW5jZWwsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgZGVzdHJveTogZGVzdHJveSxcbiAgICBjYW5Nb3ZlOiBjYW5Nb3ZlLFxuICAgIGRyYWdnaW5nOiBmYWxzZVxuICB9KTtcblxuICBpZiAoby5yZW1vdmVPblNwaWxsID09PSB0cnVlKSB7XG4gICAgZHJha2Uub24oJ292ZXInLCBzcGlsbE92ZXIpLm9uKCdvdXQnLCBzcGlsbE91dCk7XG4gIH1cblxuICBldmVudHMoKTtcblxuICByZXR1cm4gZHJha2U7XG5cbiAgZnVuY3Rpb24gaXNDb250YWluZXIgKGVsKSB7XG4gICAgcmV0dXJuIGRyYWtlLmNvbnRhaW5lcnMuaW5kZXhPZihlbCkgIT09IC0xIHx8IG8uaXNDb250YWluZXIoZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZlbnRzIChyZW1vdmUpIHtcbiAgICB2YXIgb3AgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICAgIHRvdWNoeShkb2N1bWVudEVsZW1lbnQsIG9wLCAnbW91c2Vkb3duJywgZ3JhYik7XG4gICAgdG91Y2h5KGRvY3VtZW50RWxlbWVudCwgb3AsICdtb3VzZXVwJywgcmVsZWFzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBldmVudHVhbE1vdmVtZW50cyAocmVtb3ZlKSB7XG4gICAgdmFyIG9wID0gcmVtb3ZlID8gJ3JlbW92ZScgOiAnYWRkJztcbiAgICB0b3VjaHkoZG9jdW1lbnRFbGVtZW50LCBvcCwgJ21vdXNlbW92ZScsIHN0YXJ0QmVjYXVzZU1vdXNlTW92ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZW1lbnRzIChyZW1vdmUpIHtcbiAgICB2YXIgb3AgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICAgIGNyb3NzdmVudFtvcF0oZG9jdW1lbnRFbGVtZW50LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50R3JhYmJlZCk7IC8vIElFOFxuICAgIGNyb3NzdmVudFtvcF0oZG9jdW1lbnRFbGVtZW50LCAnY2xpY2snLCBwcmV2ZW50R3JhYmJlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICBldmVudHModHJ1ZSk7XG4gICAgcmVsZWFzZSh7fSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmV2ZW50R3JhYmJlZCAoZSkge1xuICAgIGlmIChfZ3JhYmJlZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdyYWIgKGUpIHtcbiAgICBfbW92ZVggPSBlLmNsaWVudFg7XG4gICAgX21vdmVZID0gZS5jbGllbnRZO1xuXG4gICAgdmFyIGlnbm9yZSA9IHdoaWNoTW91c2VCdXR0b24oZSkgIT09IDEgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTtcbiAgICBpZiAoaWdub3JlKSB7XG4gICAgICByZXR1cm47IC8vIHdlIG9ubHkgY2FyZSBhYm91dCBob25lc3QtdG8tZ29kIGxlZnQgY2xpY2tzIGFuZCB0b3VjaCBldmVudHNcbiAgICB9XG4gICAgdmFyIGl0ZW0gPSBlLnRhcmdldDtcbiAgICB2YXIgY29udGV4dCA9IGNhblN0YXJ0KGl0ZW0pO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfZ3JhYmJlZCA9IGNvbnRleHQ7XG4gICAgZXZlbnR1YWxNb3ZlbWVudHMoKTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgaWYgKGlzSW5wdXQoaXRlbSkpIHsgLy8gc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8yMDhcbiAgICAgICAgaXRlbS5mb2N1cygpOyAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZHJhZ3VsYS9pc3N1ZXMvMTc2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8xNTVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEJlY2F1c2VNb3VzZU1vdmVkIChlKSB7XG4gICAgaWYgKCFfZ3JhYmJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2hpY2hNb3VzZUJ1dHRvbihlKSA9PT0gMCkge1xuICAgICAgcmVsZWFzZSh7fSk7XG4gICAgICByZXR1cm47IC8vIHdoZW4gdGV4dCBpcyBzZWxlY3RlZCBvbiBhbiBpbnB1dCBhbmQgdGhlbiBkcmFnZ2VkLCBtb3VzZXVwIGRvZXNuJ3QgZmlyZS4gdGhpcyBpcyBvdXIgb25seSBob3BlXG4gICAgfVxuICAgIC8vIHRydXRoeSBjaGVjayBmaXhlcyAjMjM5LCBlcXVhbGl0eSBmaXhlcyAjMjA3XG4gICAgaWYgKGUuY2xpZW50WCAhPT0gdm9pZCAwICYmIGUuY2xpZW50WCA9PT0gX21vdmVYICYmIGUuY2xpZW50WSAhPT0gdm9pZCAwICYmIGUuY2xpZW50WSA9PT0gX21vdmVZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvLmlnbm9yZUlucHV0VGV4dFNlbGVjdGlvbikge1xuICAgICAgdmFyIGNsaWVudFggPSBnZXRDb29yZCgnY2xpZW50WCcsIGUpO1xuICAgICAgdmFyIGNsaWVudFkgPSBnZXRDb29yZCgnY2xpZW50WScsIGUpO1xuICAgICAgdmFyIGVsZW1lbnRCZWhpbmRDdXJzb3IgPSBkb2MuZWxlbWVudEZyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgIGlmIChpc0lucHV0KGVsZW1lbnRCZWhpbmRDdXJzb3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ3JhYmJlZCA9IF9ncmFiYmVkOyAvLyBjYWxsIHRvIGVuZCgpIHVuc2V0cyBfZ3JhYmJlZFxuICAgIGV2ZW50dWFsTW92ZW1lbnRzKHRydWUpO1xuICAgIG1vdmVtZW50cygpO1xuICAgIGVuZCgpO1xuICAgIHN0YXJ0KGdyYWJiZWQpO1xuXG4gICAgdmFyIG9mZnNldCA9IGdldE9mZnNldChfaXRlbSk7XG4gICAgX29mZnNldFggPSBnZXRDb29yZCgncGFnZVgnLCBlKSAtIG9mZnNldC5sZWZ0O1xuICAgIF9vZmZzZXRZID0gZ2V0Q29vcmQoJ3BhZ2VZJywgZSkgLSBvZmZzZXQudG9wO1xuXG4gICAgY2xhc3Nlcy5hZGQoX2NvcHkgfHwgX2l0ZW0sICdndS10cmFuc2l0Jyk7XG4gICAgcmVuZGVyTWlycm9ySW1hZ2UoKTtcbiAgICBkcmFnKGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuU3RhcnQgKGl0ZW0pIHtcbiAgICBpZiAoZHJha2UuZHJhZ2dpbmcgJiYgX21pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNDb250YWluZXIoaXRlbSkpIHtcbiAgICAgIHJldHVybjsgLy8gZG9uJ3QgZHJhZyBjb250YWluZXIgaXRzZWxmXG4gICAgfVxuICAgIHZhciBoYW5kbGUgPSBpdGVtO1xuICAgIHdoaWxlIChnZXRQYXJlbnQoaXRlbSkgJiYgaXNDb250YWluZXIoZ2V0UGFyZW50KGl0ZW0pKSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChvLmludmFsaWQoaXRlbSwgaGFuZGxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpdGVtID0gZ2V0UGFyZW50KGl0ZW0pOyAvLyBkcmFnIHRhcmdldCBzaG91bGQgYmUgYSB0b3AgZWxlbWVudFxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNvdXJjZSA9IGdldFBhcmVudChpdGVtKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoby5pbnZhbGlkKGl0ZW0sIGhhbmRsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbW92YWJsZSA9IG8ubW92ZXMoaXRlbSwgc291cmNlLCBoYW5kbGUsIG5leHRFbChpdGVtKSk7XG4gICAgaWYgKCFtb3ZhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBzb3VyY2U6IHNvdXJjZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjYW5Nb3ZlIChpdGVtKSB7XG4gICAgcmV0dXJuICEhY2FuU3RhcnQoaXRlbSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYW51YWxTdGFydCAoaXRlbSkge1xuICAgIHZhciBjb250ZXh0ID0gY2FuU3RhcnQoaXRlbSk7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIHN0YXJ0KGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0IChjb250ZXh0KSB7XG4gICAgaWYgKGlzQ29weShjb250ZXh0Lml0ZW0sIGNvbnRleHQuc291cmNlKSkge1xuICAgICAgX2NvcHkgPSBjb250ZXh0Lml0ZW0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgZHJha2UuZW1pdCgnY2xvbmVkJywgX2NvcHksIGNvbnRleHQuaXRlbSwgJ2NvcHknKTtcbiAgICB9XG5cbiAgICBfc291cmNlID0gY29udGV4dC5zb3VyY2U7XG4gICAgX2l0ZW0gPSBjb250ZXh0Lml0ZW07XG4gICAgX2luaXRpYWxTaWJsaW5nID0gX2N1cnJlbnRTaWJsaW5nID0gbmV4dEVsKGNvbnRleHQuaXRlbSk7XG5cbiAgICBkcmFrZS5kcmFnZ2luZyA9IHRydWU7XG4gICAgZHJha2UuZW1pdCgnZHJhZycsIF9pdGVtLCBfc291cmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRUYXJnZXQgKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgaWYgKCFkcmFrZS5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIGRyb3AoaXRlbSwgZ2V0UGFyZW50KGl0ZW0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuZ3JhYiAoKSB7XG4gICAgX2dyYWJiZWQgPSBmYWxzZTtcbiAgICBldmVudHVhbE1vdmVtZW50cyh0cnVlKTtcbiAgICBtb3ZlbWVudHModHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWxlYXNlIChlKSB7XG4gICAgdW5ncmFiKCk7XG5cbiAgICBpZiAoIWRyYWtlLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdmFyIGNsaWVudFggPSBnZXRDb29yZCgnY2xpZW50WCcsIGUpO1xuICAgIHZhciBjbGllbnRZID0gZ2V0Q29vcmQoJ2NsaWVudFknLCBlKTtcbiAgICB2YXIgZWxlbWVudEJlaGluZEN1cnNvciA9IGdldEVsZW1lbnRCZWhpbmRQb2ludChfbWlycm9yLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICB2YXIgZHJvcFRhcmdldCA9IGZpbmREcm9wVGFyZ2V0KGVsZW1lbnRCZWhpbmRDdXJzb3IsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIGlmIChkcm9wVGFyZ2V0ICYmICgoX2NvcHkgJiYgby5jb3B5U29ydFNvdXJjZSkgfHwgKCFfY29weSB8fCBkcm9wVGFyZ2V0ICE9PSBfc291cmNlKSkpIHtcbiAgICAgIGRyb3AoaXRlbSwgZHJvcFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChvLnJlbW92ZU9uU3BpbGwpIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcm9wIChpdGVtLCB0YXJnZXQpIHtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGl0ZW0pO1xuICAgIGlmIChfY29weSAmJiBvLmNvcHlTb3J0U291cmNlICYmIHRhcmdldCA9PT0gX3NvdXJjZSkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKF9pdGVtKTtcbiAgICB9XG4gICAgaWYgKGlzSW5pdGlhbFBsYWNlbWVudCh0YXJnZXQpKSB7XG4gICAgICBkcmFrZS5lbWl0KCdjYW5jZWwnLCBpdGVtLCBfc291cmNlLCBfc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJha2UuZW1pdCgnZHJvcCcsIGl0ZW0sIHRhcmdldCwgX3NvdXJjZSwgX2N1cnJlbnRTaWJsaW5nKTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICBpZiAoIWRyYWtlLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChpdGVtKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgfVxuICAgIGRyYWtlLmVtaXQoX2NvcHkgPyAnY2FuY2VsJyA6ICdyZW1vdmUnLCBpdGVtLCBwYXJlbnQsIF9zb3VyY2UpO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCAocmV2ZXJ0KSB7XG4gICAgaWYgKCFkcmFrZS5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV2ZXJ0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gcmV2ZXJ0IDogby5yZXZlcnRPblNwaWxsO1xuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChpdGVtKTtcbiAgICB2YXIgaW5pdGlhbCA9IGlzSW5pdGlhbFBsYWNlbWVudChwYXJlbnQpO1xuICAgIGlmIChpbml0aWFsID09PSBmYWxzZSAmJiByZXZlcnRzKSB7XG4gICAgICBpZiAoX2NvcHkpIHtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChfY29weSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zb3VyY2UuaW5zZXJ0QmVmb3JlKGl0ZW0sIF9pbml0aWFsU2libGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0aWFsIHx8IHJldmVydHMpIHtcbiAgICAgIGRyYWtlLmVtaXQoJ2NhbmNlbCcsIGl0ZW0sIF9zb3VyY2UsIF9zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmFrZS5lbWl0KCdkcm9wJywgaXRlbSwgcGFyZW50LCBfc291cmNlLCBfY3VycmVudFNpYmxpbmcpO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIHVuZ3JhYigpO1xuICAgIHJlbW92ZU1pcnJvckltYWdlKCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNsYXNzZXMucm0oaXRlbSwgJ2d1LXRyYW5zaXQnKTtcbiAgICB9XG4gICAgaWYgKF9yZW5kZXJUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KF9yZW5kZXJUaW1lcik7XG4gICAgfVxuICAgIGRyYWtlLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgaWYgKF9sYXN0RHJvcFRhcmdldCkge1xuICAgICAgZHJha2UuZW1pdCgnb3V0JywgaXRlbSwgX2xhc3REcm9wVGFyZ2V0LCBfc291cmNlKTtcbiAgICB9XG4gICAgZHJha2UuZW1pdCgnZHJhZ2VuZCcsIGl0ZW0pO1xuICAgIF9zb3VyY2UgPSBfaXRlbSA9IF9jb3B5ID0gX2luaXRpYWxTaWJsaW5nID0gX2N1cnJlbnRTaWJsaW5nID0gX3JlbmRlclRpbWVyID0gX2xhc3REcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5pdGlhbFBsYWNlbWVudCAodGFyZ2V0LCBzKSB7XG4gICAgdmFyIHNpYmxpbmc7XG4gICAgaWYgKHMgIT09IHZvaWQgMCkge1xuICAgICAgc2libGluZyA9IHM7XG4gICAgfSBlbHNlIGlmIChfbWlycm9yKSB7XG4gICAgICBzaWJsaW5nID0gX2N1cnJlbnRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWJsaW5nID0gbmV4dEVsKF9jb3B5IHx8IF9pdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldCA9PT0gX3NvdXJjZSAmJiBzaWJsaW5nID09PSBfaW5pdGlhbFNpYmxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRHJvcFRhcmdldCAoZWxlbWVudEJlaGluZEN1cnNvciwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciB0YXJnZXQgPSBlbGVtZW50QmVoaW5kQ3Vyc29yO1xuICAgIHdoaWxlICh0YXJnZXQgJiYgIWFjY2VwdGVkKCkpIHtcbiAgICAgIHRhcmdldCA9IGdldFBhcmVudCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuXG4gICAgZnVuY3Rpb24gYWNjZXB0ZWQgKCkge1xuICAgICAgdmFyIGRyb3BwYWJsZSA9IGlzQ29udGFpbmVyKHRhcmdldCk7XG4gICAgICBpZiAoZHJvcHBhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbW1lZGlhdGUgPSBnZXRJbW1lZGlhdGVDaGlsZCh0YXJnZXQsIGVsZW1lbnRCZWhpbmRDdXJzb3IpO1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZSh0YXJnZXQsIGltbWVkaWF0ZSwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICB2YXIgaW5pdGlhbCA9IGlzSW5pdGlhbFBsYWNlbWVudCh0YXJnZXQsIHJlZmVyZW5jZSk7XG4gICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGRyb3AgaXQgcmlnaHQgYmFjayB3aGVyZSBpdCB3YXNcbiAgICAgIH1cbiAgICAgIHJldHVybiBvLmFjY2VwdHMoX2l0ZW0sIHRhcmdldCwgX3NvdXJjZSwgcmVmZXJlbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmFnIChlKSB7XG4gICAgaWYgKCFfbWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBjbGllbnRYID0gZ2V0Q29vcmQoJ2NsaWVudFgnLCBlKTtcbiAgICB2YXIgY2xpZW50WSA9IGdldENvb3JkKCdjbGllbnRZJywgZSk7XG4gICAgdmFyIHggPSBjbGllbnRYIC0gX29mZnNldFg7XG4gICAgdmFyIHkgPSBjbGllbnRZIC0gX29mZnNldFk7XG5cbiAgICBfbWlycm9yLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICBfbWlycm9yLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuXG4gICAgdmFyIGl0ZW0gPSBfY29weSB8fCBfaXRlbTtcbiAgICB2YXIgZWxlbWVudEJlaGluZEN1cnNvciA9IGdldEVsZW1lbnRCZWhpbmRQb2ludChfbWlycm9yLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICB2YXIgZHJvcFRhcmdldCA9IGZpbmREcm9wVGFyZ2V0KGVsZW1lbnRCZWhpbmRDdXJzb3IsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIHZhciBjaGFuZ2VkID0gZHJvcFRhcmdldCAhPT0gbnVsbCAmJiBkcm9wVGFyZ2V0ICE9PSBfbGFzdERyb3BUYXJnZXQ7XG4gICAgaWYgKGNoYW5nZWQgfHwgZHJvcFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgb3V0KCk7XG4gICAgICBfbGFzdERyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuICAgICAgb3ZlcigpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGl0ZW0pO1xuICAgIGlmIChkcm9wVGFyZ2V0ID09PSBfc291cmNlICYmIF9jb3B5ICYmICFvLmNvcHlTb3J0U291cmNlKSB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChpdGVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlZmVyZW5jZTtcbiAgICB2YXIgaW1tZWRpYXRlID0gZ2V0SW1tZWRpYXRlQ2hpbGQoZHJvcFRhcmdldCwgZWxlbWVudEJlaGluZEN1cnNvcik7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gbnVsbCkge1xuICAgICAgcmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlKGRyb3BUYXJnZXQsIGltbWVkaWF0ZSwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmIChvLnJldmVydE9uU3BpbGwgPT09IHRydWUgJiYgIV9jb3B5KSB7XG4gICAgICByZWZlcmVuY2UgPSBfaW5pdGlhbFNpYmxpbmc7XG4gICAgICBkcm9wVGFyZ2V0ID0gX3NvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9jb3B5ICYmIHBhcmVudCkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIChyZWZlcmVuY2UgPT09IG51bGwgJiYgY2hhbmdlZCkgfHxcbiAgICAgIHJlZmVyZW5jZSAhPT0gaXRlbSAmJlxuICAgICAgcmVmZXJlbmNlICE9PSBuZXh0RWwoaXRlbSlcbiAgICApIHtcbiAgICAgIF9jdXJyZW50U2libGluZyA9IHJlZmVyZW5jZTtcbiAgICAgIGRyb3BUYXJnZXQuaW5zZXJ0QmVmb3JlKGl0ZW0sIHJlZmVyZW5jZSk7XG4gICAgICBkcmFrZS5lbWl0KCdzaGFkb3cnLCBpdGVtLCBkcm9wVGFyZ2V0LCBfc291cmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW92ZWQgKHR5cGUpIHsgZHJha2UuZW1pdCh0eXBlLCBpdGVtLCBfbGFzdERyb3BUYXJnZXQsIF9zb3VyY2UpOyB9XG4gICAgZnVuY3Rpb24gb3ZlciAoKSB7IGlmIChjaGFuZ2VkKSB7IG1vdmVkKCdvdmVyJyk7IH0gfVxuICAgIGZ1bmN0aW9uIG91dCAoKSB7IGlmIChfbGFzdERyb3BUYXJnZXQpIHsgbW92ZWQoJ291dCcpOyB9IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwaWxsT3ZlciAoZWwpIHtcbiAgICBjbGFzc2VzLnJtKGVsLCAnZ3UtaGlkZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BpbGxPdXQgKGVsKSB7XG4gICAgaWYgKGRyYWtlLmRyYWdnaW5nKSB7IGNsYXNzZXMuYWRkKGVsLCAnZ3UtaGlkZScpOyB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJNaXJyb3JJbWFnZSAoKSB7XG4gICAgaWYgKF9taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlY3QgPSBfaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBfbWlycm9yID0gX2l0ZW0uY2xvbmVOb2RlKHRydWUpO1xuICAgIF9taXJyb3Iuc3R5bGUud2lkdGggPSBnZXRSZWN0V2lkdGgocmVjdCkgKyAncHgnO1xuICAgIF9taXJyb3Iuc3R5bGUuaGVpZ2h0ID0gZ2V0UmVjdEhlaWdodChyZWN0KSArICdweCc7XG4gICAgY2xhc3Nlcy5ybShfbWlycm9yLCAnZ3UtdHJhbnNpdCcpO1xuICAgIGNsYXNzZXMuYWRkKF9taXJyb3IsICdndS1taXJyb3InKTtcbiAgICBvLm1pcnJvckNvbnRhaW5lci5hcHBlbmRDaGlsZChfbWlycm9yKTtcbiAgICB0b3VjaHkoZG9jdW1lbnRFbGVtZW50LCAnYWRkJywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGNsYXNzZXMuYWRkKG8ubWlycm9yQ29udGFpbmVyLCAnZ3UtdW5zZWxlY3RhYmxlJyk7XG4gICAgZHJha2UuZW1pdCgnY2xvbmVkJywgX21pcnJvciwgX2l0ZW0sICdtaXJyb3InKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU1pcnJvckltYWdlICgpIHtcbiAgICBpZiAoX21pcnJvcikge1xuICAgICAgY2xhc3Nlcy5ybShvLm1pcnJvckNvbnRhaW5lciwgJ2d1LXVuc2VsZWN0YWJsZScpO1xuICAgICAgdG91Y2h5KGRvY3VtZW50RWxlbWVudCwgJ3JlbW92ZScsICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGdldFBhcmVudChfbWlycm9yKS5yZW1vdmVDaGlsZChfbWlycm9yKTtcbiAgICAgIF9taXJyb3IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEltbWVkaWF0ZUNoaWxkIChkcm9wVGFyZ2V0LCB0YXJnZXQpIHtcbiAgICB2YXIgaW1tZWRpYXRlID0gdGFyZ2V0O1xuICAgIHdoaWxlIChpbW1lZGlhdGUgIT09IGRyb3BUYXJnZXQgJiYgZ2V0UGFyZW50KGltbWVkaWF0ZSkgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgIGltbWVkaWF0ZSA9IGdldFBhcmVudChpbW1lZGlhdGUpO1xuICAgIH1cbiAgICBpZiAoaW1tZWRpYXRlID09PSBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW1tZWRpYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlIChkcm9wVGFyZ2V0LCB0YXJnZXQsIHgsIHkpIHtcbiAgICB2YXIgaG9yaXpvbnRhbCA9IG8uZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgdmFyIHJlZmVyZW5jZSA9IHRhcmdldCAhPT0gZHJvcFRhcmdldCA/IGluc2lkZSgpIDogb3V0c2lkZSgpO1xuICAgIHJldHVybiByZWZlcmVuY2U7XG5cbiAgICBmdW5jdGlvbiBvdXRzaWRlICgpIHsgLy8gc2xvd2VyLCBidXQgYWJsZSB0byBmaWd1cmUgb3V0IGFueSBwb3NpdGlvblxuICAgICAgdmFyIGxlbiA9IGRyb3BUYXJnZXQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgZWw7XG4gICAgICB2YXIgcmVjdDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbCA9IGRyb3BUYXJnZXQuY2hpbGRyZW5baV07XG4gICAgICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGhvcml6b250YWwgJiYgKHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyKSA+IHgpIHsgcmV0dXJuIGVsOyB9XG4gICAgICAgIGlmICghaG9yaXpvbnRhbCAmJiAocmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIpID4geSkgeyByZXR1cm4gZWw7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2lkZSAoKSB7IC8vIGZhc3RlciwgYnV0IG9ubHkgYXZhaWxhYmxlIGlmIGRyb3BwZWQgaW5zaWRlIGEgY2hpbGQgZWxlbWVudFxuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh4ID4gcmVjdC5sZWZ0ICsgZ2V0UmVjdFdpZHRoKHJlY3QpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZSh5ID4gcmVjdC50b3AgKyBnZXRSZWN0SGVpZ2h0KHJlY3QpIC8gMik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSAoYWZ0ZXIpIHtcbiAgICAgIHJldHVybiBhZnRlciA/IG5leHRFbCh0YXJnZXQpIDogdGFyZ2V0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29weSAoaXRlbSwgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvLmNvcHkgPT09ICdib29sZWFuJyA/IG8uY29weSA6IG8uY29weShpdGVtLCBjb250YWluZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvdWNoeSAoZWwsIG9wLCB0eXBlLCBmbikge1xuICB2YXIgdG91Y2ggPSB7XG4gICAgbW91c2V1cDogJ3RvdWNoZW5kJyxcbiAgICBtb3VzZWRvd246ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3VzZW1vdmU6ICd0b3VjaG1vdmUnXG4gIH07XG4gIHZhciBwb2ludGVycyA9IHtcbiAgICBtb3VzZXVwOiAncG9pbnRlcnVwJyxcbiAgICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gICAgbW91c2Vtb3ZlOiAncG9pbnRlcm1vdmUnXG4gIH07XG4gIHZhciBtaWNyb3NvZnQgPSB7XG4gICAgbW91c2V1cDogJ01TUG9pbnRlclVwJyxcbiAgICBtb3VzZWRvd246ICdNU1BvaW50ZXJEb3duJyxcbiAgICBtb3VzZW1vdmU6ICdNU1BvaW50ZXJNb3ZlJ1xuICB9O1xuICBpZiAoZ2xvYmFsLm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCkge1xuICAgIGNyb3NzdmVudFtvcF0oZWwsIHBvaW50ZXJzW3R5cGVdLCBmbik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgY3Jvc3N2ZW50W29wXShlbCwgbWljcm9zb2Z0W3R5cGVdLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgY3Jvc3N2ZW50W29wXShlbCwgdG91Y2hbdHlwZV0sIGZuKTtcbiAgICBjcm9zc3ZlbnRbb3BdKGVsLCB0eXBlLCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hpY2hNb3VzZUJ1dHRvbiAoZSkge1xuICBpZiAoZS50b3VjaGVzICE9PSB2b2lkIDApIHsgcmV0dXJuIGUudG91Y2hlcy5sZW5ndGg7IH1cbiAgaWYgKGUud2hpY2ggIT09IHZvaWQgMCAmJiBlLndoaWNoICE9PSAwKSB7IHJldHVybiBlLndoaWNoOyB9IC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZHJhZ3VsYS9pc3N1ZXMvMjYxXG4gIGlmIChlLmJ1dHRvbnMgIT09IHZvaWQgMCkgeyByZXR1cm4gZS5idXR0b25zOyB9XG4gIHZhciBidXR0b24gPSBlLmJ1dHRvbjtcbiAgaWYgKGJ1dHRvbiAhPT0gdm9pZCAwKSB7IC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzk5ZThmZjFiYWE3YWUzNDFlOTRiYjg5YzNlODQ1NzBjN2MzYWQ5ZWEvc3JjL2V2ZW50LmpzI0w1NzMtTDU3NVxuICAgIHJldHVybiBidXR0b24gJiAxID8gMSA6IGJ1dHRvbiAmIDIgPyAzIDogKGJ1dHRvbiAmIDQgPyAyIDogMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0IChlbCkge1xuICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCArIGdldFNjcm9sbCgnc2Nyb2xsTGVmdCcsICdwYWdlWE9mZnNldCcpLFxuICAgIHRvcDogcmVjdC50b3AgKyBnZXRTY3JvbGwoJ3Njcm9sbFRvcCcsICdwYWdlWU9mZnNldCcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCAoc2Nyb2xsUHJvcCwgb2Zmc2V0UHJvcCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFtvZmZzZXRQcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsW29mZnNldFByb3BdO1xuICB9XG4gIGlmIChkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudFtzY3JvbGxQcm9wXTtcbiAgfVxuICByZXR1cm4gZG9jLmJvZHlbc2Nyb2xsUHJvcF07XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRCZWhpbmRQb2ludCAocG9pbnQsIHgsIHkpIHtcbiAgdmFyIHAgPSBwb2ludCB8fCB7fTtcbiAgdmFyIHN0YXRlID0gcC5jbGFzc05hbWU7XG4gIHZhciBlbDtcbiAgcC5jbGFzc05hbWUgKz0gJyBndS1oaWRlJztcbiAgZWwgPSBkb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgcC5jbGFzc05hbWUgPSBzdGF0ZTtcbiAgcmV0dXJuIGVsO1xufVxuXG5mdW5jdGlvbiBuZXZlciAoKSB7IHJldHVybiBmYWxzZTsgfVxuZnVuY3Rpb24gYWx3YXlzICgpIHsgcmV0dXJuIHRydWU7IH1cbmZ1bmN0aW9uIGdldFJlY3RXaWR0aCAocmVjdCkgeyByZXR1cm4gcmVjdC53aWR0aCB8fCAocmVjdC5yaWdodCAtIHJlY3QubGVmdCk7IH1cbmZ1bmN0aW9uIGdldFJlY3RIZWlnaHQgKHJlY3QpIHsgcmV0dXJuIHJlY3QuaGVpZ2h0IHx8IChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKTsgfVxuZnVuY3Rpb24gZ2V0UGFyZW50IChlbCkgeyByZXR1cm4gZWwucGFyZW50Tm9kZSA9PT0gZG9jID8gbnVsbCA6IGVsLnBhcmVudE5vZGU7IH1cbmZ1bmN0aW9uIGlzSW5wdXQgKGVsKSB7IHJldHVybiBlbC50YWdOYW1lID09PSAnSU5QVVQnIHx8IGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHwgZWwudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHwgaXNFZGl0YWJsZShlbCk7IH1cbmZ1bmN0aW9uIGlzRWRpdGFibGUgKGVsKSB7XG4gIGlmICghZWwpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIG5vIHBhcmVudHMgd2VyZSBlZGl0YWJsZVxuICBpZiAoZWwuY29udGVudEVkaXRhYmxlID09PSAnZmFsc2UnKSB7IHJldHVybiBmYWxzZTsgfSAvLyBzdG9wIHRoZSBsb29rdXBcbiAgaWYgKGVsLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7IHJldHVybiB0cnVlOyB9IC8vIGZvdW5kIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgaW4gdGhlIGNoYWluXG4gIHJldHVybiBpc0VkaXRhYmxlKGdldFBhcmVudChlbCkpOyAvLyBjb250ZW50RWRpdGFibGUgaXMgc2V0IHRvICdpbmhlcml0J1xufVxuXG5mdW5jdGlvbiBuZXh0RWwgKGVsKSB7XG4gIHJldHVybiBlbC5uZXh0RWxlbWVudFNpYmxpbmcgfHwgbWFudWFsbHkoKTtcbiAgZnVuY3Rpb24gbWFudWFsbHkgKCkge1xuICAgIHZhciBzaWJsaW5nID0gZWw7XG4gICAgZG8ge1xuICAgICAgc2libGluZyA9IHNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgfSB3aGlsZSAoc2libGluZyAmJiBzaWJsaW5nLm5vZGVUeXBlICE9PSAxKTtcbiAgICByZXR1cm4gc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFdmVudEhvc3QgKGUpIHtcbiAgLy8gb24gdG91Y2hlbmQgZXZlbnQsIHdlIGhhdmUgdG8gdXNlIGBlLmNoYW5nZWRUb3VjaGVzYFxuICAvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MTkyNTYzL3RvdWNoZW5kLWV2ZW50LXByb3BlcnRpZXNcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8zNFxuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdO1xuICB9XG4gIGlmIChlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGdldENvb3JkIChjb29yZCwgZSkge1xuICB2YXIgaG9zdCA9IGdldEV2ZW50SG9zdChlKTtcbiAgdmFyIG1pc3NNYXAgPSB7XG4gICAgcGFnZVg6ICdjbGllbnRYJywgLy8gSUU4XG4gICAgcGFnZVk6ICdjbGllbnRZJyAvLyBJRThcbiAgfTtcbiAgaWYgKGNvb3JkIGluIG1pc3NNYXAgJiYgIShjb29yZCBpbiBob3N0KSAmJiBtaXNzTWFwW2Nvb3JkXSBpbiBob3N0KSB7XG4gICAgY29vcmQgPSBtaXNzTWFwW2Nvb3JkXTtcbiAgfVxuICByZXR1cm4gaG9zdFtjb29yZF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhZ3VsYTtcbiIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uLy4uL2NoZWNrcy5qcyc7aW1wb3J0J3F1aWNrZG9tJztpbXBvcnQgU2ltcGx5QmluZCBmcm9tJ0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL3JlZ2V4LmpzJztpbXBvcnQge2luY2x1ZGVzLGluc2VydEFmdGVyLHJlbW92ZUl0ZW19ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQgZXh0ZW5kIGZyb20nc21hcnQtZXh0ZW5kJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvY29uZGl0aW9uLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvdHJhbnNmb3JtU2V0dGluZ3MuanMnO2ltcG9ydCcuLi8uLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi4vLi4vZmllbGQvaW5kZXguanMnO2ltcG9ydCcuLi8uLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2FuZ2xlRG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCcuLi9ncm91cC90ZW1wbGF0ZS0wODZhODJlMi5qcyc7aW1wb3J0IHtjIGFzIHRlbXBsYXRlLGQgYXMgdGVtcGxhdGVzfWZyb20nLi90ZW1wbGF0ZS03YzI4NGU2MS5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7aW1wb3J0IGRyYWd1bGEgZnJvbSdkcmFndWxhJzsoZnVuY3Rpb24oKXtcblx0dmFyIGNzcyA9IFwiLmd1LW1pcnJvciB7XFxuICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcXG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xcbiAgei1pbmRleDogOTk5OSAhaW1wb3J0YW50O1xcbiAgb3BhY2l0eTogMC44O1xcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTgwKVxcXCI7XFxuICBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9ODApO1xcbn1cXG4uZ3UtaGlkZSB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxufVxcbi5ndS11bnNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lICFpbXBvcnRhbnQ7XFxuICB1c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG4uZ3UtdHJhbnNpdCB7XFxuICBvcGFjaXR5OiAwLjI7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9MjApXFxcIjtcXG4gIGZpbHRlcjogYWxwaGEob3BhY2l0eT0yMCk7XFxufVxcblwiO1xuXHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdHZhciBzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFxuXHRzaGVldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmlsZScsICcvVXNlcnMvZGFuaWVsa2FsZW4vc2FuZGJveC9xdWlja2ZpZWxkL25vZGVfbW9kdWxlcy9kcmFndWxhL2Rpc3QvZHJhZ3VsYS5jc3MnKTtcblx0c2hlZXQuaW5uZXJIVE1MID0gY3NzO1xuXHRoZWFkLmFwcGVuZENoaWxkKHNoZWV0KTtcbn0pKCk7dmFyIFJlcGVhdGVyRmllbGQ7XG5cblJlcGVhdGVyRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIFJlcGVhdGVyRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB2YXIgYmFzZSwgZGlmZjtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLl9jYWxjRm9jdXNTdGF0ZSA9IHRoaXMuX2NhbGNGb2N1c1N0YXRlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9jYWxjQmx1clN0YXRlID0gdGhpcy5fY2FsY0JsdXJTdGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fZW1pdFN1Ym1pdCA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdzdWJtaXQnKTtcbiAgICAgIHRoaXMuZ3JvdXBMYWJlbCA9IElTLnN0cmluZyh0aGlzLnNldHRpbmdzLm51bWJlcmluZykgPyB0aGlzLnNldHRpbmdzLm51bWJlcmluZyA6ICdJdGVtJztcbiAgICAgIHRoaXMubGFiZWxSZWdleCA9IG5ldyBSZWdFeHAoYF4ke3RoaXMuZ3JvdXBMYWJlbH0gXFxcXGQrKD86XFw6ICk/YCk7XG4gICAgICB0aGlzLnN0YXRlLmNvbGxhcHNlZCA9IHRoaXMuc2V0dGluZ3Muc3RhcnRDb2xsYXBzZWQgJiYgdGhpcy5zZXR0aW5ncy5jb2xsYXBzYWJsZTtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXR0aW5ncy5fZ3JvdXBTZXR0aW5ncyA9IGV4dGVuZC5ub3RLZXlzKFsnaW5saW5lJywgJ2Jsb2NrJ10pLmNsb25lKHRoaXMuc2V0dGluZ3MuZ3JvdXBTZXR0aW5ncyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmdyb3VwU2V0dGluZ3MgPSBleHRlbmQua2V5cyhbJ2lubGluZScsICdibG9jayddKS5jbG9uZSh0aGlzLnNldHRpbmdzLmdyb3VwU2V0dGluZ3MpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHlsZSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICB0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmZpZWxkKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc2luZ2xlTW9kZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNpbmdsZU1vZGUpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5maWVsZHMgPSBbdGhpcy5zZXR0aW5ncy5maWVsZCB8fCB0aGlzLnNldHRpbmdzLmZpZWxkc107XG4gICAgICB9XG5cbiAgICAgIGlmICgoYmFzZSA9IHRoaXMuc2V0dGluZ3MpLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgYmFzZS52YWx1ZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5taW5JdGVtcyAmJiB0aGlzLnNldHRpbmdzLnZhbHVlLmxlbmd0aCA8IHRoaXMuc2V0dGluZ3MubWluSXRlbXMpIHtcbiAgICAgICAgZGlmZiA9IHRoaXMuc2V0dGluZ3MubWluSXRlbXMgLSB0aGlzLnNldHRpbmdzLnZhbHVlLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1kaWZmKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy52YWx1ZS5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgdmFyIGdyb3VwLCBpLCBpbmRleCwgbGVuLCByZWYsIHZhbHVlcztcbiAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgcmVmID0gdGhpcy5fdmFsdWU7XG5cbiAgICAgIGZvciAoaW5kZXggPSBpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaW5kZXggPSArK2kpIHtcbiAgICAgICAgZ3JvdXAgPSByZWZbaW5kZXhdO1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gZ3JvdXAudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgX3NldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB2YXIgaSwgaW5kZXgsIGxlbiwgdmFsdWU7XG5cbiAgICAgIGlmICghSVMuYXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYWRkSXRlbShuZXdWYWx1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpbmRleCA9IGkgPSAwLCBsZW4gPSBuZXdWYWx1ZS5sZW5ndGg7IGkgPCBsZW47IGluZGV4ID0gKytpKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZVtpbmRleF07XG5cbiAgICAgICAgICBpZiAodGhpcy5fdmFsdWVbaW5kZXhdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlW2luZGV4XS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZEl0ZW0odmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cblxuICAgIF9jcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBmb3JjZU9wdHM7XG4gICAgICBmb3JjZU9wdHMgPSB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLnRlbXBsYXRlLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmRlZmF1bHQsIGZvcmNlT3B0cyk7XG4gICAgICB0aGlzLmVsLnN0YXRlKCdjb2xsYXBzYWJsZScsIHRoaXMuc2V0dGluZ3MuY29sbGFwc2FibGUpO1xuICAgICAgdGhpcy5lbC5zdGF0ZShgJHt0aGlzLnNldHRpbmdzLnN0eWxlfVN0eWxlYCwgdHJ1ZSk7XG4gICAgICB0aGlzLmVsLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXMuZWwuY2hpbGRmLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5kcmFnZHJvcCkge1xuICAgICAgICB0aGlzLmRyYWdnZXIgPSBkcmFndWxhKFt0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5yYXddLCB7XG4gICAgICAgICAgcmV2ZXJ0T25TcGlsbDogdHJ1ZSxcbiAgICAgICAgICBpbnZhbGlkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICByZXR1cm4gKChyZWYgPSBlbC5fcXVpY2tFbGVtZW50KSAhPSBudWxsID8gcmVmLnJlZiA6IHZvaWQgMCkgPT09ICdhZGRCdXR0b24nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIG1vdmVzOiAoXywgX18sIGVsKS0+IGVsLl9xdWlja0VsZW1lbnQ/LnJlZiBpcyAnaGVhZGVyJ1xuXG4gICAgICAgIHRoaXMuZHJhZ2dlci5vbignZHJvcCcsICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZU9yZ2FuaXplKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKSB7XG4gICAgICBTaW1wbHlCaW5kKCd2aXNpYmxlJykub2YodGhpcy5zdGF0ZSkudG8odmlzaWJsZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2Rpc2FibGVkJykub2YodGhpcy5zdGF0ZSkudG8oZGlzYWJsZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZGlzYWJsZWQnLCBkaXNhYmxlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dMYWJlbCcpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dMYWJlbCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93TGFiZWwnLCBzaG93TGFiZWwpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93RXJyb3InKS5vZih0aGlzLnN0YXRlKS50byhzaG93RXJyb3IgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0Vycm9yJywgc2hvd0Vycm9yKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0hlbHAnKS5vZih0aGlzLnN0YXRlKS50byhzaG93SGVscCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93SGVscCcsIHNob3dIZWxwKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnY29sbGFwc2VkJykub2YodGhpcy5zdGF0ZSkudG8oY29sbGFwc2VkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2NvbGxhcHNlZCcsIGNvbGxhcHNlZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaW1wbHlCaW5kKCd2YWxpZCcpLm9mKHRoaXMuc3RhdGUpLnRvKHZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5lbC5zdGF0ZSgndmFsaWQnLCB2YWxpZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdpbnZhbGlkJywgIXZhbGlkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCkge1xuICAgICAgdmFyIGdyb3VwLCBpLCBsZW4sIHJlZjtcbiAgICAgIFNpbXBseUJpbmQoJ3dpZHRoJykub2YodGhpcy5zdGF0ZSkudG8od2lkdGggPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdHlsZSgnd2lkdGgnLCB3aWR0aCkuc3RhdGUoJ2RlZmluZWRXaWR0aCcsIHdpZHRoICE9PSAnYXV0bycpO1xuICAgICAgfSkudHJhbnNmb3JtKHRoaXMuX2Zvcm1hdFdpZHRoLmJpbmQodGhpcykpLnVwZGF0ZU9uKCdpc01vYmlsZScpLm9mKHRoaXMuc3RhdGUpO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0Vycm9yJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzLnN0YXRlKS50byhzaG93RXJyb3IgPT4ge1xuICAgICAgICB2YXIgZ3JvdXAsIGksIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICByZWYgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGdyb3VwID0gcmVmW2ldO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChncm91cC5zdGF0ZS5zaG93RXJyb3IgPSBzaG93RXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KTtcbiAgICAgIHJlZiA9IHRoaXMuX3ZhbHVlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSByZWZbaV07XG4gICAgICAgIFNpbXBseUJpbmQoJ2Rpc2FibGVkJykub2YodGhpcy5zdGF0ZSkudG8oJ2Rpc2FibGVkJykub2YoZmllbGQuc3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCkge1xuICAgICAgdmFyIHRvZ2dsZUNvbGxhcHNlO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb2xsYXBzYWJsZSkge1xuICAgICAgICB0b2dnbGVDb2xsYXBzZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbGxhcHNlZCA9ICF0aGlzLnN0YXRlLmNvbGxhcHNlZDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdjb2xsYXBzZWQnLCB0aGlzLnN0YXRlLmNvbGxhcHNlZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Y2xpY2snKS5vZih0aGlzLmVsLmNoaWxkLmNvbGxhcHNlKS50byh0b2dnbGVDb2xsYXBzZSk7XG4gICAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YodGhpcy5lbC5jaGlsZC5sYWJlbCkudG8odG9nZ2xlQ29sbGFwc2UpO1xuICAgICAgICBTaW1wbHlCaW5kKCdjb2xsYXBzZWQnKS5vZih0aGlzLnN0YXRlKS5vbmNlLnRvKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjYWxjRGlzcGxheSgpO1xuICAgICAgICB9KS5jb25kaXRpb24oZnVuY3Rpb24gKGNvbGxhcHNlZCkge1xuICAgICAgICAgIHJldHVybiAhY29sbGFwc2VkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfdmFsdWUoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdhcnJheTpfdmFsdWUnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogdHJ1ZVxuICAgICAgfSkub2YodGhpcykudG8oKHZhbHVlLCBwcmV2VmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3JlY2FsY0xhYmVscygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUuaW50ZXJhY3RlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudmFsaWQgPSB0aGlzLnZhbGlkYXRlKHZvaWQgMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Y2xpY2snKS5vZih0aGlzLmVsLmNoaWxkLmFkZEJ1dHRvbikudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRJdGVtKCkuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZShwcm92aWRlZFZhbHVlLCB0ZXN0VW5yZXF1aXJlZCkge1xuICAgICAgdmFyIGdyb3VwLCBpLCBpc1ZhbGlkLCBsZW4sIHJlZjtcbiAgICAgIHJlZiA9IHRoaXMuX3ZhbHVlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSByZWZbaV07XG4gICAgICAgIGlzVmFsaWQgPSBncm91cC52YWxpZGF0ZShwcm92aWRlZFZhbHVlW2dyb3VwLm5hbWVdLCB0ZXN0VW5yZXF1aXJlZCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9jYWxjRm9jdXNTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZvY3VzZWQgPSB0aGlzLl92YWx1ZS5zb21lKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmllbGQuc3RhdGUuZm9jdXNlZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jYWxjQmx1clN0YXRlKCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQodGhpcy5fY2FsY0ZvY3VzU3RhdGUpO1xuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy5fdmFsdWVbMF0pICE9IG51bGwgPyByZWYuZm9jdXMoKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBibHVyKCkge1xuICAgICAgdmFyIGZpZWxkLCBpLCBsZW4sIHJlZjtcbiAgICAgIHJlZiA9IHRoaXMuX3ZhbHVlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSByZWZbaV07XG5cbiAgICAgICAgaWYgKGZpZWxkLmJsdXIpIHtcbiAgICAgICAgICBmaWVsZC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVjYWxjTGFiZWxzKCkge1xuICAgICAgdmFyIGdyb3VwLCBpLCBpbmRleCwgbGVuLCByZWY7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0eWxlID09PSAnYmxvY2snKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5udW1iZXJpbmcgJiYgIXRoaXMuc2V0dGluZ3MuZHluYW1pY0xhYmVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmID0gdGhpcy5fdmFsdWU7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpbmRleCA9ICsraSkge1xuICAgICAgICAgIGdyb3VwID0gcmVmW2luZGV4XTtcblxuICAgICAgICAgIHRoaXMuX3JlY2FsY0xhYmVsKGdyb3VwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVjYWxjTGFiZWwoZ3JvdXAsIGluZGV4KSB7XG4gICAgICB2YXIgZXhpc3RpbmdMYWJlbCwgbmV3TGFiZWw7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmR5bmFtaWNMYWJlbCAmJiBncm91cC5maWVsZHNbdGhpcy5zZXR0aW5ncy5keW5hbWljTGFiZWxdKSB7XG4gICAgICAgIG5ld0xhYmVsID0gZ3JvdXAuZmllbGRzW3RoaXMuc2V0dGluZ3MuZHluYW1pY0xhYmVsXS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nTGFiZWwgPSBncm91cC5zdGF0ZS5sYWJlbCB8fCAnJztcbiAgICAgICAgZXhpc3RpbmdMYWJlbCA9IGV4aXN0aW5nTGFiZWwucmVwbGFjZSh0aGlzLmxhYmVsUmVnZXgsICcnKTtcbiAgICAgICAgbmV3TGFiZWwgPSBgJHt0aGlzLmdyb3VwTGFiZWx9ICR7aW5kZXggKyAxfWA7XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nTGFiZWwpIHtcbiAgICAgICAgICBuZXdMYWJlbCArPSBgOiAke2V4aXN0aW5nTGFiZWx9YDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXAuc3RhdGUubGFiZWwgPSBuZXdMYWJlbDtcbiAgICB9XG5cbiAgICBfcmVjYWxjRGlzcGxheSgpIHtcbiAgICAgIHZhciBncm91cCwgaSwgbGVuLCByZWY7XG4gICAgICByZWYgPSB0aGlzLl92YWx1ZTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gcmVmW2ldO1xuXG4gICAgICAgIGlmIChncm91cC5fcmVjYWxjRGlzcGxheSkge1xuICAgICAgICAgIGdyb3VwLl9yZWNhbGNEaXNwbGF5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRJdGVtKHZhbHVlLCBza2lwSW5zZXJ0LCBza2lwRW1pdCkge1xuICAgICAgdmFyIGZpcnN0RmllbGQsIGdyb3VwLCBtYXJnaW4sIHJlZnJlc2hDaGlsZHJlbiwgcmVxdWlyZWQsIHNldHRpbmdzO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tYXhJdGVtcyAmJiB0aGlzLl92YWx1ZS5sZW5ndGggPT09IHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgfHwgdGhpcy5zdGF0ZS5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hcmdpbiA9IHRoaXMuc2V0dGluZ3Muc3R5bGUgPT09ICdpbmxpbmUnID8gYDAgJHt0aGlzLnNldHRpbmdzLmdyb3VwTWFyZ2lufXB4ICR7dGhpcy5zZXR0aW5ncy5ncm91cE1hcmdpbn1weCAwYCA6IGAwIDAgJHt0aGlzLnNldHRpbmdzLmdyb3VwTWFyZ2lufXB4IDBgO1xuICAgICAgcmVxdWlyZWQgPSB0aGlzLnNldHRpbmdzLnJlcXVpcmVkO1xuICAgICAgc2V0dGluZ3MgPSBleHRlbmQoe1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgICBmaWVsZHM6IHRoaXMuc2V0dGluZ3MuZmllbGRzLFxuICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgbWFyZ2luLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSwgdGhpcy5zZXR0aW5ncy5fZ3JvdXBTZXR0aW5ncywgdGhpcy5zZXR0aW5ncy5ncm91cFNldHRpbmdzW3RoaXMuc2V0dGluZ3Muc3R5bGVdKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2luZ2xlTW9kZSkge1xuICAgICAgICBmaXJzdEZpZWxkID0gdGhpcy5zZXR0aW5ncy5maWVsZHNbMF0ubmFtZTtcblxuICAgICAgICBzZXR0aW5ncy5nZXR0ZXIgPSBmdW5jdGlvbiAoZmllbGRzKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkc1tmaXJzdEZpZWxkXTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXR0aW5ncy5zZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2Ake2ZpcnN0RmllbGR9YF06IHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZ3JvdXAgPSB0aGlzLmJ1aWxkZXIoc2V0dGluZ3MpO1xuICAgICAgZ3JvdXAuZWwuY2hpbGQuYWN0aW9ucy5hcHBlbmQodGhpcy5zZXR0aW5ncy5ncm91cFNldHRpbmdzW3RoaXMuc2V0dGluZ3Muc3R5bGVdKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2xvbmVhYmxlKSB7XG4gICAgICAgIGdyb3VwLmFkZEFjdGlvbignY2xvbmUnLCB0aGlzLnRlbXBsYXRlcy5jbG9uZUljb24sIHRoaXMuY2xvbmVJdGVtLmJpbmQodGhpcywgZ3JvdXApLCB0aGlzLnNldHRpbmdzLnN0eWxlID09PSAnYmxvY2snKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVtb3ZlYWJsZSkge1xuICAgICAgICBncm91cC5hZGRBY3Rpb24oJ3JlbW92ZScsIHRoaXMudGVtcGxhdGVzLnJlbW92ZUljb24sIHRoaXMucmVtb3ZlSXRlbS5iaW5kKHRoaXMsIGdyb3VwKSwgdGhpcy5zZXR0aW5ncy5zdHlsZSA9PT0gJ2Jsb2NrJyk7XG4gICAgICB9XG5cbiAgICAgIGdyb3VwLm9uKCdmb2N1cycsIHRoaXMuX2NhbGNGb2N1c1N0YXRlKTtcbiAgICAgIGdyb3VwLm9uKCdibHVyJywgdGhpcy5fY2FsY0JsdXJTdGF0ZSk7XG4gICAgICBncm91cC5vbignc3VibWl0JywgdGhpcy5fZW1pdFN1Ym1pdCk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDppbnB1dCcpLm9mKGdyb3VwKS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy5fdmFsdWUsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZGlzYWJsZWQnKS5vZih0aGlzLnN0YXRlKS50bygnZGlzYWJsZWQnKS5vZihncm91cC5zdGF0ZSk7XG4gICAgICByZWZyZXNoQ2hpbGRyZW4gPSBncm91cC5lbC5jaGlsZGY7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmR5bmFtaWNMYWJlbCkge1xuICAgICAgICBncm91cC5vbignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY2FsY0xhYmVsKGdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9SZW1vdmVFbXB0eSkge1xuICAgICAgICBncm91cC5vbmNlKCdibHVyJywgKCkgPT4ge1xuICAgICAgICAgIGlmICghZ3JvdXAuc3RhdGUuaW50ZXJhY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSXRlbShncm91cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xuICAgICAgICBncm91cC5zdGF0ZS53aWR0aCA9IHRoaXMuc2V0dGluZ3MuZ3JvdXBXaWR0aDtcbiAgICAgICAgZ3JvdXAuZWwuY2hpbGQuaW5uZXJ3cmFwLm9uY2UoJ2luc2VydGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCd3aWR0aCcsIGBjYWxjKDEwMCUgLSAke3RoaXMucGFyZW50LmNoaWxkLmFjdGlvbnMud2lkdGggfHwgMTd9cHgpYCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNraXBJbnNlcnQpIHtcbiAgICAgICAgZ3JvdXAuaW5zZXJ0QmVmb3JlKHRoaXMuZWwuY2hpbGQuYWRkQnV0dG9uKTtcblxuICAgICAgICBpZiAoIXNraXBFbWl0KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdpdGVtQWRkJywgZ3JvdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWUucHVzaChncm91cCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICBjbG9uZUl0ZW0oZ3JvdXApIHtcbiAgICAgIHZhciBjbG9uZTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgJiYgdGhpcy5fdmFsdWUubGVuZ3RoID09PSB0aGlzLnNldHRpbmdzLm1heEl0ZW1zIHx8IHRoaXMuc3RhdGUuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluY2x1ZGVzKHRoaXMuX3ZhbHVlLCBncm91cCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjbG9uZSA9IHRoaXMuYWRkSXRlbShncm91cC52YWx1ZSwgdHJ1ZSk7XG4gICAgICBjbG9uZS5pbnNlcnRBZnRlcihncm91cC5lbCk7XG4gICAgICBpbnNlcnRBZnRlcih0aGlzLl92YWx1ZSwgZ3JvdXAsIGNsb25lKTtcbiAgICAgIHRoaXMuZW1pdCgnaXRlbUFkZCcsIGNsb25lKTtcbiAgICAgIHRoaXMuZW1pdCgnaXRlbUNsb25lJywgY2xvbmUpO1xuICAgICAgdGhpcy5yZU9yZ2FuaXplKCk7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShncm91cCkge1xuICAgICAgdmFyIHJlZiwgcmVtb3ZlZCwgdGFyZ2V0SW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1pbkl0ZW1zICYmIHRoaXMuX3ZhbHVlLmxlbmd0aCA9PT0gdGhpcy5zZXR0aW5ncy5taW5JdGVtcyB8fCB0aGlzLnN0YXRlLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXggPSBNYXRoLm1heCgxLCB0aGlzLl92YWx1ZS5pbmRleE9mKGdyb3VwKSk7XG5cbiAgICAgIGlmIChyZW1vdmVkID0gcmVtb3ZlSXRlbSh0aGlzLl92YWx1ZSwgZ3JvdXApKSB7XG4gICAgICAgIGdyb3VwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbWl0KCdpdGVtUmVtb3ZlJywgZ3JvdXApO1xuXG4gICAgICAgIGlmICgocmVmID0gdGhpcy5fdmFsdWVbdGFyZ2V0SW5kZXggLSAxXSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJlZi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVPcmdhbml6ZSgpO1xuICAgICAgcmV0dXJuICEhcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZU9yZ2FuaXplKCkge1xuICAgICAgdmFyIGNoaWxkcmVuO1xuICAgICAgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdy5jaGlsZE5vZGVzLCAwLCAtMSk7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS5fcXVpY2tGaWVsZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG4gIFJlcGVhdGVyRmllbGQucHJvdG90eXBlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFJlcGVhdGVyRmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgUmVwZWF0ZXJGaWVsZC5wcm90b3R5cGUuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgUmVwZWF0ZXJGaWVsZC5wcm90b3R5cGUuc2hhbGxvd1NldHRpbmdzID0gWydmaWVsZHMnXTtcbiAgcmV0dXJuIFJlcGVhdGVyRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxudmFyIFJlcGVhdGVyRmllbGQkMSA9IFJlcGVhdGVyRmllbGQ7ZXhwb3J0IGRlZmF1bHQgUmVwZWF0ZXJGaWVsZCQxOyIsImltcG9ydCBDT0xPUlMgZnJvbScuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJzt2YXIgZGVmYXVsdHMgPSB7XG4gIGFsd2F5c1ZhbGlkOiBmYWxzZSxcbiAgbGFiZWxDbGlja3M6IGZhbHNlLFxuICBzaXplOiAxNSxcbiAgZm9udFNpemU6IDEzLFxuICBkaXNwbGF5OiAnYmxvY2snLFxuICBjb2xvcnM6IHtcbiAgICB0ZXh0OiBDT0xPUlMuZ3JleSxcbiAgICBzeW1ib2w6IENPTE9SUy5vcmFuZ2UsXG4gICAgYmFja2dyb3VuZDogJ3doaXRlJ1xuICB9XG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IGNoZWNrbWFyayBmcm9tJy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7dmFyIHRlbXBsYXRlID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdmaWVsZCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zdGF0ZS53aWR0aDtcbiAgICB9LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGZvbnRGYW1pbHk6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmZvbnRGYW1pbHk7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAkdmlzaWJsZToge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICB9LFxuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGFuaW1hdGlvbjogJzAuMnMgZmllbGRFcnJvclNoYWtlJ1xuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHJlZjogJ2lubmVyd3JhcCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBmbGV4V3JhcDogJ25vd3JhcCcsXG4gICAgYWxpZ25Db250ZW50OiAnZmxleC1zdGFydCcsXG4gICAgYWxpZ25JdGVtczogJ2ZsZXgtc3RhcnQnXG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdpbnB1dCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgYWxpZ25TZWxmOiAnc3RhcnQnLFxuICAgIHpJbmRleDogMixcbiAgICBmbGV4R3JvdzogMCxcbiAgICBmbGV4U2hyaW5rOiAwLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplO1xuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplO1xuICAgIH0sXG4gICAgbWFyZ2luOiAnMCBhdXRvJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmNvbG9ycy5iYWNrZ3JvdW5kO1xuICAgIH0sXG4gICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7Q09MT1JTLmdyZXlfbGlnaHR9YCxcbiAgICBib3JkZXJSYWRpdXM6IDMsXG4gICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgYm9yZGVyQ29sb3I6IENPTE9SUy5yZWRcbiAgICB9XG4gIH1cbn0sIFsvLyAkdG9nZ2xlZDpcbi8vIFx0Ym9yZGVyQ29sb3I6IChmaWVsZCktPiBmaWVsZC5zZXR0aW5ncy5jb2xvcnMuc3ltYm9sXG4nZGl2Jywge1xuICByZWY6ICdjaGVja21hcmsnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogJzUwJScsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKScsXG4gICAgd2lkdGg6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnNpemUgLyAxLjU7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnNpemUgLyAxLjU7XG4gICAgfSxcbiAgICBtYXJnaW46ICcwIGF1dG8nLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGxpbmVIZWlnaHQ6IDAsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAkdG9nZ2xlZDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufSwgY2hlY2ttYXJrLmV4dGVuZCh7XG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBzdHJva2U6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmNvbG9ycy5zeW1ib2w7XG4gICAgfSxcbiAgICBvdXRsaW5lOiAnbm9uZSdcbiAgfVxufSldXSwgWydkaXYnLCB7XG4gIHJlZjogJ2xhYmVsJyxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgbWFyZ2luTGVmdDogNSxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmZvbnRTaXplO1xuICAgIH0sXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHNob3dMYWJlbDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufV1dLCBbLy8gJHNob3dFcnJvcjpcbi8vIFx0Y29sb3I6IENPTE9SUy5yZWRcbidkaXYnLCB7XG4gIHJlZjogJ2hlbHAnLFxuICBzdHlsZToge1xuICAgIG1hcmdpblRvcDogJzEwcHgnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIGNvbG9yOiBDT0xPUlMuZ3JleSxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWQsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0hlbHA6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH1cbn1dXSk7dmFyIHRlbXBsYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZhdWx0OiB0ZW1wbGF0ZX0pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBifTsiLCJpbXBvcnQnQGRhbmllbGthbGVuL2lzJztpbXBvcnQnLi4vLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7aW5oZXJpdFByb3RvfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0J3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NoZWNrbWFyay5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9hbmdsZURvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXRVcC5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldERvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvcGx1cy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jbG9uZS5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9yZW1vdmUuanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYiBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLWZhZmI1ZjQxLmpzJztpbXBvcnQnLi4vY2hvaWNlL3RlbXBsYXRlLWM4OGZhOTViLmpzJztpbXBvcnQnLi4vY2hvaWNlL2RlZmF1bHRzLmpzJztpbXBvcnQgQ2hvaWNlRmllbGQgZnJvbScuLi9jaG9pY2UvaW5kZXguanMnO3ZhciBDaGVja2JveEZpZWxkO1xuXG5DaGVja2JveEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBjbGFzcyBDaGVja2JveEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gISF0aGlzLl92YWx1ZTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2l6ZSA9IHBhcnNlRmxvYXQodGhpcy5zZXR0aW5ncy5zaXplKSB8fCBkZWZhdWx0cy5zaXplO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5kaXNwbGF5ICE9PSAnYmxvY2snICYmIHRoaXMuc2V0dGluZ3MuZGlzcGxheSAhPT0gJ2lubGluZScpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5kaXNwbGF5ID0gZGVmYXVsdHMuZGlzcGxheTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3MoKTtcblxuICAgICAgdGhpcy5fY29uc3RydWN0b3JFbmQoKTtcbiAgICB9XG5cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgX3NldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSAhIW5ld1ZhbHVlO1xuICAgIH1cblxuICAgIF9jcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBmb3JjZU9wdHM7XG4gICAgICBmb3JjZU9wdHMgPSB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLnRlbXBsYXRlLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmRlZmF1bHQsIGZvcmNlT3B0cyk7XG4gICAgICB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCk7XG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZXR1cm4gU2ltcGx5QmluZCgnbGFiZWwnKS5vZih0aGlzLnN0YXRlKS50bygnaHRtbCcpLm9mKHRoaXMuZWwuY2hpbGQubGFiZWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCkge1xuICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJykub2YodGhpcykudG8odmFsdWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgndG9nZ2xlZCcsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzKS50byh2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKFwiZXZlbnQ6Y2xpY2tcIikub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9ICF0aGlzLl92YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5sYWJlbENsaWNrcykge1xuICAgICAgICBTaW1wbHlCaW5kKFwiZXZlbnQ6Y2xpY2tcIikub2YodGhpcy5lbC5jaGlsZC5sYWJlbCkudG8oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gIXRoaXMuX3ZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdmFsaWRhdGUocHJvdmlkZWRWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuVHJ1ZSkge1xuICAgICAgICBpZiAoIXByb3ZpZGVkVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH1cbiAgQ2hlY2tib3hGaWVsZC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgQ2hlY2tib3hGaWVsZC5wcm90b3R5cGUudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICBDaGVja2JveEZpZWxkLnByb3RvdHlwZS5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICByZXR1cm4gQ2hlY2tib3hGaWVsZDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuXG5pbmhlcml0UHJvdG8oQ2hlY2tib3hGaWVsZCwgQ2hvaWNlRmllbGQsIFsnX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUnLCAnX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMnLCAnX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXknXSk7XG52YXIgQ2hlY2tib3hGaWVsZCQxID0gQ2hlY2tib3hGaWVsZDtleHBvcnQgZGVmYXVsdCBDaGVja2JveEZpZWxkJDE7IiwiaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgcHJvbWlzZUV2ZW50IGZyb20gJ3AtZXZlbnQnXG5pbXBvcnQgZXh0ZW5kIGZyb20gJ3NtYXJ0LWV4dGVuZCdcbmltcG9ydCBET00gZnJvbSAncXVpY2tkb20nXG5pbXBvcnQgQ09MT1JTIGZyb20gJy4uL3NyYy9jb25zdGFudHMvY29sb3JzJ1xuaW1wb3J0IGNoYWkgZnJvbSAnY2hhaSdcbmltcG9ydCBjaGFpRG9tIGZyb20gJ2NoYWktZG9tJ1xuaW1wb3J0IGNoYWlTdHlsZSBmcm9tICdjaGFpLXN0eWxlJ1xuaW1wb3J0IGNoYWlBbG1vc3QgZnJvbSAnY2hhaS1hbG1vc3QnXG5pbXBvcnQgY2hhaUFzc2VydHR5cGUgZnJvbSAnY2hhaS1hc3NlcnR0eXBlJ1xuaW1wb3J0IGNoYWlFdmVudHMgZnJvbSAnY2hhaS1ldmVudHMnXG5jaGFpLnVzZShjaGFpRG9tKVxuY2hhaS51c2UoY2hhaVN0eWxlKVxuY2hhaS51c2UoY2hhaUFsbW9zdClcbmNoYWkudXNlKGNoYWlBc3NlcnR0eXBlKVxuY2hhaS51c2UoY2hhaUV2ZW50cylcbmNoYWkuY29uZmlnLnRydW5jYXRlVGhyZXNob2xkID0gMWUzXG5tb2NoYS5zZXR1cCgndGRkJylcbm1vY2hhLnNsb3coNDAwKVxubW9jaGEudGltZW91dCgxMjAwMClcbm1vY2hhLmJhaWwoKSB1bmxlc3Mgd2luZG93Ll9fa2FybWFfX1xuYXNzZXJ0ID0gY2hhaS5hc3NlcnRcbmV4cGVjdCA9IGNoYWkuZXhwZWN0XG53aW5kb3cuc2FuZGJveCA9IG51bGxcblxuaW1wb3J0IHF1aWNrZmllbGQgZnJvbSAnLi4vYnVpbGQvcXVpY2tmaWVsZCdcbmltcG9ydCBUZXh0YXJlYUZpZWxkIGZyb20gJy4uL2J1aWxkL2ZpZWxkcy90ZXh0YXJlYSdcbmltcG9ydCBOdW1iZXJGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvbnVtYmVyJ1xuaW1wb3J0IFNlbGVjdEZpZWxkIGZyb20gJy4uL2J1aWxkL2ZpZWxkcy9zZWxlY3QnXG5pbXBvcnQgQ2hvaWNlRmllbGQgZnJvbSAnLi4vYnVpbGQvZmllbGRzL2Nob2ljZSdcbmltcG9ydCBUcnVlZmFsc2VGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvdHJ1ZWZhbHNlJ1xuaW1wb3J0IFRvZ2dsZUZpZWxkIGZyb20gJy4uL2J1aWxkL2ZpZWxkcy90b2dnbGUnXG5pbXBvcnQgR3JvdXBGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvZ3JvdXAnXG5pbXBvcnQgUmVwZWF0ZXJGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvcmVwZWF0ZXInXG5pbXBvcnQgQ2hlY2tib3hGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvY2hlY2tib3gnXG5pbXBvcnQgRmlsZUZpZWxkIGZyb20gJy4uL2J1aWxkL2ZpZWxkcy9maWxlJ1xucXVpY2tmaWVsZC5yZWdpc3RlcigndGV4dGFyZWEnLCBUZXh0YXJlYUZpZWxkKVxucXVpY2tmaWVsZC5yZWdpc3RlcignbnVtYmVyJywgTnVtYmVyRmllbGQpXG5xdWlja2ZpZWxkLnJlZ2lzdGVyKCdzZWxlY3QnLCBTZWxlY3RGaWVsZClcbnF1aWNrZmllbGQucmVnaXN0ZXIoJ2Nob2ljZScsIENob2ljZUZpZWxkKVxucXVpY2tmaWVsZC5yZWdpc3RlcigndHJ1ZWZhbHNlJywgVHJ1ZWZhbHNlRmllbGQpXG5xdWlja2ZpZWxkLnJlZ2lzdGVyKCd0b2dnbGUnLCBUb2dnbGVGaWVsZClcbnF1aWNrZmllbGQucmVnaXN0ZXIoJ2dyb3VwJywgR3JvdXBGaWVsZClcbnF1aWNrZmllbGQucmVnaXN0ZXIoJ3JlcGVhdGVyJywgUmVwZWF0ZXJGaWVsZClcbnF1aWNrZmllbGQucmVnaXN0ZXIoJ2NoZWNrYm94JywgQ2hlY2tib3hGaWVsZClcbiMgcXVpY2tmaWVsZC5yZWdpc3RlcignZmlsZScsIEZpbGVGaWVsZClcbndpbmRvdy5xdWlja2ZpZWxkID0gcXVpY2tmaWVsZFxuXG5lbWl0RXZlbnQgPSAodGFyZ2V0LCBldmVudCwgdHJpZ2dlciktPlxuXHRwcm9taXNlID0gcHJvbWlzZUV2ZW50KHRhcmdldCwgZXZlbnQpXG5cdHRyaWdnZXIoKVxuXHRyZXR1cm4gcHJvbWlzZVxuXG5cbnN1aXRlIFwiUXVpY2tGaWVsZFwiLCAoKS0+XHRcblx0dGVhcmRvd24gKCktPlxuXHRcdGxhc3RDaGlsZCA9IHNhbmRib3guY2hpbGRyZW5bc2FuZGJveC5jaGlsZHJlbi5sZW5ndGgtMV1cblx0XHRsYXN0Q2hpbGQucmVtb3ZlKCkgaWYgbGFzdENoaWxkPy5yZWYgaXMgJ3Rlc3RUaXRsZSdcblx0XG5cdHN1aXRlU2V0dXAgKCktPlxuXHRcdGhlbHBlcnMucmVzdGFydFNhbmRib3goKVxuXG5cblx0c3VpdGUgXCJjcmVhdGlvblwiLCAoKS0+XG5cdFx0dGVhcmRvd24oaGVscGVycy5yZXN0YXJ0U2FuZGJveClcblxuXHRcdHRlc3QgXCJ0ZXh0IGZpZWxkXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh0eXBlOid0ZXh0JykuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5lbC5wYXJlbnQsIHNhbmRib3hcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5lbC5jaGlsZC5pbnB1dC5hdHRyKCd0eXBlJyksICd0ZXh0J1xuXG5cdFx0dGVzdCBcInRleHRhcmVhIGZpZWxkXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh0eXBlOid0ZXh0YXJlYScpLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZWwucGFyZW50LCBzYW5kYm94XG5cblx0XHR0ZXN0IFwibnVtYmVyIGZpZWxkXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh0eXBlOidudW1iZXInKS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLmVsLnBhcmVudCwgc2FuZGJveFxuXG5cdFx0dGVzdCBcInNlbGVjdCBmaWVsZFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQodHlwZTonc2VsZWN0JykuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5lbC5wYXJlbnQsIHNhbmRib3hcblxuXHRcdHRlc3QgXCJjaG9pY2UgZmllbGRcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHR5cGU6J2Nob2ljZScsIGNob2ljZXM6WydhJywnYiddKS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLmVsLnBhcmVudCwgc2FuZGJveFxuXG5cdFx0dGVzdCBcInRydWVmYWxzZSBmaWVsZFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQodHlwZTondHJ1ZWZhbHNlJykuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5lbC5wYXJlbnQsIHNhbmRib3hcblxuXHRcdHRlc3QgXCJ0b2dnbGUgZmllbGRcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHR5cGU6J3RvZ2dsZScpLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZWwucGFyZW50LCBzYW5kYm94XG5cblx0XHRzdWl0ZSBcIm1pc2NcIiwgKCktPlxuXHRcdFx0dGVzdCBcIndpdGggbXVsdGlwbGUgb3B0aW9ucyBvYmplY3RcIiwgKCktPlxuXHRcdFx0XHRjb25maWcgPSB0eXBlOid0ZXh0JywgbGFiZWw6J2FiYycsIHZhbHVlOicxMjMnXG5cdFx0XHRcdGZpZWxkMSA9IHF1aWNrZmllbGQoY29uZmlnKVxuXHRcdFx0XHRmaWVsZDIgPSBxdWlja2ZpZWxkKGNvbmZpZywge2xhYmVsOidkZWYnfSwge2hlaWdodDo1MCwgdmFsdWU6JzQ1Nid9KVxuXG5cdFx0XHRcdGV4cGVjdChjb25maWcpLnRvLmVxbCB0eXBlOid0ZXh0JywgbGFiZWw6J2FiYycsIHZhbHVlOicxMjMnXG5cdFx0XHRcdGV4cGVjdChmaWVsZDEuc2V0dGluZ3MubGFiZWwpLnRvLmVxdWFsICdhYmMnXG5cdFx0XHRcdGV4cGVjdChmaWVsZDIuc2V0dGluZ3MubGFiZWwpLnRvLmVxdWFsICdkZWYnXG5cdFx0XHRcdGV4cGVjdChmaWVsZDEuc2V0dGluZ3MuaGVpZ2h0KS50by5lcXVhbCA0NlxuXHRcdFx0XHRleHBlY3QoZmllbGQyLnNldHRpbmdzLmhlaWdodCkudG8uZXF1YWwgNTBcblx0XHRcdFx0ZXhwZWN0KGZpZWxkMS52YWx1ZSkudG8uZXF1YWwgJzEyMydcblx0XHRcdFx0ZXhwZWN0KGZpZWxkMi52YWx1ZSkudG8uZXF1YWwgJzQ1NidcblxuXG5cdHN1aXRlIFwidGV4dCBmaWVsZFwiLCAoKS0+XG5cdFx0c3VpdGVTZXR1cCAoKS0+XG5cdFx0XHRoZWxwZXJzLmFkZFRpdGxlKFwidGV4dCBmaWVsZFwiKVxuXHRcdFx0QGNvbnRyb2wgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J1JlZ3VsYXInfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHR0ZWFyZG93biAoKS0+XG5cdFx0XHRAY29udHJvbC52YWx1ZSA9ICcnXG5cblx0XHR0ZXN0IFwiZ2V0dGVyL3NldHRlclwiLCAoKS0+XG5cdFx0XHRnZXR0ZXIgPSAodmFsdWUpLT4gXCJleGFtcGxlLmNvbS8je3ZhbHVlfVwiXG5cdFx0XHRzZXR0ZXIgPSAodmFsdWUpLT4gdmFsdWUudG9Mb3dlckNhc2UoKVxuXHRcdFx0ZmllbGRBID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidwYXRoJywgZ2V0dGVyfSlcblx0XHRcdGZpZWxkQiA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDoncGF0aCcsIHNldHRlcn0pXG5cdFx0XHRmaWVsZEMgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J3BhdGgnLCBnZXR0ZXIsIHNldHRlcn0pXG5cblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS8nXG5cdFx0XHRleHBlY3QoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS8nXG5cdFx0XHRleHBlY3QoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJydcblxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdywgJ0FiQycpXG5cdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LCAnQWJDJylcblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcsICdBYkMnKVxuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tL0FiQydcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnQWJDJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgJ2FiYydcblx0XHRcdGV4cGVjdChmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnYWJjJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tL2FiYydcblx0XHRcdGV4cGVjdChmaWVsZEMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnYWJjJ1xuXG5cdFx0XHRmaWVsZEEudmFsdWUgPSAnRGVGJ1xuXHRcdFx0ZmllbGRCLnZhbHVlID0gJ0RlRidcblx0XHRcdGZpZWxkQy52YWx1ZSA9ICdEZUYnXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vRGVGJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICdEZUYnXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCAnZGVmJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICdkZWYnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vZGVmJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICdkZWYnXG5cblxuXHRcdHRlc3QgXCJ3aXRoIGhlbHAgbWVzc2FnZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonV2l0aCBIZWxwIE1lc3NhZ2UnLCBoZWxwOidoZWxwIDxiPm1lc3NhZ2U8L2I+IGhlcmUnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGV4cGVjdChmaWVsZC5lbC50ZXh0KS50by5pbmNsdWRlICdoZWxwIG1lc3NhZ2UgaGVyZSdcblx0XHRcdGV4cGVjdChmaWVsZC5lbHMuaGVscC5odG1sKS50by5lcXVhbCAnaGVscCA8Yj5tZXNzYWdlPC9iPiBoZXJlJ1xuXHRcdFx0ZXhwZWN0KEBjb250cm9sLmVscy5oZWxwLmh0bWwpLnRvLmVxdWFsICcnXG5cdFx0XHRcblx0XHRcdGV4cGVjdChAY29udHJvbC5lbC5yYXcpLnRvLmhhdmUuc3R5bGUgJ21hcmdpbkJvdHRvbScsICcwcHgnXG5cdFx0XHRleHBlY3QoZmllbGQuZWwucmF3KS50by5oYXZlLnN0eWxlICdtYXJnaW5Cb3R0b20nLCAnMjVweCdcblx0XHRcdFxuXHRcdFx0ZmllbGQuc3RhdGUuaGVscCA9ICcnXG5cdFx0XHRleHBlY3QoZmllbGQuZWwucmF3KS50by5oYXZlLnN0eWxlICdtYXJnaW5Cb3R0b20nLCAnMHB4J1xuXHRcdFx0ZXhwZWN0KGZpZWxkLmVscy5oZWxwLmh0bWwpLnRvLmVxdWFsICcnXG5cdFx0XHRcblx0XHRcdGZpZWxkLnN0YXRlLmVycm9yID0gJ2FiYzEyMydcblx0XHRcdGV4cGVjdChmaWVsZC5lbC5yYXcpLnRvLmhhdmUuc3R5bGUgJ21hcmdpbkJvdHRvbScsICcwcHgnXG5cdFx0XHRleHBlY3QoZmllbGQuZWxzLmhlbHAuaHRtbCkudG8uZXF1YWwgJydcblxuXHRcdFx0ZmllbGQuc3RhdGUuc2hvd0Vycm9yID0gdHJ1ZVxuXHRcdFx0ZXhwZWN0KGZpZWxkLmVsLnJhdykudG8uaGF2ZS5zdHlsZSAnbWFyZ2luQm90dG9tJywgJzI1cHgnXG5cdFx0XHRleHBlY3QoZmllbGQuZWxzLmhlbHAuaHRtbCkudG8uZXF1YWwgJ2FiYzEyMydcblxuXHRcdFx0ZmllbGQuc3RhdGUuaGVscCA9ICdkZWY0NTYnXG5cdFx0XHRleHBlY3QoZmllbGQuZWwucmF3KS50by5oYXZlLnN0eWxlICdtYXJnaW5Cb3R0b20nLCAnMjVweCdcblx0XHRcdGV4cGVjdChmaWVsZC5lbHMuaGVscC5odG1sKS50by5lcXVhbCAnZGVmNDU2J1xuXHRcdFx0XG5cdFx0XHRmaWVsZC5zdGF0ZS5oZWxwID0gJydcblx0XHRcdGZpZWxkLnN0YXRlLnNob3dFcnJvciA9IGZhbHNlXG5cdFx0XHRleHBlY3QoZmllbGQuZWwucmF3KS50by5oYXZlLnN0eWxlICdtYXJnaW5Cb3R0b20nLCAnMjVweCdcblx0XHRcdGV4cGVjdChmaWVsZC5lbHMuaGVscC5odG1sKS50by5lcXVhbCAnaGVscCA8Yj5tZXNzYWdlPC9iPiBoZXJlJ1xuXG5cblx0XHR0ZXN0IFwid2l0aG91dCBsYWJlbFwiLCAoKS0+XG5cdFx0XHR3aXRoTGFiZWwgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J1dpdGggTGFiZWwnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdHdpdGhvdXRMYWJlbCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBwbGFjZWhvbGRlcjonV2l0aG91dCBMYWJlbCd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0RE9NLmJhdGNoKFtcblx0XHRcdFx0d2l0aExhYmVsLmVscy5sYWJlbFxuXHRcdFx0XHR3aXRoTGFiZWwuZWxzLmlubmVyd3JhcFxuXHRcdFx0XHR3aXRoTGFiZWwuZWxzLmlucHV0XG5cdFx0XHRcdHdpdGhvdXRMYWJlbC5lbHMubGFiZWxcblx0XHRcdFx0d2l0aG91dExhYmVsLmVscy5pbm5lcndyYXBcblx0XHRcdFx0d2l0aG91dExhYmVsLmVscy5pbnB1dFxuXHRcdFx0XSkuc3R5bGUgJ3RyYW5zaXRpb24nLCBudWxsXG5cblx0XHRcdGFzc2VydC5lcXVhbCB3aXRoTGFiZWwuZWwuY2hpbGQucGxhY2Vob2xkZXIuaHRtbCwgJ1dpdGggTGFiZWwnXG5cdFx0XHRhc3NlcnQuZXF1YWwgd2l0aExhYmVsLmVsLmNoaWxkLmxhYmVsLmh0bWwsICdXaXRoIExhYmVsJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIHdpdGhMYWJlbC5lbC5jaGlsZC5sYWJlbC5zdHlsZSgnb3BhY2l0eScpLCAnMCdcblx0XHRcdFxuXHRcdFx0YXNzZXJ0LmVxdWFsIHdpdGhvdXRMYWJlbC5lbC5jaGlsZC5wbGFjZWhvbGRlci5odG1sLCAnV2l0aG91dCBMYWJlbCdcblx0XHRcdGFzc2VydC5ub3RFcXVhbCB3aXRob3V0TGFiZWwuZWwuY2hpbGQubGFiZWwuaHRtbCwgJ1dpdGhvdXQgTGFiZWwnXG5cdFx0XHRhc3NlcnQuZXF1YWwgd2l0aG91dExhYmVsLmVsLmNoaWxkLmxhYmVsLnN0eWxlKCdvcGFjaXR5JyksICcwJ1xuXG5cdFx0XHRpbml0aWFsVG9wID1cblx0XHRcdFx0d2l0aExhYmVsOiB3aXRoTGFiZWwuZWwuY2hpbGQuaW5wdXQucmVjdC50b3Bcblx0XHRcdFx0d2l0aG91dExhYmVsOiB3aXRob3V0TGFiZWwuZWwuY2hpbGQuaW5wdXQucmVjdC50b3Bcblx0XHRcdFxuXHRcdFx0d2l0aExhYmVsLnZhbHVlID0gJ2FiYzEyMydcblx0XHRcdHdpdGhvdXRMYWJlbC52YWx1ZSA9ICdhYmMxMjMnXG5cblx0XHRcdGFzc2VydC5ub3RFcXVhbCB3aXRoTGFiZWwuZWwuY2hpbGQuaW5wdXQucmVjdC50b3AsIGluaXRpYWxUb3Aud2l0aExhYmVsXG5cdFx0XHRhc3NlcnQuZXF1YWwgd2l0aG91dExhYmVsLmVsLmNoaWxkLmlucHV0LnJlY3QudG9wLCBpbml0aWFsVG9wLndpdGhvdXRMYWJlbFxuXHRcdFx0YXNzZXJ0LmVxdWFsIHdpdGhMYWJlbC5lbC5jaGlsZC5sYWJlbC5zdHlsZSgnb3BhY2l0eScpLCAnMSdcblx0XHRcdGFzc2VydC5lcXVhbCB3aXRob3V0TGFiZWwuZWwuY2hpbGQubGFiZWwuc3R5bGUoJ29wYWNpdHknKSwgJzAnXG5cblxuXHRcdHRlc3QgXCJ3aXRoIGljb25cIiwgKCktPlxuXHRcdFx0aWNvbkZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidXaXRoIEljb24nLCBpY29uOidCJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdHRlc3QgXCJjdXN0b20gaGVpZ2h0L2ZvbnRzaXplXCIsICgpLT5cblx0XHRcdGZpZWxkQSA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonQ3VzdG9tIEhlaWdodCcsIGhlaWdodDo0MCwgZm9udFNpemU6MTMsIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGZpZWxkQiA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonQ3VzdG9tIEhlaWdodCcsIGhlaWdodDo2MCwgZm9udFNpemU6MTYsIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdFx0YXNzZXJ0LmlzQXRMZWFzdCBAY29udHJvbC5lbC5oZWlnaHQsIEBjb250cm9sLnNldHRpbmdzLmhlaWdodFxuXHRcdFx0YXNzZXJ0LmlzQXRNb3N0IEBjb250cm9sLmVsLmhlaWdodCwgQGNvbnRyb2wuc2V0dGluZ3MuaGVpZ2h0KzVcblx0XHRcdFxuXHRcdFx0YXNzZXJ0LmlzQXRMZWFzdCBmaWVsZEEuZWwuaGVpZ2h0LCA0MFxuXHRcdFx0YXNzZXJ0LmlzQXRNb3N0IGZpZWxkQS5lbC5oZWlnaHQsIDQ1XG5cdFx0XHRcblx0XHRcdGFzc2VydC5pc0F0TGVhc3QgZmllbGRCLmVsLmhlaWdodCwgNjBcblx0XHRcdGFzc2VydC5pc0F0TW9zdCBmaWVsZEIuZWwuaGVpZ2h0LCA2NVxuXG5cblx0XHR0ZXN0IFwiY3VzdG9tIGJvcmRlclwiLCAoKS0+XG5cdFx0XHRjdXN0b20gPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0N1c3RvbSBCb3JkZXInLCBib3JkZXI6JzAgMCAycHggMCd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0XG5cdFx0XHRhc3NlcnQuZGVlcEVxdWFsIGhlbHBlcnMuZ2V0Qm9yZGVyU2lkZXMoQGNvbnRyb2wuZWwuY2hpbGQuaW5uZXJ3cmFwKSwge3RvcDonMXB4JywgbGVmdDonMXB4JywgcmlnaHQ6JzFweCcsIGJvdHRvbTonMXB4J31cblx0XHRcdGFzc2VydC5kZWVwRXF1YWwgaGVscGVycy5nZXRCb3JkZXJTaWRlcyhjdXN0b20uZWwuY2hpbGQuaW5uZXJ3cmFwKSwge3RvcDonMHB4JywgbGVmdDonMHB4JywgcmlnaHQ6JzBweCcsIGJvdHRvbTonMnB4J31cblxuXG5cdFx0dGVzdCBcImRlZmF1bHQgdmFsdWVcIiwgKCktPlxuXHRcdFx0ZmllbGRBID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCd9KVxuXHRcdFx0ZmllbGRCID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGRlZmF1bHRWYWx1ZTondmFsdWVCJ30pXG5cdFx0XHRmaWVsZEMgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgdmFsdWU6J3ZhbHVlQyd9KVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkQS52YWx1ZSwgJydcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlLCAnJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkQi52YWx1ZSwgJ3ZhbHVlQidcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlLCAndmFsdWVCJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkQy52YWx1ZSwgJ3ZhbHVlQydcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZEMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlLCAndmFsdWVDJ1xuXG5cblx0XHR0ZXN0IFwiZGlzYWJsZWRcIiwgKCktPlxuXHRcdFx0ZmllbGRBID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidEaXNhYmxlZCcsIGF1dG9XaWR0aDp0cnVlLCBkaXNhYmxlZDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGZpZWxkQiA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonRGlzYWJsZWQgdy8gdmFsdWUnLCBhdXRvV2lkdGg6dHJ1ZSwgZGlzYWJsZWQ6dHJ1ZSwgdmFsdWU6J2FiYzEyMyd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0d2luZG93LmFzc2VydCA9IGFzc2VydFxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KEBjb250cm9sLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdGV4cGVjdChAY29udHJvbC5lbC5jaGlsZC5pbm5lcndyYXAucmF3KS50by5oYXZlLnN0eWxlICdiYWNrZ3JvdW5kQ29sb3InLCAnd2hpdGUnXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoZmllbGRBLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcpLnRvLmhhdmUuc3R5bGUgJ2JhY2tncm91bmRDb2xvcicsIENPTE9SUy5ncmV5X2xpZ2h0XG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCAnYWJjMTIzJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICdhYmMxMjMnXG5cdFx0XHRleHBlY3QoZmllbGRCLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcpLnRvLmhhdmUuc3R5bGUgJ2JhY2tncm91bmRDb2xvcicsIENPTE9SUy5ncmV5X2xpZ2h0XG5cblx0XHRcdCMgZXhwZWN0KEBjb250cm9sLnN0YXRlLmZvY3VzZWQpLnRvLmVxdWFsIGZhbHNlXG5cdFx0XHQjIEBjb250cm9sLmZvY3VzKClcblx0XHRcdCMgZXhwZWN0KEBjb250cm9sLnN0YXRlLmZvY3VzZWQpLnRvLmVxdWFsIHRydWVcblxuXHRcdFx0IyBleHBlY3QoZmllbGRBLnN0YXRlLmZvY3VzZWQpLnRvLmVxdWFsIGZhbHNlXG5cdFx0XHQjIGZpZWxkQS5mb2N1cygpXG5cdFx0XHQjIFByb21pc2UuZGVsYXkoNSkudGhlbiAoKS0+XG5cdFx0XHQjIFx0ZXhwZWN0KGZpZWxkQS5zdGF0ZS5mb2N1c2VkKS50by5lcXVhbCBmYWxzZVxuXG5cblx0XHR0ZXN0IFwiY29uZGl0aW9uc1wiLCAoKS0+XG5cdFx0XHRtYXN0ZXIgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J01hc3RlciBGaWVsZCcsIElEOidtYXN0ZXJGaWVsZCcsIG1hc2s6J2FhYS0xMTEnLCByZXF1aXJlZDp0cnVlLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRzbGF2ZSA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonU2xhdmUgRmllbGQnLCBjb25kaXRpb25zOlt0YXJnZXQ6J21hc3RlckZpZWxkJ10sIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdFx0dGVzdCBcImF1dG93aWR0aFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonQXV0b3dpZHRoJywgYXV0b1dpZHRoOnRydWUsIGNoZWNrbWFyazpmYWxzZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdHRlc3QgXCJpbnB1dCBldmVudFwiLCAoKS0+XG5cdFx0XHRjb3VudCA9IDBcblx0XHRcdGZpZWxkID0gQGNvbnRyb2xcblx0XHRcdGlucHV0ID0gZmllbGQuZWxzLmlucHV0LnJhd1xuXHRcdFx0ZmllbGQub24gJ2lucHV0JywgKCktPiBjb3VudCsrXG5cdFx0XHRcblxuXHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0LnRoZW4gKCktPiBleHBlY3QoY291bnQpLnRvLmVxdWFsIDBcblx0XHRcdFx0LnRoZW4gKCktPiBlbWl0RXZlbnQgZmllbGQsICdpbnB1dCcsICgpPT4gZmllbGQudmFsdWUgPSAnY2hhbmdlJ1xuXHRcdFx0XHQudGhlbiAoKS0+IGV4cGVjdChjb3VudCkudG8uZXF1YWwgMVxuXHRcdFx0XHQudGhlbiAoKS0+IGVtaXRFdmVudCBmaWVsZCwgJ2lucHV0JywgKCk9PiBmaWVsZC52YWx1ZSA9ICdjaGFuZ2UyJ1xuXHRcdFx0XHQudGhlbiAoKS0+IGV4cGVjdChjb3VudCkudG8uZXF1YWwgMlxuXHRcdFx0XHQudGhlbiAoKS0+IGVtaXRFdmVudCBmaWVsZCwgJ2lucHV0JywgKCk9PiBoZWxwZXJzLnNpbXVsYXRlS2V5cyhpbnB1dCwgJ2EnKVxuXHRcdFx0XHQudGhlbiAoKS0+IGV4cGVjdChjb3VudCkudG8uZXF1YWwgM1xuXHRcdFx0XHQudGhlbiAoKS0+IGVtaXRFdmVudCBmaWVsZCwgJ2lucHV0JywgKCk9PiBoZWxwZXJzLnNpbXVsYXRlS2V5cyhpbnB1dCwgJ2FiYycpXG5cdFx0XHRcdC50aGVuICgpLT4gZXhwZWN0KGNvdW50KS50by5lcXVhbCA2XG5cblxuXHRcdHN1aXRlIFwib3B0aW9ucy9hdXRvY29tcGxldGVcIiwgKCktPlxuXHRcdFx0c3VpdGVTZXR1cCAoKS0+XG5cdFx0XHRcdEBmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonTXkgb3B0aW9ucyBmaWVsZCcsIGNob2ljZXM6WydhcHBsZScsICdiYW5hbmEnLCAnb3JhbmdlJywgJ2JhbmFuYSByZXB1YmxpYycsIHtsYWJlbDonb3JhbmdlIHNwbGl0JywgdmFsdWU6J3NwbGl0J31dfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdFx0QGNob2ljZXMgPSBAZmllbGQuZHJvcGRvd24uY2hvaWNlc1xuXHRcdFx0XHRAZHJvcGRvd25FbCA9IEBmaWVsZC5kcm9wZG93bi5lbHMuY29udGFpbmVyLnJhd1xuXHRcdFx0XHRAaW5wdXRFbCA9IEBmaWVsZC5lbC5jaGlsZC5pbnB1dC5yYXdcblx0XHRcdFxuXHRcdFx0dGVhcmRvd24gKCktPlxuXHRcdFx0XHRAZmllbGQuYmx1cigpXG5cdFx0XHRcdEBmaWVsZC52YWx1ZSA9ICcnXG5cblx0XHRcdHRlc3QgXCJ0cmlnZ2VyaW5nXCIsICgpLT5cblx0XHRcdFx0UHJvbWlzZS5iaW5kKEApXG5cdFx0XHRcdFx0LnRoZW4gKCktPlxuXHRcdFx0XHRcdFx0ZXhwZWN0KEBkcm9wZG93bkVsKS5ub3QudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRcdFx0XHRwcm9taXNlID0gcHJvbWlzZUV2ZW50KEBmaWVsZC5lbC5jaGlsZC5pbnB1dCwgJ2ZvY3VzJylcblx0XHRcdFx0XHRcdEBmaWVsZC5mb2N1cygpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZVxuXG5cdFx0XHRcdFx0LnRoZW4gKCktPlxuXHRcdFx0XHRcdFx0ZXhwZWN0KEBkcm9wZG93bkVsKS5ub3QudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhAaW5wdXRFbCwgJ2EnKVxuXHRcdFx0XHRcdFx0ZXhwZWN0KEBkcm9wZG93bkVsKS50by5iZS5kaXNwbGF5ZWRcblx0XHRcdFx0XHRcdHByb21pc2UgPSBwcm9taXNlRXZlbnQoQGZpZWxkLmVsLmNoaWxkLmlucHV0LCAnYmx1cicpXG5cdFx0XHRcdFx0XHRAZmllbGQuYmx1cigpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZVxuXG5cdFx0XHRcdFx0LnRoZW4gKCktPlxuXHRcdFx0XHRcdFx0ZXhwZWN0KEBkcm9wZG93bkVsKS5ub3QudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRcdFx0XHRAZmllbGQuZm9jdXMoKVxuXHRcdFx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUFjdGlvbihAaW5wdXRFbCwgJ2Rvd24nKVxuXHRcdFx0XHRcdFx0ZXhwZWN0KEBkcm9wZG93bkVsKS5ub3QudG8uYmUuZGlzcGxheWVkXG5cblx0XHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhAaW5wdXRFbCwgJ2EnKVxuXHRcdFx0XHRcdFx0ZXhwZWN0KEBkcm9wZG93bkVsKS50by5iZS5kaXNwbGF5ZWRcblxuXHRcdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRcdHByb21pc2UgPSBwcm9taXNlRXZlbnQoQGZpZWxkLmVsLmNoaWxkLmlucHV0LCAnYmx1cicpXG5cdFx0XHRcdFx0XHRAZmllbGQuYmx1cigpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZVxuXG5cdFx0XHRcdFx0LnRoZW4gKCktPlxuXHRcdFx0XHRcdFx0QGZpZWxkLmRyb3Bkb3duLmlzT3BlbiA9IHRydWVcblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRcdFx0XHRAZmllbGQuZHJvcGRvd24uaXNPcGVuID0gZmFsc2Vcblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkubm90LnRvLmJlLmRpc3BsYXllZFxuXG5cblx0XHRcdHRlc3QgXCJoaWdobGlnaHRpbmdcIiwgKCktPlxuXHRcdFx0XHRAZmllbGQuZm9jdXMoKVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoQGlucHV0RWwsICdhJylcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQpLnRvLmVxdWFsIG51bGxcblx0XHRcdFx0XG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVBY3Rpb24oQGlucHV0RWwsICdkb3duJylcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQpLnRvLmVxdWFsIEBjaG9pY2VzWzBdXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVBY3Rpb24oQGlucHV0RWwsICdkb3duJylcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQpLnRvLmVxdWFsIEBjaG9pY2VzWzJdXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVBY3Rpb24oQGlucHV0RWwsICdkb3duJylcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQpLnRvLmVxdWFsIEBjaG9pY2VzWzRdXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBAY2hvaWNlc1swXVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUFjdGlvbihAaW5wdXRFbCwgJ3VwJylcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQpLnRvLmVxdWFsIEBjaG9pY2VzWzRdXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAndXAnKVxuXHRcdFx0XHRleHBlY3QoQGZpZWxkLmRyb3Bkb3duLmN1cnJlbnRIaWdobGlnaHRlZCkudG8uZXF1YWwgQGNob2ljZXNbM11cblxuXHRcdFx0XHRAZmllbGQuYmx1cigpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBudWxsXG5cblxuXHRcdFx0dGVzdCBcImZpbHRlcmluZ1wiLCAoKS0+XG5cdFx0XHRcdGdldFZpc2libGUgPSAoKT0+IEBjaG9pY2VzLmZpbHRlcigoY2hvaWNlKS0+IGNob2ljZS52aXNpYmxlKS5tYXAoKGNob2ljZSktPiBjaG9pY2UudmFsdWUpXG5cdFx0XHRcdEBmaWVsZC5mb2N1cygpXG5cblx0XHRcdFx0ZXhwZWN0KGdldFZpc2libGUoKSkudG8uZXFsIFsnYXBwbGUnLCAnYmFuYW5hJywgJ29yYW5nZScsICdiYW5hbmEgcmVwdWJsaWMnLCAnc3BsaXQnXVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoQGlucHV0RWwsICdiYW4nKVxuXHRcdFx0XHRleHBlY3QoZ2V0VmlzaWJsZSgpKS50by5lcWwgWydiYW5hbmEnLCAnYmFuYW5hIHJlcHVibGljJ11cblx0XHRcdFx0XG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKEBpbnB1dEVsLCAnYW5hJylcblx0XHRcdFx0ZXhwZWN0KGdldFZpc2libGUoKSkudG8uZXFsIFsnYmFuYW5hJywgJ2JhbmFuYSByZXB1YmxpYyddXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhAaW5wdXRFbCwgJyAnKVxuXHRcdFx0XHRleHBlY3QoZ2V0VmlzaWJsZSgpKS50by5lcWwgWydiYW5hbmEgcmVwdWJsaWMnXVxuXHRcdFx0XHRcblx0XHRcdFx0QGZpZWxkLnZhbHVlID0gJ29yYSdcblx0XHRcdFx0ZXhwZWN0KGdldFZpc2libGUoKSkudG8uZXFsIFsnb3JhbmdlJywgJ3NwbGl0J11cblxuXG5cdFx0XHR0ZXN0IFwic2VsZWN0aW5nXCIsICgpLT5cblx0XHRcdFx0QGZpZWxkLmZvY3VzKClcblxuXHRcdFx0XHRleHBlY3QoQGZpZWxkLnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0XHRcblx0XHRcdFx0QGNob2ljZXNbMV0uZWwuZW1pdCAnY2xpY2snXG5cdFx0XHRcdGV4cGVjdChAZmllbGQudmFsdWUpLnRvLmVxdWFsICdiYW5hbmEnXG5cdFx0XHRcdGV4cGVjdChAaW5wdXRFbC52YWx1ZSkudG8uZXF1YWwgJ2JhbmFuYSdcblx0XHRcdFx0XG5cdFx0XHRcdEBmaWVsZC5mb2N1cygpOyBAZmllbGQuc3RhdGUudHlwaW5nID0gdHJ1ZVxuXHRcdFx0XHRAZmllbGQudmFsdWUgPSAnb3JhJ1xuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVBY3Rpb24oQGlucHV0RWwsICdkb3duJylcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQpLnRvLmVxdWFsIEBjaG9pY2VzWzRdXG5cdFx0XHRcdGV4cGVjdChAZmllbGQudmFsdWUpLnRvLmVxdWFsICdvcmEnXG5cdFx0XHRcdGV4cGVjdChAaW5wdXRFbC52YWx1ZSkudG8uZXF1YWwgJ29yYSdcblx0XHRcdFx0XG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVBY3Rpb24oQGlucHV0RWwsICdlbnRlcicpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQudmFsdWUpLnRvLmVxdWFsICdzcGxpdCdcblx0XHRcdFx0ZXhwZWN0KEBpbnB1dEVsLnZhbHVlKS50by5lcXVhbCAnb3JhbmdlIHNwbGl0J1xuXHRcdFx0XHRcblx0XHRcdFx0QGZpZWxkLnZhbHVlID0gJ29yYW5nZSdcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC52YWx1ZSkudG8uZXF1YWwgJ29yYW5nZSdcblx0XHRcdFx0ZXhwZWN0KEBpbnB1dEVsLnZhbHVlKS50by5lcXVhbCAnb3JhbmdlJ1xuXHRcdFx0XHRcblx0XHRcdFx0QGZpZWxkLnZhbHVlID0gJ29yYW5nZSBzcGxpdCdcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC52YWx1ZSkudG8uZXF1YWwgJ3NwbGl0J1xuXHRcdFx0XHRleHBlY3QoQGlucHV0RWwudmFsdWUpLnRvLmVxdWFsICdvcmFuZ2Ugc3BsaXQnXG5cblxuXG5cdFx0c3VpdGUgXCJrZXlib2FyZC9jdXN0b20tdHlwZVwiLCAoKS0+XG5cdFx0XHR0ZXN0IFwicGFzc3dvcmRcIiwgKCktPlxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonUGFzc3dvcmQnLCBrZXlib2FyZDoncGFzc3dvcmQnfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdFx0XHR0ZXN0IFwiZW1haWxcIiwgKCktPlxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonRW1haWwnLCBJRDonZW1haWwnLCBrZXlib2FyZDonZW1haWwnLCByZXF1aXJlZDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0VtYWlsJywga2V5Ym9hcmQ6J2VtYWlsJywgbWFzazp7Z3VpZGU6ZmFsc2V9LCByZXF1aXJlZDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdFx0XHR0ZXN0IFwibnVtYmVyIChzaW1sdWF0ZWQpXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J051bWJlciAoc2ltbHVhdGVkKScsIGtleWJvYXJkOidudW1iZXInLCB2YWxpZFdoZW5SZWdleDovW14wXS8sIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdFx0c3VpdGUgXCJtYXNrXCIsICgpLT5cblx0XHRcdHN1aXRlU2V0dXAgKCktPiBoZWxwZXJzLmFkZFRpdGxlKCdtYXNrJylcblx0XHRcdFxuXHRcdFx0dGVzdCBcImFscGhhXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J05hbWUnLCBtYXNrOidOQU1FJywgd2lkdGg6JzUwJSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonRnVsbCBOYW1lJywgbWFzazonRlVMTE5BTUUnLCB3aWR0aDonNTAlJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdHRlc3QgXCJudW1lcmljXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J1Bob25lJywgZGlzdGFuY2U6MTAsIHdpZHRoOic1MCUnLCBtb2JpbGVXaWR0aDonMTAwJScsIG1hc2s6JygxMTEpIDExMS0xMTExJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidQaG9uZScsIGRpc3RhbmNlOjEwLCB3aWR0aDonNTAlJywgbW9iaWxlV2lkdGg6JzEwMCUnLCBrZXlib2FyZDoncGhvbmUnfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdFx0dGVzdCBcImFscGhhbnVtZXJpY1wiLCAoKS0+XG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidMaWNlbmNlIFBsYXRlJywgbWFzazp7cGF0dGVybjonYWFhLTExMScsIHRyYW5zZm9ybToodiktPiB2LnRvVXBwZXJDYXNlKCl9fSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdFx0dGVzdCBcInByZWZpeFwiLCAoKS0+XG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidEb2xsYXInLCBtYXNrOntwYXR0ZXJuOidOVU1CRVInLCBwcmVmaXg6JyQnLCBkZWNpbWFsOnRydWUsIHNlcDp0cnVlfX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdHRlc3QgXCJkYXRlXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0RhdGUnLCBrZXlib2FyZDonZGF0ZScsIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0RhdGUnLCBtYXNrOntwYXR0ZXJuOlsnREFURScsJ21tIC8geXknXX0sIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdFx0dGVzdCBcImxpdGVyYWxcIiwgKCktPlxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonTGl0ZXJhbCcsIG1hc2s6J015IE5cXFxcYW1lIGlzIGErIEtcXFxcYWxlbid9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHR0ZXN0IFwib3B0aW9uYWxzXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J09wdGlvbmFscycsIG1hc2s6J2FhYVtBQUFdMTExJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdHRlc3QgXCJjdXN0b20gcGF0dGVybnNcIiwgKCktPlxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonT25seSBzcGVjaWZpYyBjaGFycycsIG1hc2s6e3BhdHRlcm46JyYmKy1hYS0xMTEtWyBhYStdJywgY3VzdG9tUGF0dGVybnM6XG5cdFx0XHRcdFx0JyYnOiAvW2FiMTJdL1xuXHRcdFx0XHRcdCdhJzogL1swLTRdL1xuXHRcdFx0XHR9fSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdHN1aXRlIFwibnVtYmVyIGZpZWxkXCIsICgpLT5cblx0XHRzdWl0ZVNldHVwICgpLT5cblx0XHRcdGhlbHBlcnMuYWRkVGl0bGUoJ251bWJlciBmaWVsZCcpXG5cblx0XHR0ZXN0IFwiYmFzaWNcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidudW1iZXInLCBsYWJlbDonTnVtYmVyJywgYXV0b1dpZHRoOmZhbHNlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdHRlc3Quc2tpcCBcImdldHRlci9zZXR0ZXJcIiwgKCktPlxuXHRcdFx0Z2V0dGVyID0gKHZhbHVlKS0+ICh2YWx1ZSBvciAwKSAqIDEwXG5cdFx0XHRzZXR0ZXIgPSAodmFsdWUpLT4gKHZhbHVlIG9yIDApICogMlxuXHRcdFx0ZmllbGRBID0gcXVpY2tmaWVsZCh7dHlwZTonbnVtYmVyJywgbGFiZWw6J051bWJlcicsIGF1dG9XaWR0aDp0cnVlLCBnZXR0ZXJ9KVxuXHRcdFx0ZmllbGRCID0gcXVpY2tmaWVsZCh7dHlwZTonbnVtYmVyJywgbGFiZWw6J051bWJlcicsIGF1dG9XaWR0aDp0cnVlLCBzZXR0ZXJ9KVxuXHRcdFx0ZmllbGRDID0gcXVpY2tmaWVsZCh7dHlwZTonbnVtYmVyJywgbGFiZWw6J051bWJlcicsIGF1dG9XaWR0aDp0cnVlLCBnZXR0ZXIsIHNldHRlcn0pXG5cblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsIDBcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgMFxuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCAwXG5cdFx0XHRleHBlY3QoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJydcblxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdywgJzMnKVxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdywgJzMnKVxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdywgJzMnKVxuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZSkudG8uZXF1YWwgMzBcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnMydcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsIDZcblx0XHRcdGV4cGVjdChmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnNidcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsIDYwXG5cdFx0XHRleHBlY3QoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJzYnXG5cblx0XHRcdGZpZWxkQS52YWx1ZSA9IDEyXG5cdFx0XHRmaWVsZEIudmFsdWUgPSAxMlxuXHRcdFx0ZmllbGRDLnZhbHVlID0gMTJcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsIDEyMFxuXHRcdFx0ZXhwZWN0KGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcxMidcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsIDI0XG5cdFx0XHRleHBlY3QoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJzI0J1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZSkudG8uZXF1YWwgMjQwXG5cdFx0XHRleHBlY3QoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJzI0J1xuXG5cblx0XHR0ZXN0IFwibWluL21heFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J251bWJlcicsIGxhYmVsOidOdW1iZXIgKG1pbi9tYXgpJywgbWluVmFsdWU6MTAsIG1heFZhbHVlOjEwMDAsIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdFx0dGVzdCBcIm1pbi9tYXgvc3RlcFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J251bWJlcicsIGxhYmVsOidOdW1iZXIgKG1pbi9tYXgvc3RlcCknLCBtaW5WYWx1ZToxMCwgbWF4VmFsdWU6MTAwLCBzdGVwOjMsIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdFx0dGVzdCBcIm1pbi9tYXgvc3RlcCAoZW5mb3JjZWQpXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonbnVtYmVyJywgbGFiZWw6J051bWJlciAoZW5mb3JjZWQpJywgbWluVmFsdWU6MTAsIG1heFZhbHVlOjEwMCwgc3RlcDoxMiwgZW5mb3JjZTp0cnVlLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcblx0XHR0ZXN0IFwiZGVjaW1hbCBzdGVwXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonbnVtYmVyJywgbGFiZWw6J051bWJlciAoZGVjaW1hbCBzdGVwKScsIG1pblZhbHVlOjAuMSwgbWF4VmFsdWU6MTAwLCBzdGVwOjAuMSwgYXV0b1dpZHRoOnRydWV9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cblx0c3VpdGUgXCJ0ZXh0YXJlYSBmaWVsZFwiLCAoKS0+XG5cdFx0c3VpdGVTZXR1cCAoKS0+XG5cdFx0XHRoZWxwZXJzLmFkZFRpdGxlKCd0ZXh0YXJlYSBmaWVsZCcpXG5cdFxuXHRcdHRlc3QgXCJiYXNpY1wiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHRhcmVhJywgbGFiZWw6J1RleHRhcmVhJywgd2lkdGg6JzMwMHB4JywgaGVpZ2h0OicyNTBweCcsIGF1dG9IZWlnaHQ6ZmFsc2V9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0dGVzdCBcImdldHRlci9zZXR0ZXJcIiwgKCktPlxuXHRcdFx0Z2V0dGVyID0gKHZhbHVlKS0+IFwiZXhhbXBsZS5jb20vI3t2YWx1ZX1cIlxuXHRcdFx0c2V0dGVyID0gKHZhbHVlKS0+IHZhbHVlLnRvTG93ZXJDYXNlKClcblx0XHRcdGZpZWxkQSA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHRhcmVhJywgbGFiZWw6J3BhdGgnLCBnZXR0ZXJ9KVxuXHRcdFx0ZmllbGRCID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dGFyZWEnLCBsYWJlbDoncGF0aCcsIHNldHRlcn0pXG5cdFx0XHRmaWVsZEMgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0YXJlYScsIGxhYmVsOidwYXRoJywgZ2V0dGVyLCBzZXR0ZXJ9KVxuXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcsICdBYkMnKVxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdywgJ0FiQycpXG5cdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhmaWVsZEMuZWwuY2hpbGQuaW5wdXQucmF3LCAnQWJDJylcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS9BYkMnXG5cdFx0XHRleHBlY3QoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ0FiQydcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsICdhYmMnXG5cdFx0XHRleHBlY3QoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ2FiYydcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS9hYmMnXG5cdFx0XHRleHBlY3QoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ2FiYydcblxuXHRcdFx0ZmllbGRBLnZhbHVlID0gJ0RlRidcblx0XHRcdGZpZWxkQi52YWx1ZSA9ICdEZUYnXG5cdFx0XHRmaWVsZEMudmFsdWUgPSAnRGVGJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tL0RlRidcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnRGVGJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgJ2RlZidcblx0XHRcdGV4cGVjdChmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnZGVmJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tL2RlZidcblx0XHRcdGV4cGVjdChmaWVsZEMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnZGVmJ1xuXG5cblx0XHR0ZXN0IFwiYXV0b2hlaWdodFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHRhcmVhJywgbGFiZWw6J1RleHRhcmVhIChhdXRvSGVpZ2h0KScsIHdpZHRoOiczMDBweCcsIG1heEhlaWdodDo1MDB9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFxuXHRcdHRlc3QgXCJhdXRvd2lkdGhcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0YXJlYScsIGxhYmVsOidUZXh0YXJlYSAoYXV0b3dpZHRoKScsIGF1dG9XaWR0aDp0cnVlLCBtYXhXaWR0aDozMDB9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cblx0c3VpdGUgXCJzZWxlY3QgZmllbGRcIiwgKCktPlxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGRUaXRsZSgnc2VsZWN0IGZpZWxkJylcblxuXHRcdHRlc3QgXCJzaW5nbGUgc2VsZWN0YWJsZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3NlbGVjdCcsIGxhYmVsOidNeSBDaG9pY2VzIChzaW5nbGUpJywgY2hvaWNlczpbJ0FwcGxlJywgJ0FwcGxlIEp1aWNlJywgJ0JhbmFuYScsICdPcmFuZ2UnLCB7bGFiZWw6J0xlbW9uJywgdmFsdWU6J2xpbWUnLCBjb25kaXRpb25zOnsnZW1haWwnOid2YWxpZCd9fV19KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0dGVzdCBcIm11bHRpIHNlbGVjdGFibGVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidzZWxlY3QnLCBsYWJlbDonTXkgQ2hvaWNlcyAobXVsdGkpJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGltZScsICdLaXdpJ10sIG11bHRpcGxlOnRydWUsIGRlZmF1bHRWYWx1ZTonQXBwbGUnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC52YWx1ZSwgJ0FwcGxlJ1xuXG5cdFx0dGVzdCBcImRlZmF1bHQgdmFsdWVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidzZWxlY3QnLCBsYWJlbDonTXkgQ2hvaWNlcyAoZGVmYXVsdCknLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZScsIHtsYWJlbDonTGVtb24nLCB2YWx1ZTonbGltZScsIGNvbmRpdGlvbnM6eydlbWFpbCc6J3ZhbGlkJ319XSwgdmFsdWU6J0JhbmFuYSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLnZhbHVlLCAnQmFuYW5hJ1xuXHRcdFx0XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3NlbGVjdCcsIGxhYmVsOidNeSBDaG9pY2VzIChkZWZhdWx0KScsIHZhbHVlOidCYW5hbmEnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC52YWx1ZSwgJ0JhbmFuYSdcblxuXHRcdHRlc3QgXCJjdXNvdG0gYm9yZGVyXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonc2VsZWN0JywgbGFiZWw6J0N1c3RvbSBCb3JkZXInLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZSddLCBib3JkZXI6JzAgMCAycHggMCcsIG1hcmdpbjonMCAwIDMwcHgnfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdHRlc3QgXCJubyBjaG9pY2VzXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonc2VsZWN0JywgbGFiZWw6J05vIGNob2ljZXMnLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwibWFueSBjaG9pY2VzXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonc2VsZWN0JywgbGFiZWw6J01hbnkgQ2hvaWNlcycsIGNob2ljZXM6aGVscGVycy5jb21wYW55TmFtZXMsIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdHN1aXRlIFwiY2hvaWNlIGZpZWxkXCIsICgpLT5cblx0XHRzdWl0ZVNldHVwICgpLT5cblx0XHRcdGhlbHBlcnMuYWRkVGl0bGUoJ2Nob2ljZSBmaWVsZCcpXG5cdFx0XHRAY29udHJvbCA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGNob2ljZXM6WydBcHBsZScsICdCYW5hbmEnLCAnT3JhbmdlJ10sIHJlcXVpcmVkOnRydWV9KVxuXHRcdFx0QGNvbnRyb2xNdWx0aSA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGNob2ljZXM6WydBcHBsZScsICdCYW5hbmEnLCAnT3JhbmdlJ10sIHJlcXVpcmVkOnRydWUsIG11bHRpcGxlOnRydWV9KVxuXG5cdFx0dGVzdCBcInNpbmdsZSBzZWxlY3RhYmxlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgbGFiZWw6J015IENob2ljZXMgKHNpbmdsZSknLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZSddfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdHRlc3QgXCJtdWx0aSBzZWxlY3RhYmxlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgbGFiZWw6J015IENob2ljZXMgKG11bHRpKScsIGNob2ljZXM6WydBcHBsZScsICdCYW5hbmEnLCAnT3JhbmdlJywgJ0xpbWUnLCAnS2l3aSddLCBwZXJHcm91cDozLCBtdWx0aXBsZTp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdHRlc3QgXCJkZWZhdWx0IHZhbHVlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgbGFiZWw6J015IENob2ljZXMgKHNpbmdsZSknLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZSddLCB2YWx1ZTonT3JhbmdlJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsICdPcmFuZ2UnXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZmluZENob2ljZSgnT3JhbmdlJykuc2VsZWN0ZWQsIHRydWVcblx0XHRcdFxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidjaG9pY2UnLCBsYWJlbDonTXkgQ2hvaWNlcyAobXVsdGkpJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGltZScsICdLaXdpJ10sIG11bHRpcGxlOnRydWUsIHZhbHVlOlsnQmFuYW5hJywgJ0xpbWUnXX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZGVlcEVxdWFsIGZpZWxkLnZhbHVlLCBbJ0JhbmFuYScsICdMaW1lJ11cblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5maW5kQ2hvaWNlKCdCYW5hbmEnKS5zZWxlY3RlZCwgdHJ1ZVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLmZpbmRDaG9pY2UoJ0xpbWUnKS5zZWxlY3RlZCwgdHJ1ZVxuXG5cdFx0dGVzdCBcImNvbmRpdGlvbnNcIiwgKCktPlxuXHRcdFx0bWFzdGVyID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIElEOidtYXN0ZXInLCByZXF1aXJlZDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgbGFiZWw6J015IENob2ljZXMgKHNpbmdsZSknLCBjaG9pY2VzOltcblx0XHRcdFx0J0FwcGxlJ1xuXHRcdFx0XHR7bGFiZWw6J0JhbmFuYScsIHZhbHVlOidiYW5hbmEnLCBjb25kaXRpb25zOnsnbWFzdGVyJzovXmJhbmEvfX1cblx0XHRcdFx0J09yYW5nZSdcblx0XHRcdFx0e2xhYmVsOidMZW1vbicsIHZhbHVlOidsaW1lJywgY29uZGl0aW9uczp7J21hc3Rlcic6J3ZhbGlkJ319XG5cdFx0XHRdfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdHRlc3QgXCJnZXR0ZXIvc2V0dGVyXCIsICgpLT5cblx0XHRcdGdldHRlciA9ICh2YWx1ZSktPiB2YWx1ZT8udG9VcHBlckNhc2UoKSBvciB2YWx1ZVxuXHRcdFx0c2V0dGVyID0gKHZhbHVlKS0+IGlmIHZhbHVlPy52YWx1ZSBpcyAnQmFuYW5hJyB0aGVuICdBcHBsZScgZWxzZSB2YWx1ZVxuXHRcdFx0ZmllbGRBID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgY2hvaWNlczpbJ0FwcGxlJywnQmFuYW5hJywnT3JhbmdlJ10sIGdldHRlcn0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZEIgPSBxdWlja2ZpZWxkKHt0eXBlOidjaG9pY2UnLCBjaG9pY2VzOlsnQXBwbGUnLCdCYW5hbmEnLCdPcmFuZ2UnXSwgc2V0dGVyfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGZpZWxkQyA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGNob2ljZXM6WydBcHBsZScsJ0JhbmFuYScsJ09yYW5nZSddLCBnZXR0ZXIsIHNldHRlcn0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsIHVuZGVmaW5lZFxuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZVJhdykudG8uZXF1YWwgbnVsbFxuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgdW5kZWZpbmVkXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlUmF3KS50by5lcXVhbCBudWxsXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCB1bmRlZmluZWRcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWVSYXcpLnRvLmVxdWFsIG51bGxcblxuXHRcdFx0ZmllbGRBLmNob2ljZXNbMV0uZWwuZW1pdCAnY2xpY2snXG5cdFx0XHRmaWVsZEIuY2hvaWNlc1sxXS5lbC5lbWl0ICdjbGljaydcblx0XHRcdGZpZWxkQy5jaG9pY2VzWzFdLmVsLmVtaXQgJ2NsaWNrJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZSkudG8uZXF1YWwgJ0JBTkFOQSdcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWVSYXc/LnZhbHVlKS50by5lcXVhbCAnQmFuYW5hJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgJ0FwcGxlJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZVJhdz8udmFsdWUpLnRvLmVxdWFsICdBcHBsZSdcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsICdBUFBMRSdcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWVSYXc/LnZhbHVlKS50by5lcXVhbCAnQXBwbGUnXG5cblx0XHRcdGZpZWxkQS52YWx1ZSA9ICdPcmFuZ2UnXG5cdFx0XHRmaWVsZEIudmFsdWUgPSAnT3JhbmdlJ1xuXHRcdFx0ZmllbGRDLnZhbHVlID0gJ09yYW5nZSdcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsICdPUkFOR0UnXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlUmF3Py52YWx1ZSkudG8uZXF1YWwgJ09yYW5nZSdcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsICdPcmFuZ2UnXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlUmF3Py52YWx1ZSkudG8uZXF1YWwgJ09yYW5nZSdcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsICdPUkFOR0UnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlUmF3Py52YWx1ZSkudG8uZXF1YWwgJ09yYW5nZSdcblxuXG5cdFx0dGVzdCBcInZhbGlkIHdoZW4gc2VsZWN0ZWRcIiwgKCktPlxuXHRcdFx0c2luZ2xlID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnXSwgcmVxdWlyZWQ6dHJ1ZSwgdmFsaWRXaGVuU2VsZWN0ZWQ6dHJ1ZX0pXG5cdFx0XHRtdWx0aXBsZSA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGNob2ljZXM6WydBcHBsZScsICdCYW5hbmEnLCAnT3JhbmdlJ10sIHJlcXVpcmVkOnRydWUsIHZhbGlkV2hlblNlbGVjdGVkOjIsIG11bHRpcGxlOnRydWV9KVxuXHRcdFx0ZXhwZWN0KHNpbmdsZS52YWxpZGF0ZSgpKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0ZXhwZWN0KG11bHRpcGxlLnZhbGlkYXRlKCkpLnRvLmVxdWFsIGZhbHNlXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsaWRhdGUoKSkudG8uZXF1YWwgZmFsc2Vcblx0XHRcdGV4cGVjdChAY29udHJvbE11bHRpLnZhbGlkYXRlKCkpLnRvLmVxdWFsIGZhbHNlXG5cdFx0XHRcblx0XHRcdHNpbmdsZS52YWx1ZSA9IG11bHRpcGxlLnZhbHVlID0gQGNvbnRyb2wudmFsdWUgPSBAY29udHJvbE11bHRpLnZhbHVlID0gJ0JhbmFuYSdcblx0XHRcdGV4cGVjdChzaW5nbGUudmFsaWRhdGUoKSkudG8uZXF1YWwgdHJ1ZVxuXHRcdFx0ZXhwZWN0KG11bHRpcGxlLnZhbGlkYXRlKCkpLnRvLmVxdWFsIGZhbHNlXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsaWRhdGUoKSkudG8uZXF1YWwgdHJ1ZVxuXHRcdFx0ZXhwZWN0KEBjb250cm9sTXVsdGkudmFsaWRhdGUoKSkudG8uZXF1YWwgdHJ1ZVxuXHRcdFx0XG5cdFx0XHRtdWx0aXBsZS52YWx1ZSA9IFsnQXBwbGUnLCAnQmFuYW5hJ11cblx0XHRcdGV4cGVjdChtdWx0aXBsZS52YWxpZGF0ZSgpKS50by5lcXVhbCB0cnVlXG5cblxuXHRzdWl0ZSBcInRydWVmYWxzZSBmaWVsZFwiLCAoKS0+XG5cdFx0c3VpdGVTZXR1cCAoKS0+XG5cdFx0XHRoZWxwZXJzLmFkZFRpdGxlKCd0cnVlZmFsc2UgZmllbGQnKVxuXHRcdFxuXHRcdHRlc3QgXCJiYXNpY1wiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RydWVmYWxzZScsIGxhYmVsOidJcyBpdCB0cnVlIG9yIGZhbHNlPycsIHdpZHRoOidhdXRvJ30pLmFwcGVuZFRvKHNhbmRib3gpLmVsLnN0eWxlICdtYXJnaW5SaWdodCcsIDIwXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsIG51bGxcblxuXHRcdHRlc3QgXCJkZWZhdWx0IHZhbHVlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondHJ1ZWZhbHNlJywgbGFiZWw6J0l0XFwncyBmYWxzZSBieSBkZWZhdWx0Jywgd2lkdGg6J2F1dG8nLCBjaG9pY2VMYWJlbHM6WydZZXMnLCAnTm8nXSwgdmFsdWU6ZmFsc2V9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0ZmllbGQuZWwuc3R5bGUgJ21hcmdpblJpZ2h0JywgMjBcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC52YWx1ZSwgZmFsc2Vcblx0XHRcdFxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0cnVlZmFsc2UnLCBsYWJlbDonSXRcXCdzIHRydWUgYnkgZGVmYXVsdCcsIHdpZHRoOidhdXRvJywgY2hvaWNlTGFiZWxzOlsnWWVzJywgJ05vJ10sIHZhbHVlOnRydWV9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0ZmllbGQuZWwuc3R5bGUgJ21hcmdpblJpZ2h0JywgMjBcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC52YWx1ZSwgdHJ1ZVxuXG5cblx0c3VpdGUgXCJ0b2dnbGUgZmllbGRcIiwgKCktPlxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGRUaXRsZSgndG9nZ2xlIGZpZWxkJylcblx0XHRcblx0XHR0ZXN0IFwiYmFzaWNcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0b2dnbGUnLCBsYWJlbDonVGhlIHRvZ2dsZSBmaWVsZCcsIHdpZHRoOidhdXRvJ30pLmFwcGVuZFRvKHNhbmRib3gpLmVsLnN0eWxlICdtYXJnaW5SaWdodCcsIDIwXG5cblx0XHR0ZXN0IFwiZGVmYXVsdCB2YWx1ZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RvZ2dsZScsIGxhYmVsOidUb2dnbGVkIGJ5IGRlZmF1bHQnLCB3aWR0aDonMTMwcHgnLCBkZWZhdWx0VmFsdWU6MX0pLmFwcGVuZFRvKHNhbmRib3gpLmVsLnN0eWxlICdtYXJnaW5SaWdodCcsIDIwXG5cblx0XHR0ZXN0IFwiY3VzdG9tIHNpemVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0b2dnbGUnLCBsYWJlbDonQ3VzdG9tIHNpemUgdG9nZ2xlJywgd2lkdGg6J2F1dG8nLCBzaXplOjQwfSkuYXBwZW5kVG8oc2FuZGJveCkuZWwuc3R5bGUgJ21hcmdpblJpZ2h0JywgMjBcblxuXHRcdHRlc3QgXCJhbGlnbmVkIHN0eWxlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondG9nZ2xlJywgbGFiZWw6J0FsaWduZWQgc3R5bGUnLCBzdHlsZTonYWxpZ25lZCcsIHdpZHRoOidhdXRvJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwiYWxpZ25lZCBzdHlsZSArIGRlZmluZWQgd2lkdGhcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0b2dnbGUnLCBsYWJlbDonQWxpZ25lZCBzdHlsZSB3aXRoIGRlZmluZWQgd2lkdGgnLCBzdHlsZTonYWxpZ25lZCcsIHdpZHRoOic0MDBweCd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0b2dnbGUnLCBsYWJlbDonQWxpZ25lZCBzdHlsZSB3aXRoIGRlZmluZWQgd2lkdGgnLCBzdHlsZTonYWxpZ25lZCcsIHdpZHRoOicyMDBweCd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFxuXHRzdWl0ZSBcImNoZWNrYm94IGZpZWxkXCIsICgpLT5cblx0XHRzdWl0ZVNldHVwICgpLT5cblx0XHRcdGhlbHBlcnMuYWRkVGl0bGUoJ2NoZWNrYm94IGZpZWxkJylcblx0XHRcblx0XHR0ZXN0IFwiYmFzaWNcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidjaGVja2JveCcsIGxhYmVsOidJcyBpdCB0cnVlIG9yIGZhbHNlPycsIHdpZHRoOidhdXRvJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZC5lbC5zdHlsZSAnbWFyZ2luUmlnaHQnLCAyMFxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLnZhbHVlLCBmYWxzZVxuXG5cdFx0dGVzdCBcImRlZmF1bHQgdmFsdWVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidjaGVja2JveCcsIGxhYmVsOidJdFxcJ3MgZmFsc2UgYnkgZGVmYXVsdCcsIHdpZHRoOidhdXRvJywgdmFsdWU6ZmFsc2V9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0ZmllbGQuZWwuc3R5bGUgJ21hcmdpblJpZ2h0JywgMjBcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC52YWx1ZSwgZmFsc2Vcblx0XHRcdFxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidjaGVja2JveCcsIGxhYmVsOidJdFxcJ3MgdHJ1ZSBieSBkZWZhdWx0Jywgd2lkdGg6J2F1dG8nLCBjaG9pY2VMYWJlbHM6WydZZXMnLCAnTm8nXSwgdmFsdWU6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZC5lbC5zdHlsZSAnbWFyZ2luUmlnaHQnLCAyMFxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLnZhbHVlLCB0cnVlXG5cblx0XHR0ZXN0IFwibXVsdGktbGluZSBkaXNwbGF5XCIsICgpLT5cblx0XHRcdGxhYmVsID0gJ0lzIGl0IHRydWUgb3IgZmFsc2U/IFRoaXMgaXMgYSBmYWlybHkgbG9uZyB0ZXh0IGFuZCBjYW4gZ2V0IGV2ZW4gPGI+bG9uZ2VyPC9iPiBpZiB3ZSBkb250IHN0b3AgdHlwaW5nLidcblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonY2hlY2tib3gnLCBsYWJlbCwgbGFiZWxDbGlja3M6dHJ1ZSwgd2lkdGg6JzE1MHB4J30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZC5lbC5zdHlsZSAnbWFyZ2luUmlnaHQnLCAyMFxuXHRcdFx0XG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsIGZhbHNlXG5cdFx0XHRcblx0XHRcdGZpZWxkLmVsLmNoaWxkLmxhYmVsLnJhdy5jbGljaygpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsIHRydWVcblxuXG5cdHN1aXRlIFwiZ3JvdXAgZmllbGRcIiwgKCktPlxuXHRcdHNldHVwIGhlbHBlcnMuYWRkRGl2aWRlclxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGRUaXRsZSgnZ3JvdXAgZmllbGQnKVxuXHRcdFx0QGZpZWxkcyA9IFxuXHRcdFx0XHRmaXJzdDpcblx0XHRcdFx0XHR0eXBlOiAndGV4dCdcblx0XHRcdFx0XHRsYWJlbDogJ0ZpcnN0J1xuXHRcdFx0XHRcdHdpZHRoOiAnNDklJ1xuXHRcdFx0XHRzZWNvbmQ6XG5cdFx0XHRcdFx0dHlwZTogJ3RleHQnXG5cdFx0XHRcdFx0bGFiZWw6ICdTZWNvbmQnXG5cdFx0XHRcdFx0d2lkdGg6ICc0OSUnXG5cdFx0XHRcdHRoaXJkOlxuXHRcdFx0XHRcdHR5cGU6ICdzZWxlY3QnXG5cdFx0XHRcdFx0bGFiZWw6ICdUaGlyZCdcblx0XHRcdFx0XHR3aWR0aDogJzc0JSdcblx0XHRcdFx0XHRjaG9pY2VzOiBbJ0FwcGxlJywgJ0JhbmFuYScsICdLaXdpJ11cblx0XHRcdFx0XHR2YWx1ZTogJ0tpd2knXG5cdFx0XHRcdGZvdXJ0aDpcblx0XHRcdFx0XHR0eXBlOiAndG9nZ2xlJ1xuXHRcdFx0XHRcdGxhYmVsOiAnRm91cnRoJ1xuXHRcdFx0XHRcdHN0eWxlOiAnYWxpZ25lZCdcblx0XHRcdFx0XHR3aWR0aDogJzI0JSdcblx0XHRcdFx0XHRjb25kaXRpb25zOiB0aGlyZDonS2l3aSdcblx0XHRcdFxuXHRcdFx0QGNvbnRyb2wgPSBxdWlja2ZpZWxkKHt0eXBlOidncm91cCcsIGxhYmVsOidCYXNpYyBHcm91cCcsIHdpZHRoOic3MCUnLCBmaWVsZE1hcmdpbjoxMCwgZmllbGRBbGlnbjonbWlkZGxlJywgQGZpZWxkc30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XG5cdFx0dGVzdCBcImJhc2ljXCIsICgpLT5cblx0XHRcdGV4cGVjdChAY29udHJvbC52YWx1ZSkudG8uZXFsIHtmaXJzdDonJywgc2Vjb25kOicnLCB0aGlyZDonS2l3aScsIGZvdXJ0aDpmYWxzZX1cblx0XHRcdGV4cGVjdChAY29udHJvbC5zdGF0ZS5pbnRlcmFjdGVkKS50by5lcXVhbCBmYWxzZVxuXG5cdFx0XHRAY29udHJvbC52YWx1ZSA9IHtmaXJzdDondmFsdWVBJywgdGhpcmQ6J0thd2EnLCBmb3VydGg6dHJ1ZSwgZmlmdGg6JzUnfVxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwge2ZpcnN0Oid2YWx1ZUEnLCBzZWNvbmQ6JycsIHRoaXJkOidLYXdhJywgZm91cnRoOnRydWV9XG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuc3RhdGUuaW50ZXJhY3RlZCkudG8uZXF1YWwgdHJ1ZVxuXHRcdFx0XG5cdFx0XHRAY29udHJvbC52YWx1ZSA9IHtzZWNvbmQ6J3ZhbHVlQicsIHRoaXJkOidBcHBsZSd9XG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCB7Zmlyc3Q6J3ZhbHVlQScsIHNlY29uZDondmFsdWVCJywgdGhpcmQ6J0FwcGxlJywgZm91cnRoOnRydWV9XG5cblx0XHRcdEBjb250cm9sLnZhbHVlID0gbnVsbFxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwge2ZpcnN0Oid2YWx1ZUEnLCBzZWNvbmQ6J3ZhbHVlQicsIHRoaXJkOidBcHBsZScsIGZvdXJ0aDp0cnVlfVxuXG5cblx0XHR0ZXN0IFwiY29sbGFwc2VkIGJ5IGRlZmF1bHRcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidncm91cCcsIHdpZHRoOic3MCUnLCBmaWVsZE1hcmdpbjoxMCwgc3RhcnRDb2xsYXBzZWQ6dHJ1ZSwgQGZpZWxkc30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuZWxzLmlubmVyd3JhcC5yYXcpLnRvLmJlLmRpc3BsYXllZFxuXHRcdFx0ZXhwZWN0KGZpZWxkLmVscy5pbm5lcndyYXAucmF3KS5ub3QudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRcblx0XHRcdEBjb250cm9sLnN0YXRlLmNvbGxhcHNlZCA9IHRydWVcblx0XHRcdGZpZWxkLnN0YXRlLmNvbGxhcHNlZCA9IGZhbHNlXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuZWxzLmlubmVyd3JhcC5yYXcpLm5vdC50by5iZS5kaXNwbGF5ZWRcblx0XHRcdGV4cGVjdChmaWVsZC5lbHMuaW5uZXJ3cmFwLnJhdykudG8uYmUuZGlzcGxheWVkXG5cblx0XHRcdEBjb250cm9sLmVscy5jb2xsYXBzZS5lbWl0ICdjbGljaydcblx0XHRcdGZpZWxkLmVscy5jb2xsYXBzZS5lbWl0ICdjbGljaydcblx0XHRcdGV4cGVjdChAY29udHJvbC5lbHMuaW5uZXJ3cmFwLnJhdykudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRleHBlY3QoZmllbGQuZWxzLmlubmVyd3JhcC5yYXcpLm5vdC50by5iZS5kaXNwbGF5ZWRcblxuXG5cdFx0dGVzdCBcImRlZmF1bHQgdmFsdWVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidncm91cCcsIHdpZHRoOic3MCUnLCBmaWVsZE1hcmdpbjoxMCwgQGZpZWxkcywgdmFsdWU6e2ZpcnN0OidmaXJzdFZhbHVlJywgdGhpcmQ6J0JhbmFuYSd9fSlcblx0XHRcdGV4cGVjdChmaWVsZC52YWx1ZSkudG8uZXFsIHtmaXJzdDonZmlyc3RWYWx1ZScsIHNlY29uZDonJywgdGhpcmQ6J0JhbmFuYScsIGZvdXJ0aDpmYWxzZX1cblx0XHRcblx0XHQjIHRlc3QgXCJpbmxpbmUgbW9kZVwiLCAoKS0+XG5cdFx0IyBcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonZ3JvdXAnLCB3aWR0aDonNzAlJywgZmllbGRNYXJnaW46MTAsIEBmaWVsZHMsIHZhbHVlOntmaXJzdDonZmlyc3RWYWx1ZScsIHRoaXJkOidCYW5hbmEnfX0pXG5cdFx0IyBcdGV4cGVjdChmaWVsZC52YWx1ZSkudG8uZXFsIHtmaXJzdDonZmlyc3RWYWx1ZScsIHNlY29uZDonJywgdGhpcmQ6J0JhbmFuYScsIGZvdXJ0aDpmYWxzZX1cblxuXG5cdHN1aXRlIFwicmVwZWF0ZXIgZmllbGRcIiwgKCktPlxuXHRcdHNldHVwIGhlbHBlcnMuYWRkRGl2aWRlclxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGREaXZpZGVyKDQwKVxuXHRcdFx0QGZpZWxkcyA9IFxuXHRcdFx0XHRmaXJzdDpcblx0XHRcdFx0XHR0eXBlOiAndGV4dCdcblx0XHRcdFx0XHRuYW1lOiAnZmlyc3QnXG5cdFx0XHRcdFx0bGFiZWw6ICdGaXJzdCdcblx0XHRcdFx0XHR3aWR0aDogJzQ5JSdcblx0XHRcdFx0c2Vjb25kOlxuXHRcdFx0XHRcdHR5cGU6ICd0ZXh0J1xuXHRcdFx0XHRcdG5hbWU6ICdzZWNvbmQnXG5cdFx0XHRcdFx0bGFiZWw6ICdTZWNvbmQnXG5cdFx0XHRcdFx0d2lkdGg6ICc0OSUnXG5cdFx0XHRcblx0XHRcdEBjb250cm9sID0gcXVpY2tmaWVsZCh7dHlwZToncmVwZWF0ZXInLCBsYWJlbDonQmFzaWMgUmVwZWF0ZXInLCB3aWR0aDonNzAlJywgZmllbGRNYXJnaW46MTAsIG51bWJlcmluZzp0cnVlLCBjbG9uZWFibGU6dHJ1ZSwgZHJhZ2Ryb3A6dHJ1ZSwgQGZpZWxkc30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwiYmxvY2tcIiwgKCktPlxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwgW11cblx0XHRcdGV4cGVjdChAY29udHJvbC5zdGF0ZS5pbnRlcmFjdGVkKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0XG5cdFx0XHRAY29udHJvbC5lbHMuYWRkQnV0dG9uLmVtaXQgJ2NsaWNrJ1xuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwgW3tmaXJzdDonJywgc2Vjb25kOicnfV1cblx0XHRcdGV4cGVjdChAY29udHJvbC5zdGF0ZS5pbnRlcmFjdGVkKS50by5lcXVhbCB0cnVlXG5cblx0XHRcdEBjb250cm9sLnZhbHVlID0ge2ZpcnN0OidhYmMnLCBzZWNvbmQ6J2RlZid9XG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCBbe2ZpcnN0OicnLCBzZWNvbmQ6Jyd9LCB7Zmlyc3Q6J2FiYycsIHNlY29uZDonZGVmJ31dXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuX3ZhbHVlWzBdLmVscy5sYWJlbC50ZXh0KS50by5lcXVhbCAnSXRlbSAxJ1xuXHRcdFx0ZXhwZWN0KEBjb250cm9sLl92YWx1ZVsxXS5lbHMubGFiZWwudGV4dCkudG8uZXF1YWwgJ0l0ZW0gMidcblxuXHRcdFx0QGNvbnRyb2wuX3ZhbHVlWzBdLmVscy5yZW1vdmUuZW1pdCAnY2xpY2snXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCBbe2ZpcnN0OidhYmMnLCBzZWNvbmQ6J2RlZid9XVxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLl92YWx1ZVswXS5lbHMubGFiZWwudGV4dCkudG8uZXF1YWwgJ0l0ZW0gMSdcblx0XHRcdFxuXHRcdFx0QGNvbnRyb2wudmFsdWUgPSBbe2ZpcnN0OidBQkMnfSwge3NlY29uZDonREVGJ31dXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCBbe2ZpcnN0OidBQkMnLCBzZWNvbmQ6J2RlZid9LCB7Zmlyc3Q6JycsIHNlY29uZDonREVGJ31dXG5cblxuXHRcdHRlc3QgXCJpbmxpbmVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHtcblx0XHRcdFx0dHlwZToncmVwZWF0ZXInXG5cdFx0XHRcdGxhYmVsOidJbmxpbmUgUmVwZWF0ZXInXG5cdFx0XHRcdHdpZHRoOic3MCUnXG5cdFx0XHRcdGZpZWxkTWFyZ2luOjEwXG5cdFx0XHRcdG51bWJlcmluZzp0cnVlXG5cdFx0XHRcdGF1dG9SZW1vdmVFbXB0eTogdHJ1ZVxuXHRcdFx0XHRkcmFnZHJvcDogdHJ1ZVxuXHRcdFx0XHRzdHlsZTonaW5saW5lJ1xuXHRcdFx0XHR2YWx1ZTogW3tmaXJzdDonYWJjJywgc2Vjb25kOicxMjMnfSwge3NlY29uZDonNDU2J31dXG5cdFx0XHRcdGZpZWxkczpcblx0XHRcdFx0XHRmaXJzdDogZXh0ZW5kKHthdXRvV2lkdGg6dHJ1ZX0sIEBmaWVsZHMuZmlyc3QpXG5cdFx0XHRcdFx0c2Vjb25kOiBleHRlbmQoe2F1dG9XaWR0aDp0cnVlfSwgQGZpZWxkcy5zZWNvbmQpXG5cdFx0XHR9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHRleHBlY3QoZmllbGQudmFsdWUpLnRvLmVxbCBbXG5cdFx0XHRcdHtmaXJzdDonYWJjJywgc2Vjb25kOicxMjMnfVxuXHRcdFx0XHR7Zmlyc3Q6JycsIHNlY29uZDonNDU2J31cblx0XHRcdF1cblxuXG5cdFx0dGVzdCBcImlubGluZSBzaW5nbGVNb2RlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7XG5cdFx0XHRcdHR5cGU6J3JlcGVhdGVyJ1xuXHRcdFx0XHRsYWJlbDonSW5saW5lIFJlcGVhdGVyJ1xuXHRcdFx0XHR3aWR0aDonNzAlJ1xuXHRcdFx0XHRmaWVsZE1hcmdpbjogMTBcblx0XHRcdFx0YXV0b1dpZHRoOiBmYWxzZVxuXHRcdFx0XHRhdXRvUmVtb3ZlRW1wdHk6IHRydWVcblx0XHRcdFx0bnVtYmVyaW5nOnRydWVcblx0XHRcdFx0c3R5bGU6J2lubGluZSdcblx0XHRcdFx0c2luZ2xlTW9kZTogdHJ1ZVxuXHRcdFx0XHRkcmFnZHJvcDogdHJ1ZVxuXHRcdFx0XHRncm91cFNldHRpbmdzOiBpbmxpbmU6IHdpZHRoOiAnMTAwJSdcblx0XHRcdFx0ZmllbGRzOiBleHRlbmQuY2xvbmUoQGZpZWxkcy5maXJzdCwge3dpZHRoOicxMDAlJ30pXG5cdFx0XHR9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHRleHBlY3QoZmllbGQudmFsdWUpLnRvLmVxbCBbXVxuXHRcdFx0ZmllbGQudmFsdWUgPSBbJ2FiYycsICcxMjMnXVxuXHRcdFx0ZXhwZWN0KGZpZWxkLnZhbHVlKS50by5lcWwgWydhYmMnLCAnMTIzJ11cblx0XHRcdGZpZWxkLnZhbHVlID0gJ2RlZidcblx0XHRcdGV4cGVjdChmaWVsZC52YWx1ZSkudG8uZXFsIFsnYWJjJywgJzEyMycsICdkZWYnXVxuXG5cblx0XHR0ZXN0IFwiZHluYW1pY0xhYmVsXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7XG5cdFx0XHRcdHR5cGU6J3JlcGVhdGVyJ1xuXHRcdFx0XHRsYWJlbDonSW5saW5lIFJlcGVhdGVyJ1xuXHRcdFx0XHR3aWR0aDonNzAlJ1xuXHRcdFx0XHRkeW5hbWljTGFiZWw6ICdmaXJzdCdcblx0XHRcdFx0ZmllbGRNYXJnaW46MTBcblx0XHRcdFx0YXV0b1JlbW92ZUVtcHR5OiB0cnVlXG5cdFx0XHRcdGRyYWdkcm9wOiB0cnVlXG5cdFx0XHRcdHZhbHVlOiBbe2ZpcnN0OidhYmMnLCBzZWNvbmQ6JzEyMyd9LCB7c2Vjb25kOic0NTYnfV1cblx0XHRcdFx0ZmllbGRzOlxuXHRcdFx0XHRcdGZpcnN0OiBleHRlbmQoe2F1dG9XaWR0aDp0cnVlfSwgQGZpZWxkcy5maXJzdClcblx0XHRcdFx0XHRzZWNvbmQ6IGV4dGVuZCh7YXV0b1dpZHRoOnRydWV9LCBAZmllbGRzLnNlY29uZClcblx0XHRcdH0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMF0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJ2FiYydcblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMV0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJydcblxuXHRcdFx0ZmllbGQudmFsdWUgPSBbe2ZpcnN0OidkZWYnfSwge2ZpcnN0OicxMjMnfV1cblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMF0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJ2RlZidcblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMV0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJzEyMydcblx0XHRcdCMgZXhwZWN0KGZpZWxkLnZhbHVlKS50by5lcWwgW1xuXHRcdFx0IyBcdHtmaXJzdDonYWJjJywgc2Vjb25kOicxMjMnfVxuXHRcdFx0IyBcdHtmaXJzdDonJywgc2Vjb25kOic0NTYnfVxuXG5cblx0XHR0ZXN0IFwidmFsaWRhdGVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHtcblx0XHRcdFx0dHlwZToncmVwZWF0ZXInXG5cdFx0XHRcdGxhYmVsOidJbmxpbmUgUmVwZWF0ZXInXG5cdFx0XHRcdHdpZHRoOic3MCUnXG5cdFx0XHRcdGR5bmFtaWNMYWJlbDogJ2ZpcnN0J1xuXHRcdFx0XHRmaWVsZE1hcmdpbjoxMFxuXHRcdFx0XHRhdXRvUmVtb3ZlRW1wdHk6IHRydWVcblx0XHRcdFx0ZHJhZ2Ryb3A6IHRydWVcblx0XHRcdFx0cmVxdWlyZWQ6IHRydWVcblx0XHRcdFx0IyB2YWx1ZTogW3tmaXJzdDonYWJjJywgc2Vjb25kOicxMjMnfSwge3NlY29uZDonNDU2J31dXG5cdFx0XHRcdGZpZWxkczpcblx0XHRcdFx0XHRmaXJzdDogZXh0ZW5kKHthdXRvV2lkdGg6dHJ1ZSwgcmVxdWlyZWQ6dHJ1ZX0sIEBmaWVsZHMuZmlyc3QpXG5cdFx0XHRcdFx0c2Vjb25kOiBleHRlbmQoe2F1dG9XaWR0aDp0cnVlfSwgQGZpZWxkcy5zZWNvbmQpXG5cdFx0XHR9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHRleHBlY3QoZmllbGQudmFsaWRhdGUoKSkudG8uZXF1YWwgZmFsc2Vcblx0XHRcdFxuXHRcdFx0ZmllbGQudmFsdWUgPSBbe2ZpcnN0OidkZWYnfSwge3NlY29uZDonMTIzJ31dXG5cdFx0XHRleHBlY3QoZmllbGQudmFsaWRhdGUoKSkudG8uZXF1YWwgZmFsc2Vcblx0XHRcdFxuXHRcdFx0ZmllbGQudmFsdWUgPSBbe2ZpcnN0OidkZWYnfSwge2ZpcnN0OicxMjMnfV1cblx0XHRcdGV4cGVjdChmaWVsZC52YWxpZGF0ZSgpKS50by5lcXVhbCB0cnVlXG5cblxuXG5cdHN1aXRlIFwiLmNvbmZpZygpXCIsICgpLT5cblx0XHR0ZXN0IFwiY3JlYXRlcyBhIG5ldyBjb3B5IG9mIFF1aWNrRmllbGQgd2l0aCBzZXR0aW5nIG92ZXJyaWRlcyBhbmQgdGVtcGxhdGUgb3ZlcnJpZGVzXCIsICgpLT5cblx0XHRcdHF1aWNrZmllbGQyID0gcXVpY2tmaWVsZC5jb25maWcoXG5cdFx0XHRcdGdsb2JhbDpcblx0XHRcdFx0XHRmb250RmFtaWx5OiAnaGVsdmV0aWNhJ1xuXHRcdFx0XHRcdHdpZHRoOiAnNTAlJ1xuXHRcdFx0XHRcdHJlcXVpcmVkOiB0cnVlXG5cdFx0XHRcdFx0Ym9yZGVyOiAnMCAwIDJweCAwJ1xuXHRcdFx0XHRcdG1hcmdpbjogJzAgMTBweCAxMHB4IDAnXG5cdFx0XHRcdFx0Zm9udFNpemU6IDEzXG5cdFx0XHRcdFx0aW5wdXRQYWRkaW5nOiA4XG5cblx0XHRcdFx0dGV4dDpcblx0XHRcdFx0XHRoZWlnaHQ6IDQwXG5cdFx0XHRcdFx0YXV0b1dpZHRoOiB0cnVlXG5cdFx0XHRcdFx0aW5wdXRQYWRkaW5nOiAwXG5cdFx0XHRcdFx0Y2hlY2ttYXJrOiBmYWxzZVxuXHRcdFx0XHRcdG1pbkxlbmd0aDogMlxuXHRcdFx0XHRcdG1hc2s6XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlcjogJyonXG5cdFx0XHRcdFx0XHRkZWNpbWFsOiB0cnVlXG5cblx0XHRcdCxcblx0XHRcdFx0Z2xvYmFsOlxuXHRcdFx0XHRcdGZpZWxkOlxuXHRcdFx0XHRcdFx0b3B0aW9uczogc3R5bGU6XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG5cblx0XHRcdFx0XHRcdGNoaWxkcmVuOlxuXHRcdFx0XHRcdFx0XHRsYWJlbDogb3B0aW9uczogc3R5bGU6XG5cdFx0XHRcdFx0XHRcdFx0JGZvY3VzOiBjb2xvcjogQ09MT1JTLmdyZWVuXG5cdFx0XHRcdFx0XHRcdGlubmVyd3JhcDogb3B0aW9uczogc3R5bGU6XG5cdFx0XHRcdFx0XHRcdFx0JGZvY3VzOiBib3JkZXJDb2xvcjogQ09MT1JTLmdyZWVuXG5cdFx0XHRcdFxuXHRcdFx0XHR0ZXh0OlxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNoaWxkcmVuOlxuXHRcdFx0XHRcdFx0bGFiZWw6IG9wdGlvbnM6IHN0eWxlOlxuXHRcdFx0XHRcdFx0XHRmb250V2VpZ2h0OiA3MDBcblx0XHRcdFx0XG5cdFx0XHRcdGNob2ljZTpcblx0XHRcdFx0XHRjaG9pY2U6IG9wdGlvbnM6IHN0eWxlOlxuXHRcdFx0XHRcdFx0JHNlbGVjdGVkOiBjb2xvcjogQ09MT1JTLmdyZWVuXG5cdFx0XHQpXG5cblx0XHRcdGV4cGVjdChxdWlja2ZpZWxkMikubm90LnRvLmVxdWFsKHF1aWNrZmllbGQpXG5cdFx0XHR0ZXh0QSA9IHF1aWNrZmllbGQodHlwZTondGV4dCcsIGxhYmVsOid0ZXh0QScpLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHR0ZXh0QiA9IHF1aWNrZmllbGQyKHR5cGU6J3RleHQnLCBsYWJlbDondGV4dEInLCBhdXRvV2lkdGg6ZmFsc2UpLmFwcGVuZFRvKHNhbmRib3gpOyBoZWxwZXJzLmFkZERpdmlkZXIoKVxuXHRcdFx0dGV4dEMgPSBxdWlja2ZpZWxkMih0eXBlOid0ZXh0JywgbGFiZWw6J3RleHRDJywgbWFzazp7cGF0dGVybjonTlVNQkVSJywgc3VmZml4OiclJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHR0ZXh0RCA9IHF1aWNrZmllbGQyKHR5cGU6J3RleHQnLCBsYWJlbDondGV4dEQnLCBtYXNrOntwYXR0ZXJuOidEQVRFJywgc3VmZml4OiclJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRjaG9pY2UgPSBxdWlja2ZpZWxkMih0eXBlOidjaG9pY2UnLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZSddKS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0XG5cdFx0XHRleHBlY3QodGV4dEEuZWwuc3R5bGUgJ2ZvbnRGYW1pbHknKS50by5lcXVhbCBxdWlja2ZpZWxkLkZpZWxkOjpnbG9iYWxEZWZhdWx0cy5mb250RmFtaWx5XG5cdFx0XHRleHBlY3QodGV4dEIuZWwuc3R5bGUgJ2ZvbnRGYW1pbHknKS50by5lcXVhbCAnaGVsdmV0aWNhJ1xuXHRcdFx0ZXhwZWN0KHRleHRBLmVsLnN0eWxlICd2ZXJ0aWNhbEFsaWduJykudG8uZXF1YWwgJ3RvcCdcblx0XHRcdGV4cGVjdCh0ZXh0Qi5lbC5zdHlsZSAndmVydGljYWxBbGlnbicpLnRvLmVxdWFsICdtaWRkbGUnXG5cdFx0XHRleHBlY3QodGV4dEEuZWwuc3R5bGVQYXJzZWQgJ21hcmdpbkJvdHRvbScpLnRvLmVxdWFsIDBcblx0XHRcdGV4cGVjdCh0ZXh0Qi5lbC5zdHlsZVBhcnNlZCAnbWFyZ2luQm90dG9tJykudG8uZXF1YWwgMTBcblx0XHRcdGV4cGVjdCh0ZXh0QS5lbC5zdHlsZVNhZmUgJ3dpZHRoJyx0cnVlKS50by5lcXVhbCAnMTAwJSdcblx0XHRcdGV4cGVjdCh0ZXh0Qi5lbC5zdHlsZVNhZmUgJ3dpZHRoJyx0cnVlKS50by5lcXVhbCAnNTAlJ1xuXHRcdFx0ZXhwZWN0KHRleHRBLmVsLmNoaWxkLmxhYmVsLnN0eWxlUGFyc2VkICdmb250V2VpZ2h0Jyx0cnVlKS50by5lcXVhbCA2MDBcblx0XHRcdGV4cGVjdCh0ZXh0Qi5lbC5jaGlsZC5sYWJlbC5zdHlsZVBhcnNlZCAnZm9udFdlaWdodCcsdHJ1ZSkudG8uZXF1YWwgNzAwXG5cdFx0XHRleHBlY3QodGV4dEEuZWwuaGVpZ2h0KS50by5lcXVhbCBxdWlja2ZpZWxkLkZpZWxkLnRleHQ6OmRlZmF1bHRzLmhlaWdodFxuXHRcdFx0ZXhwZWN0KHRleHRCLmVsLmhlaWdodCkudG8uZXF1YWwgNDBcblx0XHRcdGV4cGVjdCh0ZXh0QS5lbC5jaGlsZC5jaGVja21hcmspLnRvLmJlLm9iamVjdCgpXG5cdFx0XHRleHBlY3QodGV4dEIuZWwuY2hpbGQuY2hlY2ttYXJrKS5ub3QudG8uYmUub2JqZWN0KClcblx0XHRcdGV4cGVjdChoZWxwZXJzLmdldEJvcmRlclNpZGVzKHRleHRBLmVscy5pbm5lcndyYXApKS50by5lcWwge3RvcDonMXB4JywgbGVmdDonMXB4JywgcmlnaHQ6JzFweCcsIGJvdHRvbTonMXB4J31cblx0XHRcdGV4cGVjdChoZWxwZXJzLmdldEJvcmRlclNpZGVzKHRleHRCLmVscy5pbm5lcndyYXApKS50by5lcWwge3RvcDonMHB4JywgbGVmdDonMHB4JywgcmlnaHQ6JzBweCcsIGJvdHRvbTonMnB4J31cblx0XHRcdGV4cGVjdCh0ZXh0QS52YWxpZGF0ZSgpKS50by5lcXVhbCB0cnVlXG5cdFx0XHRleHBlY3QodGV4dEIudmFsaWRhdGUoKSkudG8uZXF1YWwgZmFsc2VcblxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXModGV4dEEuZWwuY2hpbGQuaW5wdXQucmF3LCAnYWJjJylcblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKHRleHRCLmVsLmNoaWxkLmlucHV0LnJhdywgJ2FiYycpXG5cdFx0XHRleHBlY3QodGV4dEEudmFsaWRhdGUoKSkudG8uZXF1YWwgdHJ1ZVxuXHRcdFx0ZXhwZWN0KHRleHRCLnZhbGlkYXRlKCkpLnRvLmVxdWFsIHRydWVcblxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXModGV4dEQuZWwuY2hpbGQuaW5wdXQucmF3LCAnMScpXG5cdFx0XHRleHBlY3QodGV4dEQudmFsdWUpLnRvLmVxdWFsICcxKi8qKi8qKioqJ1xuXG5cdFx0XHRET00uYmF0Y2goW3RleHRBLmVscy5sYWJlbCwgdGV4dEIuZWxzLmxhYmVsLCB0ZXh0QS5lbHMuaW5uZXJ3cmFwLCB0ZXh0Qi5lbHMuaW5uZXJ3cmFwXSkuc3R5bGUgJ3RyYW5zaXRpb24nLCBudWxsXG5cdFx0XHR0ZXh0QS5zdGF0ZS5mb2N1c2VkID0gdGV4dEIuc3RhdGUuZm9jdXNlZCA9IHRydWVcblx0XHRcdGV4cGVjdCh0ZXh0QS5lbC5jaGlsZC5sYWJlbC5yYXcpLnRvLmhhdmUuc3R5bGUgJ2NvbG9yJywgQ09MT1JTLm9yYW5nZVxuXHRcdFx0ZXhwZWN0KHRleHRCLmVsLmNoaWxkLmxhYmVsLnJhdykudG8uaGF2ZS5zdHlsZSAnY29sb3InLCBDT0xPUlMuZ3JlZW5cblx0XHRcdGV4cGVjdCh0ZXh0QS5lbC5jaGlsZC5pbm5lcndyYXAucmF3KS50by5oYXZlLnN0eWxlICdib3JkZXJDb2xvcicsIENPTE9SUy5vcmFuZ2Vcblx0XHRcdGV4cGVjdCh0ZXh0Qi5lbC5jaGlsZC5pbm5lcndyYXAucmF3KS50by5oYXZlLnN0eWxlICdib3JkZXJDb2xvcicsIENPTE9SUy5ncmVlblxuXHRcdFx0dGV4dEEuYmx1cigpXG5cdFx0XHR0ZXh0Qi5ibHVyKClcblxuXHRcdFx0Y2hvaWNlLnZhbHVlID0gJ0JhbmFuYSdcblx0XHRcdGV4cGVjdChjaG9pY2UudmFsdWVSYXcubGFiZWwpLnRvLmVxdWFsICdCYW5hbmEnXG5cdFx0XHRleHBlY3QoY2hvaWNlLnZhbHVlUmF3LmVsLnJhdykudG8uaGF2ZS5zdHlsZSAnY29sb3InLCBDT0xPUlMuZ3JlZW5cblxuXG5cblxuXG5cblxuXG5cbiJdLCJuYW1lcyI6WyJrZXlib2FyZCIsIktleWJvYXJkIiwiVVNfRU5HTElTSCIsInRhcmdldCIsImtleXMiLCJ2YWx1ZSIsImZvY3VzIiwiZGlzcGF0Y2hFdmVudHNGb3JJbnB1dCIsImRpc3BhdGNoRXZlbnRzRm9yQWN0aW9uIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJSRUdFWF9MRU5fVkFMIiwiUkVHRVhfRElHSVRTIiwiUkVHRVhfU1BBQ0UiLCJSRUdFWF9LRUJBQiIsIklNUE9SVEFOVCIsIlBPU1NJQkxFX1BSRUZJWEVTIiwiUkVRVUlSRVNfVU5JVF9WQUxVRSIsIlFVQURfU0hPUlRIQU5EUyIsIkRJUkVDVElPTlMiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJkaXJlY3Rpb24iLCJpIiwibGVuIiwicHVzaCIsImxlbmd0aCIsIlNBTVBMRV9TVFlMRSIsInN0eWxlQ29uZmlnIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJpbmNsdWRlcyIsIml0ZW0iLCJpbmRleE9mIiwiaXNJdGVyYWJsZSIsIm5vZGVUeXBlIiwidG9LZWJhYkNhc2UiLCJzdHJpbmciLCJyZXBsYWNlIiwiZSIsImxldHRlciIsImNvbmNhdCIsInRvTG93ZXJDYXNlIiwiaXNQcm9wU3VwcG9ydGVkIiwiaXNWYWx1ZVN1cHBvcnRlZCIsIndpbmRvdyIsIkNTUyIsInN1cHBvcnRzIiwiZ2V0UHJlZml4Iiwic2tpcEluaXRpYWxDaGVjayIsImoiLCJsZW4xIiwicHJlZml4Iiwibm9ybWFsaXplUHJvcGVydHkiLCJub3JtYWxpemVWYWx1ZSIsInRlc3QiLCJzb3J0IiwiYXJyYXkiLCJncmVhdCIsImxlc3MiLCJwaXZvdCIsImhhc2giLCJoc2giLCJjaGFyQ29kZUF0IiwicnVsZVRvU3RyaW5nIiwicnVsZSIsImltcG9ydGFudCIsIm91dHB1dCIsInByb3AiLCJwcm9wcyIsIk9iamVjdCIsImlubGluZVN0eWxlQ29uZmlnIiwiY3JlYXRlIiwiaW5saW5lU3R5bGUiLCJ2YWx1ZVRvU3RvcmUiLCJsZXZlbCIsImNvbmZpZyIsInN0eWxlRWwiLCJpZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImVsIiwiY29udGVudCIsImNhY2hlIiwidGV4dENvbnRlbnQiLCJjbGVhcklubGluZVN0eWxlIiwia2V5IiwidmVyc2lvbiIsIl9xdWlja2NzcyIsImluZGV4IiwicXVpY2tjc3MiLCJ0YXJnZXRFbCIsImNvbXB1dGVkU3R5bGUiLCJzdWJFbCIsInN1YlByb3BlcnR5Iiwic3ViVmFsdWUiLCJfY29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJzZXRQcm9wZXJ0eSIsImFuaW1hdGlvbiIsIm5hbWUkJDEiLCJmcmFtZXMiLCJmcmFtZSIsImdlbmVyYXRlZCIsInJ1bGVzIiwicmVnaXN0ZXIiLCJjbGFzc05hbWUiLCJyZWYiLCJjbGVhclJlZ2lzdGVyZWQiLCJVTlNFVCIsInN1cHBvcnRzUHJvcGVydHkiLCJfZXh0ZW5kIiwiaXNBcnJheSIsImlzT2JqZWN0IiwiX3Nob3VsZERlZXBFeHRlbmQiLCJBcnJheSIsInRvU3RyaW5nIiwiY2FsbCIsInNob3VsZERlZXBFeHRlbmQiLCJvcHRpb25zIiwicGFyZW50S2V5IiwiZGVlcCIsIm5vdERlZXAiLCJkZWVwT25seSIsImV4dGVuZCIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VWYWx1ZSIsInN1YlRhcmdldCIsInRhcmdldFZhbHVlIiwiYWxsb3dOdWxsIiwibnVsbERlbGV0ZXMiLCJub3RLZXlzIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJnbG9iYWxGaWx0ZXIiLCJmaWx0ZXJzIiwiZ2xvYmFsVHJhbnNmb3JtIiwidHJhbnNmb3JtcyIsIm1vZGlmaWVycyIsIm5ld0J1aWxkZXIiLCJub3JtYWxpemVLZXlzIiwicHJpbWFyeUJ1aWxkZXIiLCJpc0Jhc2UiLCJfYnVpbGRlciIsImJ1aWxkZXIiLCJ0aGVUYXJnZXQiLCIkX2xlbiIsImFyZ3VtZW50cyIsIiRfaSIsInNoaWZ0IiwiZGVmaW5lUHJvcGVydGllcyIsImdldCIsIl8iLCJ0cmFuc2Zvcm0iLCJmaWx0ZXIiLCJwcmltYXJ5QnVpbGRlciQxIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiZGVmaW5lZCIsInN1YmplY3QiLCJvYmplY3QiLCJvYmplY3RQbGFpbiIsIm51bWJlciIsImlzTmFOIiwibnVtYmVyTG9vc2UiLCJOdW1iZXIiLCJpdGVyYWJsZSIsImZ1bmN0aW9uXyIsIm5hdGl2ZXMiLCJmcmVlemUiLCJkb21Eb2MiLCJkb21FbCIsImRvbVRleHQiLCJkb21Ob2RlIiwiZG9tVGV4dGFyZWEiLCJub2RlTmFtZSIsImRvbUlucHV0IiwiZG9tU2VsZWN0IiwiZG9tRmllbGQiLCJkb20iLCJBVkFJTF9TRVRTIiwiQ2hlY2tzIiwiYXJncyIsInNsaWNlIiwic2V0cyIsInNldCIsImxvYWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiYXJyMiIsIml0ZXIiLCJmcm9tIiwidGVtcGxhdGUiLCJlbGVtZW50IiwiSVMiLCJJU18iLCJxdWlja0RvbUVsIiwibmFtZSIsIklTJDEiLCJRdWlja0VsZW1lbnQiLCJRdWlja1dpbmRvdyIsIl9xdWlja2RvbSIsInF1aWNrZG9tIiwiYXJnIiwicHJldkNvdW50IiwiY291bnQiLCJfcG9zdENyZWF0aW9uIiwiYXJnc0xlbmd0aCIsImNoaWxkIiwiY2hpbGRyZW4iLCJ0eXBlIiwiYXBwbHkiLCJzcGF3biIsInVwZGF0ZU9wdGlvbnMiLCJfcXVpY2tFbGVtZW50IiwiZXhpc3RpbmciLCJ0ZXh0IiwiYXBwZW5kIiwiaHRtbCIsImlubmVySFRNTCIsImNvbnRhaW5lciIsImNoaWxkTm9kZXMiLCJiYXRjaCIsImlzUXVpY2tFbCIsImlzRWwiLCJpbml0IiwiUXVpY2tFbGVtZW50XyIsIlF1aWNrV2luZG93XyIsInJlbW92ZUl0ZW0iLCJpdGVtSW5kZXgiLCJzcGxpY2UiLCJub3JtYWxpemVFbGVtZW50QXJnIiwiaXNTdGF0ZVN0eWxlIiwicmVnaXN0ZXJTdHlsZSIsImNhY2hlZCIsInN0eWxlQ2FjaGUiLCJmbnMiLCJfY2xhc3MiLCJ2YWx1ZXMiLCJSRUdFWF9XSElURVNQQUNFIiwib25fIiwiZXZlbnROYW1lcyIsImNhbGxiYWNrIiwidXNlQ2FwdHVyZSIsImlzUHJpdmF0ZSIsIl90aGlzIiwiY2FsbGJhY2tSZWYiLCJzcGxpdCIsIl9ldmVudENhbGxiYWNrcyIsIl9fcmVmcyIsImZ1bmN0aW9uIiwiX2luc2VydGVkIiwiX3BhcmVudCIsImV2ZW50TmFtZSIsImJhc2UiLCJfbGlzdGVuVG8iLCJldmVudCIsIl9pbnZva2VIYW5kbGVycyIsIm9uY2UiLCJfdGhpczIiLCJfb25jZUNhbGxiYWNrIiwib24iLCJvbmNlQ2FsbGJhY2siLCJvZmYiLCJvZmZfIiwiX3RoaXMzIiwiZW1pdCIsImJ1YmJsZXMiLCJ1bmRlZmluZWQiLCJjYW5jZWxhYmxlIiwiZGF0YSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImVtaXRQcml2YXRlIiwiY2FsbGJhY2tzIiwiY2IiLCJldmVudE5hbWVUb0xpc3RlbkZvciIsImxpc3Rlbk1ldGhvZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudHMiLCJyZXN1bHQiLCJyZWxhdGVkIiwiY3VycmVudFN0YXRlU3R5bGUiLCJ0aGVuIiwiZm9yY2VTdHlsZSIsInN0eWxlU2FmZSIsInNraXBDb21wdXRlZCIsImNvbXB1dGVkIiwic2FtcGxlIiwic3R5bGVQYXJzZWQiLCJwYXJzZUZsb2F0IiwicmVjYWxjU3R5bGUiLCJyZWNhbGNDaGlsZHJlbiIsInRhcmdldFN0eWxlcyIsIl9yZXNvbHZlRm5TdHlsZXMiLCJfZ2V0QWN0aXZlU3RhdGVzIiwiX2NoaWxkcmVuIiwic3RhdGUiLCJzdGF0ZXMiLCJfc3RhdGUiLCJfc3RhdGVTaGFyZWQiLCJfc3RhdGVzIiwiX3N0eWxlcyIsImhpZGUiLCJzaG93IiwiZGlzcGxheSIsIm9yaWVudGF0aW9uR2V0dGVyIiwid2lkdGgiLCJoZWlnaHQiLCJhc3BlY3RSYXRpb0dldHRlciIsInN0eWxlJDEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJRdWlja1dpbmRvdyQxIiwiUXVpY2tXaW5kb3ckMiIsInJhdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIk1lZGlhUXVlcnkiLCJSVUxFX0RFSUxJTUlURVIiLCJNZWRpYVF1ZXJ5JDEiLCJ0ZXN0UnVsZSIsInBhcnNlUXVlcnkiLCJxdWVyeVN0cmluZyIsInF1ZXJ5U3BsaXQiLCJwYXJlbnQiLCJwYXJlbnRNYXRjaGluZyIsIm1hcCIsImdldHRlciIsImtleVByZWZpeCIsIm1heCIsIm1pbiIsIm9yaWVudGF0aW9uIiwiYXNwZWN0UmF0aW8iLCJwYXJzZWRWYWx1ZSIsInN0cmluZ1ZhbHVlIiwicXVlcnkiLCJjdXJyZW50VmFsdWUiLCJwYXNzZWQiLCJTdGF0ZUNoYWluIiwiU3RhdGVDaGFpbiQxIiwiam9pbiIsIndpdGhvdXQiLCJpc0FwcGxpY2FibGUiLCJvdGhlckFjdGl2ZSIsImFjdGl2ZSIsIkJBU0VfU1RBVEVfVFJJR0dFUlMiLCJDQUNIRURfRk5fSU5TRVJURUQiLCJfbm9ybWFsaXplT3B0aW9ucyIsImJhc2UxIiwiYmFzZTIiLCJiYXNlMyIsImJhc2U0IiwiYmFzZTUiLCJyZWxhdGVkSW5zdGFuY2UiLCJjbGFzcyIsInVybCIsImhyZWYiLCJ1bnBhc3NhYmxlU3RhdGVzIiwicGFzc1N0YXRlVG9DaGlsZHJlbiIsInBhc3NEYXRhVG9DaGlsZHJlbiIsInN0YXRlVHJpZ2dlcnMiLCJjbG9uZSIsIl9wYXJzZVRleHRzIiwiX3RleHRzIiwiX3BhcnNlU3R5bGVzIiwic3R5bGVzIiwic3RvcmUiLCJfbWVkaWFTdGF0ZXMiLCJfcHJvdmlkZWRTdGF0ZXMiLCJfcHJvdmlkZWRTdGF0ZXNTaGFyZWQiLCJfZmxhdHRlbk5lc3RlZFN0YXRlcyIsInNwZWNpYWxTdGF0ZXMiLCJzdGF0ZVN0eWxlcyIsInN0YXRlXyIsIiRiYXNlIiwiZmxhdHRlbk5lc3RlZFN0YXRlcyIsInN0eWxlT2JqZWN0IiwiY2hhaW4iLCJoYXNOb25TdGF0ZVByb3BzIiwic3RhdGVDaGFpbiIsInN0eWxlS2V5cyIsInRleHRzIiwiX2FwcGx5T3B0aW9ucyIsImhhbmRsZXIiLCJtZXRob2QiLCJyZWYxIiwicmVmMiIsImF0dHIiLCJzcmMiLCJzZWxlY3RlZCIsImNoZWNrZWQiLCJhdHRycyIsIl9hcHBseVJlZ2lzdGVyZWRTdHlsZSIsInN0eWxlQWZ0ZXJJbnNlcnQiLCJpbnZva2VDb21wdXRlcnNPbmNlIiwiX2ludm9rZWRDb21wdXRlcnMiLCJyZWNhbGNPblJlc2l6ZSIsIm1ldGhvZHMiLCJjb21wdXRlcnMiLCJhcHBseURhdGEiLCJfaW5pdCIsIl9ydW5Db21wdXRlciIsIl9hdHRhY2hTdGF0ZUV2ZW50cyIsImZvcmNlIiwiZGlzYWJsZXIiLCJlbmFibGVyIiwidHJpZ2dlciIsIl9wcm94eVBhcmVudCIsIm5ld1BhcmVudCIsImxhc3RQYXJlbnQiLCJwYXJlbnRzIiwiZG9jdW1lbnRFbGVtZW50IiwiX3VucHJveHlQYXJlbnQiLCJtZWRpYVN0YXRlcyIsInJlc3VsdHMiLCJpbml0JDEiLCJhbGlhc2VzIiwicGFyZW50c1VudGlsIiwiX2dldFBhcmVudHMiLCJpc1JlZiIsIm5leHRQYXJlbnQiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeUFsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJfZ2V0Q2hpbGRSZWZzIiwiZnJlc2hDb3B5IiwiY2hpbGRSZWZzIiwicmVmcyIsIl9jaGlsZFJlZnMiLCJfZ2V0SW5kZXhCeVByb3AiLCJtYWluIiwiX2ZpbHRlckVsZW1lbnRzIiwidHJhdmVyc2luZyIsInBhcmVudE5vZGUiLCJuZXh0U2libGluZyIsIm5leHRFbGVtZW50U2libGluZyIsIm5leHRBbGwiLCJzaWJsaW5ncyIsIm5leHQiLCJwcmV2aW91c1NpYmxpbmciLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicHJldkFsbCIsInByZXZTaWJsaW5nIiwicHJldiIsInJldmVyc2UiLCJEVU1NWV9BUlJBWSIsInRhcmdldFN0YXRlIiwiYWN0aXZlU3RhdGVzIiwiZGVzaXJlZFZhbHVlIiwidG9nZ2xlIiwiX3N0YXRlUGlwZVRhcmdldCIsInRvZ2dsZVN0YXRlIiwicmVzZXRTdGF0ZSIsImFjdGl2ZVN0YXRlIiwicGlwZVN0YXRlIiwidGFyZ2V0U3R5bGUiLCJzdXBlcmlvclN0YXRlcyIsImluY2x1ZGVCYXNlIiwic2tpcEZucyIsImVudHJ5IiwiayIsInN1cGVyaW9yU3R5bGVzIiwiYWRkQ2xhc3MiLCJfcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlIiwicmVzZXRWYWx1ZSIsInJlbW92ZUNsYXNzIiwiX3R1cm5TdHlsZU9OIiwic2hhcmVkU3RhdGVzIiwiX2dldFN1cGVyaW9yU3RhdGVzIiwiX2dldFNoYXJlZFN0YXRlcyIsIl90dXJuU3R5bGVPRkYiLCJhY3RpdmVTaGFyZWRTdGF0ZXMiLCJfdHVyblRleHRPTiIsInRhcmdldFRleHQiLCJfdHVyblRleHRPRkYiLCJzdGF0ZVRvRXhjbHVkZSIsImluY2x1ZGVTaGFyZWRTdGF0ZXMiLCJwbGFpblN0YXRlcyIsImNhbmRpZGF0ZSIsInN1cGVyaW9yIiwidGFyZ2V0U3RhdGVJbmRleCIsInN0YXRlJDEiLCJ0b1RlbXBsYXRlIiwiZWxDbG9uZSIsImxlbjIiLCJuZXdFbCIsImNsb25lTm9kZSIsInByZXZQYXJlbnQiLCJfcmVtb3ZlQ2hpbGQiLCJfcmVmcmVzaFBhcmVudCIsImFwcGVuZFRvIiwicHJlcGVuZCIsInVuc2hpZnQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwicHJlcGVuZFRvIiwiYWZ0ZXIiLCJteUluZGV4IiwiaW5zZXJ0QWZ0ZXIiLCJiZWZvcmUiLCJkZXRhY2giLCJyZW1vdmUiLCJlbXB0eSIsIndyYXAiLCJjdXJyZW50UGFyZW50IiwidW53cmFwIiwiZ3JhbmRQYXJlbnQiLCJwYXJlbnRDaGlsZHJlbiIsInBhcmVudFNpYmxpbmciLCJoYXNDbGFzcyIsImNsYXNzTGlzdCIsInRhcmdldEluZGV4IiwidG9nZ2xlQ2xhc3MiLCJzZXRSZWYiLCJ0YXJnZXRDaGlsZCIsInJlcGxhY2VtZW50Q2hpbGQiLCJpbmRleE9mQ2hpbGQiLCJyZXBsYWNlQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIm1hbmlwdWxhdGlvbiIsIm5ld1ZhbHVlIiwic3ZnIiwibGlzdCIsInBvcCIsInVwZGF0ZVN0YXRlU3R5bGVzIiwicGFyc2VkIiwidXBkYXRlZFN0YXRlcyIsInVwZGF0ZVN0YXRlVGV4dHMiLCJwYXNzVGhyb3VnaCIsImRlZmF1bHRzIiwiY29tcHV0ZXIiLCJhcHBsaWNhdGlvbiIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImF0dHJpYnV0ZXNBbmRQcm9wZXJ0aWVzIiwiUXVpY2tFbGVtZW50JDEiLCJzdmdOYW1lc3BhY2UiLCJRdWlja0VsZW1lbnQkMiIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwidG9KU09OIiwic2NoZW1hIiwibWF0Y2hlc1NjaGVtYSIsIlBBUlNFX0VSUk9SX1BSRUZJWCIsInBhcnNlVHJlZSIsInBhcnNlVHJlZSQxIiwidHJlZSIsInBhcnNlQ2hpbGRyZW4iLCJFcnJvciIsIlN0cmluZyIsIk5PVF9ERUVQX0tFWVMiLCJOT1RfS0VZUyIsIl9leHRlbmRCeVJlZiIsImV4dGVuZFRlbXBsYXRlIiwiZXh0ZW5kVGVtcGxhdGUkMSIsImN1cnJlbnRPcHRzIiwibmV3T3B0cyIsImdsb2JhbE9wdHMiLCJjdXJyZW50Q2hpbGQiLCJjdXJyZW50Q2hpbGRyZW4iLCJnbG9iYWxPcHRzVHJhbnNmb3JtIiwibWF4TGVuZ3RoIiwibmVlZHNUZW1wbGF0ZVdyYXAiLCJuZXdDaGlsZCIsIm5ld0NoaWxkUHJvY2Vzc2VkIiwibmV3Q2hpbGRyZW4iLCJub0NoYW5nZXMiLCJyZW1haW5pbmdOZXdDaGlsZHJlbiIsIm9wdHMiLCJNYXRoIiwiUXVpY2tUZW1wbGF0ZSQxIiwiZXh0ZW5kQnlSZWYiLCJuZXdDaGlsZHJlblJlZnMiLCJRdWlja1RlbXBsYXRlIiwiaXNUcmVlIiwiZXh0ZW5kJCQxIiwibmV3VmFsdWVzIiwiY2hpbGREYXRhIiwiX2V4dGVuZFRlbXBsYXRlIiwiaXNUZW1wbGF0ZSIsIlF1aWNrQmF0Y2giLCJRdWlja0JhdGNoJDEiLCJlbGVtZW50cyIsInJldHVyblJlc3VsdHMxIiwicmV0dXJuUmVzdWx0cyIsIl9yZXR1cm4iLCJyZXR1cm5OZXh0IiwibGFzdFJlc3VsdHMiLCJyZXN1bHRzMSIsIl9lbGVtZW50IiwiU0hPUlRDVVRTIiwic2hvcnRjdXQiLCJyZXN0YXJ0U2FuZGJveCIsImZpZWxkIiwic2FuZGJveCIsInF1aWNrZmllbGQiLCJpbnN0YW5jZXMiLCJET00iLCJkaXYiLCJib3JkZXIiLCJwYWRkaW5nIiwiYm94U2l6aW5nIiwiYm9keSIsInRpdGxlIiwibWFyZ2luIiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwiZm9udEZhbWlseSIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsInByb21pc2UiLCJvbkZpbmFsbHkiLCJ2YWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsIlRpbWVvdXRFcnJvciIsIm1lc3NhZ2UiLCJtcyIsImZhbGxiYWNrIiwicmVqZWN0IiwidGltZXIiLCJzZXRUaW1lb3V0IiwicEZpbmFsbHkiLCJjbGVhclRpbWVvdXQiLCJlbWl0dGVyIiwiY2FuY2VsIiwicmV0IiwiYXNzaWduIiwicmVqZWN0aW9uRXZlbnRzIiwibXVsdGlBcmdzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJiaW5kIiwicmVzb2x2ZUhhbmRsZXIiLCJyZWplY3RIYW5kbGVyIiwicmVhc29uIiwicmVqZWN0aW9uRXZlbnQiLCJ0aW1lb3V0IiwicFRpbWVvdXQiLCJyZWQiLCJncmVlbiIsIm9yYW5nZSIsImJsYWNrIiwiZ3JleV9kYXJrIiwiZ3JleSIsImdyZXlfc2VtaV9saWdodCIsImdyZXlfbGlnaHQiLCJncmV5X2xpZ2h0MiIsImdyZXlfbGlnaHQzIiwiZ3JleV9saWdodDQiLCJleGNsdWRlIiwiZXhjbHVkZXMiLCJleGNsdWRlUHJvcHMiLCJyZXMiLCJleHRlbmRFeGNsdWRlIiwiQXNzZXJ0aW9uRXJyb3IiLCJfcHJvcHMiLCJzc2YiLCJzaG93RGlmZiIsImNhbGxlZSIsImNhcHR1cmVTdGFja1RyYWNlIiwic3RhY2siLCJoYXNQcm9wZXJ0eSIsInBhcnNlUGF0aCIsInBhdGgiLCJzdHIiLCJwYXJ0cyIsIm1hdGNoIiwibWFwTWF0Y2hlcyIsInJlZ2V4cCIsIm1BcnIiLCJleGVjIiwicCIsImludGVybmFsR2V0UGF0aFZhbHVlIiwicGF0aERlcHRoIiwidGVtcG9yYXJ5VmFsdWUiLCJwYXJ0IiwiaW50ZXJuYWxTZXRQYXRoVmFsdWUiLCJ0ZW1wT2JqIiwicHJvcE5hbWUiLCJwcm9wVmFsIiwiZ2V0UGF0aEluZm8iLCJsYXN0IiwiaW5mbyIsImV4aXN0cyIsImdldFBhdGhWYWx1ZSIsInNldFBhdGhWYWx1ZSIsImZsYWciLCJmbGFncyIsIl9fZmxhZ3MiLCJuZWdhdGUiLCJleHByIiwicHJvbWlzZUV4aXN0cyIsImdsb2JhbE9iamVjdCIsImdsb2JhbCIsInNlbGYiLCJpc0RvbSIsInN5bWJvbEV4aXN0cyIsIm1hcEV4aXN0cyIsIk1hcCIsInNldEV4aXN0cyIsIlNldCIsIndlYWtNYXBFeGlzdHMiLCJXZWFrTWFwIiwid2Vha1NldEV4aXN0cyIsIldlYWtTZXQiLCJkYXRhVmlld0V4aXN0cyIsIkRhdGFWaWV3Iiwic3ltYm9sSXRlcmF0b3JFeGlzdHMiLCJzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyIsInRvU3RyaW5nVGFnIiwic2V0RW50cmllc0V4aXN0cyIsImVudHJpZXMiLCJtYXBFbnRyaWVzRXhpc3RzIiwic2V0SXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIm1hcEl0ZXJhdG9yUHJvdG90eXBlIiwiYXJyYXlJdGVyYXRvckV4aXN0cyIsImFycmF5SXRlcmF0b3JQcm90b3R5cGUiLCJzdHJpbmdJdGVyYXRvckV4aXN0cyIsInN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlIiwidG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGgiLCJ0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGgiLCJtb2R1bGUiLCJ0eXBlRGV0ZWN0IiwidHlwZW9mT2JqIiwibG9jYXRpb24iLCJuYXZpZ2F0b3IiLCJtaW1lVHlwZXMiLCJwbHVnaW5zIiwiSFRNTEVsZW1lbnQiLCJ0YWdOYW1lIiwic3RyaW5nVGFnIiwib2JqUHJvdG90eXBlIiwiUmVnRXhwIiwiRGF0ZSIsImV4cG9ydHMiLCJleHBlY3RUeXBlcyIsInR5cGVzIiwiZmxhZ01zZyIsInNzZmkiLCJ0IiwiYXJ0IiwiY2hhckF0Iiwib3IiLCJvYmpUeXBlIiwic29tZSIsImV4cGVjdGVkIiwiZ2V0QWN0dWFsIiwiX29iaiIsIkZ1bmN0aW9uIiwiZnVuY3Rpb25OYW1lTWF0Y2giLCJnZXRGdW5jTmFtZSIsImFGdW5jIiwiZ2V0UHJvcGVydGllcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJhZGRQcm9wZXJ0eSIsInByb3RvIiwiZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMiLCJpbmNsdWRlU3RhY2siLCJ0cnVuY2F0ZVRocmVzaG9sZCIsInVzZVByb3h5IiwicHJveHlFeGNsdWRlZEtleXMiLCJpbnNwZWN0Iiwic2hvd0hpZGRlbiIsImRlcHRoIiwiY29sb3JzIiwiY3R4Iiwic2VlbiIsInN0eWxpemUiLCJmb3JtYXRWYWx1ZSIsImlzRE9NRWxlbWVudCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsIm91dGVySFRNTCIsInhtbFZlcnNpb24iLCJ4bWxTZXJpYWxpemVyIiwiWE1MU2VyaWFsaXplciIsInNlcmlhbGl6ZVRvU3RyaW5nIiwibnMiLCJ2aXNpYmxlS2V5cyIsIm5hbWVTdWZmaXgiLCJpc0Vycm9yIiwiZ2V0TmFtZSIsImlzUmVnRXhwIiwiaXNEYXRlIiwidG9VVENTdHJpbmciLCJmb3JtYXRFcnJvciIsInR5cGVkQXJyYXkiLCJicmFjZXMiLCJpc1R5cGVkQXJyYXkiLCJmb3JtYXRBcnJheSIsImZvcm1hdFR5cGVkQXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkluZmluaXR5IiwibCIsInByb3BEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwibGluZSIsInN1YnN0ciIsInJlZHVjZSIsImN1ciIsIm51bUxpbmVzRXN0IiwiYXIiLCJvYmplY3RUb1N0cmluZyIsInJlIiwiZCIsIm8iLCJvYmpEaXNwbGF5Iiwia3N0ciIsImdldE1lc3NhZ2UiLCJhY3R1YWwiLCJtc2ciLCJ0cmFuc2ZlckZsYWdzIiwiYXNzZXJ0aW9uIiwiaW5jbHVkZUFsbCIsIkZha2VNYXAiLCJfa2V5IiwicmFuZG9tIiwibm93IiwiZ2V0TWFwIiwic2V0TWFwIiwiaXNFeHRlbnNpYmxlIiwiTWVtb2l6ZU1hcCIsIm1lbW9pemVDb21wYXJlIiwibGVmdEhhbmRPcGVyYW5kIiwicmlnaHRIYW5kT3BlcmFuZCIsIm1lbW9pemVNYXAiLCJpc1ByaW1pdGl2ZSIsImxlZnRIYW5kTWFwIiwibWVtb2l6ZVNldCIsImRlZXBFcXVhbCIsImNvbXBhcmF0b3IiLCJleHRlbnNpdmVEZWVwRXF1YWwiLCJzaW1wbGVSZXN1bHQiLCJzaW1wbGVFcXVhbCIsIm1lbW9pemUiLCJtZW1vaXplUmVzdWx0TGVmdCIsIm1lbW9pemVSZXN1bHRSaWdodCIsImNvbXBhcmF0b3JSZXN1bHQiLCJsZWZ0SGFuZFR5cGUiLCJleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUiLCJ2YWx1ZU9mIiwiaXRlcmFibGVFcXVhbCIsInJlZ2V4cEVxdWFsIiwiZ2VuZXJhdG9yRXF1YWwiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiZW50cmllc0VxdWFsIiwib2JqZWN0RXF1YWwiLCJzaXplIiwibGVmdEhhbmRJdGVtcyIsInJpZ2h0SGFuZEl0ZW1zIiwiZ2F0aGVyRW50cmllcyIsImdldEdlbmVyYXRvckVudHJpZXMiLCJoYXNJdGVyYXRvckZ1bmN0aW9uIiwiZ2V0SXRlcmF0b3JFbnRyaWVzIiwiaXRlcmF0b3JFcnJvciIsImdlbmVyYXRvciIsImdlbmVyYXRvclJlc3VsdCIsImFjY3VtdWxhdG9yIiwiZG9uZSIsImdldEVudW1lcmFibGVLZXlzIiwia2V5c0VxdWFsIiwibGVmdEhhbmRLZXlzIiwicmlnaHRIYW5kS2V5cyIsImxlZnRIYW5kRW50cmllcyIsInJpZ2h0SGFuZEVudHJpZXMiLCJpc1Byb3h5RW5hYmxlZCIsIlByb3h5IiwiUmVmbGVjdCIsInByb3BlcnR5R2V0dGVyIiwibmV3QXNzZXJ0aW9uIiwiY2hhaSIsIkFzc2VydGlvbiIsImZuTGVuZ3RoRGVzYyIsImFkZExlbmd0aEd1YXJkIiwiZm4iLCJhc3NlcnRpb25OYW1lIiwiaXNDaGFpbmFibGUiLCJidWlsdGlucyIsInByb3hpZnkiLCJub25DaGFpbmFibGVNZXRob2ROYW1lIiwicHJveHlHZXR0ZXIiLCJoYXMiLCJvcmRlcmVkUHJvcGVydGllcyIsImEiLCJiIiwic3RyaW5nRGlzdGFuY2UiLCJzdHJBIiwic3RyQiIsIm1lbW8iLCJhZGRNZXRob2QiLCJtZXRob2RXcmFwcGVyIiwib3ZlcndyaXRlUHJvcGVydHkiLCJfZ2V0IiwiX3N1cGVyIiwib3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlciIsIm9yaWdMb2NrU3NmaSIsIm92ZXJ3cml0ZU1ldGhvZCIsIl9tZXRob2QiLCJvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIiLCJjYW5TZXRQcm90b3R5cGUiLCJzZXRQcm90b3R5cGVPZiIsInRlc3RGbiIsImV4Y2x1ZGVOYW1lcyIsInByb3BEZXNjIiwiYWRkQ2hhaW5hYmxlTWV0aG9kIiwiY2hhaW5pbmdCZWhhdmlvciIsImNoYWluYWJsZUJlaGF2aW9yIiwiX19tZXRob2RzIiwiY2hhaW5hYmxlTWV0aG9kR2V0dGVyIiwiY2hhaW5hYmxlTWV0aG9kV3JhcHBlciIsImFzc2VydGVyTmFtZXMiLCJhc3NlcnRlck5hbWUiLCJwZCIsIm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCIsIl9jaGFpbmluZ0JlaGF2aW9yIiwib3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RHZXR0ZXIiLCJvdmVyd3JpdGluZ0NoYWluYWJsZU1ldGhvZFdyYXBwZXIiLCJjb21wYXJlQnlJbnNwZWN0IiwiZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bSIsImdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzIiwiY29tcGF0aWJsZUluc3RhbmNlIiwidGhyb3duIiwiZXJyb3JMaWtlIiwiY29tcGF0aWJsZUNvbnN0cnVjdG9yIiwiY29tcGF0aWJsZU1lc3NhZ2UiLCJlcnJNYXRjaGVyIiwiY29tcGFyaXNvblN0cmluZyIsImdldEZ1bmN0aW9uTmFtZSIsImNvbnN0cnVjdG9yRm4iLCJnZXRDb25zdHJ1Y3Rvck5hbWUiLCJjb25zdHJ1Y3Rvck5hbWUiLCJ0cmltIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsInBhdGh2YWwiLCJyZXF1aXJlJCQxMCIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMiIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjQiLCJfY2hhaSIsInV0aWwiLCJsb2NrU3NmaSIsImNvbnNvbGUiLCJ3YXJuIiwiYXNzZXJ0IiwibmVnYXRlTXNnIiwiX2FjdHVhbCIsIm9rIiwiYW4iLCJhcnRpY2xlIiwiU2FtZVZhbHVlWmVybyIsImluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yIiwiaW5jbHVkZSIsImlzRGVlcCIsImluY2x1ZGVkIiwiaXNFcWwiLCJlcWwiLCJmaXJzdEVyciIsIm51bUVycnMiLCJwcm9wQXNzZXJ0aW9uIiwiY2hlY2tFcnJvciIsIml0ZW1zQ291bnQiLCJjaGVja0FyZ3VtZW50cyIsImFzc2VydEVxdWFsIiwiYXNzZXJ0RXFsIiwiYXNzZXJ0QWJvdmUiLCJuIiwiZG9MZW5ndGgiLCJtc2dQcmVmaXgiLCJuVHlwZSIsInNob3VsZFRocm93IiwidG8iLCJoYXZlIiwiZXJyb3JNZXNzYWdlIiwicHJpbnRPYmoiLCJhc3NlcnRMZWFzdCIsImFzc2VydEJlbG93IiwiYXNzZXJ0TW9zdCIsInN0YXJ0IiwiZmluaXNoIiwic3RhcnRUeXBlIiwiZmluaXNoVHlwZSIsInJhbmdlIiwiYXNzZXJ0SW5zdGFuY2VPZiIsImlzSW5zdGFuY2VPZiIsImFzc2VydFByb3BlcnR5IiwiaXNOZXN0ZWQiLCJpc093biIsInBhdGhJbmZvIiwiYXNzZXJ0T3duUHJvcGVydHkiLCJhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJhY3R1YWxEZXNjcmlwdG9yIiwiYXNzZXJ0TGVuZ3RoQ2hhaW4iLCJhc3NlcnRMZW5ndGgiLCJhc3NlcnRNYXRjaCIsImlzIiwiYXNzZXJ0S2V5cyIsImtleXNUeXBlIiwiZGVlcFN0ciIsIm1peGVkQXJnc01zZyIsImFueSIsImFsbCIsImV4cGVjdGVkS2V5IiwiYWN0dWFsS2V5IiwiZXZlcnkiLCJhc3NlcnRUaHJvd3MiLCJlcnJNc2dNYXRjaGVyIiwiY2F1Z2h0RXJyIiwiZXZlcnlBcmdJc1VuZGVmaW5lZCIsImV2ZXJ5QXJnSXNEZWZpbmVkIiwiQm9vbGVhbiIsImVycm9yTGlrZUZhaWwiLCJlcnJNc2dNYXRjaGVyRmFpbCIsImVycm9yTGlrZVN0cmluZyIsImlzQ29tcGF0aWJsZUluc3RhbmNlIiwiaXNDb21wYXRpYmxlQ29uc3RydWN0b3IiLCJwbGFjZWhvbGRlciIsImlzQ29tcGF0aWJsZU1lc3NhZ2UiLCJyZXNwb25kVG8iLCJpdHNlbGYiLCJjb250ZXh0Iiwic2F0aXNmeSIsIm1hdGNoZXIiLCJjbG9zZVRvIiwiZGVsdGEiLCJhYnMiLCJpc1N1YnNldE9mIiwic3Vic2V0Iiwic3VwZXJzZXQiLCJjbXAiLCJjb250YWlucyIsIm9yZGVyZWQiLCJlbGVtIiwiaWR4IiwibWF0Y2hJZHgiLCJlbGVtMiIsImJlIiwiZmFpbE1zZyIsImZhaWxOZWdhdGVNc2ciLCJvbmVPZiIsImFzc2VydENoYW5nZXMiLCJpbml0aWFsIiwiZmluYWwiLCJtc2dPYmoiLCJhc3NlcnRJbmNyZWFzZXMiLCJhc3NlcnREZWNyZWFzZXMiLCJhc3NlcnREZWx0YSIsImJlaGF2aW9yIiwicmVhbERlbHRhIiwiZXhwcmVzc2lvbiIsImlzU2VhbGVkIiwiaXNGcm96ZW4iLCJpc0Zpbml0ZSIsImV4cGVjdCIsImZhaWwiLCJvcGVyYXRvciIsImxvYWRTaG91bGQiLCJzaG91bGRHZXR0ZXIiLCJzaG91bGRTZXR0ZXIiLCJzaG91bGQiLCJlcXVhbCIsInZhbDEiLCJ2YWwyIiwiVGhyb3ciLCJlcnJ0IiwiZXJycyIsImV4aXN0Iiwibm90IiwiU2hvdWxkIiwiZXhwcmVzcyIsImVycm1zZyIsImlzT2siLCJpc05vdE9rIiwiYWN0IiwiZXhwIiwibm90RXF1YWwiLCJzdHJpY3RFcXVhbCIsIm5vdFN0cmljdEVxdWFsIiwiZGVlcFN0cmljdEVxdWFsIiwibm90RGVlcEVxdWFsIiwiaXNBYm92ZSIsImFidiIsImFib3ZlIiwiaXNBdExlYXN0IiwiYXRsc3QiLCJsZWFzdCIsImlzQmVsb3ciLCJibHciLCJiZWxvdyIsImlzQXRNb3N0IiwiYXRtc3QiLCJtb3N0IiwiaXNUcnVlIiwiaXNOb3RUcnVlIiwiaXNGYWxzZSIsImlzTm90RmFsc2UiLCJpc051bGwiLCJpc05vdE51bGwiLCJOYU4iLCJpc05vdE5hTiIsIm5vdEV4aXN0cyIsImlzVW5kZWZpbmVkIiwiaXNEZWZpbmVkIiwiaXNGdW5jdGlvbiIsImlzTm90RnVuY3Rpb24iLCJpc05vdE9iamVjdCIsImlzTm90QXJyYXkiLCJpc1N0cmluZyIsImlzTm90U3RyaW5nIiwiaXNOdW1iZXIiLCJpc05vdE51bWJlciIsImZpbml0ZSIsImlzQm9vbGVhbiIsImlzTm90Qm9vbGVhbiIsInR5cGVPZiIsIm5vdFR5cGVPZiIsImluc3RhbmNlT2YiLCJub3RJbnN0YW5jZU9mIiwiaW5jIiwibm90SW5jbHVkZSIsImRlZXBJbmNsdWRlIiwibm90RGVlcEluY2x1ZGUiLCJuZXN0ZWRJbmNsdWRlIiwibmVzdGVkIiwibm90TmVzdGVkSW5jbHVkZSIsImRlZXBOZXN0ZWRJbmNsdWRlIiwibm90RGVlcE5lc3RlZEluY2x1ZGUiLCJvd25JbmNsdWRlIiwibm90T3duSW5jbHVkZSIsImRlZXBPd25JbmNsdWRlIiwibm90RGVlcE93bkluY2x1ZGUiLCJub3RNYXRjaCIsIm5vdFByb3BlcnR5IiwicHJvcGVydHlWYWwiLCJub3RQcm9wZXJ0eVZhbCIsImRlZXBQcm9wZXJ0eVZhbCIsIm5vdERlZXBQcm9wZXJ0eVZhbCIsIm93blByb3BlcnR5Iiwibm90T3duUHJvcGVydHkiLCJvd25Qcm9wZXJ0eVZhbCIsIm5vdE93blByb3BlcnR5VmFsIiwiZGVlcE93blByb3BlcnR5VmFsIiwibm90RGVlcE93blByb3BlcnR5VmFsIiwibmVzdGVkUHJvcGVydHkiLCJub3ROZXN0ZWRQcm9wZXJ0eSIsIm5lc3RlZFByb3BlcnR5VmFsIiwibm90TmVzdGVkUHJvcGVydHlWYWwiLCJkZWVwTmVzdGVkUHJvcGVydHlWYWwiLCJub3REZWVwTmVzdGVkUHJvcGVydHlWYWwiLCJsZW5ndGhPZiIsImhhc0FueUtleXMiLCJoYXNBbGxLZXlzIiwiY29udGFpbnNBbGxLZXlzIiwiY29udGFpbiIsImRvZXNOb3RIYXZlQW55S2V5cyIsImRvZXNOb3RIYXZlQWxsS2V5cyIsImhhc0FueURlZXBLZXlzIiwiaGFzQWxsRGVlcEtleXMiLCJjb250YWluc0FsbERlZXBLZXlzIiwiZG9lc05vdEhhdmVBbnlEZWVwS2V5cyIsImRvZXNOb3RIYXZlQWxsRGVlcEtleXMiLCJ0aHJvd3MiLCJhc3NlcnRFcnIiLCJ0aHJvdyIsImRvZXNOb3RUaHJvdyIsImFwcHJveGltYXRlbHkiLCJzYW1lTWVtYmVycyIsInNldDEiLCJzZXQyIiwic2FtZSIsIm1lbWJlcnMiLCJub3RTYW1lTWVtYmVycyIsInNhbWVEZWVwTWVtYmVycyIsIm5vdFNhbWVEZWVwTWVtYmVycyIsInNhbWVPcmRlcmVkTWVtYmVycyIsIm5vdFNhbWVPcmRlcmVkTWVtYmVycyIsInNhbWVEZWVwT3JkZXJlZE1lbWJlcnMiLCJub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzIiwiaW5jbHVkZU1lbWJlcnMiLCJub3RJbmNsdWRlTWVtYmVycyIsImluY2x1ZGVEZWVwTWVtYmVycyIsIm5vdEluY2x1ZGVEZWVwTWVtYmVycyIsImluY2x1ZGVPcmRlcmVkTWVtYmVycyIsIm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyIsImluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMiLCJub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzIiwiaW5MaXN0IiwiY2hhbmdlcyIsImNoYW5nZSIsImNoYW5nZXNCeSIsInRtcE1zZyIsImJ5IiwiZG9lc05vdENoYW5nZSIsImNoYW5nZXNCdXROb3RCeSIsImJ1dCIsImluY3JlYXNlcyIsImluY3JlYXNlIiwiaW5jcmVhc2VzQnkiLCJkb2VzTm90SW5jcmVhc2UiLCJpbmNyZWFzZXNCdXROb3RCeSIsImRlY3JlYXNlcyIsImRlY3JlYXNlIiwiZGVjcmVhc2VzQnkiLCJkb2VzTm90RGVjcmVhc2UiLCJkb2VzTm90RGVjcmVhc2VCeSIsImRlY3JlYXNlc0J1dE5vdEJ5IiwiaWZFcnJvciIsImV4dGVuc2libGUiLCJpc05vdEV4dGVuc2libGUiLCJzZWFsZWQiLCJpc05vdFNlYWxlZCIsImZyb3plbiIsImlzTm90RnJvemVuIiwiaXNFbXB0eSIsImlzTm90RW1wdHkiLCJhbGlhcyIsImFzIiwidXNlZCIsInVzZSIsImNvcmUiLCJjaGFpRG9tIiwicmVxdWlyZSIsInV0aWxzIiwiZWxUb1N0cmluZyIsImRlc2MiLCJOb2RlTGlzdCIsImF0dHJpYnV0ZXMiLCJhdHRyQXNzZXJ0Iiwib2JqRGVzYyIsImFjdHVhbExlbmd0aCIsIm1hdGNoZXMiLCJzdWJpdGVtIiwiY2hhaVN0eWxlIiwiaXNOb25Db2xvcnMiLCJwcm9wZXJ0eVZhbHVlIiwiY29tcGFyZUNTU1ZhbHVlIiwiZWxlbWVudFRhZyIsInRocm93TWVzc2FnZSIsInRocm93TWVzc2FnZU5lZ2F0aXZlIiwicHJvcGVydHlIaWZlbkNhc2UiLCJmYWtlIiwiaWZyYW1lIiwidmlzaWJpbGl0eSIsImZha2VTdHlsZSIsImhhc0F1dG9WYWx1ZSIsInJlZyIsImVzY2FwZVJlZ0V4cCIsImdldFByb3RvdHlwZU9mRXhpc3RzIiwiaHRtbEVsZW1lbnRFeGlzdHMiLCJpc0FycmF5RXhpc3RzIiwiY2xlYXIiLCJjbGVhck1hcCIsImRlbGV0ZSIsImRlbGV0ZU1hcCIsIkRFRkFVTFRfVE9MRVJBTkNFIiwiYm90aE51bWJlcnMiLCJhbG1vc3RFcXVhbCIsInRvbCIsInRvbGVyYW5jZSIsImNoYWlBbG1vc3QiLCJjdXN0b21Ub2xlcmFuY2UiLCJzdGFuZGFyZFRvbGVyYW5jZSIsIm92ZXJyaWRlQXNzZXJ0RXF1YWwiLCJvdmVycmlkZUFzc2VydEVxbCIsInRvbGVyYW5jZU92ZXJyaWRlIiwiZ2xvYmFscyIsInN0cmluZ3MiLCJtZXNzYWdlcyIsInByZWRpY2F0ZXMiLCJmdW5jdGlvbnMiLCJtYXliZSIsImNvbGxlY3Rpb25zIiwibmVnaW5mIiwicG9zaW5mIiwiaGF2ZVN5bWJvbHMiLCJ2IiwicyIsImFsIiwiZiIsImFzc2lnbmVkIiwiemVybyIsImluZmluaXR5IiwiaW50ZWdlciIsImV2ZW4iLCJvZGQiLCJncmVhdGVyIiwiYmV0d2VlbiIsImdyZWF0ZXJPckVxdWFsIiwibGVzc09yRXF1YWwiLCJpblJhbmdlIiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsImVtcHR5U3RyaW5nIiwibm9uRW1wdHlTdHJpbmciLCJib29sZWFuIiwiZW1wdHlPYmplY3QiLCJub25FbXB0eU9iamVjdCIsImluc3RhbmNlU3RyaWN0IiwibGlrZSIsImVtcHR5QXJyYXkiLCJub25FbXB0eUFycmF5IiwiYXJyYXlMaWtlIiwiZGF0ZSIsImhhc0xlbmd0aCIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJtaXhpbiIsImNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyIsImFzc2VydE1vZGlmaWVyIiwiYXNzZXJ0SW1wbCIsIm5vdE1vZGlmaWVyIiwibm90SW1wbCIsIm1heWJlTW9kaWZpZXIiLCJtYXliZUltcGwiLCJjcmVhdGVNb2RpZmllZE1vZGlmaWVyIiwiY3JlYXRlT2ZQcmVkaWNhdGVzIiwiY3JlYXRlT2ZNb2RpZmllcnMiLCJjcmVhdGVNYXliZU9mTW9kaWZpZXJzIiwiZXhwb3J0RnVuY3Rpb25zIiwibGhzIiwicmhzIiwieCIsInkiLCJzdWJzdHJpbmciLCJyZWdleCIsImVycm9yIiwiYXJjaGV0eXBlIiwiaXRlcmF0aW9uIiwiZ2V0VGltZSIsIm1hcFNpbXBsZSIsIm1hcENvbXBsZXgiLCJwcmVkaWNhdGUiLCJtIiwidGVzdEFycmF5IiwidGVzdE9iamVjdCIsImRlZmF1bHRNZXNzYWdlIiwiYXNzZXJ0UHJlZGljYXRlIiwiYXJnQ291bnQiLCJFcnJvclR5cGUiLCJtb2RpZmllZFByZWRpY2F0ZSIsIm9mTW9kaWZpZXIiLCJjb2xsZWN0aW9uIiwiY29lcmNlQ29sbGVjdGlvbiIsImlnbm9yZSIsIm1vZGlmaWVyIiwiY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMiLCJtb2RpZmllZCIsIm9mIiwiY2hlY2siLCJ0aGlzIiwicGx1Z2luIiwiaXNFbWl0dGVyIiwiRXZlbnRFbWl0dGVyIiwiRXZlbnRUYXJnZXQiLCJub2RlIiwiYnJvd3NlciIsInJlZ2lzdGVyZWQiLCJyZWdpc3RlckFuaW1hdGlvbnMiLCJvcGFjaXR5Iiwib2JqZWN0YWJsZSIsImxvZyIsInIiLCJoIiwidSIsInNpbGVudCIsIk8iLCJpQSIsIkMiLCJjIiwiZGVsYXkiLCJ0aHJvdHRsZSIsInNpbXBsZVNlbGVjdG9yIiwicHJvbWlzZVRyYW5zZm9ybXMiLCJkaXNwYXRjaEV2ZW50cyIsInNlbmRBcnJheUNvcGllcyIsInVwZGF0ZUV2ZW5JZlNhbWUiLCJ1cGRhdGVPbkJpbmQiLCJfc2IiLCJFbGVtZW50IiwidUFTIiwiZyIsIkgiLCJzVSIsIlIiLCJzViIsImZEViIsIkQiLCJpRCIsImlPIiwiaVMiLCJpTiIsImlGIiwiaUJJIiwiWCIsImlCIiwiaXNJIiwiRE0iLCJkSSIsImRSIiwiZEMiLCJlQyIsIkhUTUxDb2xsZWN0aW9uIiwialF1ZXJ5IiwiZUFTIiwiZE4iLCJNIiwiSSIsIk9EIiwicHIiLCJvUiIsInRmUyIsImlzTCIsIk9HIiwiT1MiLCJDU1NTdHlsZURlY2xhcmF0aW9uIiwiUyIsIkUiLCJQIiwiX3NiX0lEIiwiX3NiX21hcCIsImdCIiwiSUQiLCJzZSIsIlYiLCJOIiwiQSIsIkIiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiRiIsIlQiLCJHIiwiTCIsInciLCJlcklQIiwiZXJGTiIsImVyRVYiLCJlbXB0eUxpc3QiLCJlck9EIiwiZXJNWCIsInNvIiwiY0MiLCJzUyIsInNQIiwic0MiLCJzZXR0aW5ncyIsImRlZmF1bHRPcHRpb25zIiwidW5CaW5kQWxsIiwickFTIiwib0QiLCJzdWJzIiwic00iLCJwTSIsImF0RVYiLCJtQyIsImNIIiwiYVMiLCJ0RiIsImRlIiwicEIiLCJzUEgiLCJwVkwiLCJQaCIsInR4TiIsImFFViIsImlzTXVsdGkiLCJiaW5kaW5ncyIsInVPIiwiVlIiLCJyUyIsIkRFUyIsInJQSSIsInVyRVZFIiwic2VsZWN0aW9uU3RhcnQiLCJzZXRTZWxlY3Rpb25SYW5nZSIsInBDVCIsInBJTSIsInBzIiwiaUUiLCJlRSIsInVTIiwiZEwiLCJsVSIsInVUIiwiY04iLCJhTSIsInNzIiwiYUQiLCJhUEkiLCJQSSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImFVViIsImV2TiIsInJFVkUiLCJldkgiLCJVIiwiZU0iLCJsaXN0ZW4iLCJldk8iLCJiaW5kaW5nRGF0YSIsInNHIiwib1AiLCJkTSIsIm9yaWdpbmFsIiwib2JqZWN0cyIsInN1YnNjcmliZXJzIiwiY3JlYXRlQlAiLCJwYXRjaENhY2hlZEJQIiwicGFyc2VJbnQiLCJyZW1vdmVNZXRob2QiLCJlbWl0TWV0aG9kIiwibnQiLCJhUCIsIlciLCIkIiwiY2hhaW5UbyIsIlkiLCJ0cmFuc2Zvcm1TZWxmIiwiUSIsInEiLCJ0cmFuc2Zvcm1BbGwiLCJ6IiwiY29uZGl0aW9uIiwiSiIsImNvbmRpdGlvbkFsbCIsIksiLCJib3RoV2F5cyIsIloiLCJ1bkJpbmQiLCJ0dCIsInBvbGxFdmVyeSIsImV0Iiwic3RvcFBvbGxpbmciLCJpdCIsInNldE9wdGlvbiIsInN0IiwiZGlzYWxsb3dGcm9tIiwidXBkYXRlT24iLCJyZW1vdmVVcGRhdGVyIiwiYW5kIiwiYWRkQlAiLCJ1cGRhdGUiLCJ0d29XYXkiLCJwaXBlIiwiSW4iLCJydCIsImRlZmluZSIsInVtZCIsInNpbXBseWJpbmQiLCJSRUdFWCIsIndoaXRlU3BhY2UiLCJudW1lcmljIiwid2lkZW51bWVyaWMiLCJhbHBoYW51bWVyaWMiLCJlbWFpbCIsIm5vb3AiLCJyZXBlYXQiLCJuZXdJdGVtIiwiaGV4VG9SR0JBIiwiaGV4IiwiYWxwaGEiLCJkZWZhdWx0Q29sb3IiLCJjb2xvciIsImNhbGNQYWRkaW5nIiwiZGVzaXJlZEhlaWdodCIsImNlaWwiLCJ1bmxvY2tTY3JvbGwiLCJleGNsdWRlZEVsIiwiX2lzTG9ja2VkIiwibG9ja1Njcm9sbCIsIndoZWVsRGVsdGEiLCJzY3JvbGxUb3AiLCJwcmV2ZW50RGVmYXVsdCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImZ1enp5TWF0Y2giLCJuZWVkbGUiLCJoYXlzdGFjayIsImNhc2VTZW5zaXRpdmUiLCJoSSIsImhMZW5ndGgiLCJtYXRjaGVkQ291bnQiLCJuSSIsIm5MZW5ndGgiLCJuZWVkbGVDaGFyIiwidG9VcHBlckNhc2UiLCJzdGFydHNXaXRoIiwiZ2V0SW5kZXhPZkZpcnN0RGlmZiIsInNvdXJjZVN0cmluZyIsImNvbXBhcmVTdHJpbmciLCJjdXJyZW50UG9zIiwicGFyc2VDc3NTaG9ydGhhbmRWYWx1ZSIsInNob3J0aGFuZFNpZGVWYWx1ZSIsInNpZGUiLCJ1cGRhdGVTaG9ydGhhbmRWYWx1ZSIsImluaGVyaXRQcm90byIsIlJFUVVJUkVEX0ZJRUxEX01FVEhPRFMiLCJ3aW4iLCJkZWJ1ZyIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiRmFzdERvbSIsInJlYWRzIiwid3JpdGVzIiwibWVhc3VyZSIsInRhc2siLCJzY2hlZHVsZUZsdXNoIiwibXV0YXRlIiwiZmFzdGRvbSIsImluaXRpYWxpemUiLCJjYXRjaCIsInNjaGVkdWxlZCIsImZsdXNoIiwicnVuVGFza3MiLCJ0YXNrcyIsIkNvbmRpdGlvbiIsImZpZWxkMSIsImNhbGxiYWNrMSIsInNhdGlzZmllZCIsImFsbEZpZWxkcyIsIlNpbXBseUJpbmQiLCJvbGRWYWx1ZSIsImNvbXBhcmlzb24iLCJjb21wYXJpc29uT3BlcmF0b3JzIiwicGFzc2VkQ29tcGFyaXNvbnMiLCJ2aXNpYmxlIiwidmFsaWRhdGUiLCJuZXN0ZWRPYmplY3QiLCJwcm9wZXJ0eUNoYWluIiwic2Vla2VkVmFsdWUiLCJoZWxwZXJzIiwidGVzdE1hc2siLCJjb25kaXRpb25zIiwidmFsaWRDb25kaXRpb25zIiwidmFsaWRhdGVDb25kaXRpb25zIiwiQ29uZGl0aW9uJDEiLCJ0cmFuc2Zvcm1TZXR0aW5ncyIsImNob2ljZXMiLCJsYWJlbCIsInZhbGlkV2hlblJlZ2V4IiwiZ2xvYmFsRGVmYXVsdHMiLCJ0ZW1wbGF0ZXMiLCJoZWxwIiwicmVxdWlyZWQiLCJkaXNhYmxlZCIsImRlZmF1bHRWYWx1ZSIsIm1vYmlsZVdpZHRoIiwibW9iaWxlVGhyZXNob2xkIiwiZGlzdGFuY2UiLCJpbnB1dFBhZGRpbmciLCJsYWJlbFNpemUiLCJpY29uIiwiaWNvblNpemUiLCJzZXR0ZXIiLCJ2YWxpZGF0b3IiLCJjbGVhckVycm9yT25WYWxpZCIsIm1ha2VSb29tRm9ySGVscCIsIkZpZWxkIiwiY3VycmVudElEIiwic2V0dGluZ092ZXJyaWRlcyIsInRlbXBsYXRlT3ZlcnJpZGVzIiwic2hhbGxvd1NldHRpbmdzIiwidHJhbnNmb3JtU2V0dGluZ3NfIiwiZGVmYXVsdCIsImZpZWxkSW5zdGFuY2VzIiwiX3ZhbHVlIiwidmFsaWQiLCJmb2N1c2VkIiwiaG92ZXJlZCIsImZpbGxlZCIsImludGVyYWN0ZWQiLCJpc01vYmlsZSIsInNob3dMYWJlbCIsInNob3dIZWxwIiwic2hvd0Vycm9yIiwiX2NvbnN0cnVjdG9yRW5kIiwiY2hpbGRmIiwibXVsdGlwbGUiLCJwcmV2U2hvdyIsImNoYW5nZUFtb3VudCIsIl9xdWlja0ZpZWxkIiwiX2Zvcm1hdFdpZHRoIiwiZGVzdHJveSIsInJlbW92ZUZyb21ET00iLCJfZGVzdHJveSIsInByb3ZpZGVkVmFsdWUiLCJjb3JlVmFsdWVQcm9wIiwidGVzdFVucmVxdWlyZWQiLCJyZXBvcnQiLCJpc1ZhbGlkIiwiX3ZhbGlkYXRlIiwicGFzc2VkQ29uZGl0aW9ucyIsInRvZ2dsZVZpc2liaWxpdHkiLCJ2YWxpZGF0ZUFuZFJlcG9ydCIsIl9nZXRWYWx1ZSIsIl9zZXRWYWx1ZSIsIkZpZWxkJDEiLCJrZXlDb2RlcyIsIktFWUNPREVTIiwiZW50ZXIiLCJlc2MiLCJjdHJsIiwiYWx0Iiwic3VwZXIiLCJzdXBlcjIiLCJ1cCIsImRvd24iLCJoeXBoZW4iLCJ1bmRlcnNjb3JlIiwicXVlc3Rpb24iLCJleGNsYW1hdGlvbiIsImZyb250c2xhc2giLCJiYWNrc2xhc2giLCJjb21tYSIsInBlcmlvZCIsInNwYWNlIiwiYW55QXJyb3ciLCJjb2RlIiwiYW55TW9kaWZpZXIiLCJhbnlBbHBoYSIsImFueU51bWVyaWMiLCJhbnlBbHBoYU51bWVyaWMiLCJhbnlQcmludGFibGUiLCJjaGVja21hcmsiLCJ2aWV3Qm94IiwidGFiaW5kZXgiLCJmb2N1c2FibGUiLCJmaWxsIiwicG9pbnRzIiwiYW5nbGVEb3duIiwib3V0bGluZSIsImNhcmV0VXAiLCJjYXJldERvd24iLCJwbHVzIiwicG9zaXRpb24iLCJ6SW5kZXgiLCJvdmVyZmxvdyIsImRyb3Bkb3duIiwicmVjdCIsImJhY2tncm91bmRDb2xvciIsImJveFNoYWRvdyIsImJvcmRlcldpZHRoIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJDb2xvciIsImJvcmRlclJhZGl1cyIsIiRpc09wZW4iLCIkaGFzVmlzaWJsZUNob2ljZXMiLCJvdmVyZmxvd1Njcm9sbGluZyIsIm92ZXJmbG93U3R5bGUiLCJjaG9pY2UiLCJ1c2VyU2VsZWN0IiwibGluZUhlaWdodCIsImN1cnNvciIsIiR2aXNpYmxlIiwiJHVuYXZhaWxhYmxlIiwiJGhvdmVyIiwidmVydGljYWxBbGlnbiIsInRleHRBbGlnbiIsInN0cm9rZSIsIiRzZWxlY3RlZCIsInRleHRPdmVyZmxvdyIsIndvcmRXcmFwIiwibWF4V2lkdGgiLCJwYWRkaW5nUmlnaHQiLCJzY3JvbGxJbmRpY2F0b3JVcCIsInNjcm9sbEluZGljYXRvckRvd24iLCJib3JkZXJUb3AiLCIkc2hvd0hlbHAiLCJ0ZW1wbGF0ZSQxIiwibWF4SGVpZ2h0IiwidHlwZUJ1ZmZlciIsIkNob2ljZSIsIkRyb3Bkb3duIiwiTGlzdCIsImluaXRpYWxDaG9pY2VzIiwiaXNPcGVuIiwiX3NldHRpbmdGaWx0ZXJzIiwibGFzdFNlbGVjdGVkIiwiY3VycmVudEhpZ2hsaWdodGVkIiwidmlzaWJsZUNob2ljZXNDb3VudCIsInZpc2libGVDaG9pY2VzIiwiZWxzIiwiX3NlbGVjdGVkQ2FsbGJhY2siLCJfY3JlYXRlRWxlbWVudHMiLCJfYXR0YWNoQmluZGluZ3MiLCJhZGRDaG9pY2UiLCJfYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSIsIl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5IiwiX2F0dGFjaEJpbmRpbmdzX3Njcm9sbEluZGljYXRvcnMiLCJjdXJyZW50IiwiYXBwZW5kQ2hvaWNlcyIsImNhbGNEaXNwbGF5Iiwic2Nyb2xsVG9DaG9pY2UiLCJzZXRUcmFuc2xhdGUiLCJuZXdDaG9pY2UiLCJwcmV2Q2hvaWNlIiwiaW5wdXQiLCJrZXlDb2RlIiwiaGlnaGxpZ2h0UHJldiIsImhpZ2hsaWdodE5leHQiLCJ0eXBlQnVmZmVyVGltZW91dCIsImNob2ljZUluVmlldyIsIl91cGRhdGVTY3JvbGxJbmRpY2F0b3JWaXNpYmlsaXR5Iiwic3RhcnRTY3JvbGxpbmciLCJzdG9wU2Nyb2xsaW5nIiwic2hvd0JvdHRvbUluZGljYXRvciIsInNob3dUb3BJbmRpY2F0b3IiLCJhcHBlbmRlZENob2ljZXMiLCJyZW1vdmVDaG9pY2UiLCJmaW5kQ2hvaWNlQW55IiwicmVwbGFjZUNob2ljZXMiLCJuZXdDaG9pY2VzIiwib25TZWxlY3RlZCIsImZpbmRDaG9pY2UiLCJieUxhYmVsIiwiY3VycmVudEluZGV4Iiwic2Nyb2xsVXAiLCJzY3JvbGxEb3duIiwiYm90dG9tQ3V0b2ZmIiwiY2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJjdXRvZmYiLCJpc0JvdHRvbUN1dG9mZiIsImlzVG9wQ3V0b2ZmIiwibmVlZHNOZXdIZWlnaHQiLCJzZWxmUmVjdCIsInRvcEN1dG9mZiIsInRyYW5zbGF0aW9uIiwid2luZG93Q3V0b2ZmIiwid2luZG93SGVpZ2h0Iiwic2V0RGltZW5zaW9ucyIsImlubmVyd3JhcCIsIm9mZnNldCIsImRpc3RhbmVGcm9tVG9wIiwic2VsZWN0ZWRIZWlnaHQiLCJvZmZzZXRUb3AiLCJjaG9pY2VSZWN0IiwiZG93blBhZGRpbmciLCJsaXN0UmVjdCIsInVwUGFkZGluZyIsInNjcm9sbEludGVydmFsSUQiLCJ1bmF2YWlsYWJsZSIsImluaXRpYWxpemVkIiwic3RvcFByb3BhZ2F0aW9uIiwibmV3U3RhdGUiLCJwcmV2U3RhdGUiLCJ3YXNTZWxlY3RlZCIsIkRyb3Bkb3duJDEiLCJsb2FkZWQiLCJfX2VzTW9kdWxlIiwicGxhY2Vob2xkZXJDaGFyIiwicHJldmlvdXNDb25mb3JtZWRWYWx1ZSIsInByZXZpb3VzUGxhY2Vob2xkZXIiLCJjdXJyZW50Q2FyZXRQb3NpdGlvbiIsImNvbmZvcm1lZFZhbHVlIiwicmF3VmFsdWUiLCJpbmRleGVzT2ZQaXBlZENoYXJzIiwiY2FyZXRUcmFwSW5kZXhlcyIsImd1aWRlIiwiY29udmVydE1hc2tUb1BsYWNlaG9sZGVyIiwia2VlcENoYXJQb3NpdGlvbnMiLCJjaGFyIiwiaXNOZXciLCJtZXRhIiwic29tZUNoYXJzUmVqZWN0ZWQiLCJtYXNrV2l0aG91dENhcmV0VHJhcHMiLCJpbmRleGVzIiwicHJvY2Vzc0NhcmV0VHJhcHMiLCJpbnB1dEVsZW1lbnQiLCJtYXNrIiwic2hvd01hc2siLCJzZWxlY3Rpb25FbmQiLCJyZWplY3RlZCIsImFjdGl2ZUVsZW1lbnQiLCJ1c2VyQWdlbnQiLCJkZCIsIm1tIiwieXkiLCJ5eXl5IiwibGFzdEluZGV4T2YiLCJzdWZmaXgiLCJpbmNsdWRlVGhvdXNhbmRzU2VwYXJhdG9yIiwidGhvdXNhbmRzU2VwYXJhdG9yU3ltYm9sIiwiYWxsb3dEZWNpbWFsIiwiZGVjaW1hbFN5bWJvbCIsImRlY2ltYWxMaW1pdCIsInJlcXVpcmVEZWNpbWFsIiwiYWxsb3dOZWdhdGl2ZSIsImFsbG93TGVhZGluZ1plcm9lcyIsImludGVnZXJMaW1pdCIsIk1hc2siLCJkZWZhdWx0UGF0dGVybkNoYXJzIiwicHJldlZhbHVlIiwicHJldkN1cnNvciIsInBhdHRlcm4iLCJwYXR0ZXJuUmF3IiwicGF0dGVyblNldHRlciIsInBsYWNlaG9sZGVyUmVnZXgiLCJjaGFycyIsImN1c3RvbVBhdHRlcm5zIiwic2V0UGF0dGVybiIsImdldFN0YXRlIiwic2VsZWN0aW9uIiwiZW5kIiwiZ2V0UGxhY2Vob2xkZXIiLCJyZXNvbHZlUGF0dGVybiIsImNvcHkiLCJ0cmFwSW5kZXhlcyIsInByZXZQYXR0ZXJuIiwicmVzb2x2ZWRQYXR0ZXJuIiwidXBkYXRlVmFsdWUiLCJ1cGRhdGVGaWVsZCIsInBhcnNlUGF0dGVybiIsInBhcnNlVHJhbnNmb3JtIiwic2V0VmFsdWUiLCJlc2NhcGVkIiwibWFza0FkZG9ucyIsImVtYWlsTWFzayIsImNyZWF0ZU51bWJlck1hc2siLCJzZXAiLCJkZWNpbWFsIiwibGltaXQiLCJjcmVhdGVBdXRvQ29ycmVjdGVkRGF0ZVBpcGUiLCJuZXdQYXR0ZXJuIiwidHJhbnNmb3JtZWQiLCJtYXNrQ29yZSIsImNvbmZvcm1Ub01hc2siLCJhZGp1c3RDYXJldFBvc2l0aW9uIiwiTWFzayQxIiwiQ09MT1JTIiwidGV4dEZpZWxkVGVtcGxhdGUiLCIkc2hvd0Vycm9yIiwidHJhbnNpdGlvbiIsInBvaW50ZXJFdmVudHMiLCIkZmlsbGVkIiwiJHNob3dMYWJlbCIsIiRmb2N1cyIsIiRkaXNhYmxlZCIsImljb25TaWJsaW5nIiwiaW5wdXRTaWJsaW5nIiwicGFkZGluZ0xlZnQiLCJzdWJ0cmFjdCIsImF1dG9XaWR0aCIsImFwcGVhcmFuY2UiLCJiYWNrZ3JvdW5kQ2xpcCIsInRvdGFsSGVpZ2h0Iiwid29ya2FibGVIZWlnaHQiLCJmbG9vciIsImhvcml6IiwidmVydGkiLCJwYWRkaW5nVG9wIiwib2Zmc2V0V2lkdGgiLCJ0cmFuc2Zvcm1PcmlnaW4iLCIkaW52YWxpZCIsInZhbGlkV2hlbklzQ2hvaWNlIiwibWluV2lkdGgiLCJtaW5MZW5ndGgiLCJUZXh0RmllbGQiLCJ0eXBpbmciLCJfcmVjYWxjRGlzcGxheSIsIl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9XaWR0aCIsIl9hdHRhY2hCaW5kaW5nc192YWx1ZSIsIl9hdHRhY2hCaW5kaW5nc19hdXRvY29tcGxldGUiLCJfYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycyIsImNoZWNrbWFya19tYXNrMSIsImNoZWNrbWFya19tYXNrMiIsImNoZWNrbWFya19wYXRjaCIsIl9nZXRJbnB1dEF1dG9XaWR0aCIsInJlc2V0SW5wdXQiLCJpc1R5cGluZyIsInNob3VsZEJlVmlzaWJsZSIsInNlbGVjdGVkQ2hvaWNlIiwiYmx1ciIsIl9zY2hlZHVsZUN1cnNvclJlc2V0IiwiY3VycmVudEN1cnNvciIsImRpZmZJbmRleCIsIm5ld0N1cnNvciIsIm5vcm1hbGl6ZUN1cnNvclBvcyIsIl9zZXRWYWx1ZUlmTm90U2V0IiwiaW5wdXRXaWR0aCIsImxhYmVsV2lkdGgiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJfZ2V0V2lkdGhTZXR0aW5nIiwicGFyZW50V2lkdGgiLCJtYXRjaGluZ0Nob2ljZSIsIlRleHRGaWVsZCQxIiwiY3JlYXRlQnVpbGRlciIsInRhcmdldEZpZWxkIiwicmVxdWlyZWRNZXRob2QiLCJuZXdTZXR0aW5ncyIsIm5ld1RlbXBsYXRlcyIsImdsb2JhbENvbmZpZyIsIm9yaWdpbmFsVGVtcGxhdGVzIiwib3V0cHV0U2V0dGluZ3MiLCJvdXRwdXRUZW1wbGF0ZXMiLCJxdWlja2ZpZWxkJDEiLCJhdXRvSGVpZ2h0IiwibWluSGVpZ2h0IiwiY291bnRlciIsInJlc2l6ZSIsIlRleHRhcmVhRmllbGQiLCJmb3JjZU9wdHMiLCJfYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvSGVpZ2h0IiwiX2dldElucHV0QXV0b0hlaWdodCIsImlucHV0SGVpZ2h0IiwicHJldkhlaWdodCIsIlRleHRhcmVhRmllbGQkMSIsInZhbGlkV2hlbk1pbiIsInZhbGlkV2hlbk1heCIsImJ1dHRvbnMiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwic3RlcCIsImVuZm9yY2UiLCJzdGVwQnV0dG9uIiwiJGFjdGl2ZSIsIk51bWJlckZpZWxkIiwicHJlY2lzaW9uIiwiX25vcm1hbGl6ZVZhbHVlIiwiX2F0dGFjaEJpbmRpbmdzX3N0ZXBFdmVudHMiLCJzZWxlY3ROdW1iZXJQYXJ0Iiwic3RlcFVwIiwic3RlcERvd24iLCJfcm91bmRUb05lYXJlc3QiLCJtdWx0aXBsaWVyIiwidG9GaXhlZCIsInJvdW5kZWQiLCJOdW1iZXJGaWVsZCQxIiwidmFsaWRXaGVuQ2hvc2VNaW4iLCJsYWJlbEZpbHRlciIsInRhYkluZGV4IiwiU2VsZWN0RmllbGQiLCJzZXRDaG9pY2UiLCJ2YWx1ZUxhYmVsIiwiX2F0dGFjaEJpbmRpbmdzX2Ryb3Bkb3duIiwibGFiZWxGb3JtYXQiLCJlc2NMaXN0ZW5lciIsInRyaWdnZXJpbmdLZXljb2RlcyIsInZhbGlkQ2hvaWNlcyIsIm9wdGlvbiIsIlNlbGVjdEZpZWxkJDEiLCJjaG9pY2VHcm91cCIsInNwYWNpbmciLCJtYXJnaW5MZWZ0IiwiJGRlZmluZWRXaWR0aCIsInBlckdyb3VwIiwiY2hvaWNlSWNvbiIsInZhbGlkV2hlblNlbGVjdGVkIiwic2hvd1NlbGVjdEFsbCIsIkNob2ljZUZpZWxkIiwiY2hvaWNlR3JvdXBzIiwiZ3JvdXBJbmRleCIsImdyb3VwRWwiLCJpbmRleDEiLCJpY29uRWwiLCJ0b3RhbEluZGV4IiwiQ2hvaWNlRmllbGQkMSIsImNob2ljZSQxIiwiY2hvaWNlSWNvbiQxIiwiY2hvaWNlR3JvdXAkMSIsInZhbGlkV2hlblRydWUiLCJjaG9pY2VMYWJlbHMiLCJUcnVlRmFsc2VGaWVsZCIsIlRydWVGYWxzZUZpZWxkJDEiLCJiYWNrZ3JvdW5kIiwidHJpZ2dlckV2ZW50IiwiJGFsaWduZWRTdHlsZSIsIiR0b2dnbGVkIiwiVG9nZ2xlRmllbGQiLCJUb2dnbGVGaWVsZCQxIiwiZmllbGRzIiwiY29sbGFwc2FibGUiLCJzdGFydENvbGxhcHNlZCIsImZpZWxkTWFyZ2luIiwiZmllbGRBbGlnbiIsImFjdGlvbiIsImluc2VydGVkIiwiY29sbGFwc2VJY29ucyIsIiRjb2xsYXBzZWQiLCJ0ZXh0SnVzdGlmeSIsIkdyb3VwRmllbGQiLCJfY2FsY0ZvY3VzU3RhdGUiLCJfY2FsY0JsdXJTdGF0ZSIsIl9lbWl0U3VibWl0IiwiY29sbGFwc2VkIiwiZmllbGRzQXJyYXkiLCJhZGRBY3Rpb24iLCJ0b2dnbGVDb2xsYXBzZSIsImNvbGxhcHNlIiwiZmllbGROYW1lIiwic29tZUludmFsaWQiLCJpY29ucyIsImFjdGlvbnMiLCJHcm91cEZpZWxkJDEiLCIkY29sbGFwc2FibGUiLCIkaW5saW5lU3R5bGUiLCJncm91cE1hcmdpbiIsImNsb25lSWNvbiIsInJlbW92ZUljb24iLCJibG9ja0dyb3VwIiwiaW5saW5lR3JvdXAiLCJncm91cFdpZHRoIiwiYXV0b1JlbW92ZUVtcHR5IiwiZHluYW1pY0xhYmVsIiwibWluSXRlbXMiLCJtYXhJdGVtcyIsImRyYWdnYWJsZSIsImNsb25lYWJsZSIsInJlbW92ZWFibGUiLCJzaW5nbGVNb2RlIiwibnVtYmVyaW5nIiwiZHJhZ2Ryb3AiLCJncm91cFNldHRpbmdzIiwiaW5saW5lIiwiYmxvY2siLCJhdG9hIiwic2kiLCJzZXRJbW1lZGlhdGUiLCJ0aWNrIiwiZGVib3VuY2UiLCJ0aWNreSIsInJ1biIsInRoaW5nIiwiZXZ0IiwiX29uY2UiLCJlbWl0dGVyU25hcHNob3QiLCJhc3luYyIsIk5hdGl2ZUN1c3RvbUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJ1c2VOYXRpdmUiLCJkZXRhaWwiLCJmb28iLCJwYXJhbXMiLCJpbml0Q3VzdG9tRXZlbnQiLCJjcmVhdGVFdmVudE9iamVjdCIsImV2ZW50bWFwIiwiZXZlbnRuYW1lIiwicm9uIiwiZG9jIiwiYWRkRXZlbnQiLCJhZGRFdmVudEVhc3kiLCJyZW1vdmVFdmVudCIsInJlbW92ZUV2ZW50RWFzeSIsImhhcmRDYWNoZSIsImFkZEV2ZW50SGFyZCIsInJlbW92ZUV2ZW50SGFyZCIsImFkZCIsImZhYnJpY2F0ZSIsImZhYnJpY2F0ZUV2ZW50IiwiY2FwdHVyaW5nIiwiYXR0YWNoRXZlbnQiLCJsaXN0ZW5lciIsImRldGFjaEV2ZW50IiwibW9kZWwiLCJtYWtlQ3VzdG9tRXZlbnQiLCJtYWtlQ2xhc3NpY0V2ZW50IiwiZmlyZUV2ZW50IiwiY3VzdG9tRXZlbnQiLCJ3cmFwcGVyRmFjdG9yeSIsIndyYXBwZXIiLCJvcmlnaW5hbEV2ZW50Iiwic3JjRWxlbWVudCIsInJldHVyblZhbHVlIiwiY2FuY2VsQnViYmxlIiwid2hpY2giLCJmaW5kIiwibG9va3VwQ2xhc3MiLCJsYXN0SW5kZXgiLCJybUNsYXNzIiwicm0iLCJkcmFndWxhIiwiaW5pdGlhbENvbnRhaW5lcnMiLCJfbWlycm9yIiwiX3NvdXJjZSIsIl9pdGVtIiwiX29mZnNldFgiLCJfb2Zmc2V0WSIsIl9tb3ZlWCIsIl9tb3ZlWSIsIl9pbml0aWFsU2libGluZyIsIl9jdXJyZW50U2libGluZyIsIl9jb3B5IiwiX3JlbmRlclRpbWVyIiwiX2xhc3REcm9wVGFyZ2V0IiwiX2dyYWJiZWQiLCJtb3ZlcyIsImFsd2F5cyIsImFjY2VwdHMiLCJpbnZhbGlkIiwiaW52YWxpZFRhcmdldCIsImNvbnRhaW5lcnMiLCJpc0NvbnRhaW5lciIsIm5ldmVyIiwiY29weVNvcnRTb3VyY2UiLCJyZXZlcnRPblNwaWxsIiwicmVtb3ZlT25TcGlsbCIsImlnbm9yZUlucHV0VGV4dFNlbGVjdGlvbiIsIm1pcnJvckNvbnRhaW5lciIsImRyYWtlIiwibWFudWFsU3RhcnQiLCJjYW5Nb3ZlIiwiZHJhZ2dpbmciLCJzcGlsbE92ZXIiLCJzcGlsbE91dCIsIm9wIiwidG91Y2h5IiwiZ3JhYiIsInJlbGVhc2UiLCJldmVudHVhbE1vdmVtZW50cyIsInN0YXJ0QmVjYXVzZU1vdXNlTW92ZWQiLCJtb3ZlbWVudHMiLCJjcm9zc3ZlbnQiLCJwcmV2ZW50R3JhYmJlZCIsImNsaWVudFgiLCJjbGllbnRZIiwid2hpY2hNb3VzZUJ1dHRvbiIsIm1ldGFLZXkiLCJjdHJsS2V5IiwiY2FuU3RhcnQiLCJpc0lucHV0IiwiZ2V0Q29vcmQiLCJlbGVtZW50QmVoaW5kQ3Vyc29yIiwiZWxlbWVudEZyb21Qb2ludCIsImdyYWJiZWQiLCJnZXRPZmZzZXQiLCJjbGFzc2VzIiwicmVuZGVyTWlycm9ySW1hZ2UiLCJkcmFnIiwiaGFuZGxlIiwiZ2V0UGFyZW50IiwibW92YWJsZSIsIm5leHRFbCIsImlzQ29weSIsImRyb3AiLCJ1bmdyYWIiLCJnZXRFbGVtZW50QmVoaW5kUG9pbnQiLCJkcm9wVGFyZ2V0IiwiZmluZERyb3BUYXJnZXQiLCJpc0luaXRpYWxQbGFjZW1lbnQiLCJjbGVhbnVwIiwicmV2ZXJ0IiwicmV2ZXJ0cyIsInJlbW92ZU1pcnJvckltYWdlIiwic2libGluZyIsImFjY2VwdGVkIiwiZHJvcHBhYmxlIiwiaW1tZWRpYXRlIiwiZ2V0SW1tZWRpYXRlQ2hpbGQiLCJyZWZlcmVuY2UiLCJnZXRSZWZlcmVuY2UiLCJjaGFuZ2VkIiwib3V0Iiwib3ZlciIsIm1vdmVkIiwiZ2V0UmVjdFdpZHRoIiwiZ2V0UmVjdEhlaWdodCIsImhvcml6b250YWwiLCJpbnNpZGUiLCJvdXRzaWRlIiwidG91Y2giLCJtb3VzZXVwIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwicG9pbnRlcnMiLCJtaWNyb3NvZnQiLCJwb2ludGVyRW5hYmxlZCIsIm1zUG9pbnRlckVuYWJsZWQiLCJ0b3VjaGVzIiwiYnV0dG9uIiwiZ2V0U2Nyb2xsIiwic2Nyb2xsUHJvcCIsIm9mZnNldFByb3AiLCJwb2ludCIsImlzRWRpdGFibGUiLCJjb250ZW50RWRpdGFibGUiLCJtYW51YWxseSIsImdldEV2ZW50SG9zdCIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsImNvb3JkIiwiaG9zdCIsIm1pc3NNYXAiLCJwYWdlWCIsInBhZ2VZIiwiY3NzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzaGVldCIsIlJlcGVhdGVyRmllbGQiLCJkaWZmIiwiZ3JvdXBMYWJlbCIsImxhYmVsUmVnZXgiLCJfZ3JvdXBTZXR0aW5ncyIsImdyb3VwIiwiYWRkSXRlbSIsImRyYWdnZXIiLCJyZU9yZ2FuaXplIiwiX3JlY2FsY0xhYmVscyIsImFkZEJ1dHRvbiIsIl9yZWNhbGNMYWJlbCIsImV4aXN0aW5nTGFiZWwiLCJuZXdMYWJlbCIsInNraXBJbnNlcnQiLCJza2lwRW1pdCIsImZpcnN0RmllbGQiLCJyZWZyZXNoQ2hpbGRyZW4iLCJjbG9uZUl0ZW0iLCJyZW1vdmVkIiwiUmVwZWF0ZXJGaWVsZCQxIiwiYWx3YXlzVmFsaWQiLCJsYWJlbENsaWNrcyIsInN5bWJvbCIsImZsZXhXcmFwIiwiYWxpZ25Db250ZW50IiwiYWxpZ25JdGVtcyIsImFsaWduU2VsZiIsImZsZXhHcm93IiwiZmxleFNocmluayIsIkNoZWNrYm94RmllbGQiLCJDaGVja2JveEZpZWxkJDEiLCJlbWl0RXZlbnQiLCJjaGFpQXNzZXJ0dHlwZSIsImNoYWlFdmVudHMiLCJtb2NoYSIsInNldHVwIiwic2xvdyIsIl9fa2FybWFfXyIsImJhaWwiLCJUcnVlZmFsc2VGaWVsZCIsInByb21pc2VFdmVudCIsInN1aXRlIiwidGVhcmRvd24iLCJsYXN0Q2hpbGQiLCJzdWl0ZVNldHVwIiwiZmllbGQyIiwiY29udHJvbCIsImZpZWxkQSIsImZpZWxkQiIsImZpZWxkQyIsImluaXRpYWxUb3AiLCJ3aXRoTGFiZWwiLCJ3aXRob3V0TGFiZWwiLCJpY29uRmllbGQiLCJjdXN0b20iLCJtYXN0ZXIiLCJzbGF2ZSIsImRyb3Bkb3duRWwiLCJpbnB1dEVsIiwiZGlzcGxheWVkIiwiZ2V0VmlzaWJsZSIsInNraXAiLCJjb250cm9sTXVsdGkiLCJyZWYzIiwicmVmNCIsInJlZjUiLCJ2YWx1ZVJhdyIsInNpbmdsZSIsImNsaWNrIiwiZmlyc3QiLCJzZWNvbmQiLCJ0aGlyZCIsImZvdXJ0aCIsImZpZnRoIiwicXVpY2tmaWVsZDIiLCJ0ZXh0QSIsInRleHRCIiwidGV4dEMiLCJ0ZXh0RCJdLCJtYXBwaW5ncyI6IjRGQUFBLG1CQUFlLENBQ2IsV0FEYSxFQUViLGdCQUZhLEVBR2IsOEJBSGEsRUFJYix5QkFKYSxFQUtiLGNBTGEsRUFNYix1QkFOYSxFQU9iLDBCQVBhLEVBUWIsZ0JBUmEsRUFTYixnQkFUYSxFQVViLDZCQVZhLEVBV2IsZ0JBWGEsRUFZYiw4QkFaYSxFQWFiLGlCQWJhLEVBY2IsZ0JBZGEsRUFlYiw2QkFmYSxFQWdCYiw0QkFoQmEsRUFpQmIsZUFqQmEsRUFrQmIsWUFsQmEsRUFtQmIsc0JBbkJhLEVBb0JiLGdCQXBCYSxFQXFCYiwyQkFyQmEsRUFzQmIsaUJBdEJhLEVBdUJiLCtCQXZCYSxFQXdCYixrQkF4QmEsRUF5QmIsbUJBekJhLEVBMEJiLGdCQTFCYSxFQTJCYixnQkEzQmEsRUE0QmIsMkJBNUJhLEVBNkJiLGdCQTdCYSxFQThCYixnQkE5QmEsRUErQmIsa0JBL0JhLEVBZ0NiLHlCQWhDYSxFQWlDYiw0QkFqQ2EsRUFrQ2IsZ0JBbENhLEVBbUNiLDRCQW5DYSxFQW9DYiwyQkFwQ2EsRUFxQ2IsaUJBckNhLEVBc0NiLGdCQXRDYSxFQXVDYixnQkF2Q2EsRUF3Q2IsZ0JBeENhLEVBeUNiLDBCQXpDYSxFQTBDYix3QkExQ2EsRUEyQ2IsMEJBM0NhLEVBNENiLGdCQTVDYSxFQTZDYixrQkE3Q2EsRUE4Q2IsZUE5Q2EsRUErQ2IsY0EvQ2EsRUFnRGIsWUFoRGEsRUFpRGIsZ0NBakRhLEVBa0RiLHVCQWxEYSxDQUFmLENDQUEsSUFBSSxVQUFVLEdBQUcsVUFBVSxPQUFP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RSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDN0IsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDN0IsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDN0IsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDN0IsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDN0IsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7RUFDekIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsRUFBRSxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDeEIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7RUFDekIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDOUIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDOUIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7RUFDOUIsR0FBRyxFQUFFLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7Q0FDL0IsQ0FBQzs7QUFFRixJQUFJLDZCQUE2QixHQUFHO0VBQ2xDLFNBQVMsRUFBRSxDQUFDO0VBQ1osR0FBRyxFQUFFLENBQUM7RUFDTixLQUFLLEVBQUUsRUFBRTtFQUNULEtBQUssRUFBRSxFQUFFO0VBQ1QsSUFBSSxFQUFFLEVBQUU7RUFDUixHQUFHLEVBQUUsRUFBRTtFQUNQLEtBQUssRUFBRSxFQUFFO0VBQ1QsUUFBUSxFQUFFLEVBQUU7RUFDWixNQUFNLEVBQUUsRUFBRTtFQUNWLE1BQU0s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
